<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","todd","rust-bio","benches","approximate_matching.rs"],"content":"#![feature(test)]\n\nextern crate test;\n\nuse test::Bencher;\n\nuse bio::alignment::Alignment;\nuse bio::pattern_matching::myers::{long, Myers};\nuse bio::pattern_matching::ukkonen::*;\n\nstatic TEXT: \u0026'static [u8] = b\"GATCACAGGTCTATCACCCTATTAACCACTCACGGGAGCTCTCCATGC\\\nATTTGGTATTTTCGTCTGGGGGGTATGCACGCGATAGCATTGCGAGACGCTGGAGCCGGAGCACCCTATGTCGCAGTAT\\\nCTGTCTTTGATTCCTGCCTCATCCTATTATTTATCGCACCTACGTTCAATATTACAGGCGAACATACTTACTAAAGTGT\\\nGTTAATTAATTAATGCTTGTAGGACATAATAATAACAATTGAATGTCTGCACAGCCACTTTCCACACAGACATCATAAC\\\nAAAAAATTTCCACCAAACCCCCCCTCCCCCGCTTCTGGCCACAGCACTTAAACACATCTCTGCCAAACCCCAAAAACAA\\\nAGAACCCTAACACCAGCCTAACCAGATTTCAAATTTTATCTTTTGGCGGTATGCACTTTTAACAGTCACCCCCCAACTA\\\nACACATTATTTTCCCCTCCCACTCCCATACTACTAATCTCATCAATACAACCCCCGCCCATCCTACCCAGCACACACAC\\\nACCGCTGCTAACCCCATACCCCGAACCAACCAAACCCCAAAGACACCCCCCACAGTTTATGTAGCTTACCTCCTCAAAG\\\nCAATACACTGAAAATGTTTAGACGGGCTCACATCACCCCATAAACAAATAGGTTTGGTCCTAGCCTTTCTATTAGCTCT\\\nTAGTAAGATTACACATGCAAGCATCCCCGTTCCAGTGAGTTCACCCTCTAAATCACCACGATCAAAAGGAACAAGCATC\\\nAAGCACGCAGCAATGCAGCTCAAAACGCTTAGCCTAGCCACACCCCCACGGGAAACAGCAGTGATTAACCTTTAGCAAT\\\nAAACGAAAGTTTAACTAAGCTATACTAACCCCAGGGTTGGTCAATTTCGTGCCAGCCACCGCGGTCACACGATTAACCC\\\nAAGTCAATAGAAGCCGGCGTAAAGAGTGTTTTAGATCACCCCCTCCCCAATAAAGCTAAAACTCACCTGAGTTGTAAAA\\\nAACTCCAGTTGACACAAAATAGACTACGAAAGTGGCTTTAACATATCTGAACACACAATAGCTAAGACCCAAACTGGGA\\\nTTAGATACCCCACTATGCTTAGCCCTAAACCTCAACAGTTAAATCAACAAAACTGCTCGCCAGAACACTACGAGCCACA\\\nGCTTAAAACTCAAAGGACCTGGCGGTGCTTCATATCCCTCTAGAGGAGCCTGTTCTGTAATCGATAAACCCCGATCAAC\\\nCTCACCACCTCTTGCTCAGCCTATATACCGCCATCTTCAGCAAACCCTGATGAAGGCTACAAAGTAAGCGCAAGTACCC\\\nACGTAAAGACGTTAGGTCAAGGTGTAGCCCATGAGGTGGCAAGAAATGGGCTACATTTTCTACCCCAGAAAACTACGAT\\\nAGCCCTTATGAAACTTAAGGGTCGAAGGTGGATTTAGCAGTAAACTAAGAGTAGAGTGCTTAGTTGAACAGGGCCCTGA\\\nAGCGCGTACACACCGCCCGTCACCCTCCTCAAGTATACTTCAAAGGACATTTAACTAAAACCCCTACGCATTTATATAG\\\nAGGAGACAAGTCGTAACATGGTAAGTGTACTGGAAAGTGCACTTGGACGAACCAGAGTGTAGCTTAACACAAAGCACCC\\\nAACTTACACTTAGGAGATTTCAACTTAACTTGACCGCTCTGAGCTAAACCTAGCCCCAAACCCACTCCACCTTACTACC\\\nAGACAACCTTAGCCAAACCATTTACCCAAATAAAGTATAGGCGATAGAAATTGAAACCTGGCGCAATAGATATAGTACC\\\nGCAAGGGAAAGATGAAAAATTATAACCAAGCATAATATAGCAAGGACTAACCCCTATACCTTCTGCATAATGAATTAAC\\\nTAGAAATAACTTTGCAAGGAGAGCCAAAGCTAAGACCCCCGAAACCAGACGAGCTACCTAAGAACAGCTAAAAGAGCAC\\\nACCCGTCTATGTAGCAAAATAGTGGGAAGATTTATAGGTAGAGGCGACAAACCTACCGAGCCTGGTGATAGCTGGTTGT\\\nCCAAGATAGAATCTTAGTTCAACTTTAAATTTGCCCACAGAACCCTCTAAATCCCCTTGTAAATTTAACTGTTAGTCCA\\\nAAGAGGAACAGCTCTTTGGACACTAGGAAAAAACCTTGTAGAGAGAGTAAAAAATTTAACACCCATAGTAGGCCTAAAA\\\nGCAGCCACCAATTAAGAAAGCGTTCAAGCTCAACACCCACTACCTAAAAAATCCCAAACATATAACTGAACTCCTCACA\\\nCCCAATTGGACCAATCTATCACCCTATAGAAGAACTAATGTTAGTATAAGTAACATGAAAACATTCTCCTCCGCATAAG\\\nCCTGCGTCAGATTAAAACACTGAACTGACAATTAACAGCCCAATATCTACAATCAACCAACAAGTCATTATTACCCTCA\\\nCTGTCAACCCAACACAGGCATGCTCATAAGGAAAGGTTAAAAAAAGTAAAAGGAACTCGGCAAATCTTACCCCGCCTGT\\\nTTACCAAAAACATCACCTCTAGCATCACCAGTATTAGAGGCACCGCCTGCCCAGTGACACATGTTTAACGGCCGCGGTA\\\nCCCTAACCGTGCAAAGGTAGCATAATCACTTGTTCCTTAAATAGGGACCTGTATGAATGGCTCCACGAGGGTTCAGCTG\\\nTCTCTTACTTTTAACCAGTGAAATTGACCTGCCCGTGAAGAGGCGGGCATAACACAGCAAGACGAGAAGACCCTATGGA\\\nGCTTTAATTTATTAATGCAAACAGTACCTAACAAACCCACAGGTCCTAAACTACCAAACCTGCATTAAAAATTTCGGTT\\\nGGGGCGACCTCGGAGCAGAACCCAACCTCCGAGCAGTACATGCTAAGACTTCACCAGTCAAAGCGAACTACTATACTCA\\\nATTGATCCAATAACTTGACCAACGGAACAAGTTACCCTAGGGATAACAGCGCAATCCTATTCTAGAGTCCATATCAACA\\\nATAGGGTTTACGACCTCGATGTTGGATCAGGACATCCCGATGGTGCAGCCGCTATTAAAGGTTCGTTTGTTCAACGATT\\\nAAAGTCCTACGTGATCTGAGTTCAGACCGGAGTAATCCAGGTCGGTTTCTATCTACNTTCAAATTCCTCCCTGTACGAA\\\nAGGACAAGAGAAATAAGGCCTACTTCACAAAGCGCCTTCCCCCGTAAATGATATCATCTCAACTTAGTATTATACCCAC\\\nACCCACCCAAGAACAGGGTTTGTTAAGATGGCAGAGCCCGGTAATCGCATAAAACTTAAAACTTTACAGTCAGAGGTTC\\\nAATTCCTCTTCTTAACAACATACCCATGGCCAACCTCCTACTCCTCATTGTACCCATTCTAATCGCAATGGCATTCCTA\\\nATGCTTACCGAACGAAAAATTCTAGGCTATATACAACTACGCAAAGGCCCCAACGTTGTAGGCCCCTACGGGCTACTAC\\\nAACCCTTCGCTGACGCCATAAAACTCTTCACCAAAGAGCCCCTAAAACCCGCCACATCTACCATCACCCTCTACATCAC\\\nCGCCCCGACCTTAGCTCTCACCATCGCTCTTCTACTATGAACCCCCCTCCCCATACCCAACCCCCTGGTCAACCTCAAC\\\nCTAGGCCTCCTATTTATTCTAGCCACCTCTAGCCTAGCCGTTTACTCAATCCTCTGATCAGGGTGAGCATCAAACTCAA\\\nACTACGCCCTGATCGGCGCACTGCGAGCAGTAGCCCAAACAATCTCATATGAAGTCACCCTAGCCATCATTCTACTATC\\\nAACATTACTAATAAGTGGCTCCTTTAACCTCTCCACCCTTATCACAACACAAGAACACCTCTGATTACTCCTGCCATCA\\\nTGACCCTTGGCCATAATATGATTTATCTCCACACTAGCAGAGACCAACCGAACCCCCTTCGACCTTGCCGAAGGGGAGT\\\nCCGAACTAGTCTCAGGCTTCAACATCGAATACGCCGCAGGCCCCTTCGCCCTATTCTTCATAGCCGAATACACAAACAT\\\nTATTATAATAAACACCCTCACCACTACAATCTTCCTAGGAACAACATATGACGCACTCTCCCCTGAACTCTACACAACA\\\nTATTTTGTCACCAAGACCCTACTTCTAACCTCCCTGTTCTTATGAATTCGAACAGCATACCCCCGATTCCGCTACGACC\\\nAACTCATACACCTCCTATGAAAAAACTTCCTACCACTCACCCTAGCATTACTTATATGATATGTCTCCATACCCATTAC\\\nAATCTCCAGCATTCCCCCTCAAACCTAAGAAATATGTCTGATAAAAGAGTTACTTTGATAGAGTAAATAATAGGAGCTT\\\nAAACCCCCTTATTTCTAGGACTATGAGAATCGAACCCATCCCTGAGAATCCAAAATTCTCCGTGCCACCTATCACACCC\\\nCATCCTAAAGTAAGGTCAGCTAAATAAGCTATCGGGCCCATACCCCGAAAATGTTGGTTATACCCTTCCCGTACTAATT\\\nAATCCCCTGGCCCAACCCGTCATCTACTCTACCATCTTTGCAGGCACACTCATCACAGCGCTAAGCTCGCACTGATTTT\\\nTTACCTGAGTAGGCCTAGAAATAAACATGCTAGCTTTTATTCCAGTTCTAACCAAAAAAATAAACCCTCGTTCCACAGA\\\nAGCTGCCATCAAGTATTTCCTCACGCAAGCAACCGCATCCATAATCCTTCTAATAGCTATCCTCTTCAACAATATACTC\\\nTCCGGACAATGAACCATAACCAATACTACCAATCAATACTCATCATTAATAATCATAATAGCTATAGCAATAAAACTAG\\\nGAATAGCCCCCTTTCACTTCTGAGTCCCAGAGGTTACCCAAGGCACCCCTCTGACATCCGGCCTGCTTCTTCTCACATG\\\nACAAAAACTAGCCCCCATCTCAATCATATACCAAATCTCTCCCTCACTAAACGTAAGCCTTCTCCTCACTCTCTCAATC\\\nTTATCCATCATAGCAGGCAGTTGAGGTGGATTAAACCAAACCCAGCTACGCAAAATCTTAGCATACTCCTCAATTACCC\\\nACATAGGATGAATAATAGCAGTTCTACCGTACAACCCTAACATAACCATTCTTAATTTAACTATTTATATTATCCTAAC\\\nTACTACCGCATTCCTACTACTCAACTTAAACTCCAGCACCACGACCCTACTACTATCTCGCACCTGAAACAAGCTAACA\\\nTGACTAACACCCTTAATTCCATCCACCCTCCTCTCCCTAGGAGGCCTGCCCCCGCTAACCGGCTTTTTGCCCAAATGGG\\\nCCATTATCGAAGAATTCACAAAAAACAATAGCCTCATCATCCCCACCATCATAGCCACCATCACCCTCCTTAACCTCTA\\\nCTTCTACCTACGCCTAATCTACTCCACCTCAATCACACTACTCCCCATATCTAACAACGTAAAAATAAAATGACAGTTT\\\nGAACATACAAAACCCACCCCATTCCTCCCCACACTCATCGCCCTTACCACGCTACTCCTACCTATCTCCCCTTTTATAC\\\nTAATAATCTTATAGAAATTTAGGTTAAATACAGACCAAGAGCCTTCAAAGCCCTCAGTAAGTTGCAATACTTAATTTCT\\\nGTAACAGCTAAGGACTGCAAAACCCCACTCTGCATCAACTGAACGCAAATCAGCCACTTTAATTAAGCTAAGCCCTTAC\\\nTAGACCAATGGGACTTAAACCCACAAACACTTAGTTAACAGCTAAGCACCCTAATCAACTGGCTTCAATCTACTTCTCC\\\nCGCCGCCGGGAAAAAAGGCGGGAGAAGCCCCGGCAGGTTTGAAGCTGCTTCTTCGAATTTGCAATTCAATATGAAAATC\\\nACCTCGGAGCTGGTAAAAAGAGGCCTAACCCCTGTCTTTAGATTTACAGTCCAATGCTTCACTCAGCCATTTTACCTCA\\\nCCCCCACTGATGTTCGCCGACCGTTGACTATTCTCTACAAACCACAAAGACATTGGAACACTATACCTATTATTCGGCG\\\nCATGAGCTGGAGTCCTAGGCACAGCTCTAAGCCTCCTTATTCGAGCCGAGCTGGGCCAGCCAGGCAACCTTCTAGGTAA\\\nCGACCACATCTACAACGTTATCGTCACAGCCCATGCATTTGTAATAATCTTCTTCATAGTAATACCCATCATAATCGGA\\\nGGCTTTGGCAACTGACTAGTTCCCCTAATAATCGGTGCCCCCGATATGGCGTTTCCCCGCATAAACAACATAAGCTTCT\\\nGACTCTTACCTCCCTCTCTCCTACTCCTGCTCGCATCTGCTATAGTGGAGGCCGGAGCAGGAACAGGTTGAACAGTCTA\\\nCCCTCCCTTAGCAGGGAACTACTCCCACCCTGGAGCCTCCGTAGACCTAACCATCTTCTCCTTACACCTAGCAGGTGTC\\\nTCCTCTATCTTAGGGGCCATCAATTTCATCACAACAATTATCAATATAAAACCCCCTGCCATAACCCAATACCAAACGC\\\nCCCTCTTCGTCTGATCCGTCCTAATCACAGCAGTCCTACTTCTCCTATCTCTCCCAGTCCTAGCTGCTGGCATCACTAT\\\nACTACTAACAGACCGCAACCTCAACACCACCTTCTTCGACCCCGCCGGAGGAGGAGACCCCATTCTATACCAACACCTA\\\nTTCTGATTTTTCGGTCACCCTGAAGTTTATATTCTTATCCTACCAGGCTTCGGAATAATCTCCCATATTGTAACTTACT\\\nACTCCGGAAAAAAAGAACCATTTGGATACATAGGTATGGTCTGAGCTATGATATCAATTGGCTTCCTAGGGTTTATCGT\\\nGTGAGCACACCATATATTTACAGTAGGAATAGACGTAGACACACGAGCATATTTCACCTCCGCTACCATAATCATCGCT\\\nATCCCCACCGGCGTCAAAGTATTTAGCTGACTCGCCACACTCCACGGAAGCAATATGAAATGATCTGCTGCAGTGCTCT\\\nGAGCCCTAGGATTCATCTTTCTTTTCACCGTAGGTGGCCTGACTGGCATTGTATTAGCAAACTCATCACTAGACATCGT\\\nACTACACGACACGTACTACGTTGTAGCCCACTTCCACTATGTCCTATCAATAGGAGCTGTATTTGCCATCATAGGAGGC\\\nTTCATTCACTGATTTCCCCTATTCTCAGGCTACACCCTAGACCAAACCTACGCCAAAATCCATTTCACTATCATATTCA\\\nTCGGCGTAAATCTAACTTTCTTCCCACAACACTTTCTCGGCCTATCCGGAATGCCCCGACGTTACTCGGACTACCCCGA\\\nTGCATACACCACATGAAACATCCTATCATCTGTAGGCTCATTCATTTCTCTAACAGCAGTAATATTAATAATTTTCATG\\\nATTTGAGAAGCCTTCGCTTCGAAGCGAAAAGTCCTAATAGTAGAAGAACCCTCCATAAACCTGGAGTGACTATATGGAT\\\nGCCCCCCACCCTACCACACATTCGAAGAACCCGTATACATAAAATCTAGACAAAAAAGGAAGGAATCGAACCCCCCAAA\\\nGCTGGTTTCAAGCCAACCCCATGGCCTCCATGACTTTTTCAAAAAGGTATTAGAAAAACCATTTCATAACTTTGTCAAA\\\nGTTAAATTATAGGCTAAATCCTATATATCTTAATGGCACATGCAGCGCAAGTAGGTCTACAAGACGCTACTTCCCCTAT\\\nCATAGAAGAGCTTATCACCTTTCATGATCACGCCCTCATAATCATTTTCCTTATCTGCTTCCTAGTCCTGTATGCCCTT\\\nTTCCTAACACTCACAACAAAACTAACTAATACTAACATCTCAGACGCTCAGGAAATAGAAACCGTCTGAACTATCCTGC\\\nCCGCCATCATCCTAGTCCTCATCGCCCTCCCATCCCTACGCATCCTTTACATAACAGACGAGGTCAACGATCCCTCCCT\\\nTACCATCAAATCAATTGGCCACCAATGGTACTGAACCTACGAGTACACCGACTACGGCGGACTAATCTTCAACTCCTAC\\\nATACTTCCCCCATTATTCCTAGAACCAGGCGACCTGCGACTCCTTGACGTTGACAATCGAGTAGTACTCCCGATTGAAG\\\nCCCCCATTCGTATAATAATTACATCACAAGACGTCTTGCACTCATGAGCTGTCCCCACATTAGGCTTAAAAACAGATGC\\\nAATTCCCGGACGTCTAAACCAAACCACTTTCACCGCTACACGACCGGGGGTATACTACGGTCAATGCTCTGAAATCTGT\\\nGGAGCAAACCACAGTTTCATGCCCATCGTCCTAGAATTAATTCCCCTAAAAATCTTTGAAATAGGGCCCGTATTTACCC\\\nTATAGCACCCCCTCTACCCCCTCTAGAGCCCACTGTAAAGCTAACTTAGCATTAACCTTTTAAGTTAAAGATTAAGAGA\\\nACCAACACCTCTTTACAGTGAAATGCCCCAACTAAATACTACCGTATGGCCCACCATAATTACCCCCATACTCCTTACA\\\nCTATTCCTCATCACCCAACTAAAAATATTAAACACAAACTACCACCTACCTCCCTCACCAAAGCCCATAAAAATAAAAA\\\nATTATAACAAACCCTGAGAACCAAAATGAACGAAAATCTGTTCGCTTCATTCATTGCCCCCACAATCCTAGGCCTACCC\\\nGCCGCAGTACTGATCATTCTATTTCCCCCTCTATTGATCCCCACCTCCAAATATCTCATCAACAACCGACTAATCACCA\\\nCCCAACAATGACTAATCAAACTAACCTCAAAACAAATGATAACCATACACAACACTAAAGGACGAACCTGATCTCTTAT\\\nACTAGTATCCTTAATCATTTTTATTGCCACAACTAACCTCCTCGGACTCCTGCCTCACTCATTTACACCAACCACCCAA\\\nCTATCTATAAACCTAGCCATGGCCATCCCCTTATGAGCGGGCACAGTGATTATAGGCTTTCGCTCTAAGATTAAAAATG\\\nCCCTAGCCCACTTCTTACCACAAGGCACACCTACACCCCTTATCCCCATACTAGTTATTATCGAAACCATCAGCCTACT\\\nCATTCAACCAATAGCCCTGGCCGTACGCCTAACCGCTAACATTACTGCAGGCCACCTACTCATGCACCTAATTGGAAGC\\\nGCCACCCTAGCAATATCAACCATTAACCTTCCCTCTACACTTATCATCTTCACAATTCTAATTCTACTGACTATCCTAG\\\nAAATCGCTGTCGCCTTAATCCAAGCCTACGTTTTCACACTTCTAGTAAGCCTCTACCTGCACGACAACACATAATGACC\\\nCACCAATCACATGCCTATCATATAGTAAAACCCAGCCCATGACCCCTAACAGGGGCCCTCTCAGCCCTCCTAATGACCT\\\nCCGGCCTAGCCATGTGATTTCACTTCCACTCCATAACGCTCCTCATACTAGGCCTACTAACCAACACACTAACCATATA\\\nCCAATGATGGCGCGATGTAACACGAGAAAGCACATACCAAGGCCACCACACACCACCTGTCCAAAAAGGCCTTCGATAC\\\nGGGATAATCCTATTTATTACCTCAGAAGTTTTTTTCTTCGCAGGATTTTTCTGAGCCTTTTACCACTCCAGCCTAGCCC\\\nCTACCCCCCAATTAGGAGGGCACTGGCCCCCAACAGGCATCACCCCGCTAAATCCCCTAGAAGTCCCACTCCTAAACAC\\\nATCCGTATTACTCGCATCAGGAGTATCAATCACCTGAGCTCACCATAGTCTAATAGAAAACAACCGAAACCAAATAATT\\\nCAAGCACTGCTTATTACAATTTTACTGGGTCTCTATTTTACCCTCCTACAAGCCTCAGAGTACTTCGAGTCTCCCTTCA\\\nCCATTTCCGACGGCATCTACGGCTCAACATTTTTTGTAGCCACAGGCTTCCACGGACTTCACGTCATTATTGGCTCAAC\\\nTTTCCTCACTATCTGCTTCATCCGCCAACTAATATTTCACTTTACATCCAAACATCACTTTGGCTTCGAAGCCGCCGCC\\\nTGATACTGGCATTTTGTAGATGTGGTTTGACTATTTCTGTATGTCTCCATCTATTGATGAGGGTCTTACTCTTTTAGTA\\\nTAAATAGTACCGTTAACTTCCAATTAACTAGTTTTGACAACATTCAAAAAAGAGTAATAAACTTCGCCTTAATTTTAAT\\\nAATCAACACCCTCCTAGCCTTACTACTAATAATTATTACATTTTGACTACCACAACTCAACGGCTACATAGAAAAATCC\\\nACCCCTTACGAGTGCGGCTTCGACCCTATATCCCCCGCCCGCGTCCCTTTCTCCATAAAATTCTTCTTAGTAGCTATTA\\\nCCTTCTTATTATTTGATCTAGAAATTGCCCTCCTTTTACCCCTACCATGAGCCCTACAAACAACTAACCTGCCACTAAT\\\nAGTTATGTCATCCCTCTTATTAATCATCATCCTAGCCCTAAGTCTGGCCTATGAGTGACTACAAAAAGGATTAGACTGA\\\nACCGAATTGGTATATAGTTTAAACAAAACGAATGATTTCGACTCATTAAATTATGATAATCATATTTACCAAATGCCCC\\\nTCATTTACATAAATATTATACTAGCATTTACCATCTCACTTCTAGGAATACTAGTATATCGCTCACACCTCATATCCTC\\\nCCTACTATGCCTAGAAGGAATAATACTATCGCTGTTCATTATAGCTACTCTCATAACCCTCAACACCCACTCCCTCTTA\\\nGCCAATATTGTGCCTATTGCCATACTAGTCTTTGCCGCCTGCGAAGCAGCGGTGGGCCTAGCCCTACTAGTCTCAATCT\\\nCCAACACATATGGCCTAGACTACGTACATAACCTAAACCTACTCCAATGCTAAAACTAATCGTCCCAACAATTATATTA\\\nCTACCACTGACATGACTTTCCAAAAAACACATAATTTGAATCAACACAACCACCCACAGCCTAATTATTAGCATCATCC\\\nCTCTACTATTTTTTAACCAAATCAACAACAACCTATTTAGCTGTTCCCCAACCTTTTCCTCCGACCCCCTAACAACCCC\\\nCCTCCTAATACTAACTACCTGACTCCTACCCCTCACAATCATGGCAAGCCAACGCCACTTATCCAGTGAACCACTATCA\\\nCGAAAAAAACTCTACCTCTCTATACTAATCTCCCTACAAATCTCCTTAATTATAACATTCACAGCCACAGAACTAATCA\\\nTATTTTATATCTTCTTCGAAACCACACTTATCCCCACCTTGGCTATCATCACCCGATGAGGCAACCAGCCAGAACGCCT\\\nGAACGCAGGCACATACTTCCTATTCTACACCCTAGTAGGCTCCCTTCCCCTACTCATCGCACTAATTTACACTCACAAC\\\nACCCTAGGCTCACTAAACATTCTACTACTCACTCTCACTGCCCAAGAACTATCAAACTCCTGAGCCAACAACTTAATAT\\\nGACTAGCTTACACAATAGCTTTTATAGTAAAGATACCTCTTTACGGACTCCACTTATGACTCCCTAAAGCCCATGTCGA\\\nAGCCCCCATCGCTGGGTCAATAGTACTTGCCGCAGTACTCTTAAAACTAGGCGGCTATGGTATAATACGCCTCACACTC\\\nATTCTCAACCCCCTGACAAAACACATAGCCTACCCCTTCCTTGTACTATCCCTATGAGGCATAATTATAACAAGCTCCA\\\nTCTGCCTACGACAAACAGACCTAAAATCGCTCATTGCATACTCTTCAATCAGCCACATAGCCCTCGTAGTAACAGCCAT\\\nTCTCATCCAAACCCCCTGAAGCTTCACCGGCGCAGTCATTCTCATAATCGCCCACGGGCTTACATCCTCATTACTATTC\\\nTGCCTAGCAAACTCAAACTACGAACGCACTCACAGTCGCATCATAATCCTCTCTCAAGGACTTCAAACTCTACTCCCAC\\\nTAATAGCTTTTTGATGACTTCTAGCAAGCCTCGCTAACCTCGCCTTACCCCCCACTATTAACCTACTGGGAGAACTCTC\\\nTGTGCTAGTAACCACGTTCTCCTGATCAAATATCACTCTCCTACTTACAGGACTCAACATACTAGTCACAGCCCTATAC\\\nTCCCTCTACATATTTACCACAACACAATGGGGCTCACTCACCCACCACATTAACAACATAAAACCCTCATTCACACGAG\\\nAAAACACCCTCATGTTCATACACCTATCCCCCATTCTCCTCCTATCCCTCAACCCCGACATCATTACCGGGTTTTCCTC\\\nTTGTAAATATAGTTTAACCAAAACATCAGATTGTGAATCTGACAACAGAGGCTTACGACCCCTTATTTACCGAGAAAGC\\\nTCACAAGAACTGCTAACTCATGCCCCCATGTCTAACAACATGGCTTTCTCAACTTTTAAAGGATAACAGCTATCCATTG\\\nGTCTTAGGCCCCAAAAATTTTGGTGCAACTCCAAATAAAAGTAATAACCATGCACACTACTATAACCACCCTAACCCTG\\\nACTTCCCTAATTCCCCCCATCCTTACCACCCTCGTTAACCCTAACAAAAAAAACTCATACCCCCATTATGTAAAATCCA\\\nTTGTCGCATCCACCTTTATTATCAGTCTCTTCCCCACAACAATATTCATGTGCCTAGACCAAGAAGTTATTATCTCGAA\\\nCTGACACTGAGCCACAACCCAAACAACCCAGCTCTCCCTAAGCTTCAAACTAGACTACTTCTCCATAATATTCATCCCT\\\nGTAGCATTGTTCGTTACATGGTCCATCATAGAATTCTCACTGTGATATATAAACTCAGACCCAAACATTAATCAGTTCT\\\nTCAAATATCTACTCATCTTCCTAATTACCATACTAATCTTAGTTACCGCTAACAACCTATTCCAACTGTTCATCGGCTG\\\nAGAGGGCGTAGGAATTATATCCTTCTTGCTCATCAGTTGATGATACGCCCGAGCAGATGCCAACACAGCAGCCATTCAA\\\nGCAATCCTATACAACCGTATCGGCGATATCGGTTTCATCCTCGCCTTAGCATGATTTATCCTACACTCCAACTCATGAG\\\nACCCACAACAAATAGCCCTTCTAAACGCTAATCCAAGCCTCACCCCACTACTAGGCCTCCTCCTAGCAGCAGCAGGCAA\\\nATCAGCCCAATTAGGTCTCCACCCCTGACTCCCCTCAGCCATAGAAGGCCCCACCCCAGTCTCAGCCCTACTCCACTCA\\\nAGCACTATAGTTGTAGCAGGAATCTTCTTACTCATCCGCTTCCACCCCCTAGCAGAAAATAGCCCACTAATCCAAACTC\\\nTAACACTATGCTTAGGCGCTATCACCACTCTGTTCGCAGCAGTCTGCGCCCTTACACAAAATGACATCAAAAAAATCGT\\\nAGCCTTCTCCACTTCAAGTCAACTAGGACTCATAATAGTTACAATCGGCATCAACCAACCACACCTAGCATTCCTGCAC\\\nATCTGTACCCACGCCTTCTTCAAAGCCATACTATTTATGTGCTCCGGGTCCATCATCCACAACCTTAACAATGAACAAG\\\nATATTCGAAAAATAGGAGGACTACTCAAAACCATACCTCTCACTTCAACCTCCCTCACCATTGGCAGCCTAGCATTAGC\\\nAGGAATACCTTTCCTCACAGGTTTCTACTCCAAAGACCACATCATCGAAACCGCAAACATATCATACACAAACGCCTGA\\\nGCCCTATCTATTACTCTCATCGCTACCTCCCTGACAAGCGCCTATAGCACTCGAATAATTCTTCTCACCCTAACAGGTC\\\nAACCTCGCTTCCCCACCCTTACTAACATTAACGAAAATAACCCCACCCTACTAAACCCCATTAAACGCCTGGCAGCCGG\\\nAAGCCTATTCGCAGGATTTCTCATTACTAACAACATTTCCCCCGCATCCCCCTTCCAAACAACAATCCCCCTCTACCTA\\\nAAACTCACAGCCCTCGCTGTCACTTTCCTAGGACTTCTAACAGCCCTAGACCTCAACTACCTAACCAACAAACTTAAAA\\\nTAAAATCCCCACTATGCACATTTTATTTCTCCAACATACTCGGATTCTACCCTAGCATCACACACCGCACAATCCCCTA\\\nTCTAGGCCTTCTTACGAGCCAAAACCTGCCCCTACTCCTCCTAGACCTAACCTGACTAGAAAAGCTATTACCTAAAACA\\\nATTTCACAGCACCAAATCTCCACCTCCATCATCACCTCAACCCAAAAAGGCATAATTAAACTTTACTTCCTCTCTTTCT\\\nTCTTCCCACTCATCCTAACCCTACTCCTAATCACATAACCTATTCCCCCGAGCAATCTCAATTACAATATATACACCAA\\\nCAAACAATGTTCAACCAGTAACTACTACTAATCAACGCCCATAATCATACAAAGCCCCCGCACCAATAGGATCCTCCCG\\\nAATCAACCCTGACCCCTCTCCTTCATAAATTATTCAGCTTCCTACACTATTAAAGTTTACCACAACCACCACCCCATCA\\\nTACTCTTTCACCCACAGCACCAATCCTACCTCCATCGCTAACCCCACTAAAACACTCACCAAGACCTCAACCCCTGACC\\\nCCCATGCCTCAGGATACTCCTCAATAGCCATCGCTGTAGTATATCCAAAGACAACCATCATTCCCCCTAAATAAATTAA\\\nAAAAACTATTAAACCCATATAACCTCCCCCAAAATTCAGAATAATAACACACCCGACCACACCGCTAACAATCAATACT\\\nAAACCCCCATAAATAGGAGAAGGCTTAGAAGAAAACCCCACAAACCCCATTACTAAACCCACACTCAACAGAAACAAAG\\\nCATACATCATTATTCTCGCACGGACTACAACCACGACCAATGATATGAAAAACCATCGTTGTATTTCAACTACAAGAAC\\\nACCAATGACCCCAATACGCAAAACTAACCCCCTAATAAAATTAATTAACCACTCATTCATCGACCTCCCCACCCCATCC\\\nAACATCTCCGCATGATGAAACTTCGGCTCACTCCTTGGCGCCTGCCTGATCCTCCAAATCACCACAGGACTATTCCTAG\\\nCCATGCACTACTCACCAGACGCCTCAACCGCCTTTTCATCAATCGCCCACATCACTCGAGACGTAAATTATGGCTGAAT\\\nCATCCGCTACCTTCACGCCAATGGCGCCTCAATATTCTTTATCTGCCTCTTCCTACACATCGGGCGAGGCCTATATTAC\\\nGGATCATTTCTCTACTCAGAAACCTGAAACATCGGCATTATCCTCCTGCTTGCAACTATAGCAACAGCCTTCATAGGCT\\\nATGTCCTCCCGTGAGGCCAAATATCATTCTGAGGGGCCACAGTAATTACAAACTTACTATCCGCCATCCCATACATTGG\\\nGACAGACCTAGTTCAATGAATCTGAGGAGGCTACTCAGTAGACAGTCCCACCCTCACACGATTCTTTACCTTTCACTTC\\\nATCTTGCCCTTCATTATTGCAGCCCTAGCAACACTCCACCTCCTATTCTTGCACGAAACGGGATCAAACAACCCCCTAG\\\nGAATCACCTCCCATTCCGATAAAATCACCTTCCACCCTTACTACACAATCAAAGACGCCCTCGGCTTACTTCTCTTCCT\\\nTCTCTCCTTAATGACATTAACACTATTCTCACCAGACCTCCTAGGCGACCCAGACAATTATACCCTAGCCAACCCCTTA\\\nAACACCCCTCCCCACATCAAGCCCGAATGATATTTCCTATTCGCCTACACAATTCTCCGATCCGTCCCTAACAAACTAG\\\nGAGGCGTCCTTGCCCTATTACTATCCATCCTCATCCTAGCAATAATCCCCATCCTCCATATATCCAAACAACAAAGCAT\\\nAATATTTCGCCCACTAAGCCAATCACTTTATTGACTCCTAGCCGCAGACCTCCTCATTCTAACCTGAATCGGAGGACAA\\\nCCAGTAAGCTACCCTTTTACCATCATTGGACAAGTAGCATCCGTACTATACTTCACAACAATCCTAATCCTAATACCAA\\\nCTATCTCCCTAATTGAAAACAAAATACTCAAATGGGCCTGTCCTTGTAGTATAAACTAATACACCAGTCTTGTAAACCG\\\nGAGATGAAAACCTTTTTCCAAGGACAAATCAGAGAAAAAGTCTTTAACTCCACCATTAGCACCCAAAGCTAAGATTCTA\\\nATTTAAACTATTCTCTGTTCTTTCATGGGGAAGCAGATTTGGGTACCACCCAAGTATTGACTCACCCATCAACAACCGC\\\nTATGTATTTCGTACATTACTGCCAGCCACCATGAATATTGTACGGTACCATAAATACTTGACCACCTGTAGTACATAAA\\\nAACCCAATCCACATCAAAACCCCCTCCCCATGCTTACAAGCAAGTACAGCAATCAACCCTCAACTATCACACATCAACT\\\nGCAACTCCAAAGCCACCCCTCACCCACTAGGATACCAACAAACCTACCCACCCTTAACAGTACATAGTACATAAAGCCA\\\nTTTACCGTACATAGCACATTACAGTCAAATCCCTTCTCGTCCCCATGGATGACCCCCCTCAGATAGGGGTCCCTTGACC\\\nACCATCCTCCGTGAAATCAATATCCCGCACAAGAGTGCTACTCTCCTCGCTCCGGGCCCATAACACTTGGGGGTAGCTA\\\nAAGTGAACTGTATCCGACATCTGGTTCCTACTTCAGGGTCATAAAGCCTAAATAGCCCACACGTTCCCCTTAAATAAGA\\\nCATCACGATG\";\n\n// Pattern has same length as in pattern_matching.rs, but 2 differences to best match.\n// With k = 5 there are 14 hits, with k = 6, there are 78 hits (most are overlapping)\nstatic PATTERN: \u0026'static [u8] = b\"GCGCGTCCACACCGCTCG\";\n\nstatic K: u8 = 6;\n// used with assertions to ensure correct code and to prevent over-optimization\nstatic N_HITS: usize = 78; // at given K\n\n#[bench]\nfn ukkonen(b: \u0026mut Bencher) {\n    let mut ukkonen = Ukkonen::with_capacity(PATTERN.len(), unit_cost);\n    b.iter(|| {\n        let mut n = 0;\n        for _ in ukkonen.find_all_end(PATTERN, TEXT, K as usize) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn pairwise_align(b: \u0026mut Bencher) {\n    use bio::alignment::pairwise;\n\n    let s = pairwise::Scoring::new(-1, -1, |a, b| if a == b { 1 } else { -1 });\n    let mut aligner = pairwise::Aligner::with_scoring(s);\n\n    b.iter(|| {\n        let _ = aligner.semiglobal(PATTERN, TEXT);\n    });\n}\n\n#[bench]\nfn myers_end_32(b: \u0026mut Bencher) {\n    let myers: Myers\u003cu32\u003e = Myers::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        for _ in myers.find_all_end(TEXT, K) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_end_64(b: \u0026mut Bencher) {\n    let myers = Myers::\u003cu64\u003e::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        for _ in myers.find_all_end(TEXT, K) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_end_long_64(b: \u0026mut Bencher) {\n    let myers = long::Myers::\u003cu64\u003e::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        for _ in myers.find_all_end(TEXT, K as usize) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_end_long_8(b: \u0026mut Bencher) {\n    let myers = long::Myers::\u003cu8\u003e::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        for _ in myers.find_all_end(TEXT, K as usize) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[cfg(has_u128)]\n#[bench]\nfn myers_end_128(b: \u0026mut Bencher) {\n    let myers = Myers::\u003cu128\u003e::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        for _ in myers.find_all_end(TEXT, K) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[cfg(has_u128)]\n#[bench]\nfn myers_end_long_128(b: \u0026mut Bencher) {\n    let myers = long::Myers::\u003cu128\u003e::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        for _ in myers.find_all_end(TEXT, K as usize) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_pos_64(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu64\u003e::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        let matches = myers.find_all(TEXT, K);\n        for _ in matches {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[cfg(has_u128)]\n#[bench]\nfn myers_pos_128(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu128\u003e::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        let matches = myers.find_all(TEXT, K);\n        for _ in matches {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_path_reverse_64(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu64\u003e::new(PATTERN);\n    let mut ops = vec![];\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all(TEXT, K);\n        while let Some(_) = matches.next_path_reverse(\u0026mut ops) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_path_64(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu64\u003e::new(PATTERN);\n    let mut ops = vec![];\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all(TEXT, K);\n        while let Some(_) = matches.next_path(\u0026mut ops) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_path_long_64(b: \u0026mut Bencher) {\n    let mut myers = long::Myers::\u003cu64\u003e::new(PATTERN);\n    let mut ops = vec![];\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all(TEXT, K as usize);\n        while let Some(_) = matches.next_path(\u0026mut ops) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_path_long_8(b: \u0026mut Bencher) {\n    let mut myers = long::Myers::\u003cu8\u003e::new(PATTERN);\n    let mut ops = vec![];\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all(TEXT, K as usize);\n        while let Some(_) = matches.next_path(\u0026mut ops) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[cfg(has_u128)]\n#[bench]\nfn myers_path_long_128(b: \u0026mut Bencher) {\n    let mut myers = long::Myers::\u003cu128\u003e::new(PATTERN);\n    let mut ops = vec![];\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all(TEXT, K as usize);\n        while let Some(_) = matches.next_path(\u0026mut ops) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_alignment_64(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu64\u003e::new(PATTERN);\n    let mut aln = Alignment::default();\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all(TEXT, K);\n        while matches.next_alignment(\u0026mut aln) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n// Allocates a new Alignment instance in each loop\n#[bench]\nfn myers_alignment_alloc_64(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu64\u003e::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all(TEXT, K);\n        loop {\n            let mut aln = Alignment::default();\n            if !matches.next_alignment(\u0026mut aln) {\n                break;\n            }\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n// test impact of storing traceback information\n#[bench]\nfn myers_no_alignment_64(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu64\u003e::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all(TEXT, K);\n        while let Some(_) = matches.next_end() {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n// test impact of storing traceback information\n#[bench]\nfn myers_no_alignment_lazy_64(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu64\u003e::new(PATTERN);\n    b.iter(|| {\n        let n = myers.find_all_lazy(TEXT, K).count();\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_lazy_best_alignment_64(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu64\u003e::new(PATTERN);\n    let mut aln = Alignment::default();\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all_lazy(TEXT, K);\n        let mut best_dist = u8::max_value();\n        let mut best_end = 0;\n        for (end, dist) in matches.by_ref() {\n            if dist \u003c best_dist {\n                best_dist = dist;\n                best_end = end;\n            }\n            n += 1;\n        }\n        matches.alignment_at(best_end, \u0026mut aln);\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_lazy_best_alignment_iter_min_64(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu64\u003e::new(PATTERN);\n    let mut aln = Alignment::default();\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all_lazy(TEXT, K);\n        let (best_end, _) = matches\n            .by_ref()\n            .inspect(|_| n += 1)\n            .min_by_key(|\u0026(_, dist)| dist)\n            .unwrap();\n        matches.alignment_at(best_end, \u0026mut aln);\n        assert_eq!(n, N_HITS);\n    });\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","benches","distance.rs"],"content":"#![feature(test)]\n\nextern crate test;\n\nuse test::{black_box, Bencher};\n\nuse bio::alignment::distance::*;\n\nuse std::u32;\n\n// 5,000 random nucleotides, GC content = .55\nstatic STR_1: \u0026'static [u8] = b\"ATCTAACTATTCCCTGTGCCTTATGGGGGCCTGCGCTATCTGCCTGT\\\nCGAACCATAGGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCGGGGCCTAAGACCACGAGCGTCTGGCG\\\nTCTTGGCTAACCCCCCTACATGCTGTTATAGACAATCAGTGGAAACCCGGTGCCAGGGGGTGGAGTGACCTTAAGTCAG\\\nGGACGATATTAATCGGAAGGAGTATTCAACGCAATGAAGCCGCAGGGTTGGCGTGGGAATGGTGCTTCTGTCCAAGCAG\\\nGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTGCACTTTGCAACGATTTCGGAGTCCGGAGACTCGCTG\\\nTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTACGCCCAAGAACGTAGCAAGGTGACTCAAACAAGGTA\\\nCATCTTGCCCGCGTTTCACACGAATCAAGTTGGAGGTTATGGAGCATAGTAACACGTGGGCGGCCAGTGGTCGGTTGCT\\\nACACCCCTGCCGCAACGTTGAAGGTCCCGGATTAGACTGGCTGGACCCATGCCGTGACACCCGTCACACTCCATTACCG\\\nTCTGCGGGTCACGGCTTGTTGTGGACTGGATTGCCATTCTCTCAGTGTATTACGCAGGCCGGCGCGCGGGTCCCATGTA\\\nAACCTGTCATAGCTTACCTGACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCCACGCACCTGGTCGGTCCTCGTTTGCT\\\nTTTTAGGACCGGATGAACTACAGAGCGCTGCAAGAATCTCTACCTGCTTTACAAAGCGCTGGGTCCTACTCCAGCGGGA\\\nTGTTTTATCTAAACACGATGAGAGGAGTATTCGTCAGGCCACATGGCTTTCTTGTCCTGGTCGGATCCATCGTTGGCGC\\\nCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTGCATGCCAGATCGGCAGACAGATAGCGGATCCAGTAT\\\nATCCCTGGAAGCTATAGACGCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTCCGAACCCAGCTCTACTTTAGTGGCCA\\\nCGGGTTCTGGTCCCCCCGGGCCGCGGAACCGATTAGGGCCATGTACAACAATACTTATTAGTCACCTTTCAGACACGAT\\\nCTCCCTGCTCAGTGGTATATGGTTCCTGCTATAATTAGCCACCCTCATAAGTTGCACTACTTCTGCGACCCAAGTGCAC\\\nCCTTACCACGAAGACAGGATTGTCCGATCCCATACTGCGGCCTTGGCAGGGGGTTCGCAAGTCCCACCCCAAACGATGC\\\nTGAAGGCTCAGGTTACACAGGCACAAGTGCTATATACGCGAGTTCCCGCTCTTAACCTGGACCGAATGCGGGATCATGC\\\nATCGTACCACTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGATACATAGTTCAATCAAGAATACCTTGTATTATTGTA\\\nCACCTACCGGTCACCAGCCAACAATGTGCGGACGGCGTTGCGACTTGCTGGGCCTGATCTCACCGCCCTAGATACCGCA\\\nCACTGGGCAATACGAGGTAAAGCCAGTCACCCAGTGTCGATCAACAGCTGACGTAACGGTAAGAGGCTCACAAAATCGC\\\nACCGCCGGCGTCCCCTGGGTATTTTACGTCAGCATCGGGTGGACTGGCATGAATCTTTACTCCCAGGCGGAAACGGGTG\\\nCGTGGACAAGCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGGTGTCTCGTATCCCTCTTGGAGATCGAGGAAATGTTT\\\nCACGACCAAGGGAAAGGTCGCCCTACGAAATAGATTTGCGCTACTGTCCGCATAAGGAGTCCGGTGTAGCGAAGGATGA\\\nAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAAGCAGGCACGGAAAGACACGGTCTAGC\\\nAGACCGTCTATCGGCTAGGTCAAATAGGGTGCTTTGATATCAGCATGTCCAGCCTTAGAATTCAGTTCAGCGCGCTGGT\\\nCTGGGTCGAGATAAAATCACCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTGGCTAATCCTGGTACATCTTGTAATCA\\\nATGTTCAGAAGAAAATCTGTGTTAGAGGGACGAGTCACCACGTACCAATAGCGACAACGATCGGTCGGACTATTCATCG\\\nTGGTGGTGACGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAGGATATAATGCTGAGGCGCTGCCCCAA\\\nCCGTTCAGCGTGGGGTTTGCTACAACTTCCGAGTGCTACGTGTGCGAGACCATGTTATGTATGCACAAGGCCGACAATA\\\nGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCACAGTAGATCCTCCCCGCGCATCCTATTTATTAAGTT\\\nAATTCTATAGCAATACGATCACATGCGGATGGGCAGTGGCCGGTAGTCACACGCCTACCGCGGTGCTCAATGACCGGGA\\\nCTAGAGAGGCGAAGATTATGGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGAGCGTCATTGCGAGTAGTCGATTGCTT\\\nTCCCAATCTCCGAGCGATTTAGCGTGACAGCCCCAGGGAACCCACAAAATGCGATCGCAGTCCACCCGATCGTACACAG\\\nAAAGGAGGGTCCCCATACGCCGACGCACCTGTTCGCACGTCGTATGCATAAACGAGCCGCACGAACCAGAGAGCATAAA\\\nGAGGACCTCTAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGCCGGGATGCCTTACCTAGACGCAATGACGGACGTATT\\\nCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAAGCCGCCTTTCCAAAGTGAGTCCTTCG\\\nTCTGTGACTAACTGTGCCAGATCGTCTTGCAAACTCCCGATCCAGTTTAACTCACCAAACTATAGCCGTACAGACCCAA\\\nATCTTAAGTCATATCACGCGACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGTTTTGGTCCGCCCGAGCGGTGCAGCCG\\\nATTAGGACCATCTAATGCACTTGTTACAAGACTTCTTTTAAACACTTTCTTCCTGCCCAGTGGCGGATGATAATGGTTG\\\nTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAATGTGCCGTCTCCACCAACACAGGGCTGTCCGGTCGT\\\nATAATAGGACTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGGACTCGCGATGTACATGCTCTGGTTCA\\\nATACATACGTGACCCGGCAGTTATCCTGCATCGGAACGTCAATCGTGCATCGGGCCAGCGTAATCGTGTCATCTGGGAG\\\nGCGGCCGTAGGATAAATAATTCAATAAAGATGTCGTTTTGCTAGTATACGCCTAGGCGTCACCCGCCATCTCTGTGCAG\\\nGTGGGCCGACGAGACACTGCCCCTGATTTCTCCGCTACTAATAGCACACACGGGGCAATACCAGCACAAGCCAGTCTCG\\\nCGGGAACGCTCGTCAGCATACGAAAGAGCTTGAGGCACGCCAATTCGCACTGTCGGGGTCGCTTGGGTGTTTTGCACTA\\\nCCGTCAGGTACGCTAGTATGCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGGTCAAAAGTGCGGCATTCGTATTTGCT\\\nCCCCGTGCTTGCTCTCACGAACTTGACCTGGAGATCAAGGAGATGCTTCTTGTGGAACCGGACAGCGCATCAACGCAAC\\\nGGATCTACGTTACAGCGTGCATAGCGAGAACGGAGTTGCCGACGACGAAAGCGACACTGGGATCTGTCCGTCGTCATTC\\\nGCGGAAAGCATCCGCTCACGAGGCGGACACTGATTGACACGGTTTTGCAGAAGGTTAGGGGAATAGGTCAAATTGAGTG\\\nGCTTAAAAACGCTATGTCTGGGATTAAAGTGTAGTAAACTGCGGTCAACGGAGACGGTTTTAAGACAGGAGTTCGCAAA\\\nACCAGGCGGGGTCGCCACGACGGCTATTCCTGGTGGTTTAGGCGTACAATGTCCTGAAGAATATTTAAGAAAGAAGCAC\\\nCCCTCGTCGCCTAGAATTACCTACCGCGGTCGACCATACCTTCGATTGTCGCGCCCACCCTCCCATTAGTCGGCAGAGG\\\nTGGTTGTGTTGCGATAGCCCAGCATGATATCCTAAGGCGTTACGCCGATGGATATCCCACGGAATTGCCATAGGCGCTG\\\nAACGCTACACGGACGATACGAACTTATGTATGGAGCGGGTCATCGAAAGGTCATACCCTTGTAGTTAACATGTAGCCCG\\\nGCCCTATTAGTACAGCAGTGCCTTGAGCGGCATTCTCATTATTAAGTTTTCTCTACAGCCAAACGACCAAGTGCACTTC\\\nCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCAGCTCTGTAATAGGGACTAAAAGAGTGATGATAATCATGAGTGCCGC\\\nGTTATGGTGGTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCGAGTTCCGTCCGGTTAAGCGTGACACT\\\nCCCAGTGTACCCGCAAACCGTGATGGCTGTGCTTGGGGTCAATCGCATGTAGGATGGTCTCCAGACACCGGGGCACCAG\\\nTTTTCACGCCCAAAGCATAAACGACGAGCAGTCATGAGAGTCTTAGAACTGGACGTGCCGTTTCTCTGCGAACAACACC\\\nTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTCCTATCACATTTGCCTCGACGACTGCCGCCTTCGCTG\\\nTTTCCCTAGACACTCAACAGTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGTCAGTGGCTGCGCCAAAACGTCTTCGG\\\nATCCCCTTGTCCAATCAAACTGACCGAATTCTTTCATTTAAGACCCTAATATGACATCATTAGTGACTAAATGCCACTC\\\nCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAACGA\";\n// 5,000 random nucleotides, GC content = .45\nstatic STR_2: \u0026'static [u8] = b\"CTAAAGTGGCGAAATTTATGGTGTGTGACCCGTTATGCTCCATTTCG\\\nGTCAGTGGGTCATTGCTAGTAGTCGATTGCATTGTCATTCTCCGAGTGATTTAGCGTGACAGCCGCAGGGAACCCATAA\\\nAATGTAATCGTAGTCCATCTGATCGTACTTAGAAATGAAGGTCCCCTTTTACCCACGCACCTGTTTACTCGTCGTTTGC\\\nTTTTAAGAACCGCACGAACCACAGAGCATAAAGAGAACCTCTAGTTCCTTTACAAAGTACTGGTTCCCTTTTCAGCAAG\\\nATGCCTTATCTAAATGCAATGACAGACGTATTCCTCAGGCCACATCGCTTCCTACTTTCGCTGGGATCCATCATTGGCA\\\nGCTGAAACCGCCATTCCATAGTGAGTCCTTCGTCTGTGTCTTTCTGTGCCAAATCGTCTAGCAAATTGCTGATCCAGTT\\\nTATCTCACGAAATTATAGTCATACAGACCGAAATTTTAAATCAAATCACGCGACTAGGCTCAGCTTTATTTTAGTGGTC\\\nATGGGTTTTGGTCCGCCCGAGCGGTGCAACCGATTAGGACCATGTAAAACATTTGTTACAAGTCTTCTTTTAAATACAA\\\nTCTTCCTGCTCAGTAGCGCATGATTATCGTTGTTGCTAGCCAGTGTGGTAAGTAACAGCACCACTGCGAGCCTAATGTG\\\nCCCTTTCCACGAACACAAGGCTATCCGATCCTATATTAGGATTCCGCAATGGGGTTAGCAAATCGCACCCTAAACGATA\\\nTTGAAGACTTGCGATGTACATGCTTTGGTACAATACATACGTGTTCCAGTTGTTATCCTGTATCGGAACTTCAATTATG\\\nCATCGCACCAGCATATTCATGTCATCTAGGAAGAGCGCGTAGGATAAATAATTCAATTAAGATGTCGTTATGCTAGTAT\\\nACGTCTACCCGTCACCGGCCATCTGTGTGCAGATGGGGCGACGAGTTATTGACCCTGATTTCTCCACTTCTAATACCAC\\\nACACTGGGCAATACGAGCTCAAGCTAGTCTCGCAGTAACGCTCATCAGCTAACGAAAGAGTTAAAGGCTCGCTAATTCG\\\nCACTGTCAGGGTCTCTTGGGTGTTTTGCACTAGCGTCAGGTAGGCTAGTATGTGTTTTTCCTTCCAGAGGTATGTGGCT\\\nGCGTGGTCAAATGTGCAGCATACGTATTTGCTCGACGTGTTTAGTCTCTCATACTTCTCCTGGAGATCAAGGAAATGTT\\\nTCTTGTCCAAGTGGACAACGGTTCTACGGAATGGATCTACGTTACTGCCTGCATAAAGAAAACGGAGTTGCTAAGGACG\\\nAAAGCGACTTTAGGTTCTAACTGTTGACTTTGGCGGAAAAGTTTCATTCAGGAAGCAGACACTGATTGACACGGTTTAG\\\nCAGAACGTTTGAGGATTAGGTTAAATTGAGTGGTTTAATATTGGTATGTCTGGGATTAAAATATAGTATAGTGTGTTAA\\\nTCGGAGACGAATTAAAGACACGAGTTCCCAAAATCAAGCGGGCTCATTACAACGGTTAATCCTGGTAGTTTACGTGAAC\\\nAATGTTCTGAAGAAAATTTATGAAAAAAGGACCCGTCATCGCCTACAATTACCTACAACGGTCGACCATACCTTCGATT\\\nATCGTGGCCACTCTCGGATTACACGGCAGAGGTGGTTGTGTTCCGATAGGCCAGTATATTATTCTAAGGCGTTACCCTA\\\nATCATTTTTCATCGGATTTGCTATAGCCCTTGAACGCTACATGCACGAAACCAAATTATGTATACACTGGGTCATCAAT\\\nAGGATATAGTCTTGTAGTTAACATGTAGCCCGGCCGTATTAGTACAGTAGAGCCTTCATTGACATTCTGTTTATTAAAT\\\nTATTTCTACAGCAAAACGATCATATGCAAATCCACAGTGCGCGATAGAGATACATTCACTCGGCTGCTCTGTAATAGGG\\\nACTAAAAAAGTGATGATTATCATGAGTGCCCCGTTATGGTCGTGTTCGATCAGAGCGCTCTTACGAGCAGTCGTATACT\\\nTTCTCGAATTCCGTGCAGTTAAGCGTGACAGTCCCAGTGAACCCACAAAACGTGATGGCAGTCCATGCAATCATACGCA\\\nAGAAGGATGGTCTCCAGACACCGGCGCACCAGTTTTCACGCCGAAAGCATAAACGAGGAGCACAAATGAAAGTGTTTGA\\\nACTGGACCTGTAGTTTCTCTACGAAAAATACCTTGAGCTGTTGCGTTGTTGCGCTGCCTAGATGCAGTGTTGCACATAT\\\nCACTTTTGCTTCAACGACTGCTGCTTTCGCTGTAACCCTAGACAGACAACAATAAGCGCTTTTTGTAGGCAAGAGCTCC\\\nGCCTATGACTAACTGCGCCAAAACATCTTCCAATCCCCTTATCCAATTTAATTCATCGAATTCTTACAATTTAGACCCT\\\nAATATCACATCATTAGACATTAATTGCCTCTGCCAAAATTCTGTCTACAAATGTTTTAGTTCGCTCCAGTAAAGTTGTT\\\nAATAACGACTACTAAATCCGCATGTTACGGGATTTCTTATTAATTCTTTTTTCGTAAGGAACAGCGGATCTTAATGGAT\\\nGGCGCCAGGTGGTATGGAAGCTAATAGCGCGGGTGAGAGGGTAATTAGCCGTCTTCACCAACACAACGCTATCGGGTCA\\\nTACTATAAGATTCCACAATGCGACTACTTATAAGATGTCTTAACGGTATCCGCAACTTGTGATGTGCCTACTATGCTTA\\\nAATGCATATCTCGCTCAGTAACTTTCCAATATGAGAGCATCAATTGTAGATCGGGCCGAGATAATCATGTCGTCACGGA\\\nACTTATTGTAAGAGTAATAATTTAAAAGAGATGTCAGTTTGCTGGTTCACGTAAAGGTTCCTCACACTACCTCTAAATA\\\nAGTGAGCGGTCGTGACATTATCCCTGATTTTCTCACTACTATTAGTACTCACGACACAATTCTACCACAGCCTTGTTTC\\\nGCCAGAATGCCAGTCAGCATAAAGAAGAGCTCAAGGCAGGTCAACTCGCATTGTGAGAGTTACATGAACGTTCGGCACT\\\nACCGACACGAACCTCAGTTAGCGTACATCCTACCAGAGGTCTGTGGCCCCGTGGTCAAAAGTGCGGATTTCGTATTTGC\\\nTGCTCGTCAGTACTTTCAGAATCATGACCTGCACGGTAAAAAGACGCTTATTATGGAGTTCGACATGGCAATAACGCGA\\\nCGAATCTACGTCATGACGAGAATAGTATAAACAAAACTGCTGACGGCAGAAGCGTCAAAGAAGTCTGTAAATTGTTATT\\\nCGCGAAAAACATCCGTCTCCGTGGGGGATAATCACCGACGCCATTTTATAGAAGCCTAGGGGAACAGATTGGTTTAATT\\\nAGCTTAAGAAAGTAAATTCTGGGATTATACTGTAGTAATCACTAATTTACGGTGAGGGTTTTATGGCGGATTTTTACAA\\\nATTCAAACCAGGTGATTTCAACAAATTTTGTTGACGATTTAGGCGCACTATCCCCTAAACTACAAATTAAAAAATAGCG\\\nTTCCTTGACGGCTAGAATTACTTACCGGCCTTCACCATACCTTCGATATTCGCGCCCACTCTCCCATTAATCCGTACAA\\\nGTGGATGTAATGCGATTGTCCGCTAAGATATTCTAACGTGTAACGTAGATAAGTATTTTACAGAGTTGCCGTACGCGTT\\\nGAACACTTCACAGATGATAGGAATTTGCGTATAGAGCGTGTTATTGAGGAGTTATACACCCGTAGACTACAATGGGCCC\\\nAACTCAATCAGAACTCGAGTGCCTTGAATAACATACTCATCACTAAACATTCTCAACAATCAATCGAGCAAGTCCATTA\\\nTCAACGAGTGTGTTGCAGTTTTATTCTCTTGCCAGCATTGTAATAGGCACTAAAAGAATGATGATAGTCATGAGTACTG\\\nAGCTAAGACGGCGTCGATGCATAGCGGACTTTCGGTCAATCACAATTCCTCACGAGACTCGTCCTGTTGAGCGTATCAC\\\nTCTCAATGTACAAGCAACCCAAGAAGGCTGTGCCTGGACTCAACTGGATGCAGGATGAACTCCAGACACGGGGTCACTA\\\nCTCTTCATACATAAAGCAAGAACGTCGAACAGTCATGAAAGTCTTAGTACCGCACGTACCATCTTACTGTGAATATTGC\\\nTTGAAGCTGTACCGTTATTGGGGGGCAAAGATGAAGTTCTCTTCTTTTCATAATTGTACTGACGACAGTCGTGTTCTCG\\\nGTTTCTTCAAAGGTTAAAGAATAAAGGCTTATTGTAGGCAGAGGAACGCCCTTTTAGTGGCTGGCGTTAAGTATCTTCG\\\nGACCCCCTTGTCTATCCAGATTAATCGAATTCTCTCATTTAGGACCTTAGTAAGTCATCATTGGTATTTGAATGCGACC\\\nTTGAAGAAACCGCTTAAAAATGTCAATGGTTGATCCACTAAACTTCATTTAATTAACTCCTAAATCAGCGCGATAGGCT\\\nATTAGAGGTTTAATTTTGTATAGCAAGGTACTTCCGATCTTAATGAATGGCCGGAAAAGGTACGGACGCGATATGCGAG\\\nGGTGAAAGGGCAAATAGACAGGTTCGTCTTTGTCACGCTAGGAGGCAATTCTATAAGAATGCATATTGCATCGATACAT\\\nAAAATGTCTCGATCGCATGCGCAATTTGTGAAGTGTCTATTATCCCTAAGCCCATTTCCCGCATAATAACCCCTGATTG\\\nTATCCGCATTTGATGCTACCCAGGTTGAGTTAGCGTCGAGCTCGCGGAACTTATTGCATGAGTAGAGTTGAGTAAGAGC\\\nTGTTAGATGGCTCGCTGAACTAATAGTTGTCCACAGAACGTCAAGATTAGAAAACGGTTGTAGCATTATCGGAGGTTCT\\\nCTAACTACTATCAATACCCGTGTCTTGACTCTGCTGCGGCTACCTATCGCCTGAAAACCAGTTGGTGTTAAGGGATGCT\\\nCTGTCCAGGACGCCACATGTAGTGAAACTTACATGTTCGTTGGGTTCACCCGACT\";\n// 5,000 random nucleotides, GC content = .0\nstatic STR_3: \u0026'static [u8] = b\"AATTTAAAATAAAATTATTTTAAAAAATAAATTTTTATTATTTTTTT\\\nTATAAATAATTTAATATATTAAAAATATAAAATTAATTTTTTTAATAATTATAAATTAAAAATTTAAAATATTATTTAA\\\nAATATAAATTTAATAATATATATTTTAATTATTTAATTATTTTTTATATTTTATAAAAATTTATATTATTTATTTATTA\\\nAATTATAAAATTTATATTAATATATAAATTTAAATTAAAATAAAATTTTTAAAATTTAAAATTATAAATATTTAATATT\\\nTTAATTAATTTTTATATATATTATTATAAATAATTAATAAAAATTTTATATTAAAAAATAAAATAATTTTAAATTAAAA\\\nATAATATTAATTAAAAAAAATATTTAATATAATAAAATTATAAAATTAATATAAAAATAATATTTTTATTTAAATAAAT\\\nAAAAATATAATATTATAATTATTTTTTAAATATATAAAATATATTTTATAATAATTTTTAAATTTAAAAATTTATTATT\\\nTTTAAAATTTATATTTAAAAATAAATATTAAATTAAATTTATATTTAAAAATATAATAAAATAATTTAAATAAAATATA\\\nTTTTATTTATATTTTATATAAATTAAATTAAAAATTATAAAATATAATAATATATAAATAATTAATAATTAATTATTAT\\\nATATTTATTATAATATTAAAAATTTTAAATTAAATTAATAAAATTTATATTATAATATTTATTATATTTTATTATTATT\\\nTATAAATTATAATTTATTATAAATTAAATTATTATTTTTTTAATATATTATAAAAATTAATATATAAATTTTATATAAA\\\nTTAATTATAATTTATTTAATTTTATTTAAAAATATAATTTTATTTTTATTTATATATTTAATTAATTTTTATTTATTTT\\\nTTAAAATTAAATAAATTATAAAATATTATAAAAATTTTTATTTATTTTATAAAATATTAAATTTTTTTTTAATAAAATA\\\nTTTTATTTAAATATAATAAAAAAAATATTTTTTAAATTATATAATTTTTTTATTTTATTTAAATTTATTATTAATAATT\\\nAATATTTTTATTTTATAATAAATTTTTTATTTAAATTATTATATATTAAATTAATTAATAAATAATAAATTTAATATAT\\\nTTTTAAAAATTATAAATATATAAATTAAAATTTTAAATAAAATTATATATTTAAATTTAATTTTATTTTAATAATTATA\\\nAATTTTAATTTTTTTAAATTATATAATTAATTAAAATTATATAAAATAATATTTATAAATTATTTTTTAAATATAATTT\\\nTTTTATTTAATAATATATAATTTTTATTATAATTAATTATTTTTATAAATAATATTATTTTTATAATTTAAATATATTT\\\nTTTTTATAAATATAAAATTATTTAATTTTATATTATAATTTTAATAAAAAATTTATAAATTTTATTTTAAATAATATTA\\\nAAAATTTAAATTATATAAATATAAATATTATATATATAAATTTTTATTTTTAATTTAAATTAAAAATATAATTATATAT\\\nTATATTATTATATTTATATTATTTAAAATAAATATATAAAATATATAATTTAATTAAAAATATTTTATATTATTATATA\\\nTTTATTAATTATTAATTAATAATATATAAATAATATTATAATTTATTAAATTTAATTTTATTATTTTAAATATTATATA\\\nTTAAATAATATAAAATAAAATTAATTATTTAATAATAATTATTAATTAATATAATAATAAAAAATTTATTAAATTATAT\\\nTATTAATATTTTTTAAATATTTTATATTAATATTAAATAAATTAATATAAATTTTTATTTTTAAAAAAAAATAAATATA\\\nTAAATAAATAAATAATAAATAAAAATTTTTAATATATTTAATATTTTATATTTTTTTTAAAAATTAAAAAAATATTTTA\\\nTAATTAAAAAAAAAATTATTTTATAAAATAAATTTATATTATTATTTATATAAAAAATTTAATATAATAAAAAATAAAA\\\nATAATTTTAAATAATAATTATTAATTTTAATAATAAAATATTATTTAAAAAATAAATATAAAAAAATATAATTTAATAA\\\nATTATTTAATAATTAAATTAAATAAAATATTTTAATATTAATATATTTAATTTTAAAATTTAATTTAATATATTAATTT\\\nAAATTAAAATAAAATTATTAATATTTAAAATTAAATAAATTTATTATATTAATTAATTTTAATATATTTTATAAATAAT\\\nATTTAAAAAAAAATTTATATTAAAAAAATAAATTATTATATATTAATAATAATAATAATTAATTATATTATTTATTATT\\\nATAATAATATTTAAATTATATAAAAAAAATATTTATATTTTAATAAATTAAAATATAATTTTAAAATATTATTTTAATT\\\nATTTAATATAAAATTTATTATAATTTTTAAATATTATATATATAAAATTATATTATATATATATAAAATTAATAATAAA\\\nATATAATTTTAAAATTAATATATAATATAATTATATAAATATAATAAATTTTTTTTATATATTTTATTTATTAAATTAA\\\nTTTTATAATAATATAATTATATATAAATAAATAATAATTAATAAATATATATTTATTTTATTATTTAATAATTAAAATT\\\nAAAAAAATAAAAATTATAATATATAATTTATTATATTTAAATTTAATTAAAATATTATTATAAATAATTAATTATTTTT\\\nTTAATTTTTAAATAATTAAATATAATAATTTTAAAAAATTTATAAAATATAATTATAATTTATTTAATTATATATAAAA\\\nAAAAAAATTTTTATATATTAATATATTAATTTATATATTATATATATAAATAAATTATATAAATTAAAAAATATAAAAA\\\nAAATTTTTAATTTTTTTATAAAAAATAAATTTATTTATTATTAAAATATTTTATTTAAATATAATAATAAATATATTTT\\\nTTTTATTTTAATAATTTTTATTTTTATTAAAATTTAAAATTAATAATTAAAATTATTTTTTTAAAATAAATTTTTTATT\\\nTATAATTAATTATATTAAATTATTTTATAAATTTTTAATTTAATTTAATTTATTAAATTATAATTATATAAATTTTAAT\\\nTTTATATTATATTATATAATTAATTTTTATTTAATTTTTATATTTAAAAATTTTAATTTATTTAAATAATATTATTAAT\\\nTAAAATTATTAAATATATTTATTATAAAATTTTTTTTAAATATTTTTTTTTTAAATAATAATAAATATTAATAAATATT\\\nATTAATTAATATAAAAATTAATAATATTAATAAAAATTTAATATATTATTTTTATTAATATAAAATTATTTAATTATAT\\\nAATAAAATTTTATAATAAAATTAATAAAAAATAATTTAAATAATATTAAAAATTTATAATATATATATTTTAATTTAAT\\\nATATATATAATTTAATAATTATTTTATATTAAAATATTAATTATATATTAAATTAATATAATTATATTATTTTAAAAAT\\\nAATTATAAAATAAATAATTTAATAAAAATATTATTTTATTAATATATATTTAAATATTATATATTATTTTTATATAAAT\\\nAAATTAATAAAATATTATTTTTAATTTTTTTATTATTAATAATATTTATAAAATAATATTAATATAAATTAATTTTATA\\\nAAAATATTTATTAATATATAAAAAAATTTAAAATATATTAATTTATATTATTAAAATTATTTAAATATTTTATATTATT\\\nATTAAATATATTAATATATATTTTTTTTATTAAAAATTTATAATTATATAATTAAAAATATAATTTTTATATTTATTTT\\\nTTATATTTATTTTTATAAATTTAATTTAAATATTAAAAAAATATTTTTTATAAAATTTAATAATATAATAATATAATAA\\\nATTTATATTATAATATATATAATAAAAATAAAATTATTAATAATAAAAATAATATTAAAATTTATTTATTATTATTTAT\\\nAAAAAATATTTATTTTTAAAATAAATATTAATTAATATAATTTTATAAAAAATTAAAAAAATAAATTAAATTAAATAAT\\\nTTAAAAATATTAAATTTAAAATTATAATATAATAATTTATAATTAATAAAAATAATTTTAAAATAAATATTTATAAAAT\\\nTAAATAAAATTATTTTAATAATTATTATTAATAATTTAAATATATAATATTTTAAAAAATAATTAAAAAAAAAATATTT\\\nTTTATTATTTAAAATTATTTATTATAATTTATTATATTTTTAATTATTATATTTATTTTTTTATTAATTAATAAAAATA\\\nATTATATTATAATAATTTAATATAATATTTTAAAATATTATATTAATAAATATTTTATAAAATTATTATAAATATTAAA\\\nTATTATATAAATAATATAAATTTATATATAAAATAAATTATTAAAAAATTATATTTTTATAATTAATATTTAATTTAAT\\\nTTTATTAATATAATAATATTTTAAATAATATTTTTATTATTAAATTTTTTTTATAATTAAATAATTAAATATATTTTTA\\\nAAAAATATAATAAAAATTTATTTATTTATTAATATTATAATAAAAATTAAAAAAATAATAATAATTATAAATATTATAT\\\nTAAAATAATATTAAAATAAAATAATTTTATAATTAATTATATTTTTTTTTAAATTTTATTTAATTAAATATAATATTTT\\\nTAATATATTTATAAATTATAATAATTATATTTAAAATTAATTATATATAAAATAATTTTTAAATATTAAAATATTAATT\\\nTTTATATTTAAAATATAAATAATAAATAATTATAAAAATTTTAATATTAAATATATTATTTTTTTATAAATAATATTTT\\\nAAATTATATTATTATTATATTATTTAAATATAATATTATTTTTATTATATTTATTTTAATAATTATTATTTTTATAATT\\\nTTTTTAAATATTTAATAATAAATATTTTTTATAAATAAAAATATTTTTTATTAAT\";\n// 5,000 random nucleotides, GC content = 1.\nstatic STR_4: \u0026'static [u8] = b\"GGGGGGGGGGCGCGCGGCCCCCCGCCGGGGCGCCCCCGCGCGCGGCG\\\nCGGCCGCGCGCCCCGCGGGGGCGGCGGGCGCGCCGGGCGCCCCGCGGGCGGCGGGGGCCCGGGCGGGGGGCGCGCGGCC\\\nGGGGGCCGGCGCGGGCGCGGGCCGCGGCGGCGCCGGCCCGGCCGCGGCCCGCGCGCCCCGGGCGGCGCGCCCGCCCCGG\\\nCCGGCCCCCGGCGGCCCGCGGGGCGGCCCGGCCGCCGGCGGCCGCCCGGCGGCCCCGGCCCCCCGCCGGCGCCGCGGCG\\\nGCCCCCGGGGGGCCGGCCGCGCCCGCCGGCGCGGGGGCGGCGCGGCGCCGGCGGGCGGCGGGCCCCCGGCCGGCCGCGG\\\nCCCCCCGGGGGGCGGGCCCCGCGGCGCGCGCCGCCCCGCGCGCGCGGGCGGCCCGGGCGGGCCCGGCCCGGGCCCGGCC\\\nGGCCCCCGCGCGGGCCCGGGGCCGGGGGCGGCGGCCCCCCGGGCGCGGGGCGGGGGCGCCGGGCGGCCGGGGGGCCCGC\\\nGGCGCCCCGGGCGCCGGCCCGCCCGGGCCGCCGCCCGGGGCCGCGCCGCCCCGGGGGGGGGGCGCCGGGGGCCCCCCCC\\\nCCCGGCGGCCGGGCCCGCGGGGGCCGCGGGGCCGGCCCCCCCGGCGGCCGGGGGGCGGGGGCCCGCCGCGCGGGCCGGG\\\nGCGCCCGCCCGGCGGCCCGCGCCCCGGGCGCCCGGCCCCCCCCGCCGCCCCGGGCGGGCCCGCCCCCCCCGCCCGCCGG\\\nCCCGCGGGGCCCGCGCCGGCGCGCGGGCGCGGCCCGGGGGGGGGCGCCCGGGGCCGGGGGCGGCCGGCGCCCCGCGCCC\\\nCGCCCGGCCCCCCCGCGCGCCGCCGCGGCGGGCCGGCGGGGGCCCGGCGCCGGGCGGCGGGGCGCCCCCGGCCCCGGCG\\\nGGGGGCCGGGGGGGGCGCGCGCGCGGCGCGGGGGGGCCGGGGGGCCGGCGGGGGGGCCCCCCCCCCGCCCGCCGGGGGG\\\nCGGGCGCGGGGCGGCGGCCGCCGCGCCGGCGCGCGGGGCGCGCCCGGCGGCCGCCCGGGGCGCCGGGCGCCCGCCGCCC\\\nCCGGGGCCGCCCCCCGGGCGCGGGCGCCGGGCCGGGCCCGCGCCCGGGGCCGCCGCGGGCGGGCCCGGGCCGGGCGCGC\\\nCGCGCCCGCCGCGCGGGCGGGGCCGGCCGGGGGCCGCCGGGCGCGCCGCCGCGCGGGCGGCCGCCGGCGGGCCGCCGGG\\\nCCCGGGGGGCGGCGCCGGCGCCCCCGGGGGGCCCCGGCCGGGCGCGGGCCGCGGCGCCCGCGCCGCCCCGCGGCCGCCC\\\nGCGGCCCGGGGCCCGGCCCGCGCCGGGCCGCCGCCCCCCCGGGGCGCCGCGCGGGGCGGCGCGCGCGCCCCGCGCGGGC\\\nCCGCCGCGGCCCGCCCGGGGCCGGCCGGGGGCGCGGCCGGGCCCCGGCCCGCGCGCCCGGCCGGCCCGCGCCCGGCCCC\\\nCGGGGCCCGGCGGCCCCCGGGGCGCCGCGGGGCCCGCGGCCCGCCCCGCCGGGCGCCGGGCCCCGCCCCGGCGGGGCCC\\\nCCCGCCCGGGGGCGCCGGGGGGGGCGCCCGCCGGGCCGCGCGGCCCCCGCGCCCCGGCCGGGGGGGCCGCCGGCGCCCG\\\nGCCCCCGGGCCCCGCGGCGGGCCCCGCGCGCGGGCCGCCGCGCGCGGGGCCGGCGGGCCGGCGGGGGGCGCGGGGCGCC\\\nCCCGGGCGCGGCGGGCGGGCGGCCCGGCGCCCCGGGCGCGGCCGCGCGCCCGGGCCCGGCCCCGCCCCGGGGGCCCCGG\\\nGCCCCGGCGCCCGCGGGCCGCGGGGCCGGCCGGGGGGGCGCGCGGCGGCGCCCGCCGGCCGCCCCCGGGCCGCGGCCCC\\\nCCGCCCCGCCGGGGCCCGGCCCCCGCCGCGGCCGGCCCCCCCCGCGGGCCGCGCCGCCCCGGCGCCCCGGCCGCGCCCC\\\nCGCCGCGGGGGCGGGCCCGCCCGCCCCCGCGCCCCGGCGCCGGCGGGGGGCCCGCGCGCCCCGCGCGGGGCGCCGCCGG\\\nGGCCCCGGGCCCCCGGGCGGCGGGGGCCCCGGGCGCGGGCCCCCGCCCGCGGCCCGGCCCGGGCGCGGGCCCCCGCGCC\\\nGCCCCGCCGGGCCCGCCCCGCGCGGGGCGGGCGCGGGGCGCGCCCGGCCCGGCCCCCGGCGCCCCGCGCCGCCGCGCGC\\\nCCGCCGGCCGCCGGCCGGCGGCGCGGGGGCGGCGCCGCGGCCCCCGGGGCCCGGCCCGGCCGGCCCGGGCGCGGCGCCG\\\nCGGGCGGCGCGGGGCGGCGGCGGGCGCCCGGCGCCGGGCGGCGCCCGGCCCGGCGGCGGGGGGGCCGCGCGGCGCGCCC\\\nGGCCGCGCGCCCGGGGCGCGCCCGGGCGGCGCCGGGCGGGCCGGGGCGGGCCCCCGCGCCGGCCCGGGGGCGGGCGCGC\\\nGGGCCGGCCGGGGGCGGGCGGGGGGCCCCGGCCCGCCCGGCGCCCCGCGGCGCCCCCGGGGGCGGGCGGGGCGCCCCGC\\\nGGCCCGGGGCGGGGCCGCCCCGCGGGGCGGGCCCGCGCCGCCCCCCCCGCGGGCGGCCCGGCGCGCCGGGGGGGCGGGG\\\nCCGGCCCGGGCGGCGGCCGCGGGCCGGGGGGGCGGGGCGCCGCCCGGGGGGCGGGCCCGGCGGCGCGCGGCCCGGCCGC\\\nCCGCCCGCCGCCCGGGCCGCGCGGGGGCCCCCGGCGCCCGCGCGCCCGGCCCCGGGGCCCGCCCCGGCGCGCGGGCCCG\\\nGGCCGGGGCGGGGCCGCCGGCGCCCGGGGCCGGGGGGGCCCGGCGCCCCGGCCGGCCCCGGCGCGCGCCGCCGCGGGCG\\\nGCCGGCGGGGGGCCCGCGCCGGGGGGGCGGGCCGCCGCGCGCCGGGGGCGGCGCCGGCCGGCGGGGGCGCCCGGCGCGG\\\nCGGGGGCGCCGGGCCCGCGCGGGGGCGGCGCCCCCGCCCCGGCGGGCCGGGGCGCGGCGCCGGGGCCGCCCCCCGGGCG\\\nCCCGGGGCGGGGCCCGCCGCGGCCCCCGGGCCCGGCGCGCCCGCGCCCGCGGCGCGCGCGCCCGGGGGCGGGGGCCGGG\\\nCCCGGCCCGCGCCCCGGCGCGCGGCGCGGCGGCGCGGGCGCGGCGGGCCCCGCCCGCGCCCCCCGCGCGCCGGGCCGGC\\\nCCCCGCGGGGCGCGGCGGCGCGCGGGCGGCCGGCGGCCGGCCGCCGCGCGCCCGCCGCGGCGCCGGGCGGCCCGGGCCG\\\nGGGCGGCGGGGCCCGCGGCGCGCGGCCCGCCGCGCCCCGCCCCGGCCGGCGGGCCGCGGCCGGCCGCCGGCCGCGCCGC\\\nCGCCCCCCGGGCGCCCCGGCGCGGCGGCCGCGGGGGGCCCGCGGGGCGCGGCCGCGGCCCGCCCGGCCGCGCCCGGGGG\\\nCGGGGGCCCGCCCCCGCCCGCGCGCCCGCCCGCCCGCCGCCCGCCCCCGGGGGCCGGGCGGGCCGCGGGGCGCGGGGGG\\\nGGCCCCCGGCCCCCCCGCGGGGCGCCGGCCCCCCCCCCGGCGGGGCGCCCCGCCCGGGCGCGGCGGCGGGCGCGCCCCC\\\nCGGGCCGCGCCGCCCCCCGCCCCCGCCGGGGCCCGCCGCCGGCGGCCGGGGCCGCCGCCCCGCGGCGGGCCCCCCGCCC\\\nGCGCCCCCCCGCGCCGGGCCGCCCGGCGGGCGGCCGGCCCGGCCCGCCCCGCGGGGCCGCGGCCGCGCGGGCCGGGGCC\\\nCCGGGCCGGGCCGCGCGGCCGGGCCCGGCCCCGCCCCGGCGGCCGCGGGCCCCGGCCCGCCCGGGCGGCGCGGCCGGCC\\\nGGGGCCGCGCGGGGCGCCGGCCGCGGGCCCCCCCCCGGGCGCGGCCCCCCCGCCCGGCGGCGCGCGGCCGCCGCCGCCG\\\nCCGGCCGGCCCGGCGGGCGGCGCCGCCGCCGCGGGCCCGGCGCGCCCCCCCCGCGGGCGCGGGGCCGCCCGGCCCCGCG\\\nCCGCGGCCCCGCGGCGGGGCCGGCGGGCCGCGCCCCGGGCGGCGCCGGGGGCCCGCGGCGCGCGCGCCCCGGCGCGGCG\\\nCGCGCGCGCCCCGGCCGCCGCCCCGCGCCGGGGGCCCGGCCGCGCGCCGCGCCGGCGCGCCCGCGCCGCCCGGGGGGGG\\\nCGCGCGGGGCGGGCGGCCCGGCCGGGGCGCCGCCGCGCCGGCGCGCGCCCGCCCGCCGCCGGCCGCCGGCGCGCGGGCG\\\nGCGCCGCGGGCCGCCGGCCCCGGCCCCCCCGCCCCCGGCGCCGCGCGCCGGGCGGCGCGGGCCCGGGCCGGCCCCGCGG\\\nCGGCGCCCGCCGGCCGGCGGGGGGGCCGGGGGCCCGCCGGGCCGCGCCGCCGGGGCCCCCCGGGCGCCCCGCGCCGGCG\\\nCCGGGCGGGCCGGCGCGCGCCCCCCCCCCCGGGGGCGCGCGGCCGCGCGGGCGGGCGCGCGGCGCGCGCGCCCGCCCGG\\\nCGCGCCCGGCCCCCCGCGCCCCCCCCGGGGGCCGGGGGGGCGCCCCGCGCCCGGGCGGGCGGCGGCCCCGCGGGGCGGG\\\nCCCGCGCCGCCGCCCGCGCGGGGGGGCCGGGGCCGCCGGGGGCGGGGGCGGCCCCGGGCCCCGGCCGCCGGCCCCGGCG\\\nGGGGGGCCCCGCCCGGGGGGCGGGCGCCGGCCGGCGCGGCCCGGCGGGGCGCCCGGGGGCCGGGCCGGGCCGGGCGGCC\\\nCGGCGCCGGCGCGCCCGGGCCCGGGGCCCGGCGCGGCGCGCCGGCCGGGGGCGGGCCGGGGGCGCGGGCCCCCGGGGCC\\\nGGGCGGGCCCGCCGCGCCGGCCGGCCCCGGCGGGCCGCGCGGGCGGCGCCCCGGGGGGGGCCCGCGGGGGGGGGGCGGG\\\nCCGCCGCCCGCCGCCGCCGGCGGCGGCCGGCCGCGCCCCCCGCCGCCGCGGCCGCGCCCGGGCCGCGCGGCGGGGGCGG\\\nCCGCGCCCCGGCGGGCCGGCGCGCCGCCCCGGGGCGCCGCCCCGGCCGCCCGCCGCCGGGCCCGCCGCGGCCCCCGGGC\\\nGCCGCGCGCGCGGGGCCGGGCCGCGCGCGCGCCGGGCCGCCGGCGGGGCGCGGCC\";\n\n#[bench]\nfn bench_hamming_dist_equal_str_1000iter(b: \u0026mut Bencher) {\n    b.iter(|| {\n        for _ in 0..1000 {\n            black_box(hamming(STR_1, STR_1));\n        }\n    });\n}\n\n#[bench]\nfn bench_hamming_dist_diverse_str_1000iter(b: \u0026mut Bencher) {\n    b.iter(|| {\n        for _ in 0..1000 {\n            black_box(hamming(STR_1, STR_2));\n        }\n    });\n}\n\n#[bench]\nfn bench_levenshtein_dist_equal_str(b: \u0026mut Bencher) {\n    b.iter(|| levenshtein(STR_1, STR_1));\n}\n\n#[bench]\nfn bench_levenshtein_dist_diverse_str(b: \u0026mut Bencher) {\n    b.iter(|| levenshtein(STR_1, STR_2));\n}\n\n#[bench]\nfn bench_levenshtein_dist_worst_str(b: \u0026mut Bencher) {\n    b.iter(|| levenshtein(STR_3, STR_4));\n}\n\n// SIMD-accelerated edit distance routines below\n\n#[bench]\nfn bench_simd_hamming_dist_equal_str_1000iter(b: \u0026mut Bencher) {\n    b.iter(|| {\n        for _ in 0..1000 {\n            black_box(simd::hamming(STR_1, STR_1));\n        }\n    });\n}\n\n#[bench]\nfn bench_simd_hamming_dist_diverse_str_1000iter(b: \u0026mut Bencher) {\n    b.iter(|| {\n        for _ in 0..1000 {\n            black_box(simd::hamming(STR_1, STR_2));\n        }\n    });\n}\n\n#[bench]\nfn bench_simd_levenshtein_dist_equal_str(b: \u0026mut Bencher) {\n    b.iter(|| simd::levenshtein(STR_1, STR_1));\n}\n\n#[bench]\nfn bench_simd_levenshtein_dist_diverse_str(b: \u0026mut Bencher) {\n    b.iter(|| simd::levenshtein(STR_1, STR_2));\n}\n\n#[bench]\nfn bench_simd_levenshtein_dist_worst_str(b: \u0026mut Bencher) {\n    b.iter(|| simd::levenshtein(STR_3, STR_4));\n}\n\n#[bench]\nfn bench_simd_bounded_levenshtein_dist_equal_str(b: \u0026mut Bencher) {\n    b.iter(|| simd::bounded_levenshtein(STR_1, STR_1, u32::MAX));\n}\n\n#[bench]\nfn bench_simd_bounded_levenshtein_dist_diverse_str(b: \u0026mut Bencher) {\n    b.iter(|| simd::bounded_levenshtein(STR_1, STR_2, u32::MAX));\n}\n\n#[bench]\nfn bench_simd_bounded_levenshtein_dist_worst_str(b: \u0026mut Bencher) {\n    b.iter(|| simd::bounded_levenshtein(STR_3, STR_4, u32::MAX));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","benches","fmindex.rs"],"content":"#![feature(test)]\n\nextern crate test;\n\nuse bio::alphabets;\nuse bio::data_structures::bwt::{bwt, less, Occ};\nuse bio::data_structures::fmindex::{FMIndex, FMIndexable};\nuse bio::data_structures::suffix_array::suffix_array;\nuse test::Bencher;\n\n#[bench]\nfn search_index_seeds(b: \u0026mut Bencher) {\n    let alphabet = alphabets::dna::iupac_alphabet();\n    let sa = suffix_array(STR_1);\n    let bwt = bwt(STR_1, \u0026sa);\n    let less = less(\u0026bwt, \u0026alphabet);\n    let occ = Occ::new(\u0026bwt, 128, \u0026alphabet);\n    let fmindex = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n\n    b.iter(|| {\n        let sequence = b\"TCCAAAACAATAACGGAGGTGTCCAAAGGTCAGCTCAGCGTGTGGTTTCT\";\n        let seed_length = 20;\n\n        let seeds =\n            (0..(sequence.len() + 1 - seed_length)).map(|i| (i, \u0026sequence[i..i + seed_length]));\n\n        let mut loc_temp = Vec::new();\n        for (offset, seed) in seeds {\n            let interval = fmindex.backward_search(seed.iter());\n\n            loc_temp.extend((interval.lower..interval.upper).map(|i| (sa[i], offset)));\n        }\n    });\n}\n\nstatic STR_1: \u0026'static [u8] = b\"ATCTAACTATTCCCTGTGCCTTATGGGGGCCTGCGCTATCTGCCTGT\\\nCGAACCATAGGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCGGGGCCTAAGACCACGAGCGTCTGGCG\\\nTCTTGGCTAACCCCCCTACATGCTGTTATAGACAATCAGTGGAAACCCGGTGCCAGGGGGTGGAGTGACCTTAAGTCAG\\\nGGACGATATTAATCGGAAGGAGTATTCAACGCAATGAAGCCGCAGGGTTGGCGTGGGAATGGTGCTTCTGTCCAAGCAG\\\nGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTGCACTTTGCAACGATTTCGGAGTCCGGAGACTCGCTG\\\nTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTACGCCCAAGAACGTAGCAAGGTGACTCAAACAAGGTA\\\nCATCTTGCCCGCGTTTCACACGAATCAAGTTGGAGGTTATGGAGCATAGTAACACGTGGGCGGCCAGTGGTCGGTTGCT\\\nACACCCCTGCCGCAACGTTGAAGGTCCCGGATTAGACTGGCTGGACCCATGCCGTGACACCCGTCACACTCCATTACCG\\\nTCTGCGGGTCACGGCTTGTTGTGGACTGGATTGCCATTCTCTCAGTGTATTACGCAGGCCGGCGCGCGGGTCCCATGTA\\\nAACCTGTCATAGCTTACCTGACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCCACGCACCTGGTCGGTCCTCGTTTGCT\\\nTTTTAGGACCGGATGAACTACAGAGCGCTGCAAGAATCTCTACCTGCTTTACAAAGCGCTGGGTCCTACTCCAGCGGGA\\\nTGTTTTATCTAAACACGATGAGAGGAGTATTCGTCAGGCCACATGGCTTTCTTGTCCTGGTCGGATCCATCGTTGGCGC\\\nCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTGCATGCCAGATCGGCAGACAGATAGCGGATCCAGTAT\\\nATCCCTGGAAGCTATAGACGCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTCCGAACCCAGCTCTACTTTAGTGGCCA\\\nCGGGTTCTGGTCCCCCCGGGCCGCGGAACCGATTAGGGCCATGTACAACAATACTTATTAGTCACCTTTCAGACACGAT\\\nCTCCCTGCTCAGTGGTATATGGTTCCTGCTATAATTAGCCACCCTCATAAGTTGCACTACTTCTGCGACCCAAGTGCAC\\\nCCTTACCACGAAGACAGGATTGTCCGATCCCATACTGCGGCCTTGGCAGGGGGTTCGCAAGTCCCACCCCAAACGATGC\\\nTGAAGGCTCAGGTTACACAGGCACAAGTGCTATATACGCGAGTTCCCGCTCTTAACCTGGACCGAATGCGGGATCATGC\\\nATCGTACCACTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGATACATAGTTCAATCAAGAATACCTTGTATTATTGTA\\\nCACCTACCGGTCACCAGCCAACAATGTGCGGACGGCGTTGCGACTTGCTGGGCCTGATCTCACCGCCCTAGATACCGCA\\\nCACTGGGCAATACGAGGTAAAGCCAGTCACCCAGTGTCGATCAACAGCTGACGTAACGGTAAGAGGCTCACAAAATCGC\\\nACCGCCGGCGTCCCCTGGGTATTTTACGTCAGCATCGGGTGGACTGGCATGAATCTTTACTCCCAGGCGGAAACGGGTG\\\nCGTGGACAAGCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGGTGTCTCGTATCCCTCTTGGAGATCGAGGAAATGTTT\\\nCACGACCAAGGGAAAGGTCGCCCTACGAAATAGATTTGCGCTACTGTCCGCATAAGGAGTCCGGTGTAGCGAAGGATGA\\\nAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAAGCAGGCACGGAAAGACACGGTCTAGC\\\nAGACCGTCTATCGGCTAGGTCAAATAGGGTGCTTTGATATCAGCATGTCCAGCCTTAGAATTCAGTTCAGCGCGCTGGT\\\nCTGGGTCGAGATAAAATCACCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTGGCTAATCCTGGTACATCTTGTAATCA\\\nATGTTCAGAAGAAAATCTGTGTTAGAGGGACGAGTCACCACGTACCAATAGCGACAACGATCGGTCGGACTATTCATCG\\\nTGGTGGTGACGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAGGATATAATGCTGAGGCGCTGCCCCAA\\\nCCGTTCAGCGTGGGGTTTGCTACAACTTCCGAGTGCTACGTGTGCGAGACCATGTTATGTATGCACAAGGCCGACAATA\\\nGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCACAGTAGATCCTCCCCGCGCATCCTATTTATTAAGTT\\\nAATTCTATAGCAATACGATCACATGCGGATGGGCAGTGGCCGGTAGTCACACGCCTACCGCGGTGCTCAATGACCGGGA\\\nCTAGAGAGGCGAAGATTATGGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGAGCGTCATTGCGAGTAGTCGATTGCTT\\\nTCCCAATCTCCGAGCGATTTAGCGTGACAGCCCCAGGGAACCCACAAAATGCGATCGCAGTCCACCCGATCGTACACAG\\\nAAAGGAGGGTCCCCATACGCCGACGCACCTGTTCGCACGTCGTATGCATAAACGAGCCGCACGAACCAGAGAGCATAAA\\\nGAGGACCTCTAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGCCGGGATGCCTTACCTAGACGCAATGACGGACGTATT\\\nCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAAGCCGCCTTTCCAAAGTGAGTCCTTCG\\\nTCTGTGACTAACTGTGCCAGATCGTCTTGCAAACTCCCGATCCAGTTTAACTCACCAAACTATAGCCGTACAGACCCAA\\\nATCTTAAGTCATATCACGCGACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGTTTTGGTCCGCCCGAGCGGTGCAGCCG\\\nATTAGGACCATCTAATGCACTTGTTACAAGACTTCTTTTAAACACTTTCTTCCTGCCCAGTGGCGGATGATAATGGTTG\\\nTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAATGTGCCGTCTCCACCAACACAGGGCTGTCCGGTCGT\\\nATAATAGGACTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGGACTCGCGATGTACATGCTCTGGTTCA\\\nATACATACGTGACCCGGCAGTTATCCTGCATCGGAACGTCAATCGTGCATCGGGCCAGCGTAATCGTGTCATCTGGGAG\\\nGCGGCCGTAGGATAAATAATTCAATAAAGATGTCGTTTTGCTAGTATACGCCTAGGCGTCACCCGCCATCTCTGTGCAG\\\nGTGGGCCGACGAGACACTGCCCCTGATTTCTCCGCTACTAATAGCACACACGGGGCAATACCAGCACAAGCCAGTCTCG\\\nCGGGAACGCTCGTCAGCATACGAAAGAGCTTGAGGCACGCCAATTCGCACTGTCGGGGTCGCTTGGGTGTTTTGCACTA\\\nCCGTCAGGTACGCTAGTATGCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGGTCAAAAGTGCGGCATTCGTATTTGCT\\\nCCCCGTGCTTGCTCTCACGAACTTGACCTGGAGATCAAGGAGATGCTTCTTGTGGAACCGGACAGCGCATCAACGCAAC\\\nGGATCTACGTTACAGCGTGCATAGCGAGAACGGAGTTGCCGACGACGAAAGCGACACTGGGATCTGTCCGTCGTCATTC\\\nGCGGAAAGCATCCGCTCACGAGGCGGACACTGATTGACACGGTTTTGCAGAAGGTTAGGGGAATAGGTCAAATTGAGTG\\\nGCTTAAAAACGCTATGTCTGGGATTAAAGTGTAGTAAACTGCGGTCAACGGAGACGGTTTTAAGACAGGAGTTCGCAAA\\\nACCAGGCGGGGTCGCCACGACGGCTATTCCTGGTGGTTTAGGCGTACAATGTCCTGAAGAATATTTAAGAAAGAAGCAC\\\nCCCTCGTCGCCTAGAATTACCTACCGCGGTCGACCATACCTTCGATTGTCGCGCCCACCCTCCCATTAGTCGGCAGAGG\\\nTGGTTGTGTTGCGATAGCCCAGCATGATATCCTAAGGCGTTACGCCGATGGATATCCCACGGAATTGCCATAGGCGCTG\\\nAACGCTACACGGACGATACGAACTTATGTATGGAGCGGGTCATCGAAAGGTCATACCCTTGTAGTTAACATGTAGCCCG\\\nGCCCTATTAGTACAGCAGTGCCTTGAGCGGCATTCTCATTATTAAGTTTTCTCTACAGCCAAACGACCAAGTGCACTTC\\\nCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCAGCTCTGTAATAGGGACTAAAAGAGTGATGATAATCATGAGTGCCGC\\\nGTTATGGTGGTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCGAGTTCCGTCCGGTTAAGCGTGACACT\\\nCCCAGTGTACCCGCAAACCGTGATGGCTGTGCTTGGGGTCAATCGCATGTAGGATGGTCTCCAGACACCGGGGCACCAG\\\nTTTTCACGCCCAAAGCATAAACGACGAGCAGTCATGAGAGTCTTAGAACTGGACGTGCCGTTTCTCTGCGAACAACACC\\\nTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTCCTATCACATTTGCCTCGACGACTGCCGCCTTCGCTG\\\nTTTCCCTAGACACTCAACAGTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGTCAGTGGCTGCGCCAAAACGTCTTCGG\\\nATCCCCTTGTCCAATCAAACTGACCGAATTCTTTCATTTAAGACCCTAATATGACATCATTAGTGACTAAATGCCACTC\\\nCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAACGAATCTAACTATTCCCTGTGCCTTAT\\\nGGGGGCCTGCGCTATCTGCCTGTCGAACCATAGGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCGGGG\\\nCCTAAGACCACGAGCGTCTGGCGTCTTGGCTAACCCCCCTACATGCTGTTATAGACAATCAGTGGAAACCCGGTGCCAG\\\nGGGGTGGAGTGACCTTAAGTCAGGGACGATATTAATCGGAAGGAGTATTCAACGCAATGAAGCCGCAGGGTTGGCGTGG\\\nGAATGGTGCTTCTGTCCAAGCAGGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTGCACTTTGCAACGA\\\nTTTCGGAGTCCGGAGACTCGCTGTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTACGCCCAAGAACGT\\\nAGCAAGGTGACTCAAACAAGGTACATCTTGCCCGCGTTTCACACGAATCAAGTTGGAGGTTATGGAGCATAGTAACACG\\\nTGGGCGGCCAGTGGTCGGTTGCTACACCCCTGCCGCAACGTTGAAGGTCCCGGATTAGACTGGCTGGACCCATGCCGTG\\\nACACCCGTCACACTCCATTACCGTCTGCGGGTCACGGCTTGTTGTGGACTGGATTGCCATTCTCTCAGTGTATTACGCA\\\nGGCCGGCGCGCGGGTCCCATGTAAACCTGTCATAGCTTACCTGACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCCACG\\\nCACCTGGTCGGTCCTCGTTTGCTTTTTAGGACCGGATGAACTACAGAGCGCTGCAAGAATCTCTACCTGCTTTACAAAG\\\nCGCTGGGTCCTACTCCAGCGGGATGTTTTATCTAAACACGATGAGAGGAGTATTCGTCAGGCCACATGGCTTTCTTGTC\\\nCTGGTCGGATCCATCGTTGGCGCCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTGCATGCCAGATCGG\\\nCAGACAGATAGCGGATCCAGTATATCCCTGGAAGCTATAGACGCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTCCGA\\\nACCCAGCTCTACTTTAGTGGCCACGGGTTCTGGTCCCCCCGGGCCGCGGAACCGATTAGGGCCATGTACAACAATACTT\\\nATTAGTCACCTTTCAGACACGATCTCCCTGCTCAGTGGTATATGGTTCCTGCTATAATTAGCCACCCTCATAAGTTGCA\\\nCTACTTCTGCGACCCAAGTGCACCCTTACCACGAAGACAGGATTGTCCGATCCCATACTGCGGCCTTGGCAGGGGGTTC\\\nGCAAGTCCCACCCCAAACGATGCTGAAGGCTCAGGTTACACAGGCACAAGTGCTATATACGCGAGTTCCCGCTCTTAAC\\\nCTGGACCGAATGCGGGATCATGCATCGTACCACTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGATACATAGTTCAAT\\\nCAAGAATACCTTGTATTATTGTACACCTACCGGTCACCAGCCAACAATGTGCGGACGGCGTTGCGACTTGCTGGGCCTG\\\nATCTCACCGCCCTAGATACCGCACACTGGGCAATACGAGGTAAAGCCAGTCACCCAGTGTCGATCAACAGCTGACGTAA\\\nCGGTAAGAGGCTCACAAAATCGCACCGCCGGCGTCCCCTGGGTATTTTACGTCAGCATCGGGTGGACTGGCATGAATCT\\\nTTACTCCCAGGCGGAAACGGGTGCGTGGACAAGCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGGTGTCTCGTATCCC\\\nTCTTGGAGATCGAGGAAATGTTTCACGACCAAGGGAAAGGTCGCCCTACGAAATAGATTTGCGCTACTGTCCGCATAAG\\\nGAGTCCGGTGTAGCGAAGGATGAAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAAGCA\\\nGGCACGGAAAGACACGGTCTAGCAGACCGTCTATCGGCTAGGTCAAATAGGGTGCTTTGATATCAGCATGTCCAGCCTT\\\nAGAATTCAGTTCAGCGCGCTGGTCTGGGTCGAGATAAAATCACCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTGGCT\\\nAATCCTGGTACATCTTGTAATCAATGTTCAGAAGAAAATCTGTGTTAGAGGGACGAGTCACCACGTACCAATAGCGACA\\\nACGATCGGTCGGACTATTCATCGTGGTGGTGACGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAGGAT\\\nATAATGCTGAGGCGCTGCCCCAACCGTTCAGCGTGGGGTTTGCTACAACTTCCGAGTGCTACGTGTGCGAGACCATGTT\\\nATGTATGCACAAGGCCGACAATAGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCACAGTAGATCCTCC\\\nCCGCGCATCCTATTTATTAAGTTAATTCTATAGCAATACGATCACATGCGGATGGGCAGTGGCCGGTAGTCACACGCCT\\\nACCGCGGTGCTCAATGACCGGGACTAGAGAGGCGAAGATTATGGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGAGCG\\\nTCATTGCGAGTAGTCGATTGCTTTCCCAATCTCCGAGCGATTTAGCGTGACAGCCCCAGGGAACCCACAAAATGCGATC\\\nGCAGTCCACCCGATCGTACACAGAAAGGAGGGTCCCCATACGCCGACGCACCTGTTCGCACGTCGTATGCATAAACGAG\\\nCCGCACGAACCAGAGAGCATAAAGAGGACCTCTAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGCCGGGATGCCTTAC\\\nCTAGACGCAATGACGGACGTATTCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAAGCC\\\nGCCTTTCCAAAGTGAGTCCTTCGTCTGTGACTAACTGTGCCAGATCGTCTTGCAAACTCCCGATCCAGTTTAACTCACC\\\nAAACTATAGCCGTACAGACCCAAATCTTAAGTCATATCACGCGACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGTTTT\\\nGGTCCGCCCGAGCGGTGCAGCCGATTAGGACCATCTAATGCACTTGTTACAAGACTTCTTTTAAACACTTTCTTCCTGC\\\nCCAGTGGCGGATGATAATGGTTGTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAATGTGCCGTCTCCA\\\nCCAACACAGGGCTGTCCGGTCGTATAATAGGACTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGGACT\\\nCGCGATGTACATGCTCTGGTTCAATACATACGTGACCCGGCAGTTATCCTGCATCGGAACGTCAATCGTGCATCGGGCC\\\nAGCGTAATCGTGTCATCTGGGAGGCGGCCGTAGGATAAATAATTCAATAAAGATGTCGTTTTGCTAGTATACGCCTAGG\\\nCGTCACCCGCCATCTCTGTGCAGGTGGGCCGACGAGACACTGCCCCTGATTTCTCCGCTACTAATAGCACACACGGGGC\\\nAATACCAGCACAAGCCAGTCTCGCGGGAACGCTCGTCAGCATACGAAAGAGCTTGAGGCACGCCAATTCGCACTGTCGG\\\nGGTCGCTTGGGTGTTTTGCACTACCGTCAGGTACGCTAGTATGCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGGTCA\\\nAAAGTGCGGCATTCGTATTTGCTCCCCGTGCTTGCTCTCACGAACTTGACCTGGAGATCAAGGAGATGCTTCTTGTGGA\\\nACCGGACAGCGCATCAACGCAACGGATCTACGTTACAGCGTGCATAGCGAGAACGGAGTTGCCGACGACGAAAGCGACA\\\nCTGGGATCTGTCCGTCGTCATTCGCGGAAAGCATCCGCTCACGAGGCGGACACTGATTGACACGGTTTTGCAGAAGGTT\\\nAGGGGAATAGGTCAAATTGAGTGGCTTAAAAACGCTATGTCTGGGATTAAAGTGTAGTAAACTGCGGTCAACGGAGACG\\\nGTTTTAAGACAGGAGTTCGCAAAACCAGGCGGGGTCGCCACGACGGCTATTCCTGGTGGTTTAGGCGTACAATGTCCTG\\\nAAGAATATTTAAGAAAGAAGCACCCCTCGTCGCCTAGAATTACCTACCGCGGTCGACCATACCTTCGATTGTCGCGCCC\\\nACCCTCCCATTAGTCGGCAGAGGTGGTTGTGTTGCGATAGCCCAGCATGATATCCTAAGGCGTTACGCCGATGGATATC\\\nCCACGGAATTGCCATAGGCGCTGAACGCTACACGGACGATACGAACTTATGTATGGAGCGGGTCATCGAAAGGTCATAC\\\nCCTTGTAGTTAACATGTAGCCCGGCCCTATTAGTACAGCAGTGCCTTGAGCGGCATTCTCATTATTAAGTTTTCTCTAC\\\nAGCCAAACGACCAAGTGCACTTCCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCAGCTCTGTAATAGGGACTAAAAGA\\\nGTGATGATAATCATGAGTGCCGCGTTATGGTGGTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCGAGT\\\nTCCGTCCGGTTAAGCGTGACACTCCCAGTGTACCCGCAAACCGTGATGGCTGTGCTTGGGGTCAATCGCATGTAGGATG\\\nGTCTCCAGACACCGGGGCACCAGTTTTCACGCCCAAAGCATAAACGACGAGCAGTCATGAGAGTCTTAGAACTGGACGT\\\nGCCGTTTCTCTGCGAACAACACCTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTCCTATCACATTTGC\\\nCTCGACGACTGCCGCCTTCGCTGTTTCCCTAGACACTCAACAGTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGTCAG\\\nTGGCTGCGCCAAAACGTCTTCGGATCCCCTTGTCCAATCAAACTGACCGAATTCTTTCATTTAAGACCCTAATATGACA\\\nTCATTAGTGACTAAATGCCACTCCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAACGAA\\\nTCTAACTATTCCCTGTGCCTTATGGGGGCCTGCGCTATCTGCCTGTCGAACCATAGGACTCGCGCCAGCGCGCAGGCTT\\\nGGATCGAGGTGAAATCTCCGGGGCCTAAGACCACGAGCGTCTGGCGTCTTGGCTAACCCCCCTACATGCTGTTATAGAC\\\nAATCAGTGGAAACCCGGTGCCAGGGGGTGGAGTGACCTTAAGTCAGGGACGATATTAATCGGAAGGAGTATTCAACGCA\\\nATGAAGCCGCAGGGTTGGCGTGGGAATGGTGCTTCTGTCCAAGCAGGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGC\\\nGTACAGGGTGCACTTTGCAACGATTTCGGAGTCCGGAGACTCGCTGTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGA\\\nACCAGGCTTACGCCCAAGAACGTAGCAAGGTGACTCAAACAAGGTACATCTTGCCCGCGTTTCACACGAATCAAGTTGG\\\nAGGTTATGGAGCATAGTAACACGTGGGCGGCCAGTGGTCGGTTGCTACACCCCTGCCGCAACGTTGAAGGTCCCGGATT\\\nAGACTGGCTGGACCCATGCCGTGACACCCGTCACACTCCATTACCGTCTGCGGGTCACGGCTTGTTGTGGACTGGATTG\\\nCCATTCTCTCAGTGTATTACGCAGGCCGGCGCGCGGGTCCCATGTAAACCTGTCATAGCTTACCTGACTCTACTTGGAA\\\nGTGTGGCTAGGCCTTTGCCCACGCACCTGGTCGGTCCTCGTTTGCTTTTTAGGACCGGATGAACTACAGAGCGCTGCAA\\\nGAATCTCTACCTGCTTTACAAAGCGCTGGGTCCTACTCCAGCGGGATGTTTTATCTAAACACGATGAGAGGAGTATTCG\\\nTCAGGCCACATGGCTTTCTTGTCCTGGTCGGATCCATCGTTGGCGCCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTC\\\nCGAGCCATTGCATGCCAGATCGGCAGACAGATAGCGGATCCAGTATATCCCTGGAAGCTATAGACGCACAGGTTGGAAT\\\nCCTAAGCGAAGTCGCGCGTCCGAACCCAGCTCTACTTTAGTGGCCACGGGTTCTGGTCCCCCCGGGCCGCGGAACCGAT\\\nTAGGGCCATGTACAACAATACTTATTAGTCACCTTTCAGACACGATCTCCCTGCTCAGTGGTATATGGTTCCTGCTATA\\\nATTAGCCACCCTCATAAGTTGCACTACTTCTGCGACCCAAGTGCACCCTTACCACGAAGACAGGATTGTCCGATCCCAT\\\nACTGCGGCCTTGGCAGGGGGTTCGCAAGTCCCACCCCAAACGATGCTGAAGGCTCAGGTTACACAGGCACAAGTGCTAT\\\nATACGCGAGTTCCCGCTCTTAACCTGGACCGAATGCGGGATCATGCATCGTACCACTGTGTTCGTGTCATCTAGGACGG\\\nGCGCAAAGGATACATAGTTCAATCAAGAATACCTTGTATTATTGTACACCTACCGGTCACCAGCCAACAATGTGCGGAC\\\nGGCGTTGCGACTTGCTGGGCCTGATCTCACCGCCCTAGATACCGCACACTGGGCAATACGAGGTAAAGCCAGTCACCCA\\\nGTGTCGATCAACAGCTGACGTAACGGTAAGAGGCTCACAAAATCGCACCGCCGGCGTCCCCTGGGTATTTTACGTCAGC\\\nATCGGGTGGACTGGCATGAATCTTTACTCCCAGGCGGAAACGGGTGCGTGGACAAGCGAGCAGCAAACGAAAATTCCTG\\\nGCCTGCTTGGTGTCTCGTATCCCTCTTGGAGATCGAGGAAATGTTTCACGACCAAGGGAAAGGTCGCCCTACGAAATAG\\\nATTTGCGCTACTGTCCGCATAAGGAGTCCGGTGTAGCGAAGGATGAAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGC\\\nGGTAAGGTATCACTCAGGAAGCAGGCACGGAAAGACACGGTCTAGCAGACCGTCTATCGGCTAGGTCAAATAGGGTGCT\\\nTTGATATCAGCATGTCCAGCCTTAGAATTCAGTTCAGCGCGCTGGTCTGGGTCGAGATAAAATCACCAGTACCCAAGAC\\\nCAGGCGGGCTCGCCGCGTTGGCTAATCCTGGTACATCTTGTAATCAATGTTCAGAAGAAAATCTGTGTTAGAGGGACGA\\\nGTCACCACGTACCAATAGCGACAACGATCGGTCGGACTATTCATCGTGGTGGTGACGCTCGGATTACGCGGGAAAGGTG\\\nCTTGTGTCCCGACAGGCTAGGATATAATGCTGAGGCGCTGCCCCAACCGTTCAGCGTGGGGTTTGCTACAACTTCCGAG\\\nTGCTACGTGTGCGAGACCATGTTATGTATGCACAAGGCCGACAATAGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGT\\\nCGCACAAGCACAGTAGATCCTCCCCGCGCATCCTATTTATTAAGTTAATTCTATAGCAATACGATCACATGCGGATGGG\\\nCAGTGGCCGGTAGTCACACGCCTACCGCGGTGCTCAATGACCGGGACTAGAGAGGCGAAGATTATGGCGTGTGACCCGT\\\nTATGCTCGAGTTCGGTCAGAGCGTCATTGCGAGTAGTCGATTGCTTTCCCAATCTCCGAGCGATTTAGCGTGACAGCCC\\\nCAGGGAACCCACAAAATGCGATCGCAGTCCACCCGATCGTACACAGAAAGGAGGGTCCCCATACGCCGACGCACCTGTT\\\nCGCACGTCGTATGCATAAACGAGCCGCACGAACCAGAGAGCATAAAGAGGACCTCTAGCTCCTTTACAAAGTACAGGTT\\\nCGCCTGCCGCCGGGATGCCTTACCTAGACGCAATGACGGACGTATTCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGG\\\nATCCAAGATTGGCGGCCGAAGCCGCCTTTCCAAAGTGAGTCCTTCGTCTGTGACTAACTGTGCCAGATCGTCTTGCAAA\\\nCTCCCGATCCAGTTTAACTCACCAAACTATAGCCGTACAGACCCAAATCTTAAGTCATATCACGCGACTAGCCTCTGCT\\\nCAATTTCTGTGCTCAAGGGTTTTGGTCCGCCCGAGCGGTGCAGCCGATTAGGACCATCTAATGCACTTGTTACAAGACT\\\nTCTTTTAAACACTTTCTTCCTGCCCAGTGGCGGATGATAATGGTTGTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGT\\\nGCGAGCCTAATGTGCCGTCTCCACCAACACAGGGCTGTCCGGTCGTATAATAGGACTCCGCAATGGGGTTAGCAAGTGG\\\nCAGCCTAAACGATGTCGGGGACTCGCGATGTACATGCTCTGGTTCAATACATACGTGACCCGGCAGTTATCCTGCATCG\\\nGAACGTCAATCGTGCATCGGGCCAGCGTAATCGTGTCATCTGGGAGGCGGCCGTAGGATAAATAATTCAATAAAGATGT\\\nCGTTTTGCTAGTATACGCCTAGGCGTCACCCGCCATCTCTGTGCAGGTGGGCCGACGAGACACTGCCCCTGATTTCTCC\\\nGCTACTAATAGCACACACGGGGCAATACCAGCACAAGCCAGTCTCGCGGGAACGCTCGTCAGCATACGAAAGAGCTTGA\\\nGGCACGCCAATTCGCACTGTCGGGGTCGCTTGGGTGTTTTGCACTACCGTCAGGTACGCTAGTATGCGTCCTTCCTTCC\\\nAGGGGTATGTGGCTGCGTGGTCAAAAGTGCGGCATTCGTATTTGCTCCCCGTGCTTGCTCTCACGAACTTGACCTGGAG\\\nATCAAGGAGATGCTTCTTGTGGAACCGGACAGCGCATCAACGCAACGGATCTACGTTACAGCGTGCATAGCGAGAACGG\\\nAGTTGCCGACGACGAAAGCGACACTGGGATCTGTCCGTCGTCATTCGCGGAAAGCATCCGCTCACGAGGCGGACACTGA\\\nTTGACACGGTTTTGCAGAAGGTTAGGGGAATAGGTCAAATTGAGTGGCTTAAAAACGCTATGTCTGGGATTAAAGTGTA\\\nGTAAACTGCGGTCAACGGAGACGGTTTTAAGACAGGAGTTCGCAAAACCAGGCGGGGTCGCCACGACGGCTATTCCTGG\\\nTGGTTTAGGCGTACAATGTCCTGAAGAATATTTAAGAAAGAAGCACCCCTCGTCGCCTAGAATTACCTACCGCGGTCGA\\\nCCATACCTTCGATTGTCGCGCCCACCCTCCCATTAGTCGGCAGAGGTGGTTGTGTTGCGATAGCCCAGCATGATATCCT\\\nAAGGCGTTACGCCGATGGATATCCCACGGAATTGCCATAGGCGCTGAACGCTACACGGACGATACGAACTTATGTATGG\\\nAGCGGGTCATCGAAAGGTCATACCCTTGTAGTTAACATGTAGCCCGGCCCTATTAGTACAGCAGTGCCTTGAGCGGCAT\\\nTCTCATTATTAAGTTTTCTCTACAGCCAAACGACCAAGTGCACTTCCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCA\\\nGCTCTGTAATAGGGACTAAAAGAGTGATGATAATCATGAGTGCCGCGTTATGGTGGTGTCGGAACAGAGCGGTCTTACG\\\nGCCAGTCGTATCCCTTCTCGAGTTCCGTCCGGTTAAGCGTGACACTCCCAGTGTACCCGCAAACCGTGATGGCTGTGCT\\\nTGGGGTCAATCGCATGTAGGATGGTCTCCAGACACCGGGGCACCAGTTTTCACGCCCAAAGCATAAACGACGAGCAGTC\\\nATGAGAGTCTTAGAACTGGACGTGCCGTTTCTCTGCGAACAACACCTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGC\\\nAGTGCCGCTCCTATCACATTTGCCTCGACGACTGCCGCCTTCGCTGTTTCCCTAGACACTCAACAGTAAGCGCCTTTTG\\\nTAGGCAGGGGCACCCCCTGTCAGTGGCTGCGCCAAAACGTCTTCGGATCCCCTTGTCCAATCAAACTGACCGAATTCTT\\\nTCATTTAAGACCCTAATATGACATCATTAGTGACTAAATGCCACTCCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCC\\\nCCACTAAAGTTGTCTAAAACGAATCTAACTATTCCCTGTGCCTTATGGGGGCCTGCGCTATCTGCCTGTCGAACCATAG\\\nGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCGGGGCCTAAGACCACGAGCGTCTGGCGTCTTGGCTAA\\\nCCCCCCTACATGCTGTTATAGACAATCAGTGGAAACCCGGTGCCAGGGGGTGGAGTGACCTTAAGTCAGGGACGATATT\\\nAATCGGAAGGAGTATTCAACGCAATGAAGCCGCAGGGTTGGCGTGGGAATGGTGCTTCTGTCCAAGCAGGTAAGGGCAT\\\nGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTGCACTTTGCAACGATTTCGGAGTCCGGAGACTCGCTGTTTTCGAAAT\\\nTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTACGCCCAAGAACGTAGCAAGGTGACTCAAACAAGGTACATCTTGCCC\\\nGCGTTTCACACGAATCAAGTTGGAGGTTATGGAGCATAGTAACACGTGGGCGGCCAGTGGTCGGTTGCTACACCCCTGC\\\nCGCAACGTTGAAGGTCCCGGATTAGACTGGCTGGACCCATGCCGTGACACCCGTCACACTCCATTACCGTCTGCGGGTC\\\nACGGCTTGTTGTGGACTGGATTGCCATTCTCTCAGTGTATTACGCAGGCCGGCGCGCGGGTCCCATGTAAACCTGTCAT\\\nAGCTTACCTGACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCCACGCACCTGGTCGGTCCTCGTTTGCTTTTTAGGACC\\\nGGATGAACTACAGAGCGCTGCAAGAATCTCTACCTGCTTTACAAAGCGCTGGGTCCTACTCCAGCGGGATGTTTTATCT\\\nAAACACGATGAGAGGAGTATTCGTCAGGCCACATGGCTTTCTTGTCCTGGTCGGATCCATCGTTGGCGCCCGACCCCCC\\\nCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTGCATGCCAGATCGGCAGACAGATAGCGGATCCAGTATATCCCTGGAA\\\nGCTATAGACGCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTCCGAACCCAGCTCTACTTTAGTGGCCACGGGTTCTGG\\\nTCCCCCCGGGCCGCGGAACCGATTAGGGCCATGTACAACAATACTTATTAGTCACCTTTCAGACACGATCTCCCTGCTC\\\nAGTGGTATATGGTTCCTGCTATAATTAGCCACCCTCATAAGTTGCACTACTTCTGCGACCCAAGTGCACCCTTACCACG\\\nAAGACAGGATTGTCCGATCCCATACTGCGGCCTTGGCAGGGGGTTCGCAAGTCCCACCCCAAACGATGCTGAAGGCTCA\\\nGGTTACACAGGCACAAGTGCTATATACGCGAGTTCCCGCTCTTAACCTGGACCGAATGCGGGATCATGCATCGTACCAC\\\nTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGATACATAGTTCAATCAAGAATACCTTGTATTATTGTACACCTACCGG\\\nTCACCAGCCAACAATGTGCGGACGGCGTTGCGACTTGCTGGGCCTGATCTCACCGCCCTAGATACCGCACACTGGGCAA\\\nTACGAGGTAAAGCCAGTCACCCAGTGTCGATCAACAGCTGACGTAACGGTAAGAGGCTCACAAAATCGCACCGCCGGCG\\\nTCCCCTGGGTATTTTACGTCAGCATCGGGTGGACTGGCATGAATCTTTACTCCCAGGCGGAAACGGGTGCGTGGACAAG\\\nCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGGTGTCTCGTATCCCTCTTGGAGATCGAGGAAATGTTTCACGACCAAG\\\nGGAAAGGTCGCCCTACGAAATAGATTTGCGCTACTGTCCGCATAAGGAGTCCGGTGTAGCGAAGGATGAAGGCGACCCT\\\nAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAAGCAGGCACGGAAAGACACGGTCTAGCAGACCGTCTA\\\nTCGGCTAGGTCAAATAGGGTGCTTTGATATCAGCATGTCCAGCCTTAGAATTCAGTTCAGCGCGCTGGTCTGGGTCGAG\\\nATAAAATCACCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTGGCTAATCCTGGTACATCTTGTAATCAATGTTCAGAA\\\nGAAAATCTGTGTTAGAGGGACGAGTCACCACGTACCAATAGCGACAACGATCGGTCGGACTATTCATCGTGGTGGTGAC\\\nGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAGGATATAATGCTGAGGCGCTGCCCCAACCGTTCAGCG\\\nTGGGGTTTGCTACAACTTCCGAGTGCTACGTGTGCGAGACCATGTTATGTATGCACAAGGCCGACAATAGGACGTAGCC\\\nTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCACAGTAGATCCTCCCCGCGCATCCTATTTATTAAGTTAATTCTATAG\\\nCAATACGATCACATGCGGATGGGCAGTGGCCGGTAGTCACACGCCTACCGCGGTGCTCAATGACCGGGACTAGAGAGGC\\\nGAAGATTATGGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGAGCGTCATTGCGAGTAGTCGATTGCTTTCCCAATCTC\\\nCGAGCGATTTAGCGTGACAGCCCCAGGGAACCCACAAAATGCGATCGCAGTCCACCCGATCGTACACAGAAAGGAGGGT\\\nCCCCATACGCCGACGCACCTGTTCGCACGTCGTATGCATAAACGAGCCGCACGAACCAGAGAGCATAAAGAGGACCTCT\\\nAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGCCGGGATGCCTTACCTAGACGCAATGACGGACGTATTCCTCTGGCCT\\\nCAACGGTTCCTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAAGCCGCCTTTCCAAAGTGAGTCCTTCGTCTGTGACTA\\\nACTGTGCCAGATCGTCTTGCAAACTCCCGATCCAGTTTAACTCACCAAACTATAGCCGTACAGACCCAAATCTTAAGTC\\\nATATCACGCGACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGTTTTGGTCCGCCCGAGCGGTGCAGCCGATTAGGACCA\\\nTCTAATGCACTTGTTACAAGACTTCTTTTAAACACTTTCTTCCTGCCCAGTGGCGGATGATAATGGTTGTTGCCAGCCG\\\nGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAATGTGCCGTCTCCACCAACACAGGGCTGTCCGGTCGTATAATAGGAC\\\nTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGGACTCGCGATGTACATGCTCTGGTTCAATACATACGT\\\nGACCCGGCAGTTATCCTGCATCGGAACGTCAATCGTGCATCGGGCCAGCGTAATCGTGTCATCTGGGAGGCGGCCGTAG\\\nGATAAATAATTCAATAAAGATGTCGTTTTGCTAGTATACGCCTAGGCGTCACCCGCCATCTCTGTGCAGGTGGGCCGAC\\\nGAGACACTGCCCCTGATTTCTCCGCTACTAATAGCACACACGGGGCAATACCAGCACAAGCCAGTCTCGCGGGAACGCT\\\nCGTCAGCATACGAAAGAGCTTGAGGCACGCCAATTCGCACTGTCGGGGTCGCTTGGGTGTTTTGCACTACCGTCAGGTA\\\nCGCTAGTATGCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGGTCAAAAGTGCGGCATTCGTATTTGCTCCCCGTGCTT\\\nGCTCTCACGAACTTGACCTGGAGATCAAGGAGATGCTTCTTGTGGAACCGGACAGCGCATCAACGCAACGGATCTACGT\\\nTACAGCGTGCATAGCGAGAACGGAGTTGCCGACGACGAAAGCGACACTGGGATCTGTCCGTCGTCATTCGCGGAAAGCA\\\nTCCGCTCACGAGGCGGACACTGATTGACACGGTTTTGCAGAAGGTTAGGGGAATAGGTCAAATTGAGTGGCTTAAAAAC\\\nGCTATGTCTGGGATTAAAGTGTAGTAAACTGCGGTCAACGGAGACGGTTTTAAGACAGGAGTTCGCAAAACCAGGCGGG\\\nGTCGCCACGACGGCTATTCCTGGTGGTTTAGGCGTACAATGTCCTGAAGAATATTTAAGAAAGAAGCACCCCTCGTCGC\\\nCTAGAATTACCTACCGCGGTCGACCATACCTTCGATTGTCGCGCCCACCCTCCCATTAGTCGGCAGAGGTGGTTGTGTT\\\nGCGATAGCCCAGCATGATATCCTAAGGCGTTACGCCGATGGATATCCCACGGAATTGCCATAGGCGCTGAACGCTACAC\\\nGGACGATACGAACTTATGTATGGAGCGGGTCATCGAAAGGTCATACCCTTGTAGTTAACATGTAGCCCGGCCCTATTAG\\\nTACAGCAGTGCCTTGAGCGGCATTCTCATTATTAAGTTTTCTCTACAGCCAAACGACCAAGTGCACTTCCGCGGAGCGC\\\nGGTGGAGACTCGTCCACCCGGCAGCTCTGTAATAGGGACTAAAAGAGTGATGATAATCATGAGTGCCGCGTTATGGTGG\\\nTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCGAGTTCCGTCCGGTTAAGCGTGACACTCCCAGTGTAC\\\nCCGCAAACCGTGATGGCTGTGCTTGGGGTCAATCGCATGTAGGATGGTCTCCAGACACCGGGGCACCAGTTTTCACGCC\\\nCAAAGCATAAACGACGAGCAGTCATGAGAGTCTTAGAACTGGACGTGCCGTTTCTCTGCGAACAACACCTCGAGCTGTA\\\nCCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTCCTATCACATTTGCCTCGACGACTGCCGCCTTCGCTGTTTCCCTAGA\\\nCACTCAACAGTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGTCAGTGGCTGCGCCAAAACGTCTTCGGATCCCCTTGT\\\nCCAATCAAACTGACCGAATTCTTTCATTTAAGACCCTAATATGACATCATTAGTGACTAAATGCCACTCCCAAAATTCT\\\nGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAACGAATCTAACTATTCCCTGTGCCTTATGGGGGCCTGC\\\nGCTATCTGCCTGTCGAACCATAGGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCGGGGCCTAAGACCA\\\nCGAGCGTCTGGCGTCTTGGCTAACCCCCCTACATGCTGTTATAGACAATCAGTGGAAACCCGGTGCCAGGGGGTGGAGT\\\nGACCTTAAGTCAGGGACGATATTAATCGGAAGGAGTATTCAACGCAATGAAGCCGCAGGGTTGGCGTGGGAATGGTGCT\\\nTCTGTCCAAGCAGGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTGCACTTTGCAACGATTTCGGAGTC\\\nCGGAGACTCGCTGTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTACGCCCAAGAACGTAGCAAGGTGA\\\nCTCAAACAAGGTACATCTTGCCCGCGTTTCACACGAATCAAGTTGGAGGTTATGGAGCATAGTAACACGTGGGCGGCCA\\\nGTGGTCGGTTGCTACACCCCTGCCGCAACGTTGAAGGTCCCGGATTAGACTGGCTGGACCCATGCCGTGACACCCGTCA\\\nCACTCCATTACCGTCTGCGGGTCACGGCTTGTTGTGGACTGGATTGCCATTCTCTCAGTGTATTACGCAGGCCGGCGCG\\\nCGGGTCCCATGTAAACCTGTCATAGCTTACCTGACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCCACGCACCTGGTCG\\\nGTCCTCGTTTGCTTTTTAGGACCGGATGAACTACAGAGCGCTGCAAGAATCTCTACCTGCTTTACAAAGCGCTGGGTCC\\\nTACTCCAGCGGGATGTTTTATCTAAACACGATGAGAGGAGTATTCGTCAGGCCACATGGCTTTCTTGTCCTGGTCGGAT\\\nCCATCGTTGGCGCCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTGCATGCCAGATCGGCAGACAGATA\\\nGCGGATCCAGTATATCCCTGGAAGCTATAGACGCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTCCGAACCCAGCTCT\\\nACTTTAGTGGCCACGGGTTCTGGTCCCCCCGGGCCGCGGAACCGATTAGGGCCATGTACAACAATACTTATTAGTCACC\\\nTTTCAGACACGATCTCCCTGCTCAGTGGTATATGGTTCCTGCTATAATTAGCCACCCTCATAAGTTGCACTACTTCTGC\\\nGACCCAAGTGCACCCTTACCACGAAGACAGGATTGTCCGATCCCATACTGCGGCCTTGGCAGGGGGTTCGCAAGTCCCA\\\nCCCCAAACGATGCTGAAGGCTCAGGTTACACAGGCACAAGTGCTATATACGCGAGTTCCCGCTCTTAACCTGGACCGAA\\\nTGCGGGATCATGCATCGTACCACTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGATACATAGTTCAATCAAGAATACC\\\nTTGTATTATTGTACACCTACCGGTCACCAGCCAACAATGTGCGGACGGCGTTGCGACTTGCTGGGCCTGATCTCACCGC\\\nCCTAGATACCGCACACTGGGCAATACGAGGTAAAGCCAGTCACCCAGTGTCGATCAACAGCTGACGTAACGGTAAGAGG\\\nCTCACAAAATCGCACCGCCGGCGTCCCCTGGGTATTTTACGTCAGCATCGGGTGGACTGGCATGAATCTTTACTCCCAG\\\nGCGGAAACGGGTGCGTGGACAAGCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGGTGTCTCGTATCCCTCTTGGAGAT\\\nCGAGGAAATGTTTCACGACCAAGGGAAAGGTCGCCCTACGAAATAGATTTGCGCTACTGTCCGCATAAGGAGTCCGGTG\\\nTAGCGAAGGATGAAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAAGCAGGCACGGAAA\\\nGACACGGTCTAGCAGACCGTCTATCGGCTAGGTCAAATAGGGTGCTTTGATATCAGCATGTCCAGCCTTAGAATTCAGT\\\nTCAGCGCGCTGGTCTGGGTCGAGATAAAATCACCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTGGCTAATCCTGGTA\\\nCATCTTGTAATCAATGTTCAGAAGAAAATCTGTGTTAGAGGGACGAGTCACCACGTACCAATAGCGACAACGATCGGTC\\\nGGACTATTCATCGTGGTGGTGACGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAGGATATAATGCTGA\\\nGGCGCTGCCCCAACCGTTCAGCGTGGGGTTTGCTACAACTTCCGAGTGCTACGTGTGCGAGACCATGTTATGTATGCAC\\\nAAGGCCGACAATAGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCACAGTAGATCCTCCCCGCGCATCC\\\nTATTTATTAAGTTAATTCTATAGCAATACGATCACATGCGGATGGGCAGTGGCCGGTAGTCACACGCCTACCGCGGTGC\\\nTCAATGACCGGGACTAGAGAGGCGAAGATTATGGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGAGCGTCATTGCGAG\\\nTAGTCGATTGCTTTCCCAATCTCCGAGCGATTTAGCGTGACAGCCCCAGGGAACCCACAAAATGCGATCGCAGTCCACC\\\nCGATCGTACACAGAAAGGAGGGTCCCCATACGCCGACGCACCTGTTCGCACGTCGTATGCATAAACGAGCCGCACGAAC\\\nCAGAGAGCATAAAGAGGACCTCTAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGCCGGGATGCCTTACCTAGACGCAA\\\nTGACGGACGTATTCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAAGCCGCCTTTCCAA\\\nAGTGAGTCCTTCGTCTGTGACTAACTGTGCCAGATCGTCTTGCAAACTCCCGATCCAGTTTAACTCACCAAACTATAGC\\\nCGTACAGACCCAAATCTTAAGTCATATCACGCGACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGTTTTGGTCCGCCCG\\\nAGCGGTGCAGCCGATTAGGACCATCTAATGCACTTGTTACAAGACTTCTTTTAAACACTTTCTTCCTGCCCAGTGGCGG\\\nATGATAATGGTTGTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAATGTGCCGTCTCCACCAACACAGG\\\nGCTGTCCGGTCGTATAATAGGACTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGGACTCGCGATGTAC\\\nATGCTCTGGTTCAATACATACGTGACCCGGCAGTTATCCTGCATCGGAACGTCAATCGTGCATCGGGCCAGCGTAATCG\\\nTGTCATCTGGGAGGCGGCCGTAGGATAAATAATTCAATAAAGATGTCGTTTTGCTAGTATACGCCTAGGCGTCACCCGC\\\nCATCTCTGTGCAGGTGGGCCGACGAGACACTGCCCCTGATTTCTCCGCTACTAATAGCACACACGGGGCAATACCAGCA\\\nCAAGCCAGTCTCGCGGGAACGCTCGTCAGCATACGAAAGAGCTTGAGGCACGCCAATTCGCACTGTCGGGGTCGCTTGG\\\nGTGTTTTGCACTACCGTCAGGTACGCTAGTATGCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGGTCAAAAGTGCGGC\\\nATTCGTATTTGCTCCCCGTGCTTGCTCTCACGAACTTGACCTGGAGATCAAGGAGATGCTTCTTGTGGAACCGGACAGC\\\nGCATCAACGCAACGGATCTACGTTACAGCGTGCATAGCGAGAACGGAGTTGCCGACGACGAAAGCGACACTGGGATCTG\\\nTCCGTCGTCATTCGCGGAAAGCATCCGCTCACGAGGCGGACACTGATTGACACGGTTTTGCAGAAGGTTAGGGGAATAG\\\nGTCAAATTGAGTGGCTTAAAAACGCTATGTCTGGGATTAAAGTGTAGTAAACTGCGGTCAACGGAGACGGTTTTAAGAC\\\nAGGAGTTCGCAAAACCAGGCGGGGTCGCCACGACGGCTATTCCTGGTGGTTTAGGCGTACAATGTCCTGAAGAATATTT\\\nAAGAAAGAAGCACCCCTCGTCGCCTAGAATTACCTACCGCGGTCGACCATACCTTCGATTGTCGCGCCCACCCTCCCAT\\\nTAGTCGGCAGAGGTGGTTGTGTTGCGATAGCCCAGCATGATATCCTAAGGCGTTACGCCGATGGATATCCCACGGAATT\\\nGCCATAGGCGCTGAACGCTACACGGACGATACGAACTTATGTATGGAGCGGGTCATCGAAAGGTCATACCCTTGTAGTT\\\nAACATGTAGCCCGGCCCTATTAGTACAGCAGTGCCTTGAGCGGCATTCTCATTATTAAGTTTTCTCTACAGCCAAACGA\\\nCCAAGTGCACTTCCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCAGCTCTGTAATAGGGACTAAAAGAGTGATGATAA\\\nTCATGAGTGCCGCGTTATGGTGGTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCGAGTTCCGTCCGGT\\\nTAAGCGTGACACTCCCAGTGTACCCGCAAACCGTGATGGCTGTGCTTGGGGTCAATCGCATGTAGGATGGTCTCCAGAC\\\nACCGGGGCACCAGTTTTCACGCCCAAAGCATAAACGACGAGCAGTCATGAGAGTCTTAGAACTGGACGTGCCGTTTCTC\\\nTGCGAACAACACCTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTCCTATCACATTTGCCTCGACGACT\\\nGCCGCCTTCGCTGTTTCCCTAGACACTCAACAGTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGTCAGTGGCTGCGCC\\\nAAAACGTCTTCGGATCCCCTTGTCCAATCAAACTGACCGAATTCTTTCATTTAAGACCCTAATATGACATCATTAGTGA\\\nCTAAATGCCACTCCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAACGAATCTAACTATT\\\nCCCTGTGCCTTATGGGGGCCTGCGCTATCTGCCTGTCGAACCATAGGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGT\\\nGAAATCTCCGGGGCCTAAGACCACGAGCGTCTGGCGTCTTGGCTAACCCCCCTACATGCTGTTATAGACAATCAGTGGA\\\nAACCCGGTGCCAGGGGGTGGAGTGACCTTAAGTCAGGGACGATATTAATCGGAAGGAGTATTCAACGCAATGAAGCCGC\\\nAGGGTTGGCGTGGGAATGGTGCTTCTGTCCAAGCAGGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTG\\\nCACTTTGCAACGATTTCGGAGTCCGGAGACTCGCTGTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTA\\\nCGCCCAAGAACGTAGCAAGGTGACTCAAACAAGGTACATCTTGCCCGCGTTTCACACGAATCAAGTTGGAGGTTATGGA\\\nGCATAGTAACACGTGGGCGGCCAGTGGTCGGTTGCTACACCCCTGCCGCAACGTTGAAGGTCCCGGATTAGACTGGCTG\\\nGACCCATGCCGTGACACCCGTCACACTCCATTACCGTCTGCGGGTCACGGCTTGTTGTGGACTGGATTGCCATTCTCTC\\\nAGTGTATTACGCAGGCCGGCGCGCGGGTCCCATGTAAACCTGTCATAGCTTACCTGACTCTACTTGGAAGTGTGGCTAG\\\nGCCTTTGCCCACGCACCTGGTCGGTCCTCGTTTGCTTTTTAGGACCGGATGAACTACAGAGCGCTGCAAGAATCTCTAC\\\nCTGCTTTACAAAGCGCTGGGTCCTACTCCAGCGGGATGTTTTATCTAAACACGATGAGAGGAGTATTCGTCAGGCCACA\\\nTGGCTTTCTTGTCCTGGTCGGATCCATCGTTGGCGCCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTG\\\nCATGCCAGATCGGCAGACAGATAGCGGATCCAGTATATCCCTGGAAGCTATAGACGCACAGGTTGGAATCCTAAGCGAA\\\nGTCGCGCGTCCGAACCCAGCTCTACTTTAGTGGCCACGGGTTCTGGTCCCCCCGGGCCGCGGAACCGATTAGGGCCATG\\\nTACAACAATACTTATTAGTCACCTTTCAGACACGATCTCCCTGCTCAGTGGTATATGGTTCCTGCTATAATTAGCCACC\\\nCTCATAAGTTGCACTACTTCTGCGACCCAAGTGCACCCTTACCACGAAGACAGGATTGTCCGATCCCATACTGCGGCCT\\\nTGGCAGGGGGTTCGCAAGTCCCACCCCAAACGATGCTGAAGGCTCAGGTTACACAGGCACAAGTGCTATATACGCGAGT\\\nTCCCGCTCTTAACCTGGACCGAATGCGGGATCATGCATCGTACCACTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGA\\\nTACATAGTTCAATCAAGAATACCTTGTATTATTGTACACCTACCGGTCACCAGCCAACAATGTGCGGACGGCGTTGCGA\\\nCTTGCTGGGCCTGATCTCACCGCCCTAGATACCGCACACTGGGCAATACGAGGTAAAGCCAGTCACCCAGTGTCGATCA\\\nACAGCTGACGTAACGGTAAGAGGCTCACAAAATCGCACCGCCGGCGTCCCCTGGGTATTTTACGTCAGCATCGGGTGGA\\\nCTGGCATGAATCTTTACTCCCAGGCGGAAACGGGTGCGTGGACAAGCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGG\\\nTGTCTCGTATCCCTCTTGGAGATCGAGGAAATGTTTCACGACCAAGGGAAAGGTCGCCCTACGAAATAGATTTGCGCTA\\\nCTGTCCGCATAAGGAGTCCGGTGTAGCGAAGGATGAAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTAT\\\nCACTCAGGAAGCAGGCACGGAAAGACACGGTCTAGCAGACCGTCTATCGGCTAGGTCAAATAGGGTGCTTTGATATCAG\\\nCATGTCCAGCCTTAGAATTCAGTTCAGCGCGCTGGTCTGGGTCGAGATAAAATCACCAGTACCCAAGACCAGGCGGGCT\\\nCGCCGCGTTGGCTAATCCTGGTACATCTTGTAATCAATGTTCAGAAGAAAATCTGTGTTAGAGGGACGAGTCACCACGT\\\nACCAATAGCGACAACGATCGGTCGGACTATTCATCGTGGTGGTGACGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCC\\\nGACAGGCTAGGATATAATGCTGAGGCGCTGCCCCAACCGTTCAGCGTGGGGTTTGCTACAACTTCCGAGTGCTACGTGT\\\nGCGAGACCATGTTATGTATGCACAAGGCCGACAATAGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCA\\\nCAGTAGATCCTCCCCGCGCATCCTATTTATTAAGTTAATTCTATAGCAATACGATCACATGCGGATGGGCAGTGGCCGG\\\nTAGTCACACGCCTACCGCGGTGCTCAATGACCGGGACTAGAGAGGCGAAGATTATGGCGTGTGACCCGTTATGCTCGAG\\\nTTCGGTCAGAGCGTCATTGCGAGTAGTCGATTGCTTTCCCAATCTCCGAGCGATTTAGCGTGACAGCCCCAGGGAACCC\\\nACAAAATGCGATCGCAGTCCACCCGATCGTACACAGAAAGGAGGGTCCCCATACGCCGACGCACCTGTTCGCACGTCGT\\\nATGCATAAACGAGCCGCACGAACCAGAGAGCATAAAGAGGACCTCTAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGC\\\nCGGGATGCCTTACCTAGACGCAATGACGGACGTATTCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGGATCCAAGATT\\\nGGCGGCCGAAGCCGCCTTTCCAAAGTGAGTCCTTCGTCTGTGACTAACTGTGCCAGATCGTCTTGCAAACTCCCGATCC\\\nAGTTTAACTCACCAAACTATAGCCGTACAGACCCAAATCTTAAGTCATATCACGCGACTAGCCTCTGCTCAATTTCTGT\\\nGCTCAAGGGTTTTGGTCCGCCCGAGCGGTGCAGCCGATTAGGACCATCTAATGCACTTGTTACAAGACTTCTTTTAAAC\\\nACTTTCTTCCTGCCCAGTGGCGGATGATAATGGTTGTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAA\\\nTGTGCCGTCTCCACCAACACAGGGCTGTCCGGTCGTATAATAGGACTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAAC\\\nGATGTCGGGGACTCGCGATGTACATGCTCTGGTTCAATACATACGTGACCCGGCAGTTATCCTGCATCGGAACGTCAAT\\\nCGTGCATCGGGCCAGCGTAATCGTGTCATCTGGGAGGCGGCCGTAGGATAAATAATTCAATAAAGATGTCGTTTTGCTA\\\nGTATACGCCTAGGCGTCACCCGCCATCTCTGTGCAGGTGGGCCGACGAGACACTGCCCCTGATTTCTCCGCTACTAATA\\\nGCACACACGGGGCAATACCAGCACAAGCCAGTCTCGCGGGAACGCTCGTCAGCATACGAAAGAGCTTGAGGCACGCCAA\\\nTTCGCACTGTCGGGGTCGCTTGGGTGTTTTGCACTACCGTCAGGTACGCTAGTATGCGTCCTTCCTTCCAGGGGTATGT\\\nGGCTGCGTGGTCAAAAGTGCGGCATTCGTATTTGCTCCCCGTGCTTGCTCTCACGAACTTGACCTGGAGATCAAGGAGA\\\nTGCTTCTTGTGGAACCGGACAGCGCATCAACGCAACGGATCTACGTTACAGCGTGCATAGCGAGAACGGAGTTGCCGAC\\\nGACGAAAGCGACACTGGGATCTGTCCGTCGTCATTCGCGGAAAGCATCCGCTCACGAGGCGGACACTGATTGACACGGT\\\nTTTGCAGAAGGTTAGGGGAATAGGTCAAATTGAGTGGCTTAAAAACGCTATGTCTGGGATTAAAGTGTAGTAAACTGCG\\\nGTCAACGGAGACGGTTTTAAGACAGGAGTTCGCAAAACCAGGCGGGGTCGCCACGACGGCTATTCCTGGTGGTTTAGGC\\\nGTACAATGTCCTGAAGAATATTTAAGAAAGAAGCACCCCTCGTCGCCTAGAATTACCTACCGCGGTCGACCATACCTTC\\\nGATTGTCGCGCCCACCCTCCCATTAGTCGGCAGAGGTGGTTGTGTTGCGATAGCCCAGCATGATATCCTAAGGCGTTAC\\\nGCCGATGGATATCCCACGGAATTGCCATAGGCGCTGAACGCTACACGGACGATACGAACTTATGTATGGAGCGGGTCAT\\\nCGAAAGGTCATACCCTTGTAGTTAACATGTAGCCCGGCCCTATTAGTACAGCAGTGCCTTGAGCGGCATTCTCATTATT\\\nAAGTTTTCTCTACAGCCAAACGACCAAGTGCACTTCCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCAGCTCTGTAAT\\\nAGGGACTAAAAGAGTGATGATAATCATGAGTGCCGCGTTATGGTGGTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTA\\\nTCCCTTCTCGAGTTCCGTCCGGTTAAGCGTGACACTCCCAGTGTACCCGCAAACCGTGATGGCTGTGCTTGGGGTCAAT\\\nCGCATGTAGGATGGTCTCCAGACACCGGGGCACCAGTTTTCACGCCCAAAGCATAAACGACGAGCAGTCATGAGAGTCT\\\nTAGAACTGGACGTGCCGTTTCTCTGCGAACAACACCTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTC\\\nCTATCACATTTGCCTCGACGACTGCCGCCTTCGCTGTTTCCCTAGACACTCAACAGTAAGCGCCTTTTGTAGGCAGGGG\\\nCACCCCCTGTCAGTGGCTGCGCCAAAACGTCTTCGGATCCCCTTGTCCAATCAAACTGACCGAATTCTTTCATTTAAGA\\\nCCCTAATATGACATCATTAGTGACTAAATGCCACTCCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGT\\\nTGTCTAAAACGAATCTAACTATTCCCTGTGCCTTATGGGGGCCTGCGCTATCTGCCTGTCGAACCATAGGACTCGCGCC\\\nAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCGGGGCCTAAGACCACGAGCGTCTGGCGTCTTGGCTAACCCCCCTACA\\\nTGCTGTTATAGACAATCAGTGGAAACCCGGTGCCAGGGGGTGGAGTGACCTTAAGTCAGGGACGATATTAATCGGAAGG\\\nAGTATTCAACGCAATGAAGCCGCAGGGTTGGCGTGGGAATGGTGCTTCTGTCCAAGCAGGTAAGGGCATGAGGCCGCAA\\\nCCGTCCCCCAAGCGTACAGGGTGCACTTTGCAACGATTTCGGAGTCCGGAGACTCGCTGTTTTCGAAATTTGCGCTCAA\\\nGGGCGGGTATTGAACCAGGCTTACGCCCAAGAACGTAGCAAGGTGACTCAAACAAGGTACATCTTGCCCGCGTTTCACA\\\nCGAATCAAGTTGGAGGTTATGGAGCATAGTAACACGTGGGCGGCCAGTGGTCGGTTGCTACACCCCTGCCGCAACGTTG\\\nAAGGTCCCGGATTAGACTGGCTGGACCCATGCCGTGACACCCGTCACACTCCATTACCGTCTGCGGGTCACGGCTTGTT\\\nGTGGACTGGATTGCCATTCTCTCAGTGTATTACGCAGGCCGGCGCGCGGGTCCCATGTAAACCTGTCATAGCTTACCTG\\\nACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCCACGCACCTGGTCGGTCCTCGTTTGCTTTTTAGGACCGGATGAACTA\\\nCAGAGCGCTGCAAGAATCTCTACCTGCTTTACAAAGCGCTGGGTCCTACTCCAGCGGGATGTTTTATCTAAACACGATG\\\nAGAGGAGTATTCGTCAGGCCACATGGCTTTCTTGTCCTGGTCGGATCCATCGTTGGCGCCCGACCCCCCCACTCCGTAG\\\nTGAGTTCTTCGTCCGAGCCATTGCATGCCAGATCGGCAGACAGATAGCGGATCCAGTATATCCCTGGAAGCTATAGACG\\\nCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTCCGAACCCAGCTCTACTTTAGTGGCCACGGGTTCTGGTCCCCCCGGG\\\nCCGCGGAACCGATTAGGGCCATGTACAACAATACTTATTAGTCACCTTTCAGACACGATCTCCCTGCTCAGTGGTATAT\\\nGGTTCCTGCTATAATTAGCCACCCTCATAAGTTGCACTACTTCTGCGACCCAAGTGCACCCTTACCACGAAGACAGGAT\\\nTGTCCGATCCCATACTGCGGCCTTGGCAGGGGGTTCGCAAGTCCCACCCCAAACGATGCTGAAGGCTCAGGTTACACAG\\\nGCACAAGTGCTATATACGCGAGTTCCCGCTCTTAACCTGGACCGAATGCGGGATCATGCATCGTACCACTGTGTTCGTG\\\nTCATCTAGGACGGGCGCAAAGGATACATAGTTCAATCAAGAATACCTTGTATTATTGTACACCTACCGGTCACCAGCCA\\\nACAATGTGCGGACGGCGTTGCGACTTGCTGGGCCTGATCTCACCGCCCTAGATACCGCACACTGGGCAATACGAGGTAA\\\nAGCCAGTCACCCAGTGTCGATCAACAGCTGACGTAACGGTAAGAGGCTCACAAAATCGCACCGCCGGCGTCCCCTGGGT\\\nATTTTACGTCAGCATCGGGTGGACTGGCATGAATCTTTACTCCCAGGCGGAAACGGGTGCGTGGACAAGCGAGCAGCAA\\\nACGAAAATTCCTGGCCTGCTTGGTGTCTCGTATCCCTCTTGGAGATCGAGGAAATGTTTCACGACCAAGGGAAAGGTCG\\\nCCCTACGAAATAGATTTGCGCTACTGTCCGCATAAGGAGTCCGGTGTAGCGAAGGATGAAGGCGACCCTAGGTAGCAAC\\\nCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAAGCAGGCACGGAAAGACACGGTCTAGCAGACCGTCTATCGGCTAGGT\\\nCAAATAGGGTGCTTTGATATCAGCATGTCCAGCCTTAGAATTCAGTTCAGCGCGCTGGTCTGGGTCGAGATAAAATCAC\\\nCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTGGCTAATCCTGGTACATCTTGTAATCAATGTTCAGAAGAAAATCTGT\\\nGTTAGAGGGACGAGTCACCACGTACCAATAGCGACAACGATCGGTCGGACTATTCATCGTGGTGGTGACGCTCGGATTA\\\nCGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAGGATATAATGCTGAGGCGCTGCCCCAACCGTTCAGCGTGGGGTTTGC\\\nTACAACTTCCGAGTGCTACGTGTGCGAGACCATGTTATGTATGCACAAGGCCGACAATAGGACGTAGCCTTCGAGTTAG\\\nTACGTAGCGTGGTCGCACAAGCACAGTAGATCCTCCCCGCGCATCCTATTTATTAAGTTAATTCTATAGCAATACGATC\\\nACATGCGGATGGGCAGTGGCCGGTAGTCACACGCCTACCGCGGTGCTCAATGACCGGGACTAGAGAGGCGAAGATTATG\\\nGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGAGCGTCATTGCGAGTAGTCGATTGCTTTCCCAATCTCCGAGCGATTT\\\nAGCGTGACAGCCCCAGGGAACCCACAAAATGCGATCGCAGTCCACCCGATCGTACACAGAAAGGAGGGTCCCCATACGC\\\nCGACGCACCTGTTCGCACGTCGTATGCATAAACGAGCCGCACGAACCAGAGAGCATAAAGAGGACCTCTAGCTCCTTTA\\\nCAAAGTACAGGTTCGCCTGCCGCCGGGATGCCTTACCTAGACGCAATGACGGACGTATTCCTCTGGCCTCAACGGTTCC\\\nTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAAGCCGCCTTTCCAAAGTGAGTCCTTCGTCTGTGACTAACTGTGCCAG\\\nATCGTCTTGCAAACTCCCGATCCAGTTTAACTCACCAAACTATAGCCGTACAGACCCAAATCTTAAGTCATATCACGCG\\\nACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGTTTTGGTCCGCCCGAGCGGTGCAGCCGATTAGGACCATCTAATGCAC\\\nTTGTTACAAGACTTCTTTTAAACACTTTCTTCCTGCCCAGTGGCGGATGATAATGGTTGTTGCCAGCCGGCGTGGAAGG\\\nTAACAGCACCGGTGCGAGCCTAATGTGCCGTCTCCACCAACACAGGGCTGTCCGGTCGTATAATAGGACTCCGCAATGG\\\nGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGGACTCGCGATGTACATGCTCTGGTTCAATACATACGTGACCCGGCAG\\\nTTATCCTGCATCGGAACGTCAATCGTGCATCGGGCCAGCGTAATCGTGTCATCTGGGAGGCGGCCGTAGGATAAATAAT\\\nTCAATAAAGATGTCGTTTTGCTAGTATACGCCTAGGCGTCACCCGCCATCTCTGTGCAGGTGGGCCGACGAGACACTGC\\\nCCCTGATTTCTCCGCTACTAATAGCACACACGGGGCAATACCAGCACAAGCCAGTCTCGCGGGAACGCTCGTCAGCATA\\\nCGAAAGAGCTTGAGGCACGCCAATTCGCACTGTCGGGGTCGCTTGGGTGTTTTGCACTACCGTCAGGTACGCTAGTATG\\\nCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGGTCAAAAGTGCGGCATTCGTATTTGCTCCCCGTGCTTGCTCTCACGA\\\nACTTGACCTGGAGATCAAGGAGATGCTTCTTGTGGAACCGGACAGCGCATCAACGCAACGGATCTACGTTACAGCGTGC\\\nATAGCGAGAACGGAGTTGCCGACGACGAAAGCGACACTGGGATCTGTCCGTCGTCATTCGCGGAAAGCATCCGCTCACG\\\nAGGCGGACACTGATTGACACGGTTTTGCAGAAGGTTAGGGGAATAGGTCAAATTGAGTGGCTTAAAAACGCTATGTCTG\\\nGGATTAAAGTGTAGTAAACTGCGGTCAACGGAGACGGTTTTAAGACAGGAGTTCGCAAAACCAGGCGGGGTCGCCACGA\\\nCGGCTATTCCTGGTGGTTTAGGCGTACAATGTCCTGAAGAATATTTAAGAAAGAAGCACCCCTCGTCGCCTAGAATTAC\\\nCTACCGCGGTCGACCATACCTTCGATTGTCGCGCCCACCCTCCCATTAGTCGGCAGAGGTGGTTGTGTTGCGATAGCCC\\\nAGCATGATATCCTAAGGCGTTACGCCGATGGATATCCCACGGAATTGCCATAGGCGCTGAACGCTACACGGACGATACG\\\nAACTTATGTATGGAGCGGGTCATCGAAAGGTCATACCCTTGTAGTTAACATGTAGCCCGGCCCTATTAGTACAGCAGTG\\\nCCTTGAGCGGCATTCTCATTATTAAGTTTTCTCTACAGCCAAACGACCAAGTGCACTTCCGCGGAGCGCGGTGGAGACT\\\nCGTCCACCCGGCAGCTCTGTAATAGGGACTAAAAGAGTGATGATAATCATGAGTGCCGCGTTATGGTGGTGTCGGAACA\\\nGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCGAGTTCCGTCCGGTTAAGCGTGACACTCCCAGTGTACCCGCAAACCG\\\nTGATGGCTGTGCTTGGGGTCAATCGCATGTAGGATGGTCTCCAGACACCGGGGCACCAGTTTTCACGCCCAAAGCATAA\\\nACGACGAGCAGTCATGAGAGTCTTAGAACTGGACGTGCCGTTTCTCTGCGAACAACACCTCGAGCTGTACCGTTGTTGC\\\nGCTGCCTAGATGCAGTGCCGCTCCTATCACATTTGCCTCGACGACTGCCGCCTTCGCTGTTTCCCTAGACACTCAACAG\\\nTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGTCAGTGGCTGCGCCAAAACGTCTTCGGATCCCCTTGTCCAATCAAAC\\\nTGACCGAATTCTTTCATTTAAGACCCTAATATGACATCATTAGTGACTAAATGCCACTCCCAAAATTCTGCCCAGAAGC\\\nGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAACGAATCTAACTATTCCCTGTGCCTTATGGGGGCCTGCGCTATCTGCC\\\nTGTCGAACCATAGGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCGGGGCCTAAGACCACGAGCGTCTG\\\nGCGTCTTGGCTAACCCCCCTACATGCTGTTATAGACAATCAGTGGAAACCCGGTGCCAGGGGGTGGAGTGACCTTAAGT\\\nCAGGGACGATATTAATCGGAAGGAGTATTCAACGCAATGAAGCCGCAGGGTTGGCGTGGGAATGGTGCTTCTGTCCAAG\\\nCAGGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTGCACTTTGCAACGATTTCGGAGTCCGGAGACTCG\\\nCTGTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTACGCCCAAGAACGTAGCAAGGTGACTCAAACAAG\\\nGTACATCTTGCCCGCGTTTCACACGAATCAAGTTGGAGGTTATGGAGCATAGTAACACGTGGGCGGCCAGTGGTCGGTT\\\nGCTACACCCCTGCCGCAACGTTGAAGGTCCCGGATTAGACTGGCTGGACCCATGCCGTGACACCCGTCACACTCCATTA\\\nCCGTCTGCGGGTCACGGCTTGTTGTGGACTGGATTGCCATTCTCTCAGTGTATTACGCAGGCCGGCGCGCGGGTCCCAT\\\nGTAAACCTGTCATAGCTTACCTGACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCCACGCACCTGGTCGGTCCTCGTTT\\\nGCTTTTTAGGACCGGATGAACTACAGAGCGCTGCAAGAATCTCTACCTGCTTTACAAAGCGCTGGGTCCTACTCCAGCG\\\nGGATGTTTTATCTAAACACGATGAGAGGAGTATTCGTCAGGCCACATGGCTTTCTTGTCCTGGTCGGATCCATCGTTGG\\\nCGCCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTGCATGCCAGATCGGCAGACAGATAGCGGATCCAG\\\nTATATCCCTGGAAGCTATAGACGCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTCCGAACCCAGCTCTACTTTAGTGG\\\nCCACGGGTTCTGGTCCCCCCGGGCCGCGGAACCGATTAGGGCCATGTACAACAATACTTATTAGTCACCTTTCAGACAC\\\nGATCTCCCTGCTCAGTGGTATATGGTTCCTGCTATAATTAGCCACCCTCATAAGTTGCACTACTTCTGCGACCCAAGTG\\\nCACCCTTACCACGAAGACAGGATTGTCCGATCCCATACTGCGGCCTTGGCAGGGGGTTCGCAAGTCCCACCCCAAACGA\\\nTGCTGAAGGCTCAGGTTACACAGGCACAAGTGCTATATACGCGAGTTCCCGCTCTTAACCTGGACCGAATGCGGGATCA\\\nTGCATCGTACCACTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGATACATAGTTCAATCAAGAATACCTTGTATTATT\\\nGTACACCTACCGGTCACCAGCCAACAATGTGCGGACGGCGTTGCGACTTGCTGGGCCTGATCTCACCGCCCTAGATACC\\\nGCACACTGGGCAATACGAGGTAAAGCCAGTCACCCAGTGTCGATCAACAGCTGACGTAACGGTAAGAGGCTCACAAAAT\\\nCGCACCGCCGGCGTCCCCTGGGTATTTTACGTCAGCATCGGGTGGACTGGCATGAATCTTTACTCCCAGGCGGAAACGG\\\nGTGCGTGGACAAGCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGGTGTCTCGTATCCCTCTTGGAGATCGAGGAAATG\\\nTTTCACGACCAAGGGAAAGGTCGCCCTACGAAATAGATTTGCGCTACTGTCCGCATAAGGAGTCCGGTGTAGCGAAGGA\\\nTGAAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAAGCAGGCACGGAAAGACACGGTCT\\\nAGCAGACCGTCTATCGGCTAGGTCAAATAGGGTGCTTTGATATCAGCATGTCCAGCCTTAGAATTCAGTTCAGCGCGCT\\\nGGTCTGGGTCGAGATAAAATCACCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTGGCTAATCCTGGTACATCTTGTAA\\\nTCAATGTTCAGAAGAAAATCTGTGTTAGAGGGACGAGTCACCACGTACCAATAGCGACAACGATCGGTCGGACTATTCA\\\nTCGTGGTGGTGACGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAGGATATAATGCTGAGGCGCTGCCC\\\nCAACCGTTCAGCGTGGGGTTTGCTACAACTTCCGAGTGCTACGTGTGCGAGACCATGTTATGTATGCACAAGGCCGACA\\\nATAGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCACAGTAGATCCTCCCCGCGCATCCTATTTATTAA\\\nGTTAATTCTATAGCAATACGATCACATGCGGATGGGCAGTGGCCGGTAGTCACACGCCTACCGCGGTGCTCAATGACCG\\\nGGACTAGAGAGGCGAAGATTATGGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGAGCGTCATTGCGAGTAGTCGATTG\\\nCTTTCCCAATCTCCGAGCGATTTAGCGTGACAGCCCCAGGGAACCCACAAAATGCGATCGCAGTCCACCCGATCGTACA\\\nCAGAAAGGAGGGTCCCCATACGCCGACGCACCTGTTCGCACGTCGTATGCATAAACGAGCCGCACGAACCAGAGAGCAT\\\nAAAGAGGACCTCTAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGCCGGGATGCCTTACCTAGACGCAATGACGGACGT\\\nATTCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAAGCCGCCTTTCCAAAGTGAGTCCT\\\nTCGTCTGTGACTAACTGTGCCAGATCGTCTTGCAAACTCCCGATCCAGTTTAACTCACCAAACTATAGCCGTACAGACC\\\nCAAATCTTAAGTCATATCACGCGACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGTTTTGGTCCGCCCGAGCGGTGCAG\\\nCCGATTAGGACCATCTAATGCACTTGTTACAAGACTTCTTTTAAACACTTTCTTCCTGCCCAGTGGCGGATGATAATGG\\\nTTGTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAATGTGCCGTCTCCACCAACACAGGGCTGTCCGGT\\\nCGTATAATAGGACTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGGACTCGCGATGTACATGCTCTGGT\\\nTCAATACATACGTGACCCGGCAGTTATCCTGCATCGGAACGTCAATCGTGCATCGGGCCAGCGTAATCGTGTCATCTGG\\\nGAGGCGGCCGTAGGATAAATAATTCAATAAAGATGTCGTTTTGCTAGTATACGCCTAGGCGTCACCCGCCATCTCTGTG\\\nCAGGTGGGCCGACGAGACACTGCCCCTGATTTCTCCGCTACTAATAGCACACACGGGGCAATACCAGCACAAGCCAGTC\\\nTCGCGGGAACGCTCGTCAGCATACGAAAGAGCTTGAGGCACGCCAATTCGCACTGTCGGGGTCGCTTGGGTGTTTTGCA\\\nCTACCGTCAGGTACGCTAGTATGCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGGTCAAAAGTGCGGCATTCGTATTT\\\nGCTCCCCGTGCTTGCTCTCACGAACTTGACCTGGAGATCAAGGAGATGCTTCTTGTGGAACCGGACAGCGCATCAACGC\\\nAACGGATCTACGTTACAGCGTGCATAGCGAGAACGGAGTTGCCGACGACGAAAGCGACACTGGGATCTGTCCGTCGTCA\\\nTTCGCGGAAAGCATCCGCTCACGAGGCGGACACTGATTGACACGGTTTTGCAGAAGGTTAGGGGAATAGGTCAAATTGA\\\nGTGGCTTAAAAACGCTATGTCTGGGATTAAAGTGTAGTAAACTGCGGTCAACGGAGACGGTTTTAAGACAGGAGTTCGC\\\nAAAACCAGGCGGGGTCGCCACGACGGCTATTCCTGGTGGTTTAGGCGTACAATGTCCTGAAGAATATTTAAGAAAGAAG\\\nCACCCCTCGTCGCCTAGAATTACCTACCGCGGTCGACCATACCTTCGATTGTCGCGCCCACCCTCCCATTAGTCGGCAG\\\nAGGTGGTTGTGTTGCGATAGCCCAGCATGATATCCTAAGGCGTTACGCCGATGGATATCCCACGGAATTGCCATAGGCG\\\nCTGAACGCTACACGGACGATACGAACTTATGTATGGAGCGGGTCATCGAAAGGTCATACCCTTGTAGTTAACATGTAGC\\\nCCGGCCCTATTAGTACAGCAGTGCCTTGAGCGGCATTCTCATTATTAAGTTTTCTCTACAGCCAAACGACCAAGTGCAC\\\nTTCCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCAGCTCTGTAATAGGGACTAAAAGAGTGATGATAATCATGAGTGC\\\nCGCGTTATGGTGGTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCGAGTTCCGTCCGGTTAAGCGTGAC\\\nACTCCCAGTGTACCCGCAAACCGTGATGGCTGTGCTTGGGGTCAATCGCATGTAGGATGGTCTCCAGACACCGGGGCAC\\\nCAGTTTTCACGCCCAAAGCATAAACGACGAGCAGTCATGAGAGTCTTAGAACTGGACGTGCCGTTTCTCTGCGAACAAC\\\nACCTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTCCTATCACATTTGCCTCGACGACTGCCGCCTTCG\\\nCTGTTTCCCTAGACACTCAACAGTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGTCAGTGGCTGCGCCAAAACGTCTT\\\nCGGATCCCCTTGTCCAATCAAACTGACCGAATTCTTTCATTTAAGACCCTAATATGACATCATTAGTGACTAAATGCCA\\\nCTCCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAACGAATCTAACTATTCCCTGTGCCT\\\nTATGGGGGCCTGCGCTATCTGCCTGTCGAACCATAGGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCG\\\nGGGCCTAAGACCACGAGCGTCTGGCGTCTTGGCTAACCCCCCTACATGCTGTTATAGACAATCAGTGGAAACCCGGTGC\\\nCAGGGGGTGGAGTGACCTTAAGTCAGGGACGATATTAATCGGAAGGAGTATTCAACGCAATGAAGCCGCAGGGTTGGCG\\\nTGGGAATGGTGCTTCTGTCCAAGCAGGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTGCACTTTGCAA\\\nCGATTTCGGAGTCCGGAGACTCGCTGTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTACGCCCAAGAA\\\nCGTAGCAAGGTGACTCAAACAAGGTACATCTTGCCCGCGTTTCACACGAATCAAGTTGGAGGTTATGGAGCATAGTAAC\\\nACGTGGGCGGCCAGTGGTCGGTTGCTACACCCCTGCCGCAACGTTGAAGGTCCCGGATTAGACTGGCTGGACCCATGCC\\\nGTGACACCCGTCACACTCCATTACCGTCTGCGGGTCACGGCTTGTTGTGGACTGGATTGCCATTCTCTCAGTGTATTAC\\\nGCAGGCCGGCGCGCGGGTCCCATGTAAACCTGTCATAGCTTACCTGACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCC\\\nACGCACCTGGTCGGTCCTCGTTTGCTTTTTAGGACCGGATGAACTACAGAGCGCTGCAAGAATCTCTACCTGCTTTACA\\\nAAGCGCTGGGTCCTACTCCAGCGGGATGTTTTATCTAAACACGATGAGAGGAGTATTCGTCAGGCCACATGGCTTTCTT\\\nGTCCTGGTCGGATCCATCGTTGGCGCCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTGCATGCCAGAT\\\nCGGCAGACAGATAGCGGATCCAGTATATCCCTGGAAGCTATAGACGCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTC\\\nCGAACCCAGCTCTACTTTAGTGGCCACGGGTTCTGGTCCCCCCGGGCCGCGGAACCGATTAGGGCCATGTACAACAATA\\\nCTTATTAGTCACCTTTCAGACACGATCTCCCTGCTCAGTGGTATATGGTTCCTGCTATAATTAGCCACCCTCATAAGTT\\\nGCACTACTTCTGCGACCCAAGTGCACCCTTACCACGAAGACAGGATTGTCCGATCCCATACTGCGGCCTTGGCAGGGGG\\\nTTCGCAAGTCCCACCCCAAACGATGCTGAAGGCTCAGGTTACACAGGCACAAGTGCTATATACGCGAGTTCCCGCTCTT\\\nAACCTGGACCGAATGCGGGATCATGCATCGTACCACTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGATACATAGTTC\\\nAATCAAGAATACCTTGTATTATTGTACACCTACCGGTCACCAGCCAACAATGTGCGGACGGCGTTGCGACTTGCTGGGC\\\nCTGATCTCACCGCCCTAGATACCGCACACTGGGCAATACGAGGTAAAGCCAGTCACCCAGTGTCGATCAACAGCTGACG\\\nTAACGGTAAGAGGCTCACAAAATCGCACCGCCGGCGTCCCCTGGGTATTTTACGTCAGCATCGGGTGGACTGGCATGAA\\\nTCTTTACTCCCAGGCGGAAACGGGTGCGTGGACAAGCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGGTGTCTCGTAT\\\nCCCTCTTGGAGATCGAGGAAATGTTTCACGACCAAGGGAAAGGTCGCCCTACGAAATAGATTTGCGCTACTGTCCGCAT\\\nAAGGAGTCCGGTGTAGCGAAGGATGAAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAA\\\nGCAGGCACGGAAAGACACGGTCTAGCAGACCGTCTATCGGCTAGGTCAAATAGGGTGCTTTGATATCAGCATGTCCAGC\\\nCTTAGAATTCAGTTCAGCGCGCTGGTCTGGGTCGAGATAAAATCACCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTG\\\nGCTAATCCTGGTACATCTTGTAATCAATGTTCAGAAGAAAATCTGTGTTAGAGGGACGAGTCACCACGTACCAATAGCG\\\nACAACGATCGGTCGGACTATTCATCGTGGTGGTGACGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAG\\\nGATATAATGCTGAGGCGCTGCCCCAACCGTTCAGCGTGGGGTTTGCTACAACTTCCGAGTGCTACGTGTGCGAGACCAT\\\nGTTATGTATGCACAAGGCCGACAATAGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCACAGTAGATCC\\\nTCCCCGCGCATCCTATTTATTAAGTTAATTCTATAGCAATACGATCACATGCGGATGGGCAGTGGCCGGTAGTCACACG\\\nCCTACCGCGGTGCTCAATGACCGGGACTAGAGAGGCGAAGATTATGGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGA\\\nGCGTCATTGCGAGTAGTCGATTGCTTTCCCAATCTCCGAGCGATTTAGCGTGACAGCCCCAGGGAACCCACAAAATGCG\\\nATCGCAGTCCACCCGATCGTACACAGAAAGGAGGGTCCCCATACGCCGACGCACCTGTTCGCACGTCGTATGCATAAAC\\\nGAGCCGCACGAACCAGAGAGCATAAAGAGGACCTCTAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGCCGGGATGCCT\\\nTACCTAGACGCAATGACGGACGTATTCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAA\\\nGCCGCCTTTCCAAAGTGAGTCCTTCGTCTGTGACTAACTGTGCCAGATCGTCTTGCAAACTCCCGATCCAGTTTAACTC\\\nACCAAACTATAGCCGTACAGACCCAAATCTTAAGTCATATCACGCGACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGT\\\nTTTGGTCCGCCCGAGCGGTGCAGCCGATTAGGACCATCTAATGCACTTGTTACAAGACTTCTTTTAAACACTTTCTTCC\\\nTGCCCAGTGGCGGATGATAATGGTTGTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAATGTGCCGTCT\\\nCCACCAACACAGGGCTGTCCGGTCGTATAATAGGACTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGG\\\nACTCGCGATGTACATGCTCTGGTTCAATACATACGTGACCCGGCAGTTATCCTGCATCGGAACGTCAATCGTGCATCGG\\\nGCCAGCGTAATCGTGTCATCTGGGAGGCGGCCGTAGGATAAATAATTCAATAAAGATGTCGTTTTGCTAGTATACGCCT\\\nAGGCGTCACCCGCCATCTCTGTGCAGGTGGGCCGACGAGACACTGCCCCTGATTTCTCCGCTACTAATAGCACACACGG\\\nGGCAATACCAGCACAAGCCAGTCTCGCGGGAACGCTCGTCAGCATACGAAAGAGCTTGAGGCACGCCAATTCGCACTGT\\\nCGGGGTCGCTTGGGTGTTTTGCACTACCGTCAGGTACGCTAGTATGCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGG\\\nTCAAAAGTGCGGCATTCGTATTTGCTCCCCGTGCTTGCTCTCACGAACTTGACCTGGAGATCAAGGAGATGCTTCTTGT\\\nGGAACCGGACAGCGCATCAACGCAACGGATCTACGTTACAGCGTGCATAGCGAGAACGGAGTTGCCGACGACGAAAGCG\\\nACACTGGGATCTGTCCGTCGTCATTCGCGGAAAGCATCCGCTCACGAGGCGGACACTGATTGACACGGTTTTGCAGAAG\\\nGTTAGGGGAATAGGTCAAATTGAGTGGCTTAAAAACGCTATGTCTGGGATTAAAGTGTAGTAAACTGCGGTCAACGGAG\\\nACGGTTTTAAGACAGGAGTTCGCAAAACCAGGCGGGGTCGCCACGACGGCTATTCCTGGTGGTTTAGGCGTACAATGTC\\\nCTGAAGAATATTTAAGAAAGAAGCACCCCTCGTCGCCTAGAATTACCTACCGCGGTCGACCATACCTTCGATTGTCGCG\\\nCCCACCCTCCCATTAGTCGGCAGAGGTGGTTGTGTTGCGATAGCCCAGCATGATATCCTAAGGCGTTACGCCGATGGAT\\\nATCCCACGGAATTGCCATAGGCGCTGAACGCTACACGGACGATACGAACTTATGTATGGAGCGGGTCATCGAAAGGTCA\\\nTACCCTTGTAGTTAACATGTAGCCCGGCCCTATTAGTACAGCAGTGCCTTGAGCGGCATTCTCATTATTAAGTTTTCTC\\\nTACAGCCAAACGACCAAGTGCACTTCCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCAGCTCTGTAATAGGGACTAAA\\\nAGAGTGATGATAATCATGAGTGCCGCGTTATGGTGGTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCG\\\nAGTTCCGTCCGGTTAAGCGTGACACTCCCAGTGTACCCGCAAACCGTGATGGCTGTGCTTGGGGTCAATCGCATGTAGG\\\nATGGTCTCCAGACACCGGGGCACCAGTTTTCACGCCCAAAGCATAAACGACGAGCAGTCATGAGAGTCTTAGAACTGGA\\\nCGTGCCGTTTCTCTGCGAACAACACCTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTCCTATCACATT\\\nTGCCTCGACGACTGCCGCCTTCGCTGTTTCCCTAGACACTCAACAGTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGT\\\nCAGTGGCTGCGCCAAAACGTCTTCGGATCCCCTTGTCCAATCAAACTGACCGAATTCTTTCATTTAAGACCCTAATATG\\\nACATCATTAGTGACTAAATGCCACTCCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAAC\\\nGA\";\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","benches","interval_tree.rs"],"content":"#![feature(test)]\n\nextern crate test;\n\nuse test::Bencher;\n\nuse bio::data_structures::interval_tree::*;\nuse bio::utils::Interval;\nuse std::cmp::{max, min};\nuse std::ops::Range;\n\n#[bench]\nfn bench_interval_few_large_queries(b: \u0026mut Bencher) {\n    // insert 100_000 intervals of size 10\n    // do 1000 queries, each resulting in 1000 matches\n    b.iter(|| test_insert_query(10, \u0026(100_000..200_000), 1000, 105_000..106_000));\n}\n\n#[bench]\nfn bench_interval_many_small_queries(b: \u0026mut Bencher) {\n    // insert 100_000 intervals of size 10\n    // do 100_000 queries, each resulting in at most 10 matches\n    b.iter(|| test_insert_query(10, \u0026(100_000..200_000), 10, 99_995..199_995));\n}\n\nfn test_insert_query(\n    insert_size: i64,\n    insert_bounds: \u0026Range\u003ci64\u003e,\n    query_size: i64,\n    query_bounds: Range\u003ci64\u003e,\n) {\n    let mut tree: IntervalTree\u003ci64, Range\u003ci64\u003e\u003e = IntervalTree::new();\n\n    for i in insert_bounds.clone() {\n        tree.insert(i..i + insert_size, i..i + insert_size);\n    }\n    for i in query_bounds {\n        let lower_bound = i;\n        let upper_bound = i + query_size;\n        let smallest_start = max(lower_bound - insert_size + 1, insert_bounds.start);\n        let largest_start = min(upper_bound, insert_bounds.end);\n        let mut expected_intersections = vec![];\n        for j in smallest_start..largest_start {\n            expected_intersections.push(j..j + insert_size);\n        }\n        assert_intersections(\u0026tree, lower_bound..upper_bound, \u0026expected_intersections);\n    }\n}\n\nfn assert_intersections(\n    tree: \u0026IntervalTree\u003ci64, Range\u003ci64\u003e\u003e,\n    target: Range\u003ci64\u003e,\n    expected_results: \u0026[Range\u003ci64\u003e],\n) {\n    let mut actual_entries: Vec\u003c_\u003e = tree.find(target).collect();\n    actual_entries.sort_by(|x1, x2| x1.data().start.cmp(\u0026x2.data().start));\n    let mut expected_entries: Vec\u003c_\u003e = expected_results\n        .iter()\n        .map(|x| (x.clone(), Interval::from(x.clone())))\n        .collect();\n    expected_entries.sort_by(|x1, x2| x1.0.start.cmp(\u0026x2.0.start));\n    assert_eq!(actual_entries.len(), expected_entries.len());\n    for (actual, expected) in actual_entries.iter().zip(expected_entries.iter()) {\n        assert_eq!(actual.interval(), \u0026expected.1);\n        assert_eq!(actual.data(), \u0026expected.0);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","benches","orf.rs"],"content":"#![feature(test)]\n\nextern crate test;\n\nuse test::Bencher;\n\nuse bio::seq_analysis::gc::*;\nuse bio::seq_analysis::orf::Finder;\n\n// 5,000 random nucleotides, GC content = .55\nstatic STR_1: \u0026'static [u8] = b\"ATCTAACTATTCCCTGTGCCTTATGGGGGCCTGCGCTATCTGCCTGT\\\nCGAACCATAGGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCGGGGCCTAAGACCACGAGCGTCTGGCG\\\nTCTTGGCTAACCCCCCTACATGCTGTTATAGACAATCAGTGGAAACCCGGTGCCAGGGGGTGGAGTGACCTTAAGTCAG\\\nGGACGATATTAATCGGAAGGAGTATTCAACGCAATGAAGCCGCAGGGTTGGCGTGGGAATGGTGCTTCTGTCCAAGCAG\\\nGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTGCACTTTGCAACGATTTCGGAGTCCGGAGACTCGCTG\\\nTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTACGCCCAAGAACGTAGCAAGGTGACTCAAACAAGGTA\\\nCATCTTGCCCGCGTTTCACACGAATCAAGTTGGAGGTTATGGAGCATAGTAACACGTGGGCGGCCAGTGGTCGGTTGCT\\\nACACCCCTGCCGCAACGTTGAAGGTCCCGGATTAGACTGGCTGGACCCATGCCGTGACACCCGTCACACTCCATTACCG\\\nTCTGCGGGTCACGGCTTGTTGTGGACTGGATTGCCATTCTCTCAGTGTATTACGCAGGCCGGCGCGCGGGTCCCATGTA\\\nAACCTGTCATAGCTTACCTGACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCCACGCACCTGGTCGGTCCTCGTTTGCT\\\nTTTTAGGACCGGATGAACTACAGAGCGCTGCAAGAATCTCTACCTGCTTTACAAAGCGCTGGGTCCTACTCCAGCGGGA\\\nTGTTTTATCTAAACACGATGAGAGGAGTATTCGTCAGGCCACATGGCTTTCTTGTCCTGGTCGGATCCATCGTTGGCGC\\\nCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTGCATGCCAGATCGGCAGACAGATAGCGGATCCAGTAT\\\nATCCCTGGAAGCTATAGACGCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTCCGAACCCAGCTCTACTTTAGTGGCCA\\\nCGGGTTCTGGTCCCCCCGGGCCGCGGAACCGATTAGGGCCATGTACAACAATACTTATTAGTCACCTTTCAGACACGAT\\\nCTCCCTGCTCAGTGGTATATGGTTCCTGCTATAATTAGCCACCCTCATAAGTTGCACTACTTCTGCGACCCAAGTGCAC\\\nCCTTACCACGAAGACAGGATTGTCCGATCCCATACTGCGGCCTTGGCAGGGGGTTCGCAAGTCCCACCCCAAACGATGC\\\nTGAAGGCTCAGGTTACACAGGCACAAGTGCTATATACGCGAGTTCCCGCTCTTAACCTGGACCGAATGCGGGATCATGC\\\nATCGTACCACTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGATACATAGTTCAATCAAGAATACCTTGTATTATTGTA\\\nCACCTACCGGTCACCAGCCAACAATGTGCGGACGGCGTTGCGACTTGCTGGGCCTGATCTCACCGCCCTAGATACCGCA\\\nCACTGGGCAATACGAGGTAAAGCCAGTCACCCAGTGTCGATCAACAGCTGACGTAACGGTAAGAGGCTCACAAAATCGC\\\nACCGCCGGCGTCCCCTGGGTATTTTACGTCAGCATCGGGTGGACTGGCATGAATCTTTACTCCCAGGCGGAAACGGGTG\\\nCGTGGACAAGCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGGTGTCTCGTATCCCTCTTGGAGATCGAGGAAATGTTT\\\nCACGACCAAGGGAAAGGTCGCCCTACGAAATAGATTTGCGCTACTGTCCGCATAAGGAGTCCGGTGTAGCGAAGGATGA\\\nAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAAGCAGGCACGGAAAGACACGGTCTAGC\\\nAGACCGTCTATCGGCTAGGTCAAATAGGGTGCTTTGATATCAGCATGTCCAGCCTTAGAATTCAGTTCAGCGCGCTGGT\\\nCTGGGTCGAGATAAAATCACCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTGGCTAATCCTGGTACATCTTGTAATCA\\\nATGTTCAGAAGAAAATCTGTGTTAGAGGGACGAGTCACCACGTACCAATAGCGACAACGATCGGTCGGACTATTCATCG\\\nTGGTGGTGACGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAGGATATAATGCTGAGGCGCTGCCCCAA\\\nCCGTTCAGCGTGGGGTTTGCTACAACTTCCGAGTGCTACGTGTGCGAGACCATGTTATGTATGCACAAGGCCGACAATA\\\nGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCACAGTAGATCCTCCCCGCGCATCCTATTTATTAAGTT\\\nAATTCTATAGCAATACGATCACATGCGGATGGGCAGTGGCCGGTAGTCACACGCCTACCGCGGTGCTCAATGACCGGGA\\\nCTAGAGAGGCGAAGATTATGGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGAGCGTCATTGCGAGTAGTCGATTGCTT\\\nTCCCAATCTCCGAGCGATTTAGCGTGACAGCCCCAGGGAACCCACAAAATGCGATCGCAGTCCACCCGATCGTACACAG\\\nAAAGGAGGGTCCCCATACGCCGACGCACCTGTTCGCACGTCGTATGCATAAACGAGCCGCACGAACCAGAGAGCATAAA\\\nGAGGACCTCTAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGCCGGGATGCCTTACCTAGACGCAATGACGGACGTATT\\\nCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAAGCCGCCTTTCCAAAGTGAGTCCTTCG\\\nTCTGTGACTAACTGTGCCAGATCGTCTTGCAAACTCCCGATCCAGTTTAACTCACCAAACTATAGCCGTACAGACCCAA\\\nATCTTAAGTCATATCACGCGACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGTTTTGGTCCGCCCGAGCGGTGCAGCCG\\\nATTAGGACCATCTAATGCACTTGTTACAAGACTTCTTTTAAACACTTTCTTCCTGCCCAGTGGCGGATGATAATGGTTG\\\nTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAATGTGCCGTCTCCACCAACACAGGGCTGTCCGGTCGT\\\nATAATAGGACTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGGACTCGCGATGTACATGCTCTGGTTCA\\\nATACATACGTGACCCGGCAGTTATCCTGCATCGGAACGTCAATCGTGCATCGGGCCAGCGTAATCGTGTCATCTGGGAG\\\nGCGGCCGTAGGATAAATAATTCAATAAAGATGTCGTTTTGCTAGTATACGCCTAGGCGTCACCCGCCATCTCTGTGCAG\\\nGTGGGCCGACGAGACACTGCCCCTGATTTCTCCGCTACTAATAGCACACACGGGGCAATACCAGCACAAGCCAGTCTCG\\\nCGGGAACGCTCGTCAGCATACGAAAGAGCTTGAGGCACGCCAATTCGCACTGTCGGGGTCGCTTGGGTGTTTTGCACTA\\\nCCGTCAGGTACGCTAGTATGCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGGTCAAAAGTGCGGCATTCGTATTTGCT\\\nCCCCGTGCTTGCTCTCACGAACTTGACCTGGAGATCAAGGAGATGCTTCTTGTGGAACCGGACAGCGCATCAACGCAAC\\\nGGATCTACGTTACAGCGTGCATAGCGAGAACGGAGTTGCCGACGACGAAAGCGACACTGGGATCTGTCCGTCGTCATTC\\\nGCGGAAAGCATCCGCTCACGAGGCGGACACTGATTGACACGGTTTTGCAGAAGGTTAGGGGAATAGGTCAAATTGAGTG\\\nGCTTAAAAACGCTATGTCTGGGATTAAAGTGTAGTAAACTGCGGTCAACGGAGACGGTTTTAAGACAGGAGTTCGCAAA\\\nACCAGGCGGGGTCGCCACGACGGCTATTCCTGGTGGTTTAGGCGTACAATGTCCTGAAGAATATTTAAGAAAGAAGCAC\\\nCCCTCGTCGCCTAGAATTACCTACCGCGGTCGACCATACCTTCGATTGTCGCGCCCACCCTCCCATTAGTCGGCAGAGG\\\nTGGTTGTGTTGCGATAGCCCAGCATGATATCCTAAGGCGTTACGCCGATGGATATCCCACGGAATTGCCATAGGCGCTG\\\nAACGCTACACGGACGATACGAACTTATGTATGGAGCGGGTCATCGAAAGGTCATACCCTTGTAGTTAACATGTAGCCCG\\\nGCCCTATTAGTACAGCAGTGCCTTGAGCGGCATTCTCATTATTAAGTTTTCTCTACAGCCAAACGACCAAGTGCACTTC\\\nCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCAGCTCTGTAATAGGGACTAAAAGAGTGATGATAATCATGAGTGCCGC\\\nGTTATGGTGGTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCGAGTTCCGTCCGGTTAAGCGTGACACT\\\nCCCAGTGTACCCGCAAACCGTGATGGCTGTGCTTGGGGTCAATCGCATGTAGGATGGTCTCCAGACACCGGGGCACCAG\\\nTTTTCACGCCCAAAGCATAAACGACGAGCAGTCATGAGAGTCTTAGAACTGGACGTGCCGTTTCTCTGCGAACAACACC\\\nTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTCCTATCACATTTGCCTCGACGACTGCCGCCTTCGCTG\\\nTTTCCCTAGACACTCAACAGTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGTCAGTGGCTGCGCCAAAACGTCTTCGG\\\nATCCCCTTGTCCAATCAAACTGACCGAATTCTTTCATTTAAGACCCTAATATGACATCATTAGTGACTAAATGCCACTC\\\nCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAACGA\";\n\n#[bench]\nfn bench_orf(b: \u0026mut Bencher) {\n    let start_codons = vec![b\"ATG\"];\n    let stop_codons = vec![b\"TGA\", b\"TAG\", b\"TAA\"];\n    let finder = Finder::new(start_codons, stop_codons, 100usize);\n    b.iter(|| finder.find_all(STR_1).count());\n}\n\n#[bench]\nfn bench_gc(b: \u0026mut Bencher) {\n    b.iter(|| gc_content(STR_1));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","benches","pairhmm.rs"],"content":"#![feature(test)]\n\nextern crate test;\n\nuse bio::stats::pairhmm::*;\nuse bio::stats::{LogProb, Prob};\nuse test::Bencher;\n\nstatic TEXT: \u0026'static [u8] = b\"GATCACAGGTCTATCACCCTATTAACCACTCACGGGAGCTCTCCATGC\\\nATTTGGTATTTTCGTCTGGGGGGTATGCACGCGATAGCATTGCGAGACGCTGGAGCCGGAGCACCCTATGTCGCAGTAT\\\nCTGTCTTTGATTCCTGCCTCATCCTATTATTTATCGCACCTACGTTCAATATTACAGGCGAACATACTTACTAAAGTGT\";\n\nstatic PATTERN: \u0026'static [u8] = b\"GGGTATGCACGCGATAGCATTGCGAGACGCTGGAGCCGGAGCACCCTATGTCGC\";\n\n// Single base insertion and deletion rates for R1 according to Schirmer et al.\n// BMC Bioinformatics 2016, 10.1186/s12859-016-0976-y\nstatic PROB_ILLUMINA_INS: Prob = Prob(2.8e-6);\nstatic PROB_ILLUMINA_DEL: Prob = Prob(5.1e-6);\nstatic PROB_ILLUMINA_SUBST: Prob = Prob(0.0021);\n\nfn prob_emit_x_or_y() -\u003e LogProb {\n    LogProb::from(Prob(1.0) - PROB_ILLUMINA_SUBST)\n}\n\npub struct TestEmissionParams {\n    x: \u0026'static [u8],\n    y: \u0026'static [u8],\n}\n\nimpl EmissionParameters for TestEmissionParams {\n    fn prob_emit_xy(\u0026self, i: usize, j: usize) -\u003e XYEmission {\n        if self.x[i] == self.y[j] {\n            XYEmission::Match(LogProb::from(Prob(1.0) - PROB_ILLUMINA_SUBST))\n        } else {\n            XYEmission::Mismatch(LogProb::from(PROB_ILLUMINA_SUBST / Prob(3.0)))\n        }\n    }\n\n    fn prob_emit_x(\u0026self, _: usize) -\u003e LogProb {\n        prob_emit_x_or_y()\n    }\n\n    fn prob_emit_y(\u0026self, _: usize) -\u003e LogProb {\n        prob_emit_x_or_y()\n    }\n\n    fn len_x(\u0026self) -\u003e usize {\n        self.x.len()\n    }\n\n    fn len_y(\u0026self) -\u003e usize {\n        self.y.len()\n    }\n}\n\npub struct SemiglobalGapParams;\n\nimpl GapParameters for SemiglobalGapParams {\n    fn prob_gap_x(\u0026self) -\u003e LogProb {\n        LogProb::from(PROB_ILLUMINA_INS)\n    }\n\n    fn prob_gap_y(\u0026self) -\u003e LogProb {\n        LogProb::from(PROB_ILLUMINA_DEL)\n    }\n\n    fn prob_gap_x_extend(\u0026self) -\u003e LogProb {\n        LogProb::ln_zero()\n    }\n\n    fn prob_gap_y_extend(\u0026self) -\u003e LogProb {\n        LogProb::ln_zero()\n    }\n}\n\npub struct SemiglobalAlignment;\n\nimpl StartEndGapParameters for SemiglobalAlignment {\n    fn free_start_gap_x(\u0026self) -\u003e bool {\n        true\n    }\n\n    fn free_end_gap_x(\u0026self) -\u003e bool {\n        true\n    }\n}\n\n#[bench]\nfn pairhmm_semiglobal(b: \u0026mut Bencher) {\n    let emission_params = TestEmissionParams {\n        x: TEXT,\n        y: PATTERN,\n    };\n    let gap_params = SemiglobalGapParams;\n\n    let mut pair_hmm = PairHMM::new(\u0026gap_params);\n    pair_hmm.prob_related(\u0026emission_params, \u0026SemiglobalAlignment, Some(4));\n\n    b.iter(|| {\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026SemiglobalAlignment, Some(4));\n        assert!(*p \u003c= 0.0);\n    });\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","home","todd","rust-bio","benches","pairwise.rs"],"content":"#![feature(test)]\n\nextern crate test;\n\nuse bio::alignment::pairwise::*;\nuse test::Bencher;\n\n// 5,000 random nucleotides, GC content = .55\nstatic STR_1: \u0026'static [u8] = b\"ATCTAACTATTCCCTGTGCCTTATGGGGGCCTGCGCTATCTGCCTGT\\\nCGAACCATAGGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCGGGGCCTAAGACCACGAGCGTCTGGCG\\\nTCTTGGCTAACCCCCCTACATGCTGTTATAGACAATCAGTGGAAACCCGGTGCCAGGGGGTGGAGTGACCTTAAGTCAG\\\nGGACGATATTAATCGGAAGGAGTATTCAACGCAATGAAGCCGCAGGGTTGGCGTGGGAATGGTGCTTCTGTCCAAGCAG\\\nGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTGCACTTTGCAACGATTTCGGAGTCCGGAGACTCGCTG\\\nTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTACGCCCAAGAACGTAGCAAGGTGACTCAAACAAGGTA\\\nCATCTTGCCCGCGTTTCACACGAATCAAGTTGGAGGTTATGGAGCATAGTAACACGTGGGCGGCCAGTGGTCGGTTGCT\\\nACACCCCTGCCGCAACGTTGAAGGTCCCGGATTAGACTGGCTGGACCCATGCCGTGACACCCGTCACACTCCATTACCG\\\nTCTGCGGGTCACGGCTTGTTGTGGACTGGATTGCCATTCTCTCAGTGTATTACGCAGGCCGGCGCGCGGGTCCCATGTA\\\nAACCTGTCATAGCTTACCTGACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCCACGCACCTGGTCGGTCCTCGTTTGCT\\\nTTTTAGGACCGGATGAACTACAGAGCGCTGCAAGAATCTCTACCTGCTTTACAAAGCGCTGGGTCCTACTCCAGCGGGA\\\nTGTTTTATCTAAACACGATGAGAGGAGTATTCGTCAGGCCACATGGCTTTCTTGTCCTGGTCGGATCCATCGTTGGCGC\\\nCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTGCATGCCAGATCGGCAGACAGATAGCGGATCCAGTAT\\\nATCCCTGGAAGCTATAGACGCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTCCGAACCCAGCTCTACTTTAGTGGCCA\\\nCGGGTTCTGGTCCCCCCGGGCCGCGGAACCGATTAGGGCCATGTACAACAATACTTATTAGTCACCTTTCAGACACGAT\\\nCTCCCTGCTCAGTGGTATATGGTTCCTGCTATAATTAGCCACCCTCATAAGTTGCACTACTTCTGCGACCCAAGTGCAC\\\nCCTTACCACGAAGACAGGATTGTCCGATCCCATACTGCGGCCTTGGCAGGGGGTTCGCAAGTCCCACCCCAAACGATGC\\\nTGAAGGCTCAGGTTACACAGGCACAAGTGCTATATACGCGAGTTCCCGCTCTTAACCTGGACCGAATGCGGGATCATGC\\\nATCGTACCACTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGATACATAGTTCAATCAAGAATACCTTGTATTATTGTA\\\nCACCTACCGGTCACCAGCCAACAATGTGCGGACGGCGTTGCGACTTGCTGGGCCTGATCTCACCGCCCTAGATACCGCA\\\nCACTGGGCAATACGAGGTAAAGCCAGTCACCCAGTGTCGATCAACAGCTGACGTAACGGTAAGAGGCTCACAAAATCGC\\\nACCGCCGGCGTCCCCTGGGTATTTTACGTCAGCATCGGGTGGACTGGCATGAATCTTTACTCCCAGGCGGAAACGGGTG\\\nCGTGGACAAGCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGGTGTCTCGTATCCCTCTTGGAGATCGAGGAAATGTTT\\\nCACGACCAAGGGAAAGGTCGCCCTACGAAATAGATTTGCGCTACTGTCCGCATAAGGAGTCCGGTGTAGCGAAGGATGA\\\nAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAAGCAGGCACGGAAAGACACGGTCTAGC\\\nAGACCGTCTATCGGCTAGGTCAAATAGGGTGCTTTGATATCAGCATGTCCAGCCTTAGAATTCAGTTCAGCGCGCTGGT\\\nCTGGGTCGAGATAAAATCACCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTGGCTAATCCTGGTACATCTTGTAATCA\\\nATGTTCAGAAGAAAATCTGTGTTAGAGGGACGAGTCACCACGTACCAATAGCGACAACGATCGGTCGGACTATTCATCG\\\nTGGTGGTGACGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAGGATATAATGCTGAGGCGCTGCCCCAA\\\nCCGTTCAGCGTGGGGTTTGCTACAACTTCCGAGTGCTACGTGTGCGAGACCATGTTATGTATGCACAAGGCCGACAATA\\\nGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCACAGTAGATCCTCCCCGCGCATCCTATTTATTAAGTT\\\nAATTCTATAGCAATACGATCACATGCGGATGGGCAGTGGCCGGTAGTCACACGCCTACCGCGGTGCTCAATGACCGGGA\\\nCTAGAGAGGCGAAGATTATGGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGAGCGTCATTGCGAGTAGTCGATTGCTT\\\nTCCCAATCTCCGAGCGATTTAGCGTGACAGCCCCAGGGAACCCACAAAATGCGATCGCAGTCCACCCGATCGTACACAG\\\nAAAGGAGGGTCCCCATACGCCGACGCACCTGTTCGCACGTCGTATGCATAAACGAGCCGCACGAACCAGAGAGCATAAA\\\nGAGGACCTCTAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGCCGGGATGCCTTACCTAGACGCAATGACGGACGTATT\\\nCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAAGCCGCCTTTCCAAAGTGAGTCCTTCG\\\nTCTGTGACTAACTGTGCCAGATCGTCTTGCAAACTCCCGATCCAGTTTAACTCACCAAACTATAGCCGTACAGACCCAA\\\nATCTTAAGTCATATCACGCGACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGTTTTGGTCCGCCCGAGCGGTGCAGCCG\\\nATTAGGACCATCTAATGCACTTGTTACAAGACTTCTTTTAAACACTTTCTTCCTGCCCAGTGGCGGATGATAATGGTTG\\\nTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAATGTGCCGTCTCCACCAACACAGGGCTGTCCGGTCGT\\\nATAATAGGACTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGGACTCGCGATGTACATGCTCTGGTTCA\\\nATACATACGTGACCCGGCAGTTATCCTGCATCGGAACGTCAATCGTGCATCGGGCCAGCGTAATCGTGTCATCTGGGAG\\\nGCGGCCGTAGGATAAATAATTCAATAAAGATGTCGTTTTGCTAGTATACGCCTAGGCGTCACCCGCCATCTCTGTGCAG\\\nGTGGGCCGACGAGACACTGCCCCTGATTTCTCCGCTACTAATAGCACACACGGGGCAATACCAGCACAAGCCAGTCTCG\\\nCGGGAACGCTCGTCAGCATACGAAAGAGCTTGAGGCACGCCAATTCGCACTGTCGGGGTCGCTTGGGTGTTTTGCACTA\\\nCCGTCAGGTACGCTAGTATGCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGGTCAAAAGTGCGGCATTCGTATTTGCT\\\nCCCCGTGCTTGCTCTCACGAACTTGACCTGGAGATCAAGGAGATGCTTCTTGTGGAACCGGACAGCGCATCAACGCAAC\\\nGGATCTACGTTACAGCGTGCATAGCGAGAACGGAGTTGCCGACGACGAAAGCGACACTGGGATCTGTCCGTCGTCATTC\\\nGCGGAAAGCATCCGCTCACGAGGCGGACACTGATTGACACGGTTTTGCAGAAGGTTAGGGGAATAGGTCAAATTGAGTG\\\nGCTTAAAAACGCTATGTCTGGGATTAAAGTGTAGTAAACTGCGGTCAACGGAGACGGTTTTAAGACAGGAGTTCGCAAA\\\nACCAGGCGGGGTCGCCACGACGGCTATTCCTGGTGGTTTAGGCGTACAATGTCCTGAAGAATATTTAAGAAAGAAGCAC\\\nCCCTCGTCGCCTAGAATTACCTACCGCGGTCGACCATACCTTCGATTGTCGCGCCCACCCTCCCATTAGTCGGCAGAGG\\\nTGGTTGTGTTGCGATAGCCCAGCATGATATCCTAAGGCGTTACGCCGATGGATATCCCACGGAATTGCCATAGGCGCTG\\\nAACGCTACACGGACGATACGAACTTATGTATGGAGCGGGTCATCGAAAGGTCATACCCTTGTAGTTAACATGTAGCCCG\\\nGCCCTATTAGTACAGCAGTGCCTTGAGCGGCATTCTCATTATTAAGTTTTCTCTACAGCCAAACGACCAAGTGCACTTC\\\nCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCAGCTCTGTAATAGGGACTAAAAGAGTGATGATAATCATGAGTGCCGC\\\nGTTATGGTGGTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCGAGTTCCGTCCGGTTAAGCGTGACACT\\\nCCCAGTGTACCCGCAAACCGTGATGGCTGTGCTTGGGGTCAATCGCATGTAGGATGGTCTCCAGACACCGGGGCACCAG\\\nTTTTCACGCCCAAAGCATAAACGACGAGCAGTCATGAGAGTCTTAGAACTGGACGTGCCGTTTCTCTGCGAACAACACC\\\nTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTCCTATCACATTTGCCTCGACGACTGCCGCCTTCGCTG\\\nTTTCCCTAGACACTCAACAGTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGTCAGTGGCTGCGCCAAAACGTCTTCGG\\\nATCCCCTTGTCCAATCAAACTGACCGAATTCTTTCATTTAAGACCCTAATATGACATCATTAGTGACTAAATGCCACTC\\\nCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAACGA\";\n\n// 5,000 random nucleotides, GC content = .45\nstatic STR_2: \u0026'static [u8] = b\"CTAAAGTGGCGAAATTTATGGTGTGTGACCCGTTATGCTCCATTTCG\\\nGTCAGTGGGTCATTGCTAGTAGTCGATTGCATTGTCATTCTCCGAGTGATTTAGCGTGACAGCCGCAGGGAACCCATAA\\\nAATGTAATCGTAGTCCATCTGATCGTACTTAGAAATGAAGGTCCCCTTTTACCCACGCACCTGTTTACTCGTCGTTTGC\\\nTTTTAAGAACCGCACGAACCACAGAGCATAAAGAGAACCTCTAGTTCCTTTACAAAGTACTGGTTCCCTTTTCAGCAAG\\\nATGCCTTATCTAAATGCAATGACAGACGTATTCCTCAGGCCACATCGCTTCCTACTTTCGCTGGGATCCATCATTGGCA\\\nGCTGAAACCGCCATTCCATAGTGAGTCCTTCGTCTGTGTCTTTCTGTGCCAAATCGTCTAGCAAATTGCTGATCCAGTT\\\nTATCTCACGAAATTATAGTCATACAGACCGAAATTTTAAATCAAATCACGCGACTAGGCTCAGCTTTATTTTAGTGGTC\\\nATGGGTTTTGGTCCGCCCGAGCGGTGCAACCGATTAGGACCATGTAAAACATTTGTTACAAGTCTTCTTTTAAATACAA\\\nTCTTCCTGCTCAGTAGCGCATGATTATCGTTGTTGCTAGCCAGTGTGGTAAGTAACAGCACCACTGCGAGCCTAATGTG\\\nCCCTTTCCACGAACACAAGGCTATCCGATCCTATATTAGGATTCCGCAATGGGGTTAGCAAATCGCACCCTAAACGATA\\\nTTGAAGACTTGCGATGTACATGCTTTGGTACAATACATACGTGTTCCAGTTGTTATCCTGTATCGGAACTTCAATTATG\\\nCATCGCACCAGCATATTCATGTCATCTAGGAAGAGCGCGTAGGATAAATAATTCAATTAAGATGTCGTTATGCTAGTAT\\\nACGTCTACCCGTCACCGGCCATCTGTGTGCAGATGGGGCGACGAGTTATTGACCCTGATTTCTCCACTTCTAATACCAC\\\nACACTGGGCAATACGAGCTCAAGCTAGTCTCGCAGTAACGCTCATCAGCTAACGAAAGAGTTAAAGGCTCGCTAATTCG\\\nCACTGTCAGGGTCTCTTGGGTGTTTTGCACTAGCGTCAGGTAGGCTAGTATGTGTTTTTCCTTCCAGAGGTATGTGGCT\\\nGCGTGGTCAAATGTGCAGCATACGTATTTGCTCGACGTGTTTAGTCTCTCATACTTCTCCTGGAGATCAAGGAAATGTT\\\nTCTTGTCCAAGTGGACAACGGTTCTACGGAATGGATCTACGTTACTGCCTGCATAAAGAAAACGGAGTTGCTAAGGACG\\\nAAAGCGACTTTAGGTTCTAACTGTTGACTTTGGCGGAAAAGTTTCATTCAGGAAGCAGACACTGATTGACACGGTTTAG\\\nCAGAACGTTTGAGGATTAGGTTAAATTGAGTGGTTTAATATTGGTATGTCTGGGATTAAAATATAGTATAGTGTGTTAA\\\nTCGGAGACGAATTAAAGACACGAGTTCCCAAAATCAAGCGGGCTCATTACAACGGTTAATCCTGGTAGTTTACGTGAAC\\\nAATGTTCTGAAGAAAATTTATGAAAAAAGGACCCGTCATCGCCTACAATTACCTACAACGGTCGACCATACCTTCGATT\\\nATCGTGGCCACTCTCGGATTACACGGCAGAGGTGGTTGTGTTCCGATAGGCCAGTATATTATTCTAAGGCGTTACCCTA\\\nATCATTTTTCATCGGATTTGCTATAGCCCTTGAACGCTACATGCACGAAACCAAATTATGTATACACTGGGTCATCAAT\\\nAGGATATAGTCTTGTAGTTAACATGTAGCCCGGCCGTATTAGTACAGTAGAGCCTTCATTGACATTCTGTTTATTAAAT\\\nTATTTCTACAGCAAAACGATCATATGCAAATCCACAGTGCGCGATAGAGATACATTCACTCGGCTGCTCTGTAATAGGG\\\nACTAAAAAAGTGATGATTATCATGAGTGCCCCGTTATGGTCGTGTTCGATCAGAGCGCTCTTACGAGCAGTCGTATACT\\\nTTCTCGAATTCCGTGCAGTTAAGCGTGACAGTCCCAGTGAACCCACAAAACGTGATGGCAGTCCATGCAATCATACGCA\\\nAGAAGGATGGTCTCCAGACACCGGCGCACCAGTTTTCACGCCGAAAGCATAAACGAGGAGCACAAATGAAAGTGTTTGA\\\nACTGGACCTGTAGTTTCTCTACGAAAAATACCTTGAGCTGTTGCGTTGTTGCGCTGCCTAGATGCAGTGTTGCACATAT\\\nCACTTTTGCTTCAACGACTGCTGCTTTCGCTGTAACCCTAGACAGACAACAATAAGCGCTTTTTGTAGGCAAGAGCTCC\\\nGCCTATGACTAACTGCGCCAAAACATCTTCCAATCCCCTTATCCAATTTAATTCATCGAATTCTTACAATTTAGACCCT\\\nAATATCACATCATTAGACATTAATTGCCTCTGCCAAAATTCTGTCTACAAATGTTTTAGTTCGCTCCAGTAAAGTTGTT\\\nAATAACGACTACTAAATCCGCATGTTACGGGATTTCTTATTAATTCTTTTTTCGTAAGGAACAGCGGATCTTAATGGAT\\\nGGCGCCAGGTGGTATGGAAGCTAATAGCGCGGGTGAGAGGGTAATTAGCCGTCTTCACCAACACAACGCTATCGGGTCA\\\nTACTATAAGATTCCACAATGCGACTACTTATAAGATGTCTTAACGGTATCCGCAACTTGTGATGTGCCTACTATGCTTA\\\nAATGCATATCTCGCTCAGTAACTTTCCAATATGAGAGCATCAATTGTAGATCGGGCCGAGATAATCATGTCGTCACGGA\\\nACTTATTGTAAGAGTAATAATTTAAAAGAGATGTCAGTTTGCTGGTTCACGTAAAGGTTCCTCACACTACCTCTAAATA\\\nAGTGAGCGGTCGTGACATTATCCCTGATTTTCTCACTACTATTAGTACTCACGACACAATTCTACCACAGCCTTGTTTC\\\nGCCAGAATGCCAGTCAGCATAAAGAAGAGCTCAAGGCAGGTCAACTCGCATTGTGAGAGTTACATGAACGTTCGGCACT\\\nACCGACACGAACCTCAGTTAGCGTACATCCTACCAGAGGTCTGTGGCCCCGTGGTCAAAAGTGCGGATTTCGTATTTGC\\\nTGCTCGTCAGTACTTTCAGAATCATGACCTGCACGGTAAAAAGACGCTTATTATGGAGTTCGACATGGCAATAACGCGA\\\nCGAATCTACGTCATGACGAGAATAGTATAAACAAAACTGCTGACGGCAGAAGCGTCAAAGAAGTCTGTAAATTGTTATT\\\nCGCGAAAAACATCCGTCTCCGTGGGGGATAATCACCGACGCCATTTTATAGAAGCCTAGGGGAACAGATTGGTTTAATT\\\nAGCTTAAGAAAGTAAATTCTGGGATTATACTGTAGTAATCACTAATTTACGGTGAGGGTTTTATGGCGGATTTTTACAA\\\nATTCAAACCAGGTGATTTCAACAAATTTTGTTGACGATTTAGGCGCACTATCCCCTAAACTACAAATTAAAAAATAGCG\\\nTTCCTTGACGGCTAGAATTACTTACCGGCCTTCACCATACCTTCGATATTCGCGCCCACTCTCCCATTAATCCGTACAA\\\nGTGGATGTAATGCGATTGTCCGCTAAGATATTCTAACGTGTAACGTAGATAAGTATTTTACAGAGTTGCCGTACGCGTT\\\nGAACACTTCACAGATGATAGGAATTTGCGTATAGAGCGTGTTATTGAGGAGTTATACACCCGTAGACTACAATGGGCCC\\\nAACTCAATCAGAACTCGAGTGCCTTGAATAACATACTCATCACTAAACATTCTCAACAATCAATCGAGCAAGTCCATTA\\\nTCAACGAGTGTGTTGCAGTTTTATTCTCTTGCCAGCATTGTAATAGGCACTAAAAGAATGATGATAGTCATGAGTACTG\\\nAGCTAAGACGGCGTCGATGCATAGCGGACTTTCGGTCAATCACAATTCCTCACGAGACTCGTCCTGTTGAGCGTATCAC\\\nTCTCAATGTACAAGCAACCCAAGAAGGCTGTGCCTGGACTCAACTGGATGCAGGATGAACTCCAGACACGGGGTCACTA\\\nCTCTTCATACATAAAGCAAGAACGTCGAACAGTCATGAAAGTCTTAGTACCGCACGTACCATCTTACTGTGAATATTGC\\\nTTGAAGCTGTACCGTTATTGGGGGGCAAAGATGAAGTTCTCTTCTTTTCATAATTGTACTGACGACAGTCGTGTTCTCG\\\nGTTTCTTCAAAGGTTAAAGAATAAAGGCTTATTGTAGGCAGAGGAACGCCCTTTTAGTGGCTGGCGTTAAGTATCTTCG\\\nGACCCCCTTGTCTATCCAGATTAATCGAATTCTCTCATTTAGGACCTTAGTAAGTCATCATTGGTATTTGAATGCGACC\\\nTTGAAGAAACCGCTTAAAAATGTCAATGGTTGATCCACTAAACTTCATTTAATTAACTCCTAAATCAGCGCGATAGGCT\\\nATTAGAGGTTTAATTTTGTATAGCAAGGTACTTCCGATCTTAATGAATGGCCGGAAAAGGTACGGACGCGATATGCGAG\\\nGGTGAAAGGGCAAATAGACAGGTTCGTCTTTGTCACGCTAGGAGGCAATTCTATAAGAATGCATATTGCATCGATACAT\\\nAAAATGTCTCGATCGCATGCGCAATTTGTGAAGTGTCTATTATCCCTAAGCCCATTTCCCGCATAATAACCCCTGATTG\\\nTATCCGCATTTGATGCTACCCAGGTTGAGTTAGCGTCGAGCTCGCGGAACTTATTGCATGAGTAGAGTTGAGTAAGAGC\\\nTGTTAGATGGCTCGCTGAACTAATAGTTGTCCACAGAACGTCAAGATTAGAAAACGGTTGTAGCATTATCGGAGGTTCT\\\nCTAACTACTATCAATACCCGTGTCTTGACTCTGCTGCGGCTACCTATCGCCTGAAAACCAGTTGGTGTTAAGGGATGCT\\\nCTGTCCAGGACGCCACATGTAGTGAAACTTACATGTTCGTTGGGTTCACCCGACT\";\n\n#[bench]\nfn bench_aligner_wc_local(b: \u0026mut Bencher) {\n    let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n    let mut aligner = Aligner::with_capacity(STR_1.len(), STR_2.len(), -5, -1, \u0026score);\n    b.iter(|| aligner.local(STR_1, STR_2));\n}\n\n#[bench]\nfn bench_aligner_wc_global(b: \u0026mut Bencher) {\n    let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n    let mut aligner = Aligner::with_capacity(STR_1.len(), STR_2.len(), -5, -1, \u0026score);\n    b.iter(|| aligner.global(STR_1, STR_2));\n}\n\n#[bench]\nfn bench_aligner_wc_semiglobal(b: \u0026mut Bencher) {\n    let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n    let mut aligner = Aligner::with_capacity(STR_1.len(), STR_2.len(), -5, -1, \u0026score);\n    b.iter(|| aligner.semiglobal(STR_1, STR_2));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","benches","pattern_matching.rs"],"content":"#![feature(test)]\n\nextern crate test;\n\nuse bio::pattern_matching::bndm::BNDM;\nuse bio::pattern_matching::bom::BOM;\nuse bio::pattern_matching::horspool::Horspool;\nuse bio::pattern_matching::kmp::KMP;\nuse bio::pattern_matching::shift_and::ShiftAnd;\nuse test::Bencher;\n\nstatic TEXT: \u0026'static [u8] = b\"GATCACAGGTCTATCACCCTATTAACCACTCACGGGAGCTCTCCATGC\\\nATTTGGTATTTTCGTCTGGGGGGTATGCACGCGATAGCATTGCGAGACGCTGGAGCCGGAGCACCCTATGTCGCAGTAT\\\nCTGTCTTTGATTCCTGCCTCATCCTATTATTTATCGCACCTACGTTCAATATTACAGGCGAACATACTTACTAAAGTGT\\\nGTTAATTAATTAATGCTTGTAGGACATAATAATAACAATTGAATGTCTGCACAGCCACTTTCCACACAGACATCATAAC\\\nAAAAAATTTCCACCAAACCCCCCCTCCCCCGCTTCTGGCCACAGCACTTAAACACATCTCTGCCAAACCCCAAAAACAA\\\nAGAACCCTAACACCAGCCTAACCAGATTTCAAATTTTATCTTTTGGCGGTATGCACTTTTAACAGTCACCCCCCAACTA\\\nACACATTATTTTCCCCTCCCACTCCCATACTACTAATCTCATCAATACAACCCCCGCCCATCCTACCCAGCACACACAC\\\nACCGCTGCTAACCCCATACCCCGAACCAACCAAACCCCAAAGACACCCCCCACAGTTTATGTAGCTTACCTCCTCAAAG\\\nCAATACACTGAAAATGTTTAGACGGGCTCACATCACCCCATAAACAAATAGGTTTGGTCCTAGCCTTTCTATTAGCTCT\\\nTAGTAAGATTACACATGCAAGCATCCCCGTTCCAGTGAGTTCACCCTCTAAATCACCACGATCAAAAGGAACAAGCATC\\\nAAGCACGCAGCAATGCAGCTCAAAACGCTTAGCCTAGCCACACCCCCACGGGAAACAGCAGTGATTAACCTTTAGCAAT\\\nAAACGAAAGTTTAACTAAGCTATACTAACCCCAGGGTTGGTCAATTTCGTGCCAGCCACCGCGGTCACACGATTAACCC\\\nAAGTCAATAGAAGCCGGCGTAAAGAGTGTTTTAGATCACCCCCTCCCCAATAAAGCTAAAACTCACCTGAGTTGTAAAA\\\nAACTCCAGTTGACACAAAATAGACTACGAAAGTGGCTTTAACATATCTGAACACACAATAGCTAAGACCCAAACTGGGA\\\nTTAGATACCCCACTATGCTTAGCCCTAAACCTCAACAGTTAAATCAACAAAACTGCTCGCCAGAACACTACGAGCCACA\\\nGCTTAAAACTCAAAGGACCTGGCGGTGCTTCATATCCCTCTAGAGGAGCCTGTTCTGTAATCGATAAACCCCGATCAAC\\\nCTCACCACCTCTTGCTCAGCCTATATACCGCCATCTTCAGCAAACCCTGATGAAGGCTACAAAGTAAGCGCAAGTACCC\\\nACGTAAAGACGTTAGGTCAAGGTGTAGCCCATGAGGTGGCAAGAAATGGGCTACATTTTCTACCCCAGAAAACTACGAT\\\nAGCCCTTATGAAACTTAAGGGTCGAAGGTGGATTTAGCAGTAAACTAAGAGTAGAGTGCTTAGTTGAACAGGGCCCTGA\\\nAGCGCGTACACACCGCCCGTCACCCTCCTCAAGTATACTTCAAAGGACATTTAACTAAAACCCCTACGCATTTATATAG\\\nAGGAGACAAGTCGTAACATGGTAAGTGTACTGGAAAGTGCACTTGGACGAACCAGAGTGTAGCTTAACACAAAGCACCC\\\nAACTTACACTTAGGAGATTTCAACTTAACTTGACCGCTCTGAGCTAAACCTAGCCCCAAACCCACTCCACCTTACTACC\\\nAGACAACCTTAGCCAAACCATTTACCCAAATAAAGTATAGGCGATAGAAATTGAAACCTGGCGCAATAGATATAGTACC\\\nGCAAGGGAAAGATGAAAAATTATAACCAAGCATAATATAGCAAGGACTAACCCCTATACCTTCTGCATAATGAATTAAC\\\nTAGAAATAACTTTGCAAGGAGAGCCAAAGCTAAGACCCCCGAAACCAGACGAGCTACCTAAGAACAGCTAAAAGAGCAC\\\nACCCGTCTATGTAGCAAAATAGTGGGAAGATTTATAGGTAGAGGCGACAAACCTACCGAGCCTGGTGATAGCTGGTTGT\\\nCCAAGATAGAATCTTAGTTCAACTTTAAATTTGCCCACAGAACCCTCTAAATCCCCTTGTAAATTTAACTGTTAGTCCA\\\nAAGAGGAACAGCTCTTTGGACACTAGGAAAAAACCTTGTAGAGAGAGTAAAAAATTTAACACCCATAGTAGGCCTAAAA\\\nGCAGCCACCAATTAAGAAAGCGTTCAAGCTCAACACCCACTACCTAAAAAATCCCAAACATATAACTGAACTCCTCACA\\\nCCCAATTGGACCAATCTATCACCCTATAGAAGAACTAATGTTAGTATAAGTAACATGAAAACATTCTCCTCCGCATAAG\\\nCCTGCGTCAGATTAAAACACTGAACTGACAATTAACAGCCCAATATCTACAATCAACCAACAAGTCATTATTACCCTCA\\\nCTGTCAACCCAACACAGGCATGCTCATAAGGAAAGGTTAAAAAAAGTAAAAGGAACTCGGCAAATCTTACCCCGCCTGT\\\nTTACCAAAAACATCACCTCTAGCATCACCAGTATTAGAGGCACCGCCTGCCCAGTGACACATGTTTAACGGCCGCGGTA\\\nCCCTAACCGTGCAAAGGTAGCATAATCACTTGTTCCTTAAATAGGGACCTGTATGAATGGCTCCACGAGGGTTCAGCTG\\\nTCTCTTACTTTTAACCAGTGAAATTGACCTGCCCGTGAAGAGGCGGGCATAACACAGCAAGACGAGAAGACCCTATGGA\\\nGCTTTAATTTATTAATGCAAACAGTACCTAACAAACCCACAGGTCCTAAACTACCAAACCTGCATTAAAAATTTCGGTT\\\nGGGGCGACCTCGGAGCAGAACCCAACCTCCGAGCAGTACATGCTAAGACTTCACCAGTCAAAGCGAACTACTATACTCA\\\nATTGATCCAATAACTTGACCAACGGAACAAGTTACCCTAGGGATAACAGCGCAATCCTATTCTAGAGTCCATATCAACA\\\nATAGGGTTTACGACCTCGATGTTGGATCAGGACATCCCGATGGTGCAGCCGCTATTAAAGGTTCGTTTGTTCAACGATT\\\nAAAGTCCTACGTGATCTGAGTTCAGACCGGAGTAATCCAGGTCGGTTTCTATCTACNTTCAAATTCCTCCCTGTACGAA\\\nAGGACAAGAGAAATAAGGCCTACTTCACAAAGCGCCTTCCCCCGTAAATGATATCATCTCAACTTAGTATTATACCCAC\\\nACCCACCCAAGAACAGGGTTTGTTAAGATGGCAGAGCCCGGTAATCGCATAAAACTTAAAACTTTACAGTCAGAGGTTC\\\nAATTCCTCTTCTTAACAACATACCCATGGCCAACCTCCTACTCCTCATTGTACCCATTCTAATCGCAATGGCATTCCTA\\\nATGCTTACCGAACGAAAAATTCTAGGCTATATACAACTACGCAAAGGCCCCAACGTTGTAGGCCCCTACGGGCTACTAC\\\nAACCCTTCGCTGACGCCATAAAACTCTTCACCAAAGAGCCCCTAAAACCCGCCACATCTACCATCACCCTCTACATCAC\\\nCGCCCCGACCTTAGCTCTCACCATCGCTCTTCTACTATGAACCCCCCTCCCCATACCCAACCCCCTGGTCAACCTCAAC\\\nCTAGGCCTCCTATTTATTCTAGCCACCTCTAGCCTAGCCGTTTACTCAATCCTCTGATCAGGGTGAGCATCAAACTCAA\\\nACTACGCCCTGATCGGCGCACTGCGAGCAGTAGCCCAAACAATCTCATATGAAGTCACCCTAGCCATCATTCTACTATC\\\nAACATTACTAATAAGTGGCTCCTTTAACCTCTCCACCCTTATCACAACACAAGAACACCTCTGATTACTCCTGCCATCA\\\nTGACCCTTGGCCATAATATGATTTATCTCCACACTAGCAGAGACCAACCGAACCCCCTTCGACCTTGCCGAAGGGGAGT\\\nCCGAACTAGTCTCAGGCTTCAACATCGAATACGCCGCAGGCCCCTTCGCCCTATTCTTCATAGCCGAATACACAAACAT\\\nTATTATAATAAACACCCTCACCACTACAATCTTCCTAGGAACAACATATGACGCACTCTCCCCTGAACTCTACACAACA\\\nTATTTTGTCACCAAGACCCTACTTCTAACCTCCCTGTTCTTATGAATTCGAACAGCATACCCCCGATTCCGCTACGACC\\\nAACTCATACACCTCCTATGAAAAAACTTCCTACCACTCACCCTAGCATTACTTATATGATATGTCTCCATACCCATTAC\\\nAATCTCCAGCATTCCCCCTCAAACCTAAGAAATATGTCTGATAAAAGAGTTACTTTGATAGAGTAAATAATAGGAGCTT\\\nAAACCCCCTTATTTCTAGGACTATGAGAATCGAACCCATCCCTGAGAATCCAAAATTCTCCGTGCCACCTATCACACCC\\\nCATCCTAAAGTAAGGTCAGCTAAATAAGCTATCGGGCCCATACCCCGAAAATGTTGGTTATACCCTTCCCGTACTAATT\\\nAATCCCCTGGCCCAACCCGTCATCTACTCTACCATCTTTGCAGGCACACTCATCACAGCGCTAAGCTCGCACTGATTTT\\\nTTACCTGAGTAGGCCTAGAAATAAACATGCTAGCTTTTATTCCAGTTCTAACCAAAAAAATAAACCCTCGTTCCACAGA\\\nAGCTGCCATCAAGTATTTCCTCACGCAAGCAACCGCATCCATAATCCTTCTAATAGCTATCCTCTTCAACAATATACTC\\\nTCCGGACAATGAACCATAACCAATACTACCAATCAATACTCATCATTAATAATCATAATAGCTATAGCAATAAAACTAG\\\nGAATAGCCCCCTTTCACTTCTGAGTCCCAGAGGTTACCCAAGGCACCCCTCTGACATCCGGCCTGCTTCTTCTCACATG\\\nACAAAAACTAGCCCCCATCTCAATCATATACCAAATCTCTCCCTCACTAAACGTAAGCCTTCTCCTCACTCTCTCAATC\\\nTTATCCATCATAGCAGGCAGTTGAGGTGGATTAAACCAAACCCAGCTACGCAAAATCTTAGCATACTCCTCAATTACCC\\\nACATAGGATGAATAATAGCAGTTCTACCGTACAACCCTAACATAACCATTCTTAATTTAACTATTTATATTATCCTAAC\\\nTACTACCGCATTCCTACTACTCAACTTAAACTCCAGCACCACGACCCTACTACTATCTCGCACCTGAAACAAGCTAACA\\\nTGACTAACACCCTTAATTCCATCCACCCTCCTCTCCCTAGGAGGCCTGCCCCCGCTAACCGGCTTTTTGCCCAAATGGG\\\nCCATTATCGAAGAATTCACAAAAAACAATAGCCTCATCATCCCCACCATCATAGCCACCATCACCCTCCTTAACCTCTA\\\nCTTCTACCTACGCCTAATCTACTCCACCTCAATCACACTACTCCCCATATCTAACAACGTAAAAATAAAATGACAGTTT\\\nGAACATACAAAACCCACCCCATTCCTCCCCACACTCATCGCCCTTACCACGCTACTCCTACCTATCTCCCCTTTTATAC\\\nTAATAATCTTATAGAAATTTAGGTTAAATACAGACCAAGAGCCTTCAAAGCCCTCAGTAAGTTGCAATACTTAATTTCT\\\nGTAACAGCTAAGGACTGCAAAACCCCACTCTGCATCAACTGAACGCAAATCAGCCACTTTAATTAAGCTAAGCCCTTAC\\\nTAGACCAATGGGACTTAAACCCACAAACACTTAGTTAACAGCTAAGCACCCTAATCAACTGGCTTCAATCTACTTCTCC\\\nCGCCGCCGGGAAAAAAGGCGGGAGAAGCCCCGGCAGGTTTGAAGCTGCTTCTTCGAATTTGCAATTCAATATGAAAATC\\\nACCTCGGAGCTGGTAAAAAGAGGCCTAACCCCTGTCTTTAGATTTACAGTCCAATGCTTCACTCAGCCATTTTACCTCA\\\nCCCCCACTGATGTTCGCCGACCGTTGACTATTCTCTACAAACCACAAAGACATTGGAACACTATACCTATTATTCGGCG\\\nCATGAGCTGGAGTCCTAGGCACAGCTCTAAGCCTCCTTATTCGAGCCGAGCTGGGCCAGCCAGGCAACCTTCTAGGTAA\\\nCGACCACATCTACAACGTTATCGTCACAGCCCATGCATTTGTAATAATCTTCTTCATAGTAATACCCATCATAATCGGA\\\nGGCTTTGGCAACTGACTAGTTCCCCTAATAATCGGTGCCCCCGATATGGCGTTTCCCCGCATAAACAACATAAGCTTCT\\\nGACTCTTACCTCCCTCTCTCCTACTCCTGCTCGCATCTGCTATAGTGGAGGCCGGAGCAGGAACAGGTTGAACAGTCTA\\\nCCCTCCCTTAGCAGGGAACTACTCCCACCCTGGAGCCTCCGTAGACCTAACCATCTTCTCCTTACACCTAGCAGGTGTC\\\nTCCTCTATCTTAGGGGCCATCAATTTCATCACAACAATTATCAATATAAAACCCCCTGCCATAACCCAATACCAAACGC\\\nCCCTCTTCGTCTGATCCGTCCTAATCACAGCAGTCCTACTTCTCCTATCTCTCCCAGTCCTAGCTGCTGGCATCACTAT\\\nACTACTAACAGACCGCAACCTCAACACCACCTTCTTCGACCCCGCCGGAGGAGGAGACCCCATTCTATACCAACACCTA\\\nTTCTGATTTTTCGGTCACCCTGAAGTTTATATTCTTATCCTACCAGGCTTCGGAATAATCTCCCATATTGTAACTTACT\\\nACTCCGGAAAAAAAGAACCATTTGGATACATAGGTATGGTCTGAGCTATGATATCAATTGGCTTCCTAGGGTTTATCGT\\\nGTGAGCACACCATATATTTACAGTAGGAATAGACGTAGACACACGAGCATATTTCACCTCCGCTACCATAATCATCGCT\\\nATCCCCACCGGCGTCAAAGTATTTAGCTGACTCGCCACACTCCACGGAAGCAATATGAAATGATCTGCTGCAGTGCTCT\\\nGAGCCCTAGGATTCATCTTTCTTTTCACCGTAGGTGGCCTGACTGGCATTGTATTAGCAAACTCATCACTAGACATCGT\\\nACTACACGACACGTACTACGTTGTAGCCCACTTCCACTATGTCCTATCAATAGGAGCTGTATTTGCCATCATAGGAGGC\\\nTTCATTCACTGATTTCCCCTATTCTCAGGCTACACCCTAGACCAAACCTACGCCAAAATCCATTTCACTATCATATTCA\\\nTCGGCGTAAATCTAACTTTCTTCCCACAACACTTTCTCGGCCTATCCGGAATGCCCCGACGTTACTCGGACTACCCCGA\\\nTGCATACACCACATGAAACATCCTATCATCTGTAGGCTCATTCATTTCTCTAACAGCAGTAATATTAATAATTTTCATG\\\nATTTGAGAAGCCTTCGCTTCGAAGCGAAAAGTCCTAATAGTAGAAGAACCCTCCATAAACCTGGAGTGACTATATGGAT\\\nGCCCCCCACCCTACCACACATTCGAAGAACCCGTATACATAAAATCTAGACAAAAAAGGAAGGAATCGAACCCCCCAAA\\\nGCTGGTTTCAAGCCAACCCCATGGCCTCCATGACTTTTTCAAAAAGGTATTAGAAAAACCATTTCATAACTTTGTCAAA\\\nGTTAAATTATAGGCTAAATCCTATATATCTTAATGGCACATGCAGCGCAAGTAGGTCTACAAGACGCTACTTCCCCTAT\\\nCATAGAAGAGCTTATCACCTTTCATGATCACGCCCTCATAATCATTTTCCTTATCTGCTTCCTAGTCCTGTATGCCCTT\\\nTTCCTAACACTCACAACAAAACTAACTAATACTAACATCTCAGACGCTCAGGAAATAGAAACCGTCTGAACTATCCTGC\\\nCCGCCATCATCCTAGTCCTCATCGCCCTCCCATCCCTACGCATCCTTTACATAACAGACGAGGTCAACGATCCCTCCCT\\\nTACCATCAAATCAATTGGCCACCAATGGTACTGAACCTACGAGTACACCGACTACGGCGGACTAATCTTCAACTCCTAC\\\nATACTTCCCCCATTATTCCTAGAACCAGGCGACCTGCGACTCCTTGACGTTGACAATCGAGTAGTACTCCCGATTGAAG\\\nCCCCCATTCGTATAATAATTACATCACAAGACGTCTTGCACTCATGAGCTGTCCCCACATTAGGCTTAAAAACAGATGC\\\nAATTCCCGGACGTCTAAACCAAACCACTTTCACCGCTACACGACCGGGGGTATACTACGGTCAATGCTCTGAAATCTGT\\\nGGAGCAAACCACAGTTTCATGCCCATCGTCCTAGAATTAATTCCCCTAAAAATCTTTGAAATAGGGCCCGTATTTACCC\\\nTATAGCACCCCCTCTACCCCCTCTAGAGCCCACTGTAAAGCTAACTTAGCATTAACCTTTTAAGTTAAAGATTAAGAGA\\\nACCAACACCTCTTTACAGTGAAATGCCCCAACTAAATACTACCGTATGGCCCACCATAATTACCCCCATACTCCTTACA\\\nCTATTCCTCATCACCCAACTAAAAATATTAAACACAAACTACCACCTACCTCCCTCACCAAAGCCCATAAAAATAAAAA\\\nATTATAACAAACCCTGAGAACCAAAATGAACGAAAATCTGTTCGCTTCATTCATTGCCCCCACAATCCTAGGCCTACCC\\\nGCCGCAGTACTGATCATTCTATTTCCCCCTCTATTGATCCCCACCTCCAAATATCTCATCAACAACCGACTAATCACCA\\\nCCCAACAATGACTAATCAAACTAACCTCAAAACAAATGATAACCATACACAACACTAAAGGACGAACCTGATCTCTTAT\\\nACTAGTATCCTTAATCATTTTTATTGCCACAACTAACCTCCTCGGACTCCTGCCTCACTCATTTACACCAACCACCCAA\\\nCTATCTATAAACCTAGCCATGGCCATCCCCTTATGAGCGGGCACAGTGATTATAGGCTTTCGCTCTAAGATTAAAAATG\\\nCCCTAGCCCACTTCTTACCACAAGGCACACCTACACCCCTTATCCCCATACTAGTTATTATCGAAACCATCAGCCTACT\\\nCATTCAACCAATAGCCCTGGCCGTACGCCTAACCGCTAACATTACTGCAGGCCACCTACTCATGCACCTAATTGGAAGC\\\nGCCACCCTAGCAATATCAACCATTAACCTTCCCTCTACACTTATCATCTTCACAATTCTAATTCTACTGACTATCCTAG\\\nAAATCGCTGTCGCCTTAATCCAAGCCTACGTTTTCACACTTCTAGTAAGCCTCTACCTGCACGACAACACATAATGACC\\\nCACCAATCACATGCCTATCATATAGTAAAACCCAGCCCATGACCCCTAACAGGGGCCCTCTCAGCCCTCCTAATGACCT\\\nCCGGCCTAGCCATGTGATTTCACTTCCACTCCATAACGCTCCTCATACTAGGCCTACTAACCAACACACTAACCATATA\\\nCCAATGATGGCGCGATGTAACACGAGAAAGCACATACCAAGGCCACCACACACCACCTGTCCAAAAAGGCCTTCGATAC\\\nGGGATAATCCTATTTATTACCTCAGAAGTTTTTTTCTTCGCAGGATTTTTCTGAGCCTTTTACCACTCCAGCCTAGCCC\\\nCTACCCCCCAATTAGGAGGGCACTGGCCCCCAACAGGCATCACCCCGCTAAATCCCCTAGAAGTCCCACTCCTAAACAC\\\nATCCGTATTACTCGCATCAGGAGTATCAATCACCTGAGCTCACCATAGTCTAATAGAAAACAACCGAAACCAAATAATT\\\nCAAGCACTGCTTATTACAATTTTACTGGGTCTCTATTTTACCCTCCTACAAGCCTCAGAGTACTTCGAGTCTCCCTTCA\\\nCCATTTCCGACGGCATCTACGGCTCAACATTTTTTGTAGCCACAGGCTTCCACGGACTTCACGTCATTATTGGCTCAAC\\\nTTTCCTCACTATCTGCTTCATCCGCCAACTAATATTTCACTTTACATCCAAACATCACTTTGGCTTCGAAGCCGCCGCC\\\nTGATACTGGCATTTTGTAGATGTGGTTTGACTATTTCTGTATGTCTCCATCTATTGATGAGGGTCTTACTCTTTTAGTA\\\nTAAATAGTACCGTTAACTTCCAATTAACTAGTTTTGACAACATTCAAAAAAGAGTAATAAACTTCGCCTTAATTTTAAT\\\nAATCAACACCCTCCTAGCCTTACTACTAATAATTATTACATTTTGACTACCACAACTCAACGGCTACATAGAAAAATCC\\\nACCCCTTACGAGTGCGGCTTCGACCCTATATCCCCCGCCCGCGTCCCTTTCTCCATAAAATTCTTCTTAGTAGCTATTA\\\nCCTTCTTATTATTTGATCTAGAAATTGCCCTCCTTTTACCCCTACCATGAGCCCTACAAACAACTAACCTGCCACTAAT\\\nAGTTATGTCATCCCTCTTATTAATCATCATCCTAGCCCTAAGTCTGGCCTATGAGTGACTACAAAAAGGATTAGACTGA\\\nACCGAATTGGTATATAGTTTAAACAAAACGAATGATTTCGACTCATTAAATTATGATAATCATATTTACCAAATGCCCC\\\nTCATTTACATAAATATTATACTAGCATTTACCATCTCACTTCTAGGAATACTAGTATATCGCTCACACCTCATATCCTC\\\nCCTACTATGCCTAGAAGGAATAATACTATCGCTGTTCATTATAGCTACTCTCATAACCCTCAACACCCACTCCCTCTTA\\\nGCCAATATTGTGCCTATTGCCATACTAGTCTTTGCCGCCTGCGAAGCAGCGGTGGGCCTAGCCCTACTAGTCTCAATCT\\\nCCAACACATATGGCCTAGACTACGTACATAACCTAAACCTACTCCAATGCTAAAACTAATCGTCCCAACAATTATATTA\\\nCTACCACTGACATGACTTTCCAAAAAACACATAATTTGAATCAACACAACCACCCACAGCCTAATTATTAGCATCATCC\\\nCTCTACTATTTTTTAACCAAATCAACAACAACCTATTTAGCTGTTCCCCAACCTTTTCCTCCGACCCCCTAACAACCCC\\\nCCTCCTAATACTAACTACCTGACTCCTACCCCTCACAATCATGGCAAGCCAACGCCACTTATCCAGTGAACCACTATCA\\\nCGAAAAAAACTCTACCTCTCTATACTAATCTCCCTACAAATCTCCTTAATTATAACATTCACAGCCACAGAACTAATCA\\\nTATTTTATATCTTCTTCGAAACCACACTTATCCCCACCTTGGCTATCATCACCCGATGAGGCAACCAGCCAGAACGCCT\\\nGAACGCAGGCACATACTTCCTATTCTACACCCTAGTAGGCTCCCTTCCCCTACTCATCGCACTAATTTACACTCACAAC\\\nACCCTAGGCTCACTAAACATTCTACTACTCACTCTCACTGCCCAAGAACTATCAAACTCCTGAGCCAACAACTTAATAT\\\nGACTAGCTTACACAATAGCTTTTATAGTAAAGATACCTCTTTACGGACTCCACTTATGACTCCCTAAAGCCCATGTCGA\\\nAGCCCCCATCGCTGGGTCAATAGTACTTGCCGCAGTACTCTTAAAACTAGGCGGCTATGGTATAATACGCCTCACACTC\\\nATTCTCAACCCCCTGACAAAACACATAGCCTACCCCTTCCTTGTACTATCCCTATGAGGCATAATTATAACAAGCTCCA\\\nTCTGCCTACGACAAACAGACCTAAAATCGCTCATTGCATACTCTTCAATCAGCCACATAGCCCTCGTAGTAACAGCCAT\\\nTCTCATCCAAACCCCCTGAAGCTTCACCGGCGCAGTCATTCTCATAATCGCCCACGGGCTTACATCCTCATTACTATTC\\\nTGCCTAGCAAACTCAAACTACGAACGCACTCACAGTCGCATCATAATCCTCTCTCAAGGACTTCAAACTCTACTCCCAC\\\nTAATAGCTTTTTGATGACTTCTAGCAAGCCTCGCTAACCTCGCCTTACCCCCCACTATTAACCTACTGGGAGAACTCTC\\\nTGTGCTAGTAACCACGTTCTCCTGATCAAATATCACTCTCCTACTTACAGGACTCAACATACTAGTCACAGCCCTATAC\\\nTCCCTCTACATATTTACCACAACACAATGGGGCTCACTCACCCACCACATTAACAACATAAAACCCTCATTCACACGAG\\\nAAAACACCCTCATGTTCATACACCTATCCCCCATTCTCCTCCTATCCCTCAACCCCGACATCATTACCGGGTTTTCCTC\\\nTTGTAAATATAGTTTAACCAAAACATCAGATTGTGAATCTGACAACAGAGGCTTACGACCCCTTATTTACCGAGAAAGC\\\nTCACAAGAACTGCTAACTCATGCCCCCATGTCTAACAACATGGCTTTCTCAACTTTTAAAGGATAACAGCTATCCATTG\\\nGTCTTAGGCCCCAAAAATTTTGGTGCAACTCCAAATAAAAGTAATAACCATGCACACTACTATAACCACCCTAACCCTG\\\nACTTCCCTAATTCCCCCCATCCTTACCACCCTCGTTAACCCTAACAAAAAAAACTCATACCCCCATTATGTAAAATCCA\\\nTTGTCGCATCCACCTTTATTATCAGTCTCTTCCCCACAACAATATTCATGTGCCTAGACCAAGAAGTTATTATCTCGAA\\\nCTGACACTGAGCCACAACCCAAACAACCCAGCTCTCCCTAAGCTTCAAACTAGACTACTTCTCCATAATATTCATCCCT\\\nGTAGCATTGTTCGTTACATGGTCCATCATAGAATTCTCACTGTGATATATAAACTCAGACCCAAACATTAATCAGTTCT\\\nTCAAATATCTACTCATCTTCCTAATTACCATACTAATCTTAGTTACCGCTAACAACCTATTCCAACTGTTCATCGGCTG\\\nAGAGGGCGTAGGAATTATATCCTTCTTGCTCATCAGTTGATGATACGCCCGAGCAGATGCCAACACAGCAGCCATTCAA\\\nGCAATCCTATACAACCGTATCGGCGATATCGGTTTCATCCTCGCCTTAGCATGATTTATCCTACACTCCAACTCATGAG\\\nACCCACAACAAATAGCCCTTCTAAACGCTAATCCAAGCCTCACCCCACTACTAGGCCTCCTCCTAGCAGCAGCAGGCAA\\\nATCAGCCCAATTAGGTCTCCACCCCTGACTCCCCTCAGCCATAGAAGGCCCCACCCCAGTCTCAGCCCTACTCCACTCA\\\nAGCACTATAGTTGTAGCAGGAATCTTCTTACTCATCCGCTTCCACCCCCTAGCAGAAAATAGCCCACTAATCCAAACTC\\\nTAACACTATGCTTAGGCGCTATCACCACTCTGTTCGCAGCAGTCTGCGCCCTTACACAAAATGACATCAAAAAAATCGT\\\nAGCCTTCTCCACTTCAAGTCAACTAGGACTCATAATAGTTACAATCGGCATCAACCAACCACACCTAGCATTCCTGCAC\\\nATCTGTACCCACGCCTTCTTCAAAGCCATACTATTTATGTGCTCCGGGTCCATCATCCACAACCTTAACAATGAACAAG\\\nATATTCGAAAAATAGGAGGACTACTCAAAACCATACCTCTCACTTCAACCTCCCTCACCATTGGCAGCCTAGCATTAGC\\\nAGGAATACCTTTCCTCACAGGTTTCTACTCCAAAGACCACATCATCGAAACCGCAAACATATCATACACAAACGCCTGA\\\nGCCCTATCTATTACTCTCATCGCTACCTCCCTGACAAGCGCCTATAGCACTCGAATAATTCTTCTCACCCTAACAGGTC\\\nAACCTCGCTTCCCCACCCTTACTAACATTAACGAAAATAACCCCACCCTACTAAACCCCATTAAACGCCTGGCAGCCGG\\\nAAGCCTATTCGCAGGATTTCTCATTACTAACAACATTTCCCCCGCATCCCCCTTCCAAACAACAATCCCCCTCTACCTA\\\nAAACTCACAGCCCTCGCTGTCACTTTCCTAGGACTTCTAACAGCCCTAGACCTCAACTACCTAACCAACAAACTTAAAA\\\nTAAAATCCCCACTATGCACATTTTATTTCTCCAACATACTCGGATTCTACCCTAGCATCACACACCGCACAATCCCCTA\\\nTCTAGGCCTTCTTACGAGCCAAAACCTGCCCCTACTCCTCCTAGACCTAACCTGACTAGAAAAGCTATTACCTAAAACA\\\nATTTCACAGCACCAAATCTCCACCTCCATCATCACCTCAACCCAAAAAGGCATAATTAAACTTTACTTCCTCTCTTTCT\\\nTCTTCCCACTCATCCTAACCCTACTCCTAATCACATAACCTATTCCCCCGAGCAATCTCAATTACAATATATACACCAA\\\nCAAACAATGTTCAACCAGTAACTACTACTAATCAACGCCCATAATCATACAAAGCCCCCGCACCAATAGGATCCTCCCG\\\nAATCAACCCTGACCCCTCTCCTTCATAAATTATTCAGCTTCCTACACTATTAAAGTTTACCACAACCACCACCCCATCA\\\nTACTCTTTCACCCACAGCACCAATCCTACCTCCATCGCTAACCCCACTAAAACACTCACCAAGACCTCAACCCCTGACC\\\nCCCATGCCTCAGGATACTCCTCAATAGCCATCGCTGTAGTATATCCAAAGACAACCATCATTCCCCCTAAATAAATTAA\\\nAAAAACTATTAAACCCATATAACCTCCCCCAAAATTCAGAATAATAACACACCCGACCACACCGCTAACAATCAATACT\\\nAAACCCCCATAAATAGGAGAAGGCTTAGAAGAAAACCCCACAAACCCCATTACTAAACCCACACTCAACAGAAACAAAG\\\nCATACATCATTATTCTCGCACGGACTACAACCACGACCAATGATATGAAAAACCATCGTTGTATTTCAACTACAAGAAC\\\nACCAATGACCCCAATACGCAAAACTAACCCCCTAATAAAATTAATTAACCACTCATTCATCGACCTCCCCACCCCATCC\\\nAACATCTCCGCATGATGAAACTTCGGCTCACTCCTTGGCGCCTGCCTGATCCTCCAAATCACCACAGGACTATTCCTAG\\\nCCATGCACTACTCACCAGACGCCTCAACCGCCTTTTCATCAATCGCCCACATCACTCGAGACGTAAATTATGGCTGAAT\\\nCATCCGCTACCTTCACGCCAATGGCGCCTCAATATTCTTTATCTGCCTCTTCCTACACATCGGGCGAGGCCTATATTAC\\\nGGATCATTTCTCTACTCAGAAACCTGAAACATCGGCATTATCCTCCTGCTTGCAACTATAGCAACAGCCTTCATAGGCT\\\nATGTCCTCCCGTGAGGCCAAATATCATTCTGAGGGGCCACAGTAATTACAAACTTACTATCCGCCATCCCATACATTGG\\\nGACAGACCTAGTTCAATGAATCTGAGGAGGCTACTCAGTAGACAGTCCCACCCTCACACGATTCTTTACCTTTCACTTC\\\nATCTTGCCCTTCATTATTGCAGCCCTAGCAACACTCCACCTCCTATTCTTGCACGAAACGGGATCAAACAACCCCCTAG\\\nGAATCACCTCCCATTCCGATAAAATCACCTTCCACCCTTACTACACAATCAAAGACGCCCTCGGCTTACTTCTCTTCCT\\\nTCTCTCCTTAATGACATTAACACTATTCTCACCAGACCTCCTAGGCGACCCAGACAATTATACCCTAGCCAACCCCTTA\\\nAACACCCCTCCCCACATCAAGCCCGAATGATATTTCCTATTCGCCTACACAATTCTCCGATCCGTCCCTAACAAACTAG\\\nGAGGCGTCCTTGCCCTATTACTATCCATCCTCATCCTAGCAATAATCCCCATCCTCCATATATCCAAACAACAAAGCAT\\\nAATATTTCGCCCACTAAGCCAATCACTTTATTGACTCCTAGCCGCAGACCTCCTCATTCTAACCTGAATCGGAGGACAA\\\nCCAGTAAGCTACCCTTTTACCATCATTGGACAAGTAGCATCCGTACTATACTTCACAACAATCCTAATCCTAATACCAA\\\nCTATCTCCCTAATTGAAAACAAAATACTCAAATGGGCCTGTCCTTGTAGTATAAACTAATACACCAGTCTTGTAAACCG\\\nGAGATGAAAACCTTTTTCCAAGGACAAATCAGAGAAAAAGTCTTTAACTCCACCATTAGCACCCAAAGCTAAGATTCTA\\\nATTTAAACTATTCTCTGTTCTTTCATGGGGAAGCAGATTTGGGTACCACCCAAGTATTGACTCACCCATCAACAACCGC\\\nTATGTATTTCGTACATTACTGCCAGCCACCATGAATATTGTACGGTACCATAAATACTTGACCACCTGTAGTACATAAA\\\nAACCCAATCCACATCAAAACCCCCTCCCCATGCTTACAAGCAAGTACAGCAATCAACCCTCAACTATCACACATCAACT\\\nGCAACTCCAAAGCCACCCCTCACCCACTAGGATACCAACAAACCTACCCACCCTTAACAGTACATAGTACATAAAGCCA\\\nTTTACCGTACATAGCACATTACAGTCAAATCCCTTCTCGTCCCCATGGATGACCCCCCTCAGATAGGGGTCCCTTGACC\\\nACCATCCTCCGTGAAATCAATATCCCGCACAAGAGTGCTACTCTCCTCGCTCCGGGCCCATAACACTTGGGGGTAGCTA\\\nAAGTGAACTGTATCCGACATCTGGTTCCTACTTCAGGGTCATAAAGCCTAAATAGCCCACACGTTCCCCTTAAATAAGA\\\nCATCACGATG\";\n\nstatic PATTERN: \u0026'static [u8] = b\"GCGCGTACACACCGCCCG\";\n\n#[bench]\nfn bench_shift_and(b: \u0026mut Bencher) {\n    b.iter(|| {\n        for _ in 0..10000 {\n            let shiftand = ShiftAnd::new(PATTERN);\n            let _ = shiftand.find_all(TEXT.iter()).collect::\u003cVec\u003cusize\u003e\u003e();\n        }\n    });\n}\n\n#[bench]\nfn bench_bndm(b: \u0026mut Bencher) {\n    b.iter(|| {\n        for _ in 0..10000 {\n            let bndm = BNDM::new(PATTERN);\n            let _ = bndm.find_all(TEXT).collect::\u003cVec\u003cusize\u003e\u003e();\n        }\n    });\n}\n\n#[bench]\nfn bench_bom(b: \u0026mut Bencher) {\n    b.iter(|| {\n        for _ in 0..10000 {\n            let bom = BOM::new(PATTERN);\n            let _ = bom.find_all(TEXT).collect::\u003cVec\u003cusize\u003e\u003e();\n        }\n    });\n}\n\n#[bench]\nfn bench_horspool(b: \u0026mut Bencher) {\n    b.iter(|| {\n        for _ in 0..10000 {\n            let horspool = Horspool::new(PATTERN);\n            let _ = horspool.find_all(TEXT).collect::\u003cVec\u003cusize\u003e\u003e();\n        }\n    });\n}\n\n#[bench]\nfn bench_kmp(b: \u0026mut Bencher) {\n    b.iter(|| {\n        for _ in 0..10000 {\n            let kmp = KMP::new(PATTERN);\n            let _ = kmp.find_all(TEXT.iter()).collect::\u003cVec\u003cusize\u003e\u003e();\n        }\n    });\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","benches","suffix_array.rs"],"content":"#![feature(test)]\n\nextern crate test;\n\nuse test::Bencher;\n\nuse bio::data_structures::suffix_array::*;\n\n#[bench]\nfn bench_suffix_array(b: \u0026mut Bencher) {\n    b.iter(|| suffix_array(b\"GCCTTAACATTATTACGCCTA$\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","build.rs"],"content":"// Adapted from the num_traits crate\n\nuse std::env;\nuse std::io::Write;\nuse std::process::{Command, Stdio};\n\nfn main() {\n    if probe(\"fn main() { 0u128; }\") {\n        println!(\"cargo:rustc-cfg=has_u128\");\n    }\n}\n\n/// Test if a code snippet can be compiled\nfn probe(code: \u0026str) -\u003e bool {\n    let rustc = env::var_os(\"RUSTC\").unwrap_or_else(|| \"rustc\".into());\n    let out_dir = env::var_os(\"OUT_DIR\").expect(\"environment variable OUT_DIR\");\n\n    let mut child = Command::new(rustc)\n        .arg(\"--out-dir\")\n        .arg(out_dir)\n        .arg(\"--emit=obj\")\n        .arg(\"-\")\n        .stdin(Stdio::piped())\n        .spawn()\n        .expect(\"rustc probe\");\n\n    child\n        .stdin\n        .as_mut()\n        .expect(\"rustc stdin\")\n        .write_all(code.as_bytes())\n        .expect(\"write rustc stdin\");\n\n    child.wait().expect(\"rustc probe\").success()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","fuzz","fuzz_targets","banded_aligner.rs"],"content":"#![no_main]\n#[macro_use]\nextern crate libfuzzer_sys;\nextern crate bio;\nuse std::cmp::{min, max};\nuse bio::alignment::{Alignment, AlignmentMode, AlignmentOperation};\nuse bio::alignment::pairwise::{self, banded, Scoring, MatchParams,  MatchFunc};\nuse bio::utils::TextSlice;\n\nfn validate_alignment_score(al: \u0026Alignment, x: TextSlice, y: TextSlice, scoring: \u0026Scoring\u003cMatchParams\u003e) -\u003e bool {\n    use AlignmentOperation::*;\n    let path = al.path();\n    let mut score = 0;\n    if al.mode==AlignmentMode::Custom {\n        if al.xstart \u003e 0 {\n            score += scoring.xclip_prefix;\n        }\n        if al.ystart \u003e 0 {\n            score += scoring.yclip_prefix;\n        }\n        if al.xend \u003c al.xlen {\n            score += scoring.xclip_suffix;\n        }\n        if al.yend \u003c al.ylen {\n            score += scoring.yclip_suffix;\n        }\n    }\n    let mut last_op = None;\n    for (i, j, op) in path {\n        score += match op {\n            Match | Subst =\u003e scoring.match_fn.score(x[i-1], y[j-1]),\n            Del =\u003e if last_op==Some(Del) { scoring.gap_extend } else { scoring.gap_open + scoring.gap_extend },\n            Ins =\u003e if last_op==Some(Ins) { scoring.gap_extend } else { scoring.gap_open + scoring.gap_extend },\n            _ =\u003e 0,\n        };\n        last_op = Some(op);\n    }\n    al.score==score\n}\n\nfuzz_target!(|data: \u0026[u8]| {\n    if data.len() \u003c 50 || data.len() \u003e 300 {\n        return;\n    }\n\n    let (split_byte, data) = data.split_first().unwrap();\n    let (kmer_byte, data) = data.split_first().unwrap();\n    let (window_byte, data) = data.split_first().unwrap();\n    let (match_score_byte, data) = data.split_first().unwrap();\n    let (mismatch_score_byte, data) = data.split_first().unwrap();\n    let (gap_open_byte, data) = data.split_first().unwrap();\n    let (gap_extend_byte, data) = data.split_first().unwrap();\n    let (xclip_prefix_byte, data) = data.split_first().unwrap();\n    let (xclip_suffix_byte, data) = data.split_first().unwrap();\n    let (yclip_prefix_byte, data) = data.split_first().unwrap();\n    let (yclip_suffix_byte, data) = data.split_first().unwrap();\n\n    let alphabets = b\"ACGT\";\n    let v: Vec\u003c_\u003e = data.iter()\n        .map(|i| alphabets[(*i as usize) % alphabets.len()])\n        .collect();\n\n    let kmer_len: usize = 5 + (*kmer_byte as usize) % 10;\n    let window_size: usize = 5 + (*window_byte as usize) % 10;\n    let split_pos: usize = min(data.len() - 1, max(*split_byte as usize, 1));\n\n    let match_score = 1 + (*match_score_byte as i32) % 5;\n    let mismatch_score = -((*mismatch_score_byte as i32) % 10);\n    let gap_open = -((*gap_open_byte as i32) % 20);\n    let gap_extend = -((*gap_extend_byte as i32) % 10);\n\n    let (x, y) = v.split_at(split_pos);\n    println!(\"x: {}, y: {}, k: {}, w: {}, scoring ({}, {}, {}, {})\",\n             String::from_utf8(x.to_vec()).unwrap(),\n             String::from_utf8(y.to_vec()).unwrap(),\n             kmer_len,\n             window_size,\n             gap_open,\n             gap_extend,\n             match_score,\n             mismatch_score);\n    let base_score = Scoring::from_scores(gap_open, gap_extend, match_score, mismatch_score);\n\n    {\n        println!(\"Clip scores ({}, {}, {}, {})\", xclip_prefix_byte, xclip_suffix_byte, yclip_prefix_byte, yclip_suffix_byte);\n        let scoring = Scoring {\n            xclip_prefix: -(*xclip_prefix_byte as i32),\n            xclip_suffix: -(*xclip_suffix_byte as i32),\n            yclip_prefix: -(*yclip_prefix_byte as i32),\n            yclip_suffix: -(*yclip_suffix_byte as i32),\n            ..base_score.clone()\n        };\n        // Banded\n        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);\n        let b_alignment = b_aligner.custom(x, y);\n        assert!(validate_alignment_score(\u0026b_alignment, x, y, \u0026scoring));\n\n        // Full\n        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());\n        let f_alignment = f_aligner.custom(x, y);\n        assert!(validate_alignment_score(\u0026f_alignment, x, y, \u0026scoring));\n\n        // Compare\n        // Passing an empty match will force the banded alignmer to band the full matrix\n        let band_all_alignment = b_aligner.custom_with_matches(x, y, \u0026Vec::new());\n        assert_eq!(band_all_alignment.score, f_alignment.score);\n    }\n\n\n    {\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            xclip_suffix: 0,\n            yclip_suffix: 0,\n            ..base_score.clone()\n        };\n        // Banded\n        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);\n        let b_alignment = b_aligner.custom(x, y);\n        assert_eq!(b_alignment.ystart, 0);\n        assert!(validate_alignment_score(\u0026b_alignment, x, y, \u0026scoring));\n\n        // Full\n        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());\n        let f_alignment = f_aligner.custom(x, y);\n        assert_eq!(f_alignment.ystart, 0);\n        assert!(validate_alignment_score(\u0026f_alignment, x, y, \u0026scoring));\n\n        // Compare\n        // Passing an empty match will force the banded alignmer to band the full matrix\n        let band_all_alignment = b_aligner.custom_with_matches(x, y, \u0026Vec::new());\n        assert_eq!(band_all_alignment.score, f_alignment.score);\n    }\n\n    {\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            xclip_suffix: 0,\n            yclip_prefix: 0,\n            ..base_score.clone()\n        };\n        // Banded\n        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);\n        let b_alignment = b_aligner.custom(x, y);\n        assert_eq!(b_alignment.yend, b_alignment.ylen);\n        assert!(validate_alignment_score(\u0026b_alignment, x, y, \u0026scoring));\n\n        // Full\n        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());\n        let f_alignment = f_aligner.custom(x, y);\n        assert_eq!(f_alignment.yend, f_alignment.ylen);\n        assert!(validate_alignment_score(\u0026f_alignment, x, y, \u0026scoring));\n\n        // Compare\n        // Passing an empty match will force the banded alignmer to band the full matrix\n        let band_all_alignment = b_aligner.custom_with_matches(x, y, \u0026Vec::new());\n        assert_eq!(band_all_alignment.score, f_alignment.score);\n    }\n\n    {\n        let scoring = Scoring {\n            xclip_suffix: 0,\n            yclip_prefix: 0,\n            yclip_suffix: 0,\n            ..base_score.clone()\n        };\n        // Banded\n        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);\n        let b_alignment = b_aligner.custom(x, y);\n        assert_eq!(b_alignment.xstart, 0);\n        assert!(validate_alignment_score(\u0026b_alignment, x, y, \u0026scoring));\n\n        // Full\n        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());\n        let f_alignment = f_aligner.custom(x, y);\n        assert_eq!(f_alignment.xstart, 0);\n        assert!(validate_alignment_score(\u0026f_alignment, x, y, \u0026scoring));\n\n        // Compare\n        // Passing an empty match will force the banded alignmer to band the full matrix\n        let band_all_alignment = b_aligner.custom_with_matches(x, y, \u0026Vec::new());\n        assert_eq!(band_all_alignment.score, f_alignment.score);\n    }\n\n    {\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            yclip_prefix: 0,\n            yclip_suffix: 0,\n            ..base_score.clone()\n        };\n        // Banded\n        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);\n        let b_alignment = b_aligner.custom(x, y);\n        assert_eq!(b_alignment.xend, b_alignment.xlen);\n        assert!(validate_alignment_score(\u0026b_alignment, x, y, \u0026scoring));\n\n        // Full\n        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());\n        let f_alignment = f_aligner.custom(x, y);\n        assert_eq!(f_alignment.xend, f_alignment.xlen);\n        assert!(validate_alignment_score(\u0026f_alignment, x, y, \u0026scoring));\n\n        // Compare\n        // Passing an empty match will force the banded alignmer to band the full matrix\n        let band_all_alignment = b_aligner.custom_with_matches(x, y, \u0026Vec::new());\n        assert_eq!(band_all_alignment.score, f_alignment.score);\n    }\n\n    {\n        // banded\n        let mut aligner = banded::Aligner::with_scoring(base_score.clone(), kmer_len, window_size);\n\n        let alignment = aligner.local(x, y);\n        assert!(alignment.score \u003e= 0);\n        assert!(validate_alignment_score(\u0026alignment, x, y, \u0026base_score));\n\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.xend, alignment.xlen);\n        assert!(validate_alignment_score(\u0026alignment, x, y, \u0026base_score));\n\n        let alignment = aligner.global(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.xend, alignment.xlen);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.yend, alignment.ylen);\n        assert!(validate_alignment_score(\u0026alignment, x, y, \u0026base_score));\n    }\n\n    {\n        // full\n        let mut aligner = pairwise::Aligner::with_scoring(base_score.clone());\n\n        let alignment = aligner.local(x, y);\n        assert!(alignment.score \u003e= 0);\n        assert!(validate_alignment_score(\u0026alignment, x, y, \u0026base_score));\n\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.xend, alignment.xlen);\n        assert!(validate_alignment_score(\u0026alignment, x, y, \u0026base_score));\n\n        let alignment = aligner.global(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.xend, alignment.xlen);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.yend, alignment.ylen);\n        assert!(validate_alignment_score(\u0026alignment, x, y, \u0026base_score));\n    }\n\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","fuzz","fuzz_targets","myers_matching.rs"],"content":"#![no_main]\n#[macro_use] extern crate libfuzzer_sys;\n\nuse std::cmp::{min, max};\nuse bio::pattern_matching::myers::{MyersBuilder, Myers, long};\nuse bio::alignment::Alignment;\nuse bio::alignment::AlignmentOperation::*;\n\n\nfuzz_target!(|data: \u0026[u8]| {\n    if data.len() \u003c 3 {\n        return;\n    }\n\n    let (max_dist, data) = data.split_first().unwrap();\n    let (pattern_len, data) = data.split_first().unwrap();\n    let max_dist = min(64, *max_dist);\n    let pattern_len = max(1, min(64, min(data.len(), *pattern_len as usize)));\n\n    if data.iter().any(|\u0026b| b \u003c 65 || b \u003e 122 || b \u003e 90 \u0026\u0026 b \u003c 97) {\n        return;\n    }\n\n    let (pattern, text) = data.split_at(pattern_len);\n\n    // Test whether builders succeed\n    // TODO: Builder testing could be expanded\n    let max_dist = max_dist as u8;\n    // Test whether builders succeed\n    // TODO: Builder testing could be expanded\n    let _ = MyersBuilder::new().build_64(pattern);\n    let _ = MyersBuilder::new().build_long_64(pattern);\n\n    // Myers objects\n    let mut myers = Myers::\u003cu64\u003e::new(pattern);\n    let mut myers_long = long::Myers::\u003cu8\u003e::new(pattern);\n\n    // No traceback, just searching\n    let end_dist: Vec\u003c_\u003e = myers.find_all_end(text, max_dist).collect();\n    let end_dist_long: Vec\u003c_\u003e = myers_long.find_all_end(text, max_dist as usize)\n        .map(|(end, dist)| (end, dist as u8))\n        .collect();\n    assert_eq!(end_dist, end_dist_long);\n\n    // Test traceback algorithm:\n    // The following code compares the distance from the myers algorithm with the\n    // number of substitutions / InDels found in the alignment path. If the distances\n    // are equal, then the traceback found a valid alignment path.\n    // Additionally, the actual pattern and text are inspected; matches / substitutions\n    // that are unexpectedly (un)equal will cause a panic.\n\n    // 'Default' API\n    let mut aln = Alignment::default();\n    let mut aln_long = Alignment::default();\n    {\n        let mut matches = myers.find_all(text, max_dist);\n        let mut matches_long = myers_long.find_all(text, max_dist as usize);\n\n        matches.alignment(\u0026mut aln); // all insertions to text\n        matches_long.alignment(\u0026mut aln_long);\n\n        let mut end_dist_iter = end_dist.iter();\n        while matches.next_alignment(\u0026mut aln) {\n            assert!(matches_long.next_alignment(\u0026mut aln_long));\n            assert_eq!(aln, aln_long);\n\n            // verify alignment\n            validate_alignment(\u0026aln, pattern, text);\n            assert!(aln.score as u8 \u003c= max_dist);\n\n            // compare to find_all_end() results\n            let (end, dist) = end_dist_iter.next().unwrap();\n            assert_eq!(*end + 1, aln.yend);\n            assert_eq!(*dist, aln.score as u8);\n        }\n        assert!(end_dist_iter.next().is_none());\n        assert!(!matches_long.next_alignment(\u0026mut aln_long));\n    }\n\n    {\n        // Lazy API\n\n        let mut matches = myers.find_all_lazy(text, max_dist);\n        let mut matches_long = myers_long.find_all_lazy(text, max_dist as usize);\n        let mut end_dist_iter = end_dist.iter();\n\n        while let Some((end, dist)) = matches.next() {\n            // compare distances\n            let (end_long, dist_long) = matches_long.next().unwrap();\n            assert_eq!((end, dist), (end_long, dist_long as u8));\n\n            // compare alignments\n            assert!(matches.alignment_at(end, \u0026mut aln));\n            assert!(matches_long.alignment_at(end, \u0026mut aln_long));\n            assert_eq!(aln, aln_long);\n\n            // verify alignment\n            validate_alignment(\u0026aln, pattern, text);\n            assert_eq!(dist, aln.score as u8);\n            assert!(aln.score as u8 \u003c= max_dist);\n\n            // compare to find_all_end() results\n            let (end, dist) = end_dist_iter.next().unwrap();\n            assert_eq!(*end + 1, aln.yend);\n            assert_eq!(*dist, aln.score as u8);\n\n            // larger positions were not yet searched\n            assert!(!matches.alignment_at(end + 1, \u0026mut aln));\n        }\n        assert!(end_dist_iter.next().is_none());\n    }\n\n    // Lazy API with unlimited distance: each position should be found\n\n    let mut matches = myers.find_all_lazy(text, u8::max_value());\n    let mut matches_long = myers_long.find_all_lazy(text, u8::max_value() as usize);\n\n    let mut i = 0;\n    while let Some((end, dist)) = matches.next() {\n        assert_eq!(end, i);\n\n        // compare distances\n        let (end_long, dist_long) = matches_long.next().unwrap();\n        assert_eq!((end, dist), (end_long, dist_long as u8));\n\n        // compare alignments\n        assert!(matches.alignment_at(end, \u0026mut aln));\n        assert!(matches_long.alignment_at(end, \u0026mut aln_long));\n        assert_eq!(aln, aln_long);\n\n        // verify alignment\n        validate_alignment(\u0026aln, pattern, text);\n        assert_eq!(dist, aln.score as u8);\n        assert!(aln.score as u8 \u003c= u8::max_value());\n\n        // larger positions were not yet searched\n        assert!(!matches.alignment_at(end + 1, \u0026mut aln));\n        assert!(!matches_long.alignment_at(end + 1, \u0026mut aln_long));\n        i += 1;\n    }\n});\n\n\n// Validates an Alignment based on the sequences that were used to construct it.\n// - calculates the score using edit distance (mismatches / gap penalties = 1) and\n//   then compares it to the stored score\n// - checks if matches and substitutions are really correct given the actual sequences\nfn validate_alignment(aln: \u0026Alignment, x: \u0026[u8], y: \u0026[u8]) {\n\n    let y = \u0026y[aln.ystart..aln.yend];\n\n    let mut ix = 0;\n    let mut iy = 0;\n    let mut calc_dist = 0;\n    for op in \u0026aln.operations {\n        match *op {\n            Match =\u003e {\n                assert!(x[ix] == y[iy], \"Match operation, but characters are not equal\");\n                ix += 1;\n                iy += 1;\n            }\n            Subst =\u003e {\n                assert!(x[ix] != y[iy], \"Subst operation, but characters are equal\");\n                calc_dist += 1;\n                ix += 1;\n                iy += 1;\n            }\n            Del =\u003e {\n                calc_dist += 1;\n                iy += 1;\n            }\n            Ins =\u003e {\n                calc_dist += 1;\n                ix += 1;\n            }\n            _ =\u003e unreachable!()\n        }\n    }\n\n    assert_eq!(calc_dist, aln.score as usize);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","alignment","distance.rs"],"content":"// Copyright 2015-2017 Vadim Nazarov, Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Various subroutines for computing a distance between sequences. Features\n//! both scalar and efficient vectorized distance functions with SIMD.\n\nuse std::cmp::min;\n\nuse crate::utils::TextSlice;\n\n/// Compute the Hamming distance between two strings. Complexity: O(n).\n///\n/// # Example\n///\n/// ```\n/// use bio::alignment::distance::*;\n///\n/// let x = b\"GTCTGCATGCG\";\n/// let y = b\"TTTAGCTAGCG\";\n/// // GTCTGCATGCG\n/// //  |  ||  |||\n/// // TTTAGCTAGCG\n/// assert_eq!(hamming(x, y), 5);\n/// ```\npub fn hamming(alpha: TextSlice\u003c'_\u003e, beta: TextSlice\u003c'_\u003e) -\u003e u64 {\n    assert_eq!(\n        alpha.len(),\n        beta.len(),\n        \"hamming distance cannot be calculated for texts of different length ({}!={})\",\n        alpha.len(),\n        beta.len()\n    );\n    let mut dist = 0;\n    for (a, b) in alpha.iter().zip(beta) {\n        if a != b {\n            dist += 1;\n        }\n    }\n    dist\n}\n\n/// Compute the Levenshtein (or Edit) distance between two strings. Complexity: O(n * m) with\n/// n and m being the length of the given texts.\n///\n/// # Example\n///\n/// ```\n/// use bio::alignment::distance::*;\n///\n/// let x = b\"ACCGTGGAT\";\n/// let y = b\"AAAAACCGTTGAT\";\n/// // ----ACCGTGGAT\n/// //     ||||| |||\n/// // AAAAACCGTTGAT\n/// let ldist = levenshtein(x, y); // Distance is 5\n/// assert_eq!(ldist, 5);\n/// ```\n#[allow(unused_assignments)]\npub fn levenshtein(alpha: TextSlice\u003c'_\u003e, beta: TextSlice\u003c'_\u003e) -\u003e u32 {\n    let mut columns = [vec![0u32; alpha.len() + 1], vec![0u32; alpha.len() + 1]];\n    let mut i_prev = 0;\n    let mut i_cur = 1;\n\n    for i in 0..columns[0].len() {\n        columns[0][i] = i as u32;\n    }\n\n    for (j, item) in beta.iter().enumerate() {\n        i_cur %= 2;\n        i_prev = 1 - i_cur;\n\n        columns[i_cur][0] = 1 + j as u32;\n        for i in 1..columns[0].len() {\n            columns[i_cur][i] = min(\n                columns[i_prev][i - 1] + if alpha[i - 1] == *item { 0 } else { 1 },\n                min(columns[i_cur][i - 1] + 1, columns[i_prev][i] + 1),\n            );\n        }\n\n        i_cur += 1;\n    }\n\n    columns[i_cur - 1][columns[0].len() - 1]\n}\n\npub mod simd {\n    //! String distance routines accelerated with Single Instruction Multiple Data (SIMD)\n    //! intrinsics.\n    //!\n    //! These routines will automatically fallback to scalar versions if AVX2 or SSE4.1 is\n    //! not supported by the CPU.\n    //!\n    //! With AVX2, SIMD-accelerated Hamming distance can reach up to 40 times faster than\n    //! the scalar version on strings that are long enough.\n    //!\n    //! The performance of SIMD-accelerated Levenshtein distance depends on the number of\n    //! edits between two strings, so it can perform anywhere from 2 times to nearly 1000\n    //! times faster than the scalar version. When the two strings are completely different,\n    //! there could be no speedup at all. It is important to note that the algorithms work\n    //! best when the number of edits is known to be small compared to the length of the\n    //! strings (for example, 10% difference). This should be applicable in many situations.\n    //!\n    //! If AVX2 support is not available, there is a speed penalty for using SSE4.1 with\n    //! smaller vectors.\n\n    use crate::utils::TextSlice;\n\n    /// SIMD-accelerated Hamming distance between two strings. Complexity: O(n / w), for\n    /// SIMD vectors of length w (usually w = 16 or w = 32).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alignment::distance::simd::*;\n    ///\n    /// let x = b\"GTCTGCATGCG\";\n    /// let y = b\"TTTAGCTAGCG\";\n    /// // GTCTGCATGCG\n    /// //  |  ||  |||\n    /// // TTTAGCTAGCG\n    /// assert_eq!(hamming(x, y), 5);\n    /// ```\n    pub fn hamming(alpha: TextSlice\u003c'_\u003e, beta: TextSlice\u003c'_\u003e) -\u003e u64 {\n        assert_eq!(\n            alpha.len(),\n            beta.len(),\n            \"simd hamming distance cannot be calculated for texts of different length ({}!={})\",\n            alpha.len(),\n            beta.len()\n        );\n        // triple_accel Hamming routine returns an u32\n        triple_accel::hamming(alpha, beta) as u64\n    }\n\n    /// SIMD-accelerated Levenshtein (or Edit) distance between two strings. Complexity:\n    /// O(k / w * (n + m)), with n and m being the length of the given texts, k being the\n    /// number of edits, and w being the length of the SIMD vectors (usually w = 16 or\n    /// w = 32).\n    ///\n    /// Uses exponential search, which is approximately two times slower than the usual\n    /// O(n * m) implementation if the number of edits between the two strings is very large,\n    /// but much faster for cases where the edit distance is low (when less than half of the\n    /// characters in the strings differ).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alignment::distance::simd::*;\n    ///\n    /// let x = b\"ACCGTGGAT\";\n    /// let y = b\"AAAAACCGTTGAT\";\n    /// // ----ACCGTGGAT\n    /// //     ||||| |||\n    /// // AAAAACCGTTGAT\n    /// let ldist = levenshtein(x, y); // Distance is 5\n    /// assert_eq!(ldist, 5);\n    /// ```\n    pub fn levenshtein(alpha: TextSlice\u003c'_\u003e, beta: TextSlice\u003c'_\u003e) -\u003e u32 {\n        triple_accel::levenshtein_exp(alpha, beta)\n    }\n\n    /// SIMD-accelerated bounded Levenshtein (or Edit) distance between two strings.\n    /// Complexity: O(k / w * (n + m)), with n and m being the length of the given texts,\n    /// k being the threshold on the number of edits, and w being the length of the SIMD vectors\n    /// (usually w = 16 or w = 32).\n    ///\n    /// If the Levenshtein distance between two strings is greater than the threshold k, then\n    /// `None` is returned. This is useful for efficiently calculating whether two strings\n    /// are similar.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alignment::distance::simd::*;\n    ///\n    /// let x = b\"ACCGTGGAT\";\n    /// let y = b\"AAAAACCGTTGAT\";\n    /// // ----ACCGTGGAT\n    /// //     ||||| |||\n    /// // AAAAACCGTTGAT\n    /// let ldist = bounded_levenshtein(x, y, 5); // Distance is 5\n    /// assert_eq!(ldist, Some(5));\n    ///\n    /// let ldist = bounded_levenshtein(x, y, 4); // Threshold too low!\n    /// assert_eq!(ldist, None);\n    /// ```\n    pub fn bounded_levenshtein(alpha: TextSlice\u003c'_\u003e, beta: TextSlice\u003c'_\u003e, k: u32) -\u003e Option\u003cu32\u003e {\n        triple_accel::levenshtein::levenshtein_simd_k(alpha, beta, k)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use std::u32;\n\n    #[test]\n    fn test_hamming_dist_good() {\n        let x = b\"GTCTGCATGCG\";\n        let y = b\"TTTAGCTAGCG\";\n        // GTCTGCATGCG\n        //  |  ||  |||\n        // TTTAGCTAGCG\n        assert_eq!(hamming(x, y), 5);\n    }\n\n    #[test]\n    fn test_simd_hamming_dist_good() {\n        let x = b\"GTCTGCATGCG\";\n        let y = b\"TTTAGCTAGCG\";\n        // GTCTGCATGCG\n        //  |  ||  |||\n        // TTTAGCTAGCG\n        assert_eq!(simd::hamming(x, y), 5);\n    }\n\n    #[test]\n    #[should_panic(\n        expected = \"hamming distance cannot be calculated for texts of different length (11!=8)\"\n    )]\n    fn test_hamming_dist_bad() {\n        let x = b\"GACTATATCGA\";\n        let y = b\"TTTAGCTC\";\n        hamming(x, y);\n    }\n\n    #[test]\n    #[should_panic(\n        expected = \"simd hamming distance cannot be calculated for texts of different length (11!=8)\"\n    )]\n    fn test_simd_hamming_dist_bad() {\n        let x = b\"GACTATATCGA\";\n        let y = b\"TTTAGCTC\";\n        simd::hamming(x, y);\n    }\n\n    #[test]\n    fn test_levenshtein_dist() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        // ----ACCGTGGAT\n        //     ||||| |||\n        // AAAAACCGTTGAT\n        assert_eq!(levenshtein(x, y), 5);\n        assert_eq!(levenshtein(x, y), levenshtein(y, x));\n        assert_eq!(levenshtein(b\"AAA\", b\"TTTT\"), 4);\n        assert_eq!(levenshtein(b\"TTTT\", b\"AAA\"), 4);\n    }\n\n    #[test]\n    fn test_simd_levenshtein_dist() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        // ----ACCGTGGAT\n        //     ||||| |||\n        // AAAAACCGTTGAT\n        assert_eq!(simd::levenshtein(x, y), 5);\n        assert_eq!(simd::levenshtein(x, y), simd::levenshtein(y, x));\n        assert_eq!(simd::levenshtein(b\"AAA\", b\"TTTT\"), 4);\n        assert_eq!(simd::levenshtein(b\"TTTT\", b\"AAA\"), 4);\n    }\n\n    #[test]\n    fn test_simd_bounded_levenshtein_dist() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        // ----ACCGTGGAT\n        //     ||||| |||\n        // AAAAACCGTTGAT\n        assert_eq!(simd::bounded_levenshtein(x, y, u32::MAX), Some(5));\n        assert_eq!(\n            simd::bounded_levenshtein(x, y, u32::MAX),\n            simd::bounded_levenshtein(y, x, u32::MAX)\n        );\n        assert_eq!(\n            simd::bounded_levenshtein(b\"AAA\", b\"TTTT\", u32::MAX),\n            Some(4)\n        );\n        assert_eq!(\n            simd::bounded_levenshtein(b\"TTTT\", b\"AAA\", u32::MAX),\n            Some(4)\n        );\n    }\n}\n","traces":[{"line":27,"address":[4969712],"length":1,"stats":{"Line":1},"fn_name":"hamming"},{"line":28,"address":[4969997,4969809,4969951],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[4969771],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[4969795],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[4969959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[4969983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[4969908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4970314,4970621,4969920,4970626,4970450],"length":1,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[4970514,4970589],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[4970552,4970591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4971095,4970640],"length":1,"stats":{"Line":1},"fn_name":"levenshtein"},{"line":62,"address":[4970711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[4971041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[4971053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[4971065,4971492,4971240,4971397,4971118],"length":1,"stats":{"Line":5},"fn_name":null},{"line":67,"address":[4971437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[4971364,4971741,4973474,4971513],"length":1,"stats":{"Line":4},"fn_name":null},{"line":71,"address":[4971821],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[4971841,4971912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[4971945,4971893],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[4972111,4973453,4972378],"length":1,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[4973317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4972418,4972875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[4972846,4972924],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[4973479,4972342,4973466],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[4971705,4973520],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[9087168],"length":1,"stats":{"Line":2},"fn_name":"hamming"},{"line":126,"address":[9087427,9087262,9087381],"length":1,"stats":{"Line":4},"fn_name":null},{"line":127,"address":[9087227],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[9087248],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[9087389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[9087413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[9087728,9087356],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[9087744],"length":1,"stats":{"Line":1},"fn_name":"levenshtein"},{"line":161,"address":[9087768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":189,"address":[9087792],"length":1,"stats":{"Line":1},"fn_name":"bounded_levenshtein"},{"line":190,"address":[9087821],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[4483104],"length":1,"stats":{"Line":3},"fn_name":"test_hamming_dist_good"},{"line":202,"address":[4483111],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[4483123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[4483135,4483253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[4483296],"length":1,"stats":{"Line":3},"fn_name":"test_simd_hamming_dist_good"},{"line":212,"address":[4483303],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[4483315],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[4483327,4483445],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[4483488],"length":1,"stats":{"Line":3},"fn_name":"test_hamming_dist_bad"},{"line":225,"address":[4483492],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[4483504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[4483516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[4483552],"length":1,"stats":{"Line":3},"fn_name":"test_simd_hamming_dist_bad"},{"line":235,"address":[4483556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[4483568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[4483580],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[4483616],"length":1,"stats":{"Line":3},"fn_name":"test_levenshtein_dist"},{"line":242,"address":[4483623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[4483638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[4483653,4483804],"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[4483756,4483843,4484014],"length":1,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[4483966,4484062,4484195],"length":1,"stats":{"Line":2},"fn_name":null},{"line":250,"address":[4484243,4484147,4484344],"length":1,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[4484400],"length":1,"stats":{"Line":3},"fn_name":"test_simd_levenshtein_dist"},{"line":255,"address":[4484407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[4484422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[4484437,4484588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[4484627,4484540,4484798],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[4484979,4484750,4484846],"length":1,"stats":{"Line":2},"fn_name":null},{"line":263,"address":[4485128,4485027,4484931],"length":1,"stats":{"Line":2},"fn_name":null},{"line":267,"address":[4485184],"length":1,"stats":{"Line":3},"fn_name":"test_simd_bounded_levenshtein_dist"},{"line":268,"address":[4485191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[4485206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[4485237,4485388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[4485478,4485632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":275,"address":[4485327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[4485429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[4485676,4485829],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[4485571],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[4485981,4485873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[4485768],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":78,"coverable":78},{"path":["/","home","todd","rust-bio","src","alignment","mod.rs"],"content":"// Copyright 2014-2015 Johannes Köster, Vadim Nazarov, Patrick Marks\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Various alignment and distance computing algorithms.\n\npub mod distance;\npub mod pairwise;\npub mod poa;\npub mod sparse;\n\n// Re-export the alignment types.\npub use bio_types::alignment::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","alignment","pairwise","banded.rs"],"content":"// Copyright 2014-2015 Johannes Köster, Vadim Nazarov, Patrick Marks\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Banded Smith-Waterman alignment for fast comparison of long strings.\n//! Use sparse dynamic programming to find a 'backbone' alignment from exact\n//! k-mer matches, then compute the SW alignment in a 'band' surrounding the\n//! backbone, with a configurable width w. This method is not guaranteed\n//! to recover the Smith-Waterman alignment, but will usually find the same\n//! alignment if a) there is a reasonable density of exact k-mer matches\n//! between the sequences, and b) the width parameter w is larger than the\n//! excursion of the alignment path from diagonal between successive kmer\n//! matches.  This technique is employed in long-read aligners (e.g. BLASR and BWA)\n//! to drastically reduce runtime compared to Smith Waterman.\n//! Complexity roughly O(min(m,n) * w)\n//!\n//! # Example\n//!\n//! ```\n//! use bio::alignment::pairwise::banded::*;\n//! use bio::alignment::pairwise::{Scoring, MIN_SCORE};\n//! use bio::alignment::sparse::hash_kmers;\n//! use bio::alignment::AlignmentOperation::*;\n//! use std::iter::repeat;\n//!\n//! let x = b\"AGCACACGTGTGCGCTATACAGTAAGTAGTAGTACACGTGTCACAGTTGTACTAGCATGAC\";\n//! let y = b\"AGCACACGTGTGCGCTATACAGTACACGTGTCACAGTTGTACTAGCATGAC\";\n//! let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n//! let k = 8; // kmer match length\n//! let w = 6; // Window size for creating the band\n//! let mut aligner = Aligner::new(-5, -1, score, k, w);\n//! let alignment = aligner.local(x, y);\n//! // aligner.global(x, y), aligner.semiglobal(x, y) are also supported\n//! assert_eq!(alignment.ystart, 0);\n//! assert_eq!(alignment.xstart, 0);\n//!\n//! // For cases where the reference is reused multiple times, we can invoke the\n//! // pre-hashed version of the solver\n//! let x = b\"AGCACAAGTGTGCGCTATACAGGAAGTAGGAGTACACGTGTCA\";\n//! let y = b\"CAGTTGTACTAGCATGACCAGTTGTACTAGCATGACAGCACACGTGTGCGCTATACAGTAAGTAGTAGTACACGTGTCA\\\n//!     CAGTTGTACTAGCATGACCAGTTGTACTAGCATGAC\";\n//! let y_kmers_hash = hash_kmers(y, k);\n//! let alignment = aligner.semiglobal_with_prehash(x, y, \u0026y_kmers_hash);\n//! assert_eq!(alignment.score, 37);\n//!\n//! // In addition to the standard modes (Global, Semiglobal and Local), a custom alignment\n//! // mode is supported which supports a user-specified clipping penalty. Clipping is a\n//! // special boundary condition where you are allowed to clip off the beginning/end of\n//! // the sequence for a fixed penalty. See bio::alignment::pairwise for a more detailed\n//! // explanation\n//!\n//! // The following example considers a modification of the semiglobal mode where you are allowed\n//! // to skip a prefix of the target sequence x, for a penalty of -10, but you have to consume\n//! // the rest of the string in the alignment\n//!\n//! let scoring = Scoring {\n//!     gap_open: -5,\n//!     gap_extend: -1,\n//!     match_fn: |a: u8, b: u8| if a == b { 1i32 } else { -3i32 },\n//!     match_scores: Some((1, -3)),\n//!     xclip_prefix: -10,\n//!     xclip_suffix: MIN_SCORE,\n//!     yclip_prefix: 0,\n//!     yclip_suffix: 0,\n//! };\n//! let x = b\"GGGGGGACGTACGTACGTGTGCATCATCATGTGCGTATCATAGATAGATGTAGATGATCCACAGT\";\n//! let y = b\"AAAAACGTACGTACGTGTGCATCATCATGTGCGTATCATAGATAGATGTAGATGATCCACAGTAAAA\";\n//! let mut aligner = Aligner::with_capacity_and_scoring(x.len(), y.len(), scoring, k, w);\n//! let alignment = aligner.custom(x, y);\n//! println!(\"{}\", alignment.pretty(x, y));\n//! assert_eq!(alignment.score, 49);\n//! let mut correct_ops = Vec::new();\n//! correct_ops.push(Yclip(4));\n//! correct_ops.push(Xclip(6));\n//! correct_ops.extend(repeat(Match).take(59));\n//! correct_ops.push(Yclip(4));\n//! assert_eq!(alignment.operations, correct_ops);\n//!\n//! // aligner.custom_with_prehash(x, y, \u0026y_kmers_hash) is also supported\n//! ```\n\nuse crate::alignment::{Alignment, AlignmentOperation};\nuse crate::utils::TextSlice;\nuse std::cmp::{max, min, Ordering};\nuse std::i32;\nuse std::ops::Range;\n\nuse super::*;\nuse crate::alignment::pairwise::Scoring;\nuse crate::alignment::sparse;\nuse crate::alignment::sparse::HashMapFx;\n\nconst MAX_CELLS: usize = 5_000_000;\nconst DEFAULT_MATCH_SCORE: i32 = 2;\n\n/// A banded implementation of Smith-Waterman aligner (SWA).\n/// Unlike the full SWA, this implementation computes the alignment between a pair of sequences\n/// only inside a 'band' withing the dynamic programming matrix. The band is constructed using the\n/// Sparse DP routine (see sparse::sdpkpp), which uses kmer matches to build the best common\n/// subsequence (including gap penalties) between the two strings. The band is constructed around\n/// this subsequence (using the window length 'w'), filling in the gaps.\n///\n/// In the case where there are no k-mer matches, the  aligner will fall back to a full alignment,\n/// by setting the band to contain the full matrix.\n///\n/// Banded aligner will proceed to compute the alignment only when the total number of cells\n/// in the band is less than MAX_CELLS (currently set to 10 million), otherwise it returns an\n/// empty alignment\n#[allow(non_snake_case)]\npub struct Aligner\u003cF: MatchFunc\u003e {\n    S: [Vec\u003ci32\u003e; 2],\n    I: [Vec\u003ci32\u003e; 2],\n    D: [Vec\u003ci32\u003e; 2],\n    Lx: Vec\u003cusize\u003e,\n    Ly: Vec\u003cusize\u003e,\n    Sn: Vec\u003ci32\u003e,\n    traceback: Traceback,\n    scoring: Scoring\u003cF\u003e,\n\n    band: Band,\n    k: usize,\n    w: usize,\n}\n\nconst DEFAULT_ALIGNER_CAPACITY: usize = 200;\n\nimpl\u003cF: MatchFunc\u003e Aligner\u003cF\u003e {\n    /// Create new aligner instance with given gap open and gap extend penalties\n    /// and the score function.\n    ///\n    /// # Arguments\n    ///\n    /// * `gap_open` - the score for opening a gap (should be negative)\n    /// * `gap_extend` - the score for extending a gap (should be negative)\n    /// * `match_fn` - function that returns the score for substitutions (also see bio::scores)\n    /// * `k` - kmer length used in constructing the band\n    /// * `w` - width of the band\n    pub fn new(gap_open: i32, gap_extend: i32, match_fn: F, k: usize, w: usize) -\u003e Self {\n        Aligner::with_capacity(\n            DEFAULT_ALIGNER_CAPACITY,\n            DEFAULT_ALIGNER_CAPACITY,\n            gap_open,\n            gap_extend,\n            match_fn,\n            k,\n            w,\n        )\n    }\n\n    /// Create new aligner instance. The size hints help to\n    /// avoid unnecessary memory allocations.\n    ///\n    /// # Arguments\n    ///\n    /// * `m` - the expected size of x\n    /// * `n` - the expected size of y\n    /// * `gap_open` - the score for opening a gap (should be negative)\n    /// * `gap_extend` - the score for extending a gap (should be negative)\n    /// * `match_fn` - function that returns the score for substitutions (also see bio::scores)\n    /// * `k` - kmer length used in constructing the band\n    /// * `w` - width of the band\n    pub fn with_capacity(\n        m: usize,\n        n: usize,\n        gap_open: i32,\n        gap_extend: i32,\n        match_fn: F,\n        k: usize,\n        w: usize,\n    ) -\u003e Self {\n        Aligner {\n            band: Band::new(m, n),\n            S: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            I: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            D: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            Lx: Vec::with_capacity(n + 1),\n            Ly: Vec::with_capacity(m + 1),\n            Sn: Vec::with_capacity(m + 1),\n            traceback: Traceback::with_capacity(m, n),\n            scoring: Scoring::new(gap_open, gap_extend, match_fn),\n            k,\n            w,\n        }\n    }\n\n    /// Create new aligner instance with scoring and size hint. The size hints help to\n    /// avoid unnecessary memory allocations.\n    ///\n    /// # Arguments\n    ///\n    /// * `m` - the expected size of x\n    /// * `n` - the expected size of y\n    /// * `scoring` - the scoring struct\n    /// * `k` - kmer length used in constructing the band\n    /// * `w` - width of the band\n    pub fn with_capacity_and_scoring(\n        m: usize,\n        n: usize,\n        scoring: Scoring\u003cF\u003e,\n        k: usize,\n        w: usize,\n    ) -\u003e Self {\n        assert!(scoring.gap_open \u003c= 0, \"gap_open can't be positive\");\n        assert!(scoring.gap_extend \u003c= 0, \"gap_extend can't be positive\");\n        assert!(\n            scoring.xclip_prefix \u003c= 0,\n            \"Clipping penalty (x prefix) can't be positive\"\n        );\n        assert!(\n            scoring.xclip_suffix \u003c= 0,\n            \"Clipping penalty (x suffix) can't be positive\"\n        );\n        assert!(\n            scoring.yclip_prefix \u003c= 0,\n            \"Clipping penalty (y prefix) can't be positive\"\n        );\n        assert!(\n            scoring.yclip_suffix \u003c= 0,\n            \"Clipping penalty (y suffix) can't be positive\"\n        );\n\n        Aligner {\n            band: Band::new(m, n),\n            S: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            I: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            D: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            Lx: Vec::with_capacity(n + 1),\n            Ly: Vec::with_capacity(m + 1),\n            Sn: Vec::with_capacity(m + 1),\n            traceback: Traceback::with_capacity(m, n),\n            scoring,\n            k,\n            w,\n        }\n    }\n\n    /// Create new aligner instance with scoring and size hint. The size hints help to\n    /// avoid unnecessary memory allocations.\n    ///\n    /// # Arguments\n    ///\n    /// * `m` - the expected size of x\n    /// * `n` - the expected size of y\n    /// * `scoring` - the scoring struct\n    /// * `k` - kmer length used in constructing the band\n    /// * `w` - width of the band\n    pub fn with_scoring(scoring: Scoring\u003cF\u003e, k: usize, w: usize) -\u003e Self {\n        Aligner::with_capacity_and_scoring(\n            DEFAULT_ALIGNER_CAPACITY,\n            DEFAULT_ALIGNER_CAPACITY,\n            scoring,\n            k,\n            w,\n        )\n    }\n\n    /// Return a mutable reference to scoring. Useful if you want to have a\n    /// single aligner object but want to modify the scores within it for\n    /// different cases\n    pub fn get_mut_scoring(\u0026mut self) -\u003e \u0026mut Scoring\u003cF\u003e {\n        \u0026mut self.scoring\n    }\n\n    /// Compute the alignment with custom clip penalties\n    ///\n    /// # Arguments\n    ///\n    /// * `x` - Textslice\n    /// * `y` - Textslice\n    pub fn custom(\u0026mut self, x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) -\u003e Alignment {\n        self.band = Band::create(x, y, self.k, self.w, \u0026self.scoring);\n        self.compute_alignment(x, y)\n    }\n\n    /// Compute the alignment with custom clip penalties with 'y' being pre-hashed\n    /// (see sparse::hash_kmers)\n    ///\n    /// # Arguments\n    ///\n    /// * `x` - Textslice\n    /// * `y` - Textslice\n    pub fn custom_with_prehash(\n        \u0026mut self,\n        x: TextSlice\u003c'_\u003e,\n        y: TextSlice\u003c'_\u003e,\n        y_kmer_hash: \u0026HashMapFx\u003c\u0026[u8], Vec\u003cu32\u003e\u003e,\n    ) -\u003e Alignment {\n        self.band = Band::create_with_prehash(x, y, self.k, self.w, \u0026self.scoring, y_kmer_hash);\n        self.compute_alignment(x, y)\n    }\n\n    /// Compute the alignment with custom clip penalties with the kmer matches\n    /// between x and y being pre-computed as a Vector of pairs (xpos, ypos)\n    /// and sorted.\n    ///\n    /// # Arguments\n    ///\n    /// * `x` - Textslice\n    /// * `y` - Textslice\n    /// * `matches` - Vector of kmer matching pairs (xpos, ypos)\n    pub fn custom_with_matches(\n        \u0026mut self,\n        x: TextSlice\u003c'_\u003e,\n        y: TextSlice\u003c'_\u003e,\n        matches: \u0026[(u32, u32)],\n    ) -\u003e Alignment {\n        self.band = Band::create_with_matches(x, y, self.k, self.w, \u0026self.scoring, \u0026matches);\n        self.compute_alignment(x, y)\n    }\n\n    /// Compute the alignment with custom clip penalties with the kmer matches\n    /// between x and y being pre-computed as a Vector of pairs (xpos, ypos)\n    /// and sorted. The matches are expanded diagonally in both directions\n    /// allowing upto a user specified number of mismatches. This is useful\n    /// in constructing the band correctly, particularly when a higher frequency\n    /// of mismatches are expected.\n    ///\n    /// # Arguments\n    ///\n    /// * `x` - Textslice\n    /// * `y` - Textslice\n    /// * `matches` - Vector of kmer matching pairs (xpos, ypos)\n    /// * `allowed_mismatches` - Extend the matches diagonally allowing upto\n    /// the specified number of mismatches (Option\u003cusize\u003e)\n    /// * `use_lcskpp_union` - Extend the results from sdpkpp using lcskpp\n    pub fn custom_with_expanded_matches(\n        \u0026mut self,\n        x: TextSlice\u003c'_\u003e,\n        y: TextSlice\u003c'_\u003e,\n        matches: Vec\u003c(u32, u32)\u003e,\n        allowed_mismatches: Option\u003cusize\u003e,\n        use_lcskpp_union: bool,\n    ) -\u003e Alignment {\n        let expanded_matches = match allowed_mismatches {\n            Some(m) =\u003e sparse::expand_kmer_matches(x, y, self.k, \u0026matches, m),\n            None =\u003e matches,\n        };\n\n        self.band = if use_lcskpp_union {\n            let match_score = match self.scoring.match_scores {\n                Some((m, _)) =\u003e m,\n                None =\u003e DEFAULT_MATCH_SCORE,\n            };\n            let path = sparse::sdpkpp_union_lcskpp_path(\n                \u0026expanded_matches,\n                self.k,\n                match_score as u32,\n                self.scoring.gap_open,\n                self.scoring.gap_extend,\n            );\n            Band::create_from_match_path(\n                x,\n                y,\n                self.k,\n                self.w,\n                \u0026self.scoring,\n                \u0026path,\n                \u0026expanded_matches,\n            )\n        } else {\n            Band::create_with_matches(x, y, self.k, self.w, \u0026self.scoring, \u0026expanded_matches)\n        };\n\n        self.compute_alignment(x, y)\n    }\n\n    /// Compute the alignment with custom clip penalties by constructing\n    /// a band along the `matches` as defined by `path`. This is only\n    /// for advanced uses, where one would want to control the kmer\n    /// backbone that is used for creating the band.\n    ///\n    /// # Arguments\n    ///\n    /// * `x` - Textslice\n    /// * `y` - Textslice\n    /// * `matches` - Vector of kmer matching pairs (xpos, ypos)\n    /// * `path` - Vector of indices pointing to `matches` vector\n    /// which defines a path. The validity of the path is not checked.\n    pub fn custom_with_match_path(\n        \u0026mut self,\n        x: TextSlice,\n        y: TextSlice,\n        matches: \u0026[(u32, u32)],\n        path: \u0026[usize],\n    ) -\u003e Alignment {\n        self.band =\n            Band::create_from_match_path(x, y, self.k, self.w, \u0026self.scoring, path, matches);\n        self.compute_alignment(x, y)\n    }\n\n    // Computes the alignment. The band needs to be populated prior\n    // to calling this function\n    #[inline(never)]\n    fn compute_alignment(\u0026mut self, x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) -\u003e Alignment {\n        if self.band.num_cells() \u003e MAX_CELLS {\n            // Too many cells in the band. Return an empty alignment\n            return Alignment {\n                score: MIN_SCORE,\n                ystart: 0,\n                xstart: 0,\n                yend: 0,\n                xend: 0,\n                ylen: 0,\n                xlen: 0,\n                operations: Vec::new(),\n                mode: AlignmentMode::Custom,\n            };\n        }\n\n        let (m, n) = (x.len(), y.len());\n        self.traceback.init(m, n);\n\n        for k in 0..2 {\n            self.I[k].clear();\n            self.D[k].clear();\n            self.S[k].clear();\n            self.D[k].extend(repeat(MIN_SCORE).take(m + 1));\n            self.I[k].extend(repeat(MIN_SCORE).take(m + 1));\n            self.S[k].extend(repeat(MIN_SCORE).take(m + 1));\n        }\n        self.Lx.clear();\n        self.Lx.extend(repeat(0usize).take(n + 1));\n        self.Ly.clear();\n        self.Ly.extend(repeat(0usize).take(m + 1));\n        self.Sn.clear();\n        self.Sn.extend(repeat(MIN_SCORE).take(m + 1));\n\n        {\n            // Handle j = 0\n            let curr = 0;\n            let i_start = self.band.ranges[0].start;\n            let i_end = self.band.ranges[0].end;\n            if i_start == 0 {\n                self.S[curr][0] = 0;\n            }\n\n            for i in max(1, i_start)..i_end {\n                let mut tb = TracebackCell::new();\n                tb.set_all(TB_START);\n                if i == 1 {\n                    self.I[curr][i] = self.scoring.gap_open + self.scoring.gap_extend;\n                    tb.set_i_bits(TB_START);\n                } else {\n                    // Insert all i characters\n                    let i_score = self.scoring.gap_open + self.scoring.gap_extend * (i as i32);\n                    let c_score =\n                        self.scoring.xclip_prefix + self.scoring.gap_open + self.scoring.gap_extend; // Clip then insert\n                    if i_score \u003e c_score {\n                        self.I[curr][i] = i_score;\n                        tb.set_i_bits(TB_INS);\n                    } else {\n                        self.I[curr][i] = c_score;\n                        tb.set_i_bits(TB_XCLIP_PREFIX);\n                    }\n                }\n\n                if i == m {\n                    tb.set_s_bits(TB_XCLIP_SUFFIX);\n                }\n\n                if self.I[curr][i] \u003e self.S[curr][i] {\n                    self.S[curr][i] = self.I[curr][i];\n                    tb.set_s_bits(TB_INS);\n                }\n\n                if self.scoring.xclip_prefix \u003e self.S[curr][i] {\n                    self.S[curr][i] = self.scoring.xclip_prefix;\n                    tb.set_s_bits(TB_XCLIP_PREFIX);\n                }\n\n                // Track the score if we do a suffix clip (x) after this character\n                if self.S[curr][i] + self.scoring.xclip_suffix \u003e self.S[curr][m] {\n                    self.S[curr][m] = self.S[curr][i] + self.scoring.xclip_suffix;\n                    self.Lx[0] = m - i;\n                    self.traceback.get_mut(m, 0).set_s_bits(TB_XCLIP_SUFFIX);\n                }\n\n                self.traceback.set(i, 0, tb);\n            }\n\n            for i in i_end..min(m + 1, self.band.ranges[min(n, 1)].end) {\n                self.S[curr][i] = MIN_SCORE;\n                self.I[curr][i] = MIN_SCORE;\n            }\n\n            if i_end \u003c (m + 1) {\n                self.S[curr][m] = MIN_SCORE;\n            }\n            // Track the score if we do clip (y) from origin\n            if self.scoring.yclip_prefix \u003e self.scoring.yclip_suffix {\n                self.Sn[0] = self.scoring.yclip_prefix;\n                self.traceback.get_mut(0, n).set_s_bits(TB_YCLIP_PREFIX);\n            } else {\n                self.Sn[0] = self.scoring.yclip_suffix;\n                self.Ly[0] = n;\n                self.traceback.get_mut(0, n).set_s_bits(TB_YCLIP_SUFFIX);\n            }\n        }\n\n        for j in 1..=n {\n            let curr = j % 2;\n            let prev = 1 - curr;\n\n            let i_start = self.band.ranges[j].start;\n            let i_end = self.band.ranges[j].end;\n\n            if i_start == 0 {\n                // Handle i = 0\n                let mut tb = TracebackCell::new();\n                self.I[curr][0] = MIN_SCORE;\n\n                if j == 1 {\n                    self.D[curr][0] = self.scoring.gap_open + self.scoring.gap_extend;\n                    tb.set_d_bits(TB_START);\n                } else {\n                    // Delete all j characters\n                    let d_score = self.scoring.gap_open + self.scoring.gap_extend * (j as i32);\n                    let c_score =\n                        self.scoring.yclip_prefix + self.scoring.gap_open + self.scoring.gap_extend;\n                    if d_score \u003e c_score {\n                        self.D[curr][0] = d_score;\n                        tb.set_d_bits(TB_DEL);\n                    } else {\n                        self.D[curr][0] = c_score;\n                        tb.set_d_bits(TB_YCLIP_PREFIX);\n                    }\n                }\n\n                if self.D[curr][0] \u003e self.scoring.yclip_prefix {\n                    self.S[curr][0] = self.D[curr][0];\n                    tb.set_s_bits(TB_DEL);\n                } else {\n                    self.S[curr][0] = self.scoring.yclip_prefix;\n                    tb.set_s_bits(TB_YCLIP_PREFIX);\n                }\n\n                // Track the score if we do suffix clip (y) from here\n                if self.S[curr][0] + self.scoring.yclip_suffix \u003e self.Sn[0] {\n                    self.Sn[0] = self.S[curr][0] + self.scoring.yclip_suffix;\n                    self.Ly[0] = n - j;\n                    self.traceback.get_mut(0, n).set_s_bits(TB_YCLIP_SUFFIX);\n                }\n                self.traceback.set(0, j, tb);\n            }\n\n            for i in i_start.saturating_sub(1)..i_start {\n                self.S[curr][i] = MIN_SCORE;\n                self.I[curr][i] = MIN_SCORE;\n                self.D[curr][i] = MIN_SCORE;\n            }\n            self.S[curr][m] = MIN_SCORE;\n\n            let q = y[j - 1];\n            let xclip_score = self.scoring.xclip_prefix\n                + max(\n                    if j == n {\n                        max(self.scoring.yclip_prefix, self.Sn[0])\n                    } else {\n                        self.scoring.yclip_prefix\n                    },\n                    self.scoring.gap_open + self.scoring.gap_extend * (j as i32),\n                );\n\n            for i in max(1, i_start)..i_end {\n                let p = x[i - 1];\n                let mut tb = TracebackCell::new();\n\n                let m_score = self.S[prev][i - 1] + self.scoring.match_fn.score(p, q);\n\n                let i_score = self.I[curr][i - 1] + self.scoring.gap_extend;\n                let s_score = self.S[curr][i - 1] + self.scoring.gap_open + self.scoring.gap_extend;\n                let mut best_i_score;\n                if i_score \u003e s_score {\n                    best_i_score = i_score;\n                    tb.set_i_bits(TB_INS);\n                } else {\n                    best_i_score = s_score;\n                    tb.set_i_bits(self.traceback.get(i - 1, j).get_s_bits());\n                }\n                if j == n {\n                    let clip_score =\n                        self.Sn[i - 1] + self.scoring.gap_open + self.scoring.gap_extend;\n                    if clip_score \u003e best_i_score {\n                        best_i_score = clip_score;\n                        tb.set_i_bits(TB_YCLIP_SUFFIX);\n                    }\n                }\n\n                let d_score = self.D[prev][i] + self.scoring.gap_extend;\n                let s_score = self.S[prev][i] + self.scoring.gap_open + self.scoring.gap_extend;\n                let best_d_score;\n                if d_score \u003e s_score {\n                    best_d_score = d_score;\n                    tb.set_d_bits(TB_DEL);\n                } else {\n                    best_d_score = s_score;\n                    tb.set_d_bits(self.traceback.get(i, j - 1).get_s_bits());\n                }\n\n                if i == m {\n                    tb.set_s_bits(TB_XCLIP_SUFFIX);\n                } else {\n                    self.S[curr][i] = MIN_SCORE;\n                }\n                let mut best_s_score = self.S[curr][i];\n\n                if m_score \u003e best_s_score {\n                    best_s_score = m_score;\n                    tb.set_s_bits(if p == q { TB_MATCH } else { TB_SUBST });\n                }\n\n                if best_i_score \u003e best_s_score {\n                    best_s_score = best_i_score;\n                    tb.set_s_bits(TB_INS);\n                }\n\n                if best_d_score \u003e best_s_score {\n                    best_s_score = best_d_score;\n                    tb.set_s_bits(TB_DEL);\n                }\n\n                if xclip_score \u003e best_s_score {\n                    best_s_score = xclip_score;\n                    tb.set_s_bits(TB_XCLIP_PREFIX);\n                }\n\n                let yclip_score = self.scoring.yclip_prefix\n                    + self.scoring.gap_open\n                    + self.scoring.gap_extend * (i as i32);\n                if yclip_score \u003e best_s_score {\n                    best_s_score = yclip_score;\n                    tb.set_s_bits(TB_YCLIP_PREFIX);\n                }\n\n                self.S[curr][i] = best_s_score;\n                self.I[curr][i] = best_i_score;\n                self.D[curr][i] = best_d_score;\n\n                // Track the score if we do suffix clip (x) from here\n                if self.S[curr][i] + self.scoring.xclip_suffix \u003e self.S[curr][m] {\n                    self.S[curr][m] = self.S[curr][i] + self.scoring.xclip_suffix;\n                    self.Lx[j] = m - i;\n                    self.traceback.get_mut(m, j).set_s_bits(TB_XCLIP_SUFFIX);\n                }\n\n                // Track the score if we do suffix clip (y) from here\n                if self.S[curr][i] + self.scoring.yclip_suffix \u003e self.Sn[i] {\n                    self.Sn[i] = self.S[curr][i] + self.scoring.yclip_suffix;\n                    self.Ly[i] = n - j;\n                    self.traceback.get_mut(i, n).set_s_bits(TB_YCLIP_SUFFIX);\n                }\n\n                self.traceback.set(i, j, tb);\n            }\n\n            // Suffix clip (y) from i = m and reset Sn[m] if required\n            if self.S[curr][m] + self.scoring.yclip_suffix \u003e self.Sn[m] {\n                self.Sn[m] = self.S[curr][m] + self.scoring.yclip_suffix;\n                self.Ly[m] = n - j;\n                self.traceback.get_mut(m, n).set_s_bits(TB_YCLIP_SUFFIX);\n            }\n            if i_end \u003c (m + 1) {\n                self.traceback.get_mut(m, j).set_s_bits(TB_XCLIP_SUFFIX);\n                self.S[curr][m] = MIN_SCORE;\n            }\n\n            for i in i_end..min(m + 1, self.band.ranges[min(n, j + 1)].end) {\n                self.S[curr][i] = MIN_SCORE;\n                self.I[curr][i] = MIN_SCORE;\n                self.D[curr][i] = MIN_SCORE;\n            }\n        }\n\n        // Handle suffix clipping in the j=n case\n        for i in 0..=m {\n            let j = n;\n            let curr = j % 2;\n            // These entries are not set in the loop above and could contain leftover\n            // values from previous columns. Reset them to MIN_SCORE\n            if i != m \u0026\u0026 (i \u003c self.band.ranges[j].start || i \u003e self.band.ranges[j].end) {\n                self.S[curr][i] = MIN_SCORE;\n            }\n            if self.Sn[i] \u003e self.S[curr][i] {\n                self.S[curr][i] = self.Sn[i];\n                self.traceback.get_mut(i, j).set_s_bits(TB_YCLIP_SUFFIX);\n            }\n            if self.S[curr][i] + self.scoring.xclip_suffix \u003e self.S[curr][m] {\n                self.S[curr][m] = self.S[curr][i] + self.scoring.xclip_suffix;\n                self.Lx[j] = m - i;\n                self.traceback.get_mut(m, j).set_s_bits(TB_XCLIP_SUFFIX);\n            }\n        }\n\n        // Since there could be a change in the last column of S,\n        // recompute the last column of I as this could also change\n        for i in max(1, self.band.ranges[n].start)..self.band.ranges[n].end {\n            let j = n;\n            let curr = j % 2;\n            let s_score = self.S[curr][i - 1] + self.scoring.gap_open + self.scoring.gap_extend;\n            if s_score \u003e self.I[curr][i] {\n                self.I[curr][i] = s_score;\n                let s_bit = self.traceback.get(i - 1, j).get_s_bits();\n                self.traceback.get_mut(i, j).set_i_bits(s_bit);\n            }\n            if s_score \u003e self.S[curr][i] {\n                self.S[curr][i] = s_score;\n                self.traceback.get_mut(i, j).set_s_bits(TB_INS);\n                if self.S[curr][i] + self.scoring.xclip_suffix \u003e self.S[curr][m] {\n                    self.S[curr][m] = self.S[curr][i] + self.scoring.xclip_suffix;\n                    self.Lx[j] = m - i;\n                    self.traceback.get_mut(m, j).set_s_bits(TB_XCLIP_SUFFIX);\n                }\n            }\n        }\n\n        for j in 1..=n {\n            let d_score = self.scoring.gap_open + self.scoring.gap_extend * (j as i32);\n            if d_score \u003e self.scoring.yclip_prefix {\n                self.traceback.get_mut(0, j).set_s_bits(TB_DEL);\n            } else {\n                self.traceback.get_mut(0, j).set_s_bits(TB_YCLIP_PREFIX);\n            }\n            if j == n {\n                let mut best_score = max(d_score, self.scoring.yclip_prefix);\n                if self.scoring.yclip_suffix \u003e best_score {\n                    best_score = self.scoring.yclip_suffix;\n                    self.traceback.get_mut(0, j).set_s_bits(TB_YCLIP_SUFFIX);\n                }\n                if (self.scoring.xclip_suffix + best_score) \u003e self.S[n % 2][m] {\n                    self.S[n % 2][m] = self.scoring.xclip_suffix + best_score;\n                    self.Lx[n] = m;\n                    self.traceback.get_mut(m, n).set_s_bits(TB_XCLIP_SUFFIX);\n                }\n            }\n        }\n\n        for i in 1..=m {\n            let c_score = self.scoring.gap_open + self.scoring.gap_extend * (i as i32);\n            if c_score \u003e self.scoring.xclip_prefix {\n                self.traceback.get_mut(i, 0).set_s_bits(TB_INS);\n            } else {\n                self.traceback.get_mut(i, 0).set_s_bits(TB_XCLIP_PREFIX);\n            }\n            if i == m {\n                let mut best_score = max(c_score, self.scoring.xclip_prefix);\n                if self.scoring.xclip_suffix \u003e best_score {\n                    best_score = self.scoring.xclip_suffix;\n                    self.traceback.get_mut(i, 0).set_s_bits(TB_XCLIP_SUFFIX);\n                }\n                if (self.scoring.yclip_suffix + best_score) \u003e self.S[n % 2][m] {\n                    self.S[n % 2][m] = self.scoring.yclip_suffix + best_score;\n                    self.Ly[m] = n;\n                    self.traceback.get_mut(m, n).set_s_bits(TB_YCLIP_SUFFIX);\n                }\n            }\n        }\n\n        let mut i = m;\n        let mut j = n;\n        let mut operations = Vec::with_capacity(x.len());\n        let mut xstart: usize = 0usize;\n        let mut ystart: usize = 0usize;\n        let mut xend = m;\n        let mut yend = n;\n\n        let mut last_layer = self.traceback.get(i, j).get_s_bits();\n\n        loop {\n            let next_layer: u16;\n            match last_layer {\n                TB_START =\u003e break,\n                TB_INS =\u003e {\n                    operations.push(AlignmentOperation::Ins);\n                    next_layer = self.traceback.get(i, j).get_i_bits();\n                    i -= 1;\n                }\n                TB_DEL =\u003e {\n                    operations.push(AlignmentOperation::Del);\n                    next_layer = self.traceback.get(i, j).get_d_bits();\n                    j -= 1;\n                }\n                TB_MATCH =\u003e {\n                    operations.push(AlignmentOperation::Match);\n                    next_layer = self.traceback.get(i - 1, j - 1).get_s_bits();\n                    i -= 1;\n                    j -= 1;\n                }\n                TB_SUBST =\u003e {\n                    operations.push(AlignmentOperation::Subst);\n                    next_layer = self.traceback.get(i - 1, j - 1).get_s_bits();\n                    i -= 1;\n                    j -= 1;\n                }\n                TB_XCLIP_PREFIX =\u003e {\n                    operations.push(AlignmentOperation::Xclip(i));\n                    xstart = i;\n                    i = 0;\n                    next_layer = self.traceback.get(0, j).get_s_bits();\n                }\n                TB_XCLIP_SUFFIX =\u003e {\n                    operations.push(AlignmentOperation::Xclip(self.Lx[j]));\n                    i -= self.Lx[j];\n                    xend = i;\n                    next_layer = self.traceback.get(i, j).get_s_bits();\n                }\n                TB_YCLIP_PREFIX =\u003e {\n                    operations.push(AlignmentOperation::Yclip(j));\n                    ystart = j;\n                    j = 0;\n                    next_layer = self.traceback.get(i, 0).get_s_bits();\n                }\n                TB_YCLIP_SUFFIX =\u003e {\n                    operations.push(AlignmentOperation::Yclip(self.Ly[i]));\n                    j -= self.Ly[i];\n                    yend = j;\n                    next_layer = self.traceback.get(i, j).get_s_bits();\n                }\n                _ =\u003e panic!(\"Dint expect this!\"),\n            }\n            last_layer = next_layer;\n            // println!(\"{} of {}, {} of {} - {}\", i, m, j, n, last_layer);\n        }\n\n        // Handle the case when the traceback ends outside the band other than at (0, 0)\n        if i != 0 {\n            // Insert all i characters\n            let i_score = self.scoring.gap_open + self.scoring.gap_extend * (i as i32);\n            if i_score \u003e self.scoring.xclip_prefix {\n                operations.resize(operations.len() + i, AlignmentOperation::Ins);\n                xstart = 0;\n            } else {\n                operations.push(AlignmentOperation::Xclip(i));\n                xstart = i;\n            }\n        }\n        if j != 0 {\n            // Delete all j characters\n            let d_score = self.scoring.gap_open + self.scoring.gap_extend * (j as i32);\n            if d_score \u003e self.scoring.yclip_prefix {\n                operations.resize(operations.len() + j, AlignmentOperation::Del);\n                ystart = 0;\n            } else {\n                operations.push(AlignmentOperation::Yclip(j));\n                ystart = j;\n            }\n        }\n\n        operations.reverse();\n        Alignment {\n            score: self.S[n % 2][m],\n            ystart,\n            xstart,\n            yend,\n            xend,\n            ylen: n,\n            xlen: m,\n            operations,\n            mode: AlignmentMode::Custom,\n        }\n    }\n\n    /// Calculate global alignment of x against y.\n    pub fn global(\u0026mut self, x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) -\u003e Alignment {\n        // Store the current clip penalties\n        let clip_penalties = [\n            self.scoring.xclip_prefix,\n            self.scoring.xclip_suffix,\n            self.scoring.yclip_prefix,\n            self.scoring.yclip_suffix,\n        ];\n\n        // Temporarily Over-write the clip penalties\n        self.scoring.xclip_prefix = MIN_SCORE;\n        self.scoring.xclip_suffix = MIN_SCORE;\n        self.scoring.yclip_prefix = MIN_SCORE;\n        self.scoring.yclip_suffix = MIN_SCORE;\n\n        // Compute the alignment\n        let mut alignment = self.custom(x, y);\n        alignment.mode = AlignmentMode::Global;\n\n        // Set the clip penalties to the original values\n        self.scoring.xclip_prefix = clip_penalties[0];\n        self.scoring.xclip_suffix = clip_penalties[1];\n        self.scoring.yclip_prefix = clip_penalties[2];\n        self.scoring.yclip_suffix = clip_penalties[3];\n\n        alignment\n    }\n\n    /// Calculate semiglobal alignment of x against y (x is global, y is local).\n    pub fn semiglobal(\u0026mut self, x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) -\u003e Alignment {\n        // Store the current clip penalties\n        let clip_penalties = [\n            self.scoring.xclip_prefix,\n            self.scoring.xclip_suffix,\n            self.scoring.yclip_prefix,\n            self.scoring.yclip_suffix,\n        ];\n\n        // Temporarily Over-write the clip penalties\n        self.scoring.xclip_prefix = MIN_SCORE;\n        self.scoring.xclip_suffix = MIN_SCORE;\n        self.scoring.yclip_prefix = 0;\n        self.scoring.yclip_suffix = 0;\n\n        // Compute the alignment\n        let mut alignment = self.custom(x, y);\n        alignment.mode = AlignmentMode::Semiglobal;\n\n        // Filter out Xclip and Yclip from alignment.operations\n        alignment.filter_clip_operations();\n\n        // Set the clip penalties to the original values\n        self.scoring.xclip_prefix = clip_penalties[0];\n        self.scoring.xclip_suffix = clip_penalties[1];\n        self.scoring.yclip_prefix = clip_penalties[2];\n        self.scoring.yclip_suffix = clip_penalties[3];\n\n        alignment\n    }\n\n    /// Calculate semiglobal alignment of x against y (x is global, y is local).\n    /// This function accepts the hash map of the kmers of y. This is useful\n    /// in cases where we are interested in repeated alignment of different\n    /// queries against the same reference. The user can precompute the HashMap\n    /// using sparse::hash_kmers and invoke this function to speed up the\n    /// alignment computation.\n    pub fn semiglobal_with_prehash(\n        \u0026mut self,\n        x: TextSlice\u003c'_\u003e,\n        y: TextSlice\u003c'_\u003e,\n        y_kmer_hash: \u0026HashMapFx\u003c\u0026[u8], Vec\u003cu32\u003e\u003e,\n    ) -\u003e Alignment {\n        // Store the current clip penalties\n        let clip_penalties = [\n            self.scoring.xclip_prefix,\n            self.scoring.xclip_suffix,\n            self.scoring.yclip_prefix,\n            self.scoring.yclip_suffix,\n        ];\n\n        // Temporarily Over-write the clip penalties\n        self.scoring.xclip_prefix = MIN_SCORE;\n        self.scoring.xclip_suffix = MIN_SCORE;\n        self.scoring.yclip_prefix = 0;\n        self.scoring.yclip_suffix = 0;\n\n        // Compute the alignment\n        let mut alignment = self.custom_with_prehash(x, y, y_kmer_hash);\n        alignment.mode = AlignmentMode::Semiglobal;\n\n        // Filter out Xclip and Yclip from alignment.operations\n        alignment.filter_clip_operations();\n\n        // Set the clip penalties to the original values\n        self.scoring.xclip_prefix = clip_penalties[0];\n        self.scoring.xclip_suffix = clip_penalties[1];\n        self.scoring.yclip_prefix = clip_penalties[2];\n        self.scoring.yclip_suffix = clip_penalties[3];\n\n        alignment\n    }\n\n    /// Calculate local alignment of x against y.\n    pub fn local(\u0026mut self, x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) -\u003e Alignment {\n        // Store the current clip penalties\n        let clip_penalties = [\n            self.scoring.xclip_prefix,\n            self.scoring.xclip_suffix,\n            self.scoring.yclip_prefix,\n            self.scoring.yclip_suffix,\n        ];\n\n        // Temporarily Over-write the clip penalties\n        self.scoring.xclip_prefix = 0;\n        self.scoring.xclip_suffix = 0;\n        self.scoring.yclip_prefix = 0;\n        self.scoring.yclip_suffix = 0;\n\n        // Compute the alignment\n        let mut alignment = self.custom(x, y);\n        alignment.mode = AlignmentMode::Local;\n\n        // Filter out Xclip and Yclip from alignment.operations\n        alignment.filter_clip_operations();\n\n        // Set the clip penalties to the original values\n        self.scoring.xclip_prefix = clip_penalties[0];\n        self.scoring.xclip_suffix = clip_penalties[1];\n        self.scoring.yclip_prefix = clip_penalties[2];\n        self.scoring.yclip_suffix = clip_penalties[3];\n\n        alignment\n    }\n\n    #[allow(dead_code)]\n    pub fn visualize(\u0026self, alignment: \u0026Alignment) {\n        // First populate the band\n        let mut view = vec!['.'; self.band.rows * self.band.cols];\n        let index = |i, j| i * self.band.cols + j;\n        for j in 0..self.band.ranges.len() {\n            let range = \u0026self.band.ranges[j];\n            for i in range.start..range.end {\n                view[index(i, j)] = 'x';\n            }\n        }\n\n        // Populate the path\n        let path = alignment.path();\n        for p in path {\n            view[index(p.0, p.1)] = '\\\\';\n        }\n\n        for i in 0..self.band.rows {\n            for j in 0..self.band.cols {\n                print!(\"{}\", view[index(i, j)]);\n            }\n            println!();\n        }\n    }\n}\n\ntrait MatchPair {\n    fn continues(\u0026self, p: Option\u003c(u32, u32)\u003e) -\u003e bool;\n}\n\nimpl MatchPair for (u32, u32) {\n    fn continues(\u0026self, p: Option\u003c(u32, u32)\u003e) -\u003e bool {\n        match p {\n            Some(_p) =\u003e (self.0 == _p.0 + 1 \u0026\u0026 self.1 == _p.1 + 1),\n            None =\u003e false,\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct Band {\n    rows: usize,\n    cols: usize,\n    ranges: Vec\u003cRange\u003cusize\u003e\u003e,\n}\n\nimpl Band {\n    // Create new Band instance with given size\n    //\n    // # Arguments\n    //\n    // * `m` - the expected size of x\n    // * `n` - the expected size of y\n    //\n    fn new(m: usize, n: usize) -\u003e Self {\n        Band {\n            rows: m + 1,\n            cols: n + 1,\n            ranges: vec![m + 1..0; n + 1],\n        }\n    }\n\n    // Add cells around a kmer of length 'k', starting at 'start', which are within a\n    // distance of 'w' in x or y directions to the band.\n    fn add_kmer(\u0026mut self, start: (u32, u32), k: usize, w: usize) {\n        let (r, c) = (start.0 as usize, start.1 as usize);\n        // println!(\"{} {} {}\", r, k, self.rows);\n        debug_assert!(r + k \u003c= self.rows);\n        debug_assert!(c + k \u003c= self.cols);\n\n        if k == 0 {\n            return;\n        }\n\n        let i = r.saturating_sub(w);\n        for j in c.saturating_sub(w)..min(c + w + 1, self.cols) {\n            self.ranges[j].start = min(self.ranges[j].start, i);\n        }\n\n        let mut i = r.saturating_sub(w);\n        for j in min(c + w, self.cols)..min(c + k + w, self.cols) {\n            self.ranges[j].start = min(self.ranges[j].start, i);\n            i += 1;\n        }\n\n        let mut i = r + w + k;\n        let mut j = (c + k - 1).saturating_sub(w);\n        loop {\n            if j \u003c= c.saturating_sub(w) {\n                break;\n            }\n            j -= 1;\n            i -= 1;\n            self.ranges[j].end = max(self.ranges[j].end, min(i, self.rows));\n        }\n\n        let i = min(r + w + k, self.rows);\n        for j in (c + k - 1).saturating_sub(w)..min(c + k + w, self.cols) {\n            self.ranges[j].end = max(self.ranges[j].end, i);\n        }\n    }\n\n    // Add cells around a specific position to the band. An cell which is within 'w' distance\n    // in x or y directions are added\n    fn add_entry(\u0026mut self, pos: (u32, u32), w: usize) {\n        let (r, c) = (pos.0 as usize, pos.1 as usize);\n\n        let istart = r.saturating_sub(w);\n        let iend = min(r + w + 1, self.rows);\n        for j in c.saturating_sub(w)..min(c + w + 1, self.cols) {\n            self.ranges[j].start = min(self.ranges[j].start, istart);\n            self.ranges[j].end = max(self.ranges[j].end, iend);\n        }\n    }\n\n    // Each gap generates a line from the start to end.\n    fn add_gap(\u0026mut self, start: (u32, u32), end: (u32, u32), w: usize) {\n        let nrows = end.0 - start.0;\n        let ncols = end.1 - start.1;\n        if nrows \u003e ncols {\n            for r in start.0..end.0 {\n                let c = start.1 + (end.1 - start.1) * (r - start.0) / (end.0 - start.0);\n                self.add_entry((r, c), w);\n            }\n        } else {\n            for c in start.1..end.1 {\n                let r = start.0 + (end.0 - start.0) * (c - start.1) / (end.1 - start.1);\n                self.add_entry((r, c), w);\n            }\n        }\n    }\n\n    // The band needs to start either at (0,0) or at a point that is zero score from (0,0).\n    // This naturally sets the start positions correctly for global, semiglobal and local\n    // modes. Similarly the band has to either end at (m,n) or at a point from which there is\n    // a zero score path to (m,n).\n    //\n    // At the minimum, irrespective of the score (0,0)-\u003estart or end-\u003e(m,n), we extend the band\n    // diagonally for a length \"lazy_extend\"(2k) or when it hits the corner, whichever happens first\n    //\n    // start - the index of the first matching kmer in LCSk++\n    // end - the index of the last matching kmer in LCSk++\n    //\n    fn set_boundaries\u003cF: MatchFunc\u003e(\n        \u0026mut self,\n        start: (u32, u32),\n        end: (u32, u32),\n        k: usize,\n        w: usize,\n        scoring: \u0026Scoring\u003cF\u003e,\n    ) {\n        let lazy_extend: usize = 2 * k;\n\n        // -------------- START --------------\n        // Nothing to do if the start is already at (0,0)\n        let (r, c) = (start.0 as usize, start.1 as usize);\n        if !(r == 0usize \u0026\u0026 c == 0usize) {\n            let mut score_to_start = if r \u003e 0 { scoring.xclip_prefix } else { 0i32 };\n            score_to_start += if c \u003e 0 { scoring.yclip_prefix } else { 0i32 };\n\n            if score_to_start == 0 {\n                // Just do a \"lazy_extend\"\n                // First diagonally\n                let d = min(lazy_extend, min(r, c));\n                self.add_kmer(((r - d) as u32, (c - d) as u32), d, w);\n\n                // If we hit one of the edges before completing lazy_extend\n                self.add_gap(\n                    (\n                        r.saturating_sub(lazy_extend) as u32,\n                        c.saturating_sub(lazy_extend) as u32,\n                    ),\n                    ((r - d) as u32, (c - d) as u32),\n                    w,\n                );\n            } else {\n                // we need to find a zero cost cell\n\n                // First try the diagonal\n                let diagonal_score = match r.cmp(\u0026c) {\n                    // We will hit (r-c, 0)\n                    Ordering::Greater =\u003e scoring.xclip_prefix,\n                    // We will hit (0, c-r)\n                    Ordering::Less =\u003e scoring.yclip_prefix,\n                    Ordering::Equal =\u003e 0,\n                };\n\n                if diagonal_score == 0 {\n                    let d = min(r, c);\n                    self.add_kmer(((r - d) as u32, (c - d) as u32), d, w);\n                    // Make sure we do at least \"lazy_extend\" extension\n                    let start = (\n                        r.saturating_sub(lazy_extend) as u32,\n                        c.saturating_sub(lazy_extend) as u32,\n                    );\n                    let end = ((r - d) as u32, (c - d) as u32);\n                    if (start.0 \u003c= end.0) \u0026\u0026 (start.1 \u003c= end.1) {\n                        self.add_gap(start, end, w);\n                    }\n                } else {\n                    // Band to origin\n                    self.add_gap((0u32, 0u32), start, w);\n                }\n            }\n        }\n\n        // -------------- END --------------\n        // Nothing to do if the last kmer ends at (m, n)\n        let (r, c) = (end.0 as usize + k, end.1 as usize + k);\n        debug_assert!(r \u003c= self.rows);\n        debug_assert!(c \u003c= self.cols);\n        if !(r == self.rows \u0026\u0026 c == self.cols) {\n            let mut score_from_end = if r == self.rows {\n                0\n            } else {\n                scoring.xclip_suffix\n            };\n            score_from_end += if c == self.cols {\n                0\n            } else {\n                scoring.yclip_suffix\n            };\n\n            if score_from_end == 0 {\n                // Just a lazy_extend\n                let d = min(lazy_extend, min(self.rows - r, self.cols - c));\n                self.add_kmer((r as u32, c as u32), d, w);\n\n                let r1 = min(self.rows, r + d) - 1;\n                let c1 = min(self.cols, c + d) - 1;\n                let r2 = min(self.rows, r + lazy_extend);\n                let c2 = min(self.cols, c + lazy_extend);\n                if (r1 \u003c= r2) \u0026\u0026 (c1 \u003c= c2) {\n                    self.add_gap((r1 as u32, c1 as u32), (r2 as u32, c2 as u32), w);\n                }\n            } else {\n                // we need to find a zero cost cell\n\n                // First try the diagonal\n                let dr = self.rows - r;\n                let dc = self.cols - c;\n                let diagonal_score = match dr.cmp(\u0026dc) {\n                    // We will hit (r+dc, self.cols)\n                    Ordering::Greater =\u003e scoring.xclip_suffix,\n                    // We will hit (self.rows, c+dr)\n                    Ordering::Less =\u003e scoring.yclip_suffix,\n                    // We will hit the corner\n                    Ordering::Equal =\u003e 0,\n                };\n\n                if diagonal_score == 0 {\n                    let d = min(dr, dc);\n                    self.add_kmer((r as u32, c as u32), d, w);\n                    // Make sure we do at least \"lazy_extend\" extension\n                    let r1 = min(self.rows, r + d) - 1;\n                    let c1 = min(self.cols, c + d) - 1;\n                    let r2 = min(self.rows, r + lazy_extend);\n                    let c2 = min(self.cols, c + lazy_extend);\n                    if (r1 \u003c= r2) \u0026\u0026 (c1 \u003c= c2) {\n                        self.add_gap((r1 as u32, c1 as u32), (r2 as u32, c2 as u32), w);\n                    }\n                } else {\n                    // Band to lower right corner\n                    let rows = self.rows as u32;\n                    let cols = self.cols as u32;\n                    self.add_gap((r as u32, c as u32), (rows as u32, cols as u32), w);\n                }\n            }\n        }\n    }\n\n    fn create\u003cF: MatchFunc\u003e(\n        x: TextSlice\u003c'_\u003e,\n        y: TextSlice\u003c'_\u003e,\n        k: usize,\n        w: usize,\n        scoring: \u0026Scoring\u003cF\u003e,\n    ) -\u003e Band {\n        let matches = sparse::find_kmer_matches(x, y, k);\n        Band::create_with_matches(x, y, k, w, scoring, \u0026matches)\n    }\n\n    fn create_with_prehash\u003cF: MatchFunc\u003e(\n        x: TextSlice\u003c'_\u003e,\n        y: TextSlice\u003c'_\u003e,\n        k: usize,\n        w: usize,\n        scoring: \u0026Scoring\u003cF\u003e,\n        y_kmer_hash: \u0026HashMapFx\u003c\u0026[u8], Vec\u003cu32\u003e\u003e,\n    ) -\u003e Band {\n        let matches = sparse::find_kmer_matches_seq2_hashed(x, y_kmer_hash, k);\n        Band::create_with_matches(x, y, k, w, scoring, \u0026matches)\n    }\n\n    fn create_with_matches\u003cF: MatchFunc\u003e(\n        x: TextSlice\u003c'_\u003e,\n        y: TextSlice\u003c'_\u003e,\n        k: usize,\n        w: usize,\n        scoring: \u0026Scoring\u003cF\u003e,\n        matches: \u0026[(u32, u32)],\n    ) -\u003e Band {\n        if matches.is_empty() {\n            let mut band = Band::new(x.len(), y.len());\n            band.full_matrix();\n            return band;\n        }\n\n        let match_score = match scoring.match_scores {\n            Some((m, _)) =\u003e m,\n            None =\u003e DEFAULT_MATCH_SCORE,\n        };\n\n        let res = sparse::sdpkpp(\n            matches,\n            k,\n            match_score as u32,\n            scoring.gap_open,\n            scoring.gap_extend,\n        );\n        Band::create_from_match_path(x, y, k, w, scoring, \u0026res.path, \u0026matches)\n    }\n\n    fn create_from_match_path\u003cF: MatchFunc\u003e(\n        x: TextSlice\u003c'_\u003e,\n        y: TextSlice\u003c'_\u003e,\n        k: usize,\n        w: usize,\n        scoring: \u0026Scoring\u003cF\u003e,\n        path: \u0026[usize],\n        matches: \u0026[(u32, u32)],\n    ) -\u003e Band {\n        let mut band = Band::new(x.len(), y.len());\n\n        if matches.is_empty() {\n            band.full_matrix();\n            return band;\n        }\n\n        let ps = path[0];\n        let pe = path[path.len() - 1];\n\n        // Set the boundaries\n        band.set_boundaries(matches[ps], matches[pe], k, w, scoring);\n        let mut prev: Option\u003c(u32, u32)\u003e = None;\n\n        for \u0026idx in path {\n            let curr = matches[idx];\n            if curr.continues(prev) {\n                let p = prev.unwrap();\n                band.add_entry((p.0 + k as u32, p.1 + k as u32), w);\n            } else {\n                if let Some(p) = prev {\n                    band.add_gap((p.0 + (k - 1) as u32, p.1 + (k - 1) as u32), curr, w)\n                }\n                band.add_kmer(curr, k, w);\n            }\n            prev = Some(curr);\n        }\n        band\n    }\n\n    fn full_matrix(\u0026mut self) {\n        self.ranges.clear();\n        self.ranges.resize(self.cols, 0..self.rows);\n    }\n\n    fn num_cells(\u0026self) -\u003e usize {\n        let mut banded_cells = 0;\n        for j in 0..self.ranges.len() {\n            banded_cells += self.ranges[j].end.saturating_sub(self.ranges[j].start);\n        }\n        banded_cells\n    }\n\n    #[allow(dead_code)]\n    fn visualize(\u0026self) {\n        let mut view = vec!['.'; self.rows * self.cols];\n        let index = |i, j| i * self.cols + j;\n        for j in 0..self.ranges.len() {\n            let range = \u0026self.ranges[j];\n            for i in range.start..range.end {\n                view[index(i, j)] = 'x';\n            }\n        }\n\n        for i in 0..self.rows {\n            for j in 0..self.cols {\n                print!(\"{}\", view[index(i, j)]);\n            }\n            println!();\n        }\n    }\n\n    #[allow(dead_code)]\n    fn stat(\u0026self) {\n        let total_cells = self.rows * self.cols;\n        let banded_cells = self.num_cells();\n        let percent_cells = (banded_cells as f64) / (total_cells as f64) * 100.0;\n        println!(\n            \" {} of {} cells are in the band ({2:.2}%)\",\n            banded_cells, total_cells, percent_cells\n        );\n    }\n}\n\n//box creating reverse intervals for test\n\n#[cfg(test)]\nmod banded {\n    use crate::alignment::pairwise::{self, banded, Scoring};\n    use crate::alignment::sparse::hash_kmers;\n    use crate::utils::TextSlice;\n\n    // Check that the banded alignment is equivalent to the exhaustive SW alignment\n    fn compare_to_full_alignment_local(x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) {\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n\n        let mut banded_aligner =\n            banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let banded_alignment = banded_aligner.local(x, y);\n        // banded_aligner.visualize(\u0026banded_alignment);\n\n        let mut full_aligner = pairwise::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let full_alignment = full_aligner.local(x, y);\n\n        assert_eq!(banded_alignment, full_alignment);\n    }\n\n    fn compare_to_full_alignment_global(x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) {\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n\n        let mut banded_aligner =\n            banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let banded_alignment = banded_aligner.global(x, y);\n        banded_aligner.visualize(\u0026banded_alignment);\n\n        let mut full_aligner = pairwise::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let full_alignment = full_aligner.global(x, y);\n\n        assert_eq!(banded_alignment, full_alignment);\n    }\n\n    fn compare_to_full_alignment_semiglobal(x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) {\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n\n        let mut banded_aligner =\n            banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let banded_alignment = banded_aligner.semiglobal(x, y);\n        banded_aligner.visualize(\u0026banded_alignment);\n\n        let mut full_aligner = pairwise::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let full_alignment = full_aligner.semiglobal(x, y);\n        // banded_aligner.visualize(\u0026full_alignment);\n\n        assert_eq!(banded_alignment, full_alignment);\n\n        let set = hash_kmers(y, 10);\n        let banded_alignment = banded_aligner.semiglobal_with_prehash(x, y, \u0026set);\n        assert_eq!(banded_alignment, full_alignment);\n    }\n\n    #[test]\n    fn test_band_add_entry() {\n        let mut band = banded::Band::new(10, 10);\n        band.add_entry((3u32, 3u32), 3usize);\n        assert_eq!(\n            band.ranges,\n            [\n                0..7,\n                0..7,\n                0..7,\n                0..7,\n                0..7,\n                0..7,\n                0..7,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n            ]\n        );\n        band.add_entry((9u32, 9u32), 2usize);\n        assert_eq!(\n            band.ranges,\n            [\n                0..7,\n                0..7,\n                0..7,\n                0..7,\n                0..7,\n                0..7,\n                0..7,\n                7..11,\n                7..11,\n                7..11,\n                7..11,\n            ]\n        );\n        band.add_entry((7u32, 5u32), 2usize);\n        assert_eq!(\n            band.ranges,\n            [\n                0..7,\n                0..7,\n                0..7,\n                0..10,\n                0..10,\n                0..10,\n                0..10,\n                5..11,\n                7..11,\n                7..11,\n                7..11,\n            ]\n        );\n\n        let mut band = banded::Band::new(10, 10);\n        band.add_entry((0u32, 0u32), 2usize);\n        assert_eq!(\n            band.ranges,\n            [\n                0..3,\n                0..3,\n                0..3,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n            ]\n        );\n\n        let mut band = banded::Band::new(10, 10);\n        band.add_entry((10u32, 10u32), 2usize);\n        assert_eq!(\n            band.ranges,\n            [\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                8..11,\n                8..11,\n                8..11,\n            ]\n        );\n\n        let mut band = banded::Band::new(10, 10);\n        band.add_entry((10u32, 0u32), 2usize);\n        assert_eq!(\n            band.ranges,\n            [\n                8..11,\n                8..11,\n                8..11,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n            ]\n        );\n\n        let mut band = banded::Band::new(10, 10);\n        band.add_entry((0u32, 10u32), 2usize);\n        assert_eq!(\n            band.ranges,\n            [\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                0..3,\n                0..3,\n                0..3,\n            ]\n        );\n        band.stat();\n    }\n\n    fn compare_add_kmer_and_add_entry(start: (u32, u32), k: usize, w: usize, m: usize, n: usize) {\n        let mut band1 = banded::Band::new(m, n);\n        band1.add_kmer(start, k, w);\n\n        let mut band2 = banded::Band::new(m, n);\n        for i in 0..k {\n            band2.add_entry((start.0 + i as u32, start.1 + i as u32), w);\n        }\n        assert_eq!(band1.ranges, band2.ranges);\n    }\n\n    #[test]\n    fn test_band_add_kmer() {\n        compare_add_kmer_and_add_entry((3u32, 3u32), 4, 2, 10, 10);\n        compare_add_kmer_and_add_entry((3u32, 3u32), 8, 2, 10, 10);\n        compare_add_kmer_and_add_entry((5u32, 0u32), 6, 3, 10, 10);\n    }\n\n    #[test]\n    fn test_same() {\n        let x =\n            b\"ACGTATCATAGACCCTAGATAGGGTTGTGTAGATGATCCACAGACGTATCATAGATTAGATAGGGTTGTGTAGATGATTCC\\\n        ACAG\";\n        let y = *x;\n        compare_to_full_alignment_local(x, \u0026y);\n        compare_to_full_alignment_global(x, \u0026y);\n        compare_to_full_alignment_semiglobal(x, \u0026y);\n    }\n\n    #[test]\n    fn test_big() {\n        let query =\n            b\"CATCTCCACCCACCCTATCCAACCCTGGGGTGGCAGGTCGTGAGTGACAGCCCCAAGGACACCAAGGGATGAAGCTT\\\n        CTCCTGTGCTGAGATCCTTCTCGGACTTTCTGAGAGGCCACGCAGAACAGGAGGCCCCATCTCCCGTTCTTACTCAGAAGCTGTCAGCAGG\\\n        GCTGGGCTCAAGATGAACCCGTGGCCGGCCCCACTCCCCAGCTCTTGCTTCAGGGCCTCACGTTTCGCCCCCTGAGGCCTGGGGGCTCCAT\\\n        CCTCACGGCTGGAGGGGCTCTCAGAACATCTGGTG\";\n\n        let target =\n            b\"CCTCCCATCTCCACCCACCCTATCCAACCCTGGGGTGGCAGGTCATGAGTGACAGCCCCAAGGACACCAAGGGATG\\\n        AAGCTTCTCCTGTGCTGAGATCCTTCTCGGACTTTCTGAGAGGCCACGCAGAACAGGAGGCCCCATCTCCCGTTCTTACTCAGAAGCTGTC\\\n        AGCAGGGCTGGGCTCAAGATGAACCCGTGGCCGGCCCCACTCCCCAGCTCTTGCTTCAGGGCCTCACGTTTCGCCCCCTGAGGCCTGGGGG\\\n        CTCCGTCCTCACGGCTGGAGGGGCTCTCAGAACATCTGGTGGGCTCCGTCCTCACGGCTGGAGGGGCTCTCAGAACATCTGGTGGGCTCCG\\\n        TCCTCACGGCTGGAGGGGCTCTCAGAACATCTGGTGGGCTCCGTCCTCACGGCTGGAGGGGCTCTCAGAACATCTGGTGCACGGCTCCCAA\\\n        CTCTCTTCCGGCCAAGGATCCCGTGTTCCTGAAATGTCTTTCTACCAAACACAGTTGCTGTGTAACCACTCATTTCATTTTCCTAATTTGT\\\n        GTTGATCCAGGACACGGGAGGAGACCTGGGCAGCGGCGGACTCATTGCAGGTCGCTCTGCGGTGAGGACGCCACAGGCAC\";\n\n        compare_to_full_alignment_local(query, target);\n        // compare_to_full_alignment_global(query, target);\n        // compare_to_full_alignment_semiglobal(query, target);\n    }\n\n    #[test]\n    fn test_deletion() {\n        let x = b\"AGCACACGTGTGCGCTATACAGTACACGTGTCACAGTTGTACTAGCATGAC\";\n        let y = b\"AGCACACGTGTGCGCTATACAGTAAAAAAAACACGTGTCACAGTTGTACTAGCATGAC\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_insertion() {\n        let x = b\"AGCACACGTGTGCGCTATACAGTAAGTAGTAGTACACGTGTCACAGTTGTACTAGCATGAC\";\n        let y = b\"AGCACACGTGTGCGCTATACAGTACACGTGTCACAGTTGTACTAGCATGAC\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_substitutions() {\n        let x = b\"AGCACACGTGTGCGCTATACAGTAAGTAGTAGTACACGTGTCACAGTTGTACTAGCATGAC\";\n        let y = b\"AGCACAAGTGTGCGCTATACAGGAAGTAGGAGTACACGTGTCACATTTGTACTAGCATGAC\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_overhangs1() {\n        let x = b\"CGCTATACAGTAAGTAGTAGTACACGTGTCACAGTTGTACTAGCATGAC\";\n        let y = b\"AGCACAAGTGTGAGCACAAGTGTGCGCTATACAGGAAGTAGGAGTACACGTGTCACATTTGTACTAGCATGAC\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_overhangs2() {\n        let x = b\"GCACACGAGCACACGTAGCACACGTGTGCGCTATACAGTAAGTAGTAGTACACGTGTCACAGTTGTACTAGCATGAC\";\n        let y = b\"TATACAGGAAGTAGGAGTACACGTGTCACATTTGTACTAGCATGAC\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_overhangs3() {\n        let x = b\"AGCACACGTGTGCGCTATACAGTAAGTAGTAGTACACGTG\";\n        let y = b\"AGCACAAGTGTGCGCTATACAGGAAGTAGGAGTACACGTGTCACATTTGTACTAGCATGAC\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_overhangs4() {\n        let x = b\"AGCACACGTGTGCGCTATACAGTAAGTAGTAGTACACGTGTCACAGTTGTACTAGCATGACCAGTTGTACTAGCATGAC\";\n        let y = b\"AGCACAAGTGTGCGCTATACAGGAAGTAGGAGTACACGTGTCA\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_overhangs5() {\n        let x = b\"AGCACAAGTGTGCGCTATACAGGAAGTAGGAGTACACGTGTCA\";\n        let y = b\"CAGTTGTACTAGCATGACCAGTTGTACTAGCATGACAGCACACGTGTGCGCTATACAGTAAGTAGTAGTACACGTGTCA\\\n            CAGTTGTACTAGCATGACCAGTTGTACTAGCATGAC\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_band_starts_inside() {\n        let x = b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGGGGGGGGGGGGGGGGGGGG\";\n        let y = b\"TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTGGGGGGGGGGGGGGGGGGGG\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_band_ends_inside() {\n        let x = b\"GGGGGGGGGGGGGGGGGGGGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n        let y = b\"GGGGGGGGGGGGGGGGGGGGTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_band_is_fully_inside() {\n        let x = b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGGGGGGGGGGGGGGGGGGGG\\\n        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n        let y = b\"TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTGGGGGGGGGGGGGGGGGGGG\\\n        TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    // #[test]\n    // fn test_failure() {\n    //     let x = b\"AGAATTTTAGTGATCATATCGTTAACAGCTCCTGAGGGGACTTGGCCCAGCTGGAATAGCTACATGGCAGATTTTTCGTTCACGTTTTCTCTTCGCGATGTTCATCACTGCTTCTACCATATCGAGACCCGTTTATTGACTTCAGACAATGAGGAGCAATTAGGACGTTTATACGATGTTAGCGCGTTTAATAACTCACTGATATGCCACAGGCGCAGGCCTGACAAAGTTTATCCGGGGTCGGGAAAGCTGTGCCCTCATCCAAGTGCTCAGCTAACCAGCAACTGTCGGCTAATTCTTAGATATACCGGATTTATTAACACTGGCCTGACATCCTATACCGAGTAGGCCCCCAAAGTAATTGATGTTCCCGCAACTACTACTCCCGAGGCTAGGTCGAGTCCTACTCCAAGACATCCTGCGTAAAGACAAGGCGCTGACTTGACGTAGTAAAGACCTGGCGCGGGATACACACAGCATAGCGTGAAGCACAGACAAACTGAAGTGGCCGAAGAGAATCTAACAATGGTAC\";\n    //     let y = b\"GTTTCGATGCTCACTGAACAGTAGAGTTTACGCCCAACGGTTAGTACCTCGCTAAGGGAGTGGGTGTCCGGGCAGAATTTTAGTGATCATATCGTTAACAGCTCCTGAGGGGACTTGGCCCAGCTGGAATAGCTACATGGCAGATTTTTCGTTCACGTTTTCTCTTCCCGATGTTCATCACTGCTTCTACCATATCGCATCCAAGTGCTCAGCTAACCAGCAACTGTCGGCTAATTCTTAGATATACCGGATTTATTAACACTGGCCTGACATCCTATACCGAGTAGGCCCCCAAAGTAATTGATGTTCCCGCAACTACTACTCCCGAGGCTAGGTATTTGTACCTGTTGCCGCCACGTATCGGGGGCGCTACGGGCGGCACGGCCCGATGCCTTGCTTCCCAGGGTGTTTTTTAGGATTCGATTCAGTGGTCGGTCGGGCTTTAAGCGGTCCAGATCTTAGCTGTATCTCGAGTCCTACTCCAAGACGTCCTGCGTAAAGACAAGGCGCTGACTTGACGTAGTAAAGACCTGGCGCGGGATACACACAGCATAGCGTGAAGCACAGACAAACTGAAGTGGCCGAAGAGAATCTAACAATGGTACTGACAGG\";\n    //     compare_to_full_alignment_semiglobal(x, y);\n    // }\n\n    use crate::alignment::AlignmentOperation::*;\n    use crate::scores::blosum62;\n    use std::iter::repeat;\n\n    #[test]\n    fn test_semiglobal() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    // Test case for underflow of the SW score.\n    #[test]\n    fn test_semiglobal_gap_open_lt_mismatch() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -5i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -1, -1, \u0026score, 10, 10);\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Del, Match, Ins, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_global_affine_ins() {\n        let x = b\"ACGAGAACA\";\n        let y = b\"ACGACA\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.global(x, y);\n\n        println!(\"aln:\\n{}\", alignment.pretty(x, y));\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Ins, Ins, Ins, Match, Match, Match]\n        );\n    }\n\n    #[test]\n    fn test_local_empty() {\n        let x = b\"NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN\";\n        let y = b\"AACGTACGATACGTGGGTTGTCACACGTGTCGCGCGGCAACACATCAGACTCTAACAGCATCATCAGCACGTGACA\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.local(x, y);\n\n        println!(\"aln:\\n{}\", alignment.pretty(x, y));\n        assert_eq!(alignment.x_aln_len(), 0);\n        assert_eq!(alignment.y_aln_len(), 0);\n    }\n\n    #[test]\n    fn test_global_affine_ins2() {\n        let x = b\"AGATAGATAGATAGGGAGTTGTGTAGATGATCCACAGT\";\n        let y = b\"AGATAGATAGATGTAGATGATCCACAGT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.global(x, y);\n\n        println!(\"aln:\\n{}\", alignment.pretty(x, y));\n\n        let mut correct = Vec::new();\n        correct.extend(repeat(Match).take(11));\n        correct.extend(repeat(Ins).take(10));\n        correct.extend(repeat(Match).take(17));\n\n        assert_eq!(alignment.operations, correct);\n    }\n\n    #[test]\n    fn test_local_affine_ins2() {\n        let x = b\"ACGTATCATAGATAGATAGGGTTGTGTAGATGATCCACAG\";\n        let y = b\"CGTATCATAGATAGATGTAGATGATCCACAGT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.local(x, y);\n        assert_eq!(alignment.xstart, 1);\n        assert_eq!(alignment.ystart, 0);\n    }\n\n    #[test]\n    fn test_local() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.local(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_global() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.global(x, y);\n\n        println!(\"\\naln:\\n{}\", alignment.pretty(x, y));\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Del, Del, Del, Del, Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_blosum62() {\n        let x = b\"AAAA\";\n        let y = b\"AAAA\";\n        let score = \u0026blosum62;\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, score, 10, 10);\n        let alignment = aligner.global(x, y);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.score, 16);\n        assert_eq!(alignment.operations, [Match, Match, Match, Match]);\n    }\n\n    #[test]\n    fn test_issue11() {\n        let y = b\"TACC\"; //GTGGAC\";\n        let x = b\"AAAAACC\"; //GTTGACGCAA\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.global(x, y);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Ins, Ins, Ins, Subst, Match, Match, Match]\n        );\n    }\n\n    #[test]\n    fn test_issue12_1() {\n        let x = b\"CCGGCA\";\n        let y = b\"ACCGTTGACGC\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.ystart, 1);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Subst, Subst, Subst]\n        );\n    }\n\n    #[test]\n    fn test_issue12_2() {\n        let y = b\"CCGGCA\";\n        let x = b\"ACCGTTGACGC\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.ystart, 0);\n\n        assert_eq!(\n            alignment.operations,\n            [Subst, Match, Ins, Ins, Ins, Ins, Ins, Ins, Subst, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_issue12_3() {\n        let y = b\"CCGTCCGGCAA\";\n        let x = b\"AAAAACCGTTGACGCAA\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.semiglobal(x, y);\n\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [\n                Ins, Ins, Ins, Ins, Ins, Ins, Match, Subst, Subst, Match, Subst, Subst, Subst,\n                Match, Match, Match, Match,\n            ]\n        );\n\n        let mut aligner = banded::Aligner::with_capacity(y.len(), x.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.semiglobal(y, x);\n\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Subst, Subst, Match, Subst, Subst, Subst, Match, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_left_aligned_del() {\n        let x = b\"GTGCATCATGTG\";\n        let y = b\"GTGCATCATCATGTG\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.global(x, y);\n        println!(\"\\naln:\\n{}\", alignment.pretty(x, y));\n\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [\n                Match, Match, Match, Del, Del, Del, Match, Match, Match, Match, Match, Match,\n                Match, Match, Match,\n            ]\n        );\n    }\n\n    // Test that trailing deletions are correctly handled\n    // in global mode\n    #[test]\n    fn test_global_right_del() {\n        let x = b\"AACCACGTACGTGGGGGGA\";\n        let y = b\"CCACGTACGT\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.global(x, y);\n\n        println!(\"\\naln:\\n{}\", alignment.pretty(x, y));\n\n        println!(\"score:{}\", alignment.score);\n        assert_eq!(alignment.score, -9);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [\n                Ins, Ins, Match, Match, Match, Match, Match, Match, Match, Match, Match, Match,\n                Ins, Ins, Ins, Ins, Ins, Ins, Ins,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_left_aligned_ins() {\n        let x = b\"GTGCATCATCATGTG\";\n        let y = b\"GTGCATCATGTG\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.global(x, y);\n        println!(\"\\naln:\\n{}\", alignment.pretty(x, y));\n\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [\n                Match, Match, Match, Ins, Ins, Ins, Match, Match, Match, Match, Match, Match,\n                Match, Match, Match,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_aligner_new() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::new(-5, -1, \u0026score, 10, 10);\n\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n\n        let alignment = aligner.local(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n\n        let alignment = aligner.global(x, y);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Del, Del, Del, Del, Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_semiglobal_simple() {\n        let x = b\"GAAAACCGTTGAT\";\n        let y = b\"ACCGTGGATGGG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::new(-5, -1, \u0026score, 10, 10);\n        let alignment = aligner.semiglobal(x, y);\n\n        assert_eq!(\n            alignment.operations,\n            [Ins, Ins, Ins, Ins, Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_insert_only_semiglobal() {\n        let x = b\"TTTT\";\n        let y = b\"AAAA\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let mut aligner = banded::Aligner::new(-5, -1, \u0026score, 10, 10);\n        let alignment = aligner.semiglobal(x, y);\n\n        assert_eq!(alignment.operations, [Ins, Ins, Ins, Ins]);\n    }\n\n    #[test]\n    fn test_insert_in_between_semiglobal() {\n        let x = b\"GGGGG\";\n        let y = b\"GGTAGGG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let mut aligner = banded::Aligner::new(-5, -1, \u0026score, 10, 10);\n        let alignment = aligner.semiglobal(x, y);\n\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Del, Del, Match, Match, Match]\n        );\n    }\n\n    #[test]\n    fn test_xclip_prefix_custom() {\n        let x = b\"GGGGGGATG\";\n        let y = b\"ATG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).xclip(-5);\n\n        let mut aligner = banded::Aligner::with_scoring(scoring, 10, 10);\n        let alignment = aligner.custom(x, y);\n\n        assert_eq!(alignment.operations, [Xclip(6), Match, Match, Match]);\n    }\n\n    #[test]\n    fn test_yclip_prefix_custom() {\n        let y = b\"GGGGGGATG\";\n        let x = b\"ATG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).yclip(-5);\n\n        let mut aligner = banded::Aligner::with_scoring(scoring, 10, 10);\n        let alignment = aligner.custom(x, y);\n\n        assert_eq!(alignment.operations, [Yclip(6), Match, Match, Match]);\n    }\n\n    #[test]\n    fn test_xclip_suffix_custom() {\n        let x = b\"GAAAA\";\n        let y = b\"CG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).xclip(-5).yclip(0);\n\n        let mut aligner = banded::Aligner::with_scoring(scoring, 10, 10);\n        let alignment = aligner.custom(x, y);\n\n        assert_eq!(alignment.operations, [Yclip(1), Match, Xclip(4)]);\n    }\n\n    #[test]\n    fn test_yclip_suffix_custom() {\n        let y = b\"GAAAA\";\n        let x = b\"CG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).yclip(-5).xclip(0);\n\n        let mut aligner = banded::Aligner::with_scoring(scoring, 10, 10);\n        let alignment = aligner.custom(x, y);\n\n        assert_eq!(alignment.operations, [Xclip(1), Match, Yclip(4)]);\n    }\n\n    #[test]\n    fn test_longer_string_all_operations() {\n        let x = b\"TTTTTGGGGGGATGGCCCCCCTTTTTTTTTTGGGAAAAAAAAAGGGGGG\";\n        let y = b\"GGGGGGATTTCCCCCCCCCTTTTTTTTTTAAAAAAAAA\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).xclip(-5).yclip(0);\n\n        let mut aligner = banded::Aligner::with_scoring(scoring, 10, 10);\n        let alignment = aligner.custom(x, y);\n\n        println!(\"{}\", alignment.pretty(x, y));\n        assert_eq!(alignment.score, 7);\n    }\n\n    #[test]\n    fn test_yclip_suffix_only() {\n        let x = b\"GGACTTCGGAAGGCACTACTGAAACTCCGT\";\n        let y = b\"AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC\";\n        let base_score = Scoring::from_scores(0, -1, 1, -1);\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            xclip_suffix: 0,\n            yclip_suffix: 0,\n            ..base_score\n        };\n        let mut aligner = banded::Aligner::with_scoring(scoring, 6, 5);\n        let alignment = aligner.custom(x, y);\n        assert_eq!(alignment.ystart, 0);\n    }\n\n    #[test]\n    fn test_yclip_prefix_only() {\n        let x = b\"AATAATAAAAAAA\";\n        let y = b\"AAAAAAGTTTCACCTTA\";\n        let base_score = Scoring::from_scores(0, -1, 1, -1);\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            xclip_suffix: 0,\n            yclip_prefix: 0,\n            ..base_score\n        };\n        let mut aligner = banded::Aligner::with_scoring(scoring, 6, 5);\n        let alignment = aligner.custom(x, y);\n        assert_eq!(alignment.yend, alignment.ylen);\n    }\n\n    #[test]\n    fn test_traceback_outside_band() {\n        let x = b\"TTGTGGGTGGGGGGAAAAAAAAA\";\n        let y = b\"GACAAGAGCCCAAGGAAAGAAAA\";\n        let base_score = Scoring::from_scores(-5, 0, 1, -3);\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            xclip_suffix: 0,\n            yclip_suffix: 0,\n            ..base_score\n        };\n        let kmer_len = 5;\n        let window_len = 5;\n        let mut al = pairwise::banded::Aligner::with_scoring(scoring, kmer_len, window_len);\n        let alignment = al.custom(x, y);\n        assert_eq!(alignment.ystart, 0);\n    }\n\n    #[test]\n    fn test_deletions_ouside_band() {\n        let x = b\"AAAAATTGAGGAGTAATAGTAAA\";\n        let y = b\"AAAAAAAAAAAAGGAAGG\";\n        let base_score = Scoring::from_scores(-13, 0, 1, -5);\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            xclip_suffix: -136,\n            yclip_prefix: -112,\n            yclip_suffix: -51,\n            ..base_score\n        };\n        let kmer_len = 5;\n        let window_len = 8;\n        let mut al = pairwise::banded::Aligner::with_scoring(scoring, kmer_len, window_len);\n        let alignment = al.custom(x, y);\n        assert_eq!(alignment.score, -13);\n        assert_eq!(\n            alignment.operations,\n            [\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Xclip(23)\n            ]\n        );\n    }\n\n    #[test]\n    fn test_insertion_ouside_band() {\n        let x = b\"AATCTAAAAAAAAAAAAAAAAC\";\n        let y = b\"AATATAAAAAGAAAAAGAA\";\n\n        let base_score = Scoring::from_scores(-15, 0, 1, -6);\n\n        let scoring = Scoring {\n            xclip_prefix: -255,\n            xclip_suffix: -255,\n            yclip_prefix: 0,\n            yclip_suffix: -54,\n            ..base_score\n        };\n        let kmer_len = 5;\n        let window_len = 7;\n        let mut al = pairwise::banded::Aligner::with_scoring(scoring, kmer_len, window_len);\n        let alignment = al.custom(x, y);\n        assert_eq!(alignment.score, -15);\n        assert_eq!(\n            alignment.operations,\n            [\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Yclip(19)\n            ]\n        );\n    }\n\n    #[test]\n    fn test_insertion_after_clip() {\n        let x = b\"AAAAAAGTAAAATTT\";\n        let y = b\"AAAAAAAAAAACAAAAAAG\";\n\n        let base_score = Scoring::from_scores(-3, 0, 3, -5);\n\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            yclip_prefix: 0,\n            yclip_suffix: 0,\n            ..base_score\n        };\n        let kmer_len = 5;\n        let window_len = 7;\n        let mut al = pairwise::banded::Aligner::with_scoring(scoring, kmer_len, window_len);\n        let alignment = al.custom(x, y);\n        assert_eq!(alignment.score, 24);\n    }\n\n    #[test]\n    fn test_only_clips() {\n        let x = b\"GTAAAAAAGCCCAGA\";\n        let y = b\"AAAGTAAAAACAATGACAAAAAAAA\";\n        let base_score = Scoring::from_scores(-15, -5, 1, -5);\n        let scoring = Scoring {\n            xclip_prefix: -255,\n            xclip_suffix: -22,\n            yclip_prefix: -54,\n            yclip_suffix: -50,\n            ..base_score\n        };\n        let kmer_len = 10;\n        let window_len = 10;\n        let mut al = pairwise::banded::Aligner::with_scoring(scoring, kmer_len, window_len);\n        let alignment = al.custom(x, y);\n        assert_eq!(alignment.score, -72);\n    }\n\n    #[test]\n    fn test_zero_score_clips() {\n        let x = b\"AA\";\n        let y = b\"CC\";\n        let kmer_len = 5;\n        let window_len = 5;\n\n        let base_score = Scoring::from_scores(-1, -1, 1, -1);\n        {\n            let scoring = Scoring {\n                xclip_prefix: 0,\n                yclip_prefix: 0,\n                ..base_score.clone()\n            };\n            let mut al = pairwise::banded::Aligner::with_scoring(scoring, kmer_len, window_len);\n            let alignment = al.custom(x, y);\n            assert_eq!(alignment.score, 0);\n        }\n\n        {\n            let scoring = Scoring {\n                xclip_prefix: 0,\n                yclip_suffix: 0,\n                ..base_score.clone()\n            };\n            let mut al = pairwise::banded::Aligner::with_scoring(scoring, kmer_len, window_len);\n            let alignment = al.custom(x, y);\n            assert_eq!(alignment.score, 0);\n        }\n\n        {\n            let scoring = Scoring {\n                xclip_suffix: 0,\n                yclip_prefix: 0,\n                ..base_score.clone()\n            };\n            let mut al = pairwise::banded::Aligner::with_scoring(scoring, kmer_len, window_len);\n            let alignment = al.custom(x, y);\n            assert_eq!(alignment.score, 0);\n        }\n\n        {\n            let scoring = Scoring {\n                xclip_suffix: 0,\n                yclip_suffix: 0,\n                ..base_score\n            };\n            let mut al = pairwise::banded::Aligner::with_scoring(scoring, kmer_len, window_len);\n            let alignment = al.custom(x, y);\n            assert_eq!(alignment.score, 0);\n        }\n    }\n}\n","traces":[{"line":139,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":61},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":97},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":130},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":89},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":86},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":128},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":101},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":128},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":77},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":598,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":659,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":670,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":671,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":125},"fn_name":null},{"line":677,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":681,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":689,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":690,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":126},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":710,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":724,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":726,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":727,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":731,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":132},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":740,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":741,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":745,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":746,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":747,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":749,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":751,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":752,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":754,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":759,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":761,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":763,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":764,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":765,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":767,"address":[],"length":0,"stats":{"Line":99},"fn_name":null},{"line":769,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":770,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":771,"address":[],"length":0,"stats":{"Line":92},"fn_name":null},{"line":772,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":775,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":778,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":780,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":781,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":785,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":786,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":787,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":789,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":790,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":791,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":793,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":798,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":803,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":807,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":809,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":810,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":811,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":813,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":814,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":815,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":819,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":826,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":828,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":829,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":830,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":831,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":837,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":839,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":840,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":844,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":845,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":849,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":864,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":866,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":867,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":868,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":869,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":870,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":874,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":875,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":876,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":877,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":880,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":881,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":884,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":885,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":886,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":887,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":889,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":893,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":895,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":896,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":897,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":898,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":899,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":903,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":904,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":905,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":906,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":909,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":910,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":917,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":918,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":919,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":921,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":930,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":937,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":938,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":939,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":940,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":941,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":945,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":946,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":947,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":948,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":951,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":952,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":955,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":958,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":959,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":960,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":961,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":963,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":967,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":969,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":970,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":971,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":972,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":973,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":977,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":978,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":979,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":980,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":983,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":984,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":987,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":990,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":991,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":992,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":993,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":995,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":999,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1001,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1002,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1003,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":1004,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1005,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1006,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1011,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1012,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":1013,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1016,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":1017,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":1018,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1020,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1030,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1031,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1032,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1033,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1053,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1055,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1056,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1057,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1063,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1064,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1066,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1067,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1069,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1070,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1073,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1074,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1075,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1078,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1079,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1080,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1081,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1084,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1085,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1086,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1087,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1088,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1090,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1091,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1092,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1095,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1096,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1097,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1106,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1107,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1108,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1115,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1117,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1118,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1121,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1124,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1126,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1142,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1150,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":1154,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1155,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":1156,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1157,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1159,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":1162,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1163,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1166,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1168,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1169,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1171,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1178,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":1180,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1182,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1183,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1186,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1187,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1188,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1190,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1191,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1192,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1194,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1195,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1196,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1200,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1207,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":1208,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":1209,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":1210,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":1211,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":1212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1214,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":1216,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":1217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1219,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":1222,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":1224,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1225,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1227,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1228,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1229,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1230,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1231,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1232,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1238,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1239,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":1240,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":1242,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":1244,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1246,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1249,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":1250,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1251,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1253,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1254,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1255,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1256,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1257,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1258,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1262,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1263,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1264,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1270,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":1277,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":1278,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":1281,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1289,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1290,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1293,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":1301,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":1302,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":1303,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":1304,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":1307,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1308,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1309,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1313,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1315,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1316,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":1317,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":1319,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1322,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":1331,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1333,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":1334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1338,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":1339,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":1342,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":1343,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1345,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":1346,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":1347,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":1348,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1349,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":1351,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":1352,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1354,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1356,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1358,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1361,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1362,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1363,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1366,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1367,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1368,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1369,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1394,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1395,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1396,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1397,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1398,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1414,"address":[5310928,5311627],"length":1,"stats":{"Line":1},"fn_name":"compare_to_full_alignment_local"},{"line":1415,"address":[6314144,6314166],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1417,"address":[5310987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1419,"address":[5311105],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1422,"address":[5311279,5311122,5311188],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1423,"address":[5311322],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1425,"address":[5311460,5311337,5311535],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1428,"address":[5312383,5311664],"length":1,"stats":{"Line":2},"fn_name":"compare_to_full_alignment_global"},{"line":1429,"address":[6314208,6314230],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1431,"address":[5311723],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1433,"address":[5311841],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1434,"address":[5311861],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1436,"address":[5311982,5311915],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1437,"address":[5312078],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1439,"address":[5312291,5312093,5312216],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1442,"address":[5312416,5313517],"length":1,"stats":{"Line":2},"fn_name":"compare_to_full_alignment_semiglobal"},{"line":1443,"address":[6314272,6314294],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":1445,"address":[5312475],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1447,"address":[5312608],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1448,"address":[5312631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1450,"address":[5312755,5312688],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1451,"address":[5312854],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1454,"address":[5312869,5313078,5312992],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1456,"address":[5313061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1457,"address":[5313144],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1458,"address":[5313387,5313189,5313312],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1462,"address":[5314432,5316340],"length":1,"stats":{"Line":3},"fn_name":"test_band_add_entry"},{"line":1463,"address":[5314439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1464,"address":[5314460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1465,"address":[5314516,5314658,5314736],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1481,"address":[5314664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1482,"address":[5314782,5314962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1498,"address":[5314890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1499,"address":[5315009,5315138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1516,"address":[5315118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1517,"address":[5315185],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1518,"address":[5315241,5315371,5315410],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1535,"address":[5315390],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1536,"address":[5315457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1537,"address":[5315643,5315682,5315513],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1554,"address":[5315662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1555,"address":[5315729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1556,"address":[5315785,5315915,5315954],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1573,"address":[5315934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1574,"address":[5316001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1575,"address":[5316057,5316187,5316218],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1591,"address":[5316201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1594,"address":[5314409,5313552],"length":1,"stats":{"Line":1},"fn_name":"compare_add_kmer_and_add_entry"},{"line":1595,"address":[5313682],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1596,"address":[5313724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1598,"address":[5313755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1599,"address":[5314307,5313807,5314112,5313938],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1600,"address":[5314149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1602,"address":[5314316,5314018,5314347],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1606,"address":[5316368],"length":1,"stats":{"Line":3},"fn_name":"test_band_add_kmer"},{"line":1607,"address":[5316372],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1608,"address":[5316418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1609,"address":[5316466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1613,"address":[5316528],"length":1,"stats":{"Line":3},"fn_name":"test_same"},{"line":1614,"address":[5316532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1617,"address":[5316544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1618,"address":[5316566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1619,"address":[5316591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1620,"address":[5316616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1624,"address":[5316656],"length":1,"stats":{"Line":3},"fn_name":"test_big"},{"line":1625,"address":[5316660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1631,"address":[5316672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1640,"address":[5316684],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1646,"address":[5316720],"length":1,"stats":{"Line":3},"fn_name":"test_deletion"},{"line":1647,"address":[5316724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1648,"address":[5316736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1649,"address":[5316748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1650,"address":[5316777],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1651,"address":[5316806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1655,"address":[5316848],"length":1,"stats":{"Line":3},"fn_name":"test_insertion"},{"line":1656,"address":[5316852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1657,"address":[5316864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1658,"address":[5316876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1659,"address":[5316905],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1660,"address":[5316934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1664,"address":[5316976],"length":1,"stats":{"Line":3},"fn_name":"test_substitutions"},{"line":1665,"address":[5316980],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1666,"address":[5316992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1667,"address":[5317004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1668,"address":[5317031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1669,"address":[5317058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1673,"address":[5317104],"length":1,"stats":{"Line":3},"fn_name":"test_overhangs1"},{"line":1674,"address":[5317108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1675,"address":[5317120],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1676,"address":[5317132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1677,"address":[5317161],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1678,"address":[5317190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1682,"address":[5317232],"length":1,"stats":{"Line":3},"fn_name":"test_overhangs2"},{"line":1683,"address":[5317236],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1684,"address":[5317248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1685,"address":[5317260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1686,"address":[5317289],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1687,"address":[5317318],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1691,"address":[5317360],"length":1,"stats":{"Line":3},"fn_name":"test_overhangs3"},{"line":1692,"address":[5317364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1693,"address":[5317376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1694,"address":[5317388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1695,"address":[5317417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1696,"address":[5317446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1700,"address":[5317488],"length":1,"stats":{"Line":3},"fn_name":"test_overhangs4"},{"line":1701,"address":[5317492],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1702,"address":[5317504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1703,"address":[5317516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1704,"address":[5317545],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1705,"address":[5317574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1709,"address":[5317616],"length":1,"stats":{"Line":3},"fn_name":"test_overhangs5"},{"line":1710,"address":[5317620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1711,"address":[5317632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1713,"address":[5317644],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1714,"address":[5317673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1715,"address":[5317702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1719,"address":[5317744],"length":1,"stats":{"Line":3},"fn_name":"test_band_starts_inside"},{"line":1720,"address":[5317748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1721,"address":[5317760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1722,"address":[5317772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1723,"address":[5317799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1724,"address":[5317826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1728,"address":[5317872],"length":1,"stats":{"Line":3},"fn_name":"test_band_ends_inside"},{"line":1729,"address":[5317876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1730,"address":[5317888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1731,"address":[5317900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1732,"address":[5317927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1733,"address":[5317954],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1737,"address":[5318000],"length":1,"stats":{"Line":3},"fn_name":"test_band_is_fully_inside"},{"line":1738,"address":[5318004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1740,"address":[5318016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1742,"address":[5318028],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1743,"address":[5318055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1744,"address":[5318082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1759,"address":[5318882,5318128],"length":1,"stats":{"Line":3},"fn_name":"test_semiglobal"},{"line":1760,"address":[5318135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1761,"address":[5318150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1762,"address":[6316598,6316576],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1763,"address":[5318165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1764,"address":[5318264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1765,"address":[5318544,5318309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1766,"address":[5318438,5318732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1767,"address":[5318636,5318788,5318823],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1775,"address":[5319664,5318912],"length":1,"stats":{"Line":3},"fn_name":"test_semiglobal_gap_open_lt_mismatch"},{"line":1776,"address":[5318919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1777,"address":[5318934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1778,"address":[6316672,6316694],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1779,"address":[5318949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1780,"address":[5319046],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1781,"address":[5319326,5319091],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1782,"address":[5319220,5319514],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1783,"address":[5319418,5319605,5319570],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1790,"address":[5319696,5320397],"length":1,"stats":{"Line":3},"fn_name":"test_global_affine_ins"},{"line":1791,"address":[5319703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1792,"address":[5319718],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1793,"address":[6316790,6316768],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1794,"address":[5319733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1795,"address":[5319832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1797,"address":[5319975,5320081,5319877],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1798,"address":[5320339,5320214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1805,"address":[5321356,5320432],"length":1,"stats":{"Line":3},"fn_name":"test_local_empty"},{"line":1806,"address":[5320439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1807,"address":[5320454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1808,"address":[6316864,6316886],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1809,"address":[5320469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1810,"address":[5320568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1812,"address":[5320817,5320711,5320613],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1813,"address":[5321113,5320950],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1814,"address":[5321076,5321292,5321169],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1818,"address":[5322501,5321392],"length":1,"stats":{"Line":3},"fn_name":"test_global_affine_ins2"},{"line":1819,"address":[5321399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1820,"address":[5321414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1821,"address":[6316982,6316960],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1822,"address":[5321429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1823,"address":[5321531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1825,"address":[5321786,5321680,5321579],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1827,"address":[5321919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1828,"address":[5322076,5321938],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1829,"address":[5322083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1830,"address":[5322187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1832,"address":[5322291,5322421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1836,"address":[5323118,5322528],"length":1,"stats":{"Line":3},"fn_name":"test_local_affine_ins2"},{"line":1837,"address":[5322535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1838,"address":[5322550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1839,"address":[6317078,6317056],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1840,"address":[5322565],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1841,"address":[5322664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1842,"address":[5322936,5322709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1843,"address":[5322838,5323057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1847,"address":[5323152,5323906],"length":1,"stats":{"Line":3},"fn_name":"test_local"},{"line":1848,"address":[5323159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1849,"address":[5323174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1850,"address":[6317174,6317152],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1851,"address":[5323189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1852,"address":[5323288],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1853,"address":[5323333,5323568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1854,"address":[5323756,5323462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1855,"address":[5323812,5323660,5323847],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1862,"address":[5323936,5324943],"length":1,"stats":{"Line":3},"fn_name":"test_global"},{"line":1863,"address":[5323943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1864,"address":[5323958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1865,"address":[6317248,6317270],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1866,"address":[5323973],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1867,"address":[5324072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1869,"address":[5324321,5324117,5324215],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1870,"address":[5324646,5324454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1871,"address":[5324793,5324540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1872,"address":[5324697,5324884,5324849],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1879,"address":[5325898,5324976],"length":1,"stats":{"Line":3},"fn_name":"test_blosum62"},{"line":1880,"address":[5324983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1881,"address":[5324998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1882,"address":[5325013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1883,"address":[5325028],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1884,"address":[5325129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1885,"address":[5325403,5325168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1886,"address":[5325297,5325600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1887,"address":[5325495,5325748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1888,"address":[5325839,5325652,5325804],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1892,"address":[5325936,5326690],"length":1,"stats":{"Line":3},"fn_name":"test_issue11"},{"line":1893,"address":[5325943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1894,"address":[5325958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1895,"address":[6317376,6317398],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1896,"address":[5325973],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1897,"address":[5326072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1898,"address":[5326352,5326117],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1899,"address":[5326246,5326540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1900,"address":[5326596,5326444,5326631],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1907,"address":[5327474,5326720],"length":1,"stats":{"Line":3},"fn_name":"test_issue12_1"},{"line":1908,"address":[5326727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1909,"address":[5326742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1910,"address":[6317494,6317472],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1911,"address":[5326757],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1912,"address":[5326856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1913,"address":[5326901,5327136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1914,"address":[5327034,5327324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1915,"address":[5327380,5327415,5327228],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1922,"address":[5327504,5328258],"length":1,"stats":{"Line":3},"fn_name":"test_issue12_2"},{"line":1923,"address":[5327511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1924,"address":[5327526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1925,"address":[6317568,6317590],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1926,"address":[5327541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1927,"address":[5327640],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1928,"address":[5327685,5327920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1929,"address":[5327818,5328108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1931,"address":[5328199,5328012,5328164],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1938,"address":[5328288,5329501],"length":1,"stats":{"Line":3},"fn_name":"test_issue12_3"},{"line":1939,"address":[5328295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1940,"address":[5328310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1941,"address":[6317686,6317664],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1942,"address":[5328325],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1943,"address":[5328430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1945,"address":[5328478,5328710],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1946,"address":[5328853,5328614,5328806],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1954,"address":[5328812,5328900],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1955,"address":[5328993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1957,"address":[5329041,5329273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1958,"address":[5329177,5329405,5329370],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1965,"address":[5329536,5330543],"length":1,"stats":{"Line":3},"fn_name":"test_left_aligned_del"},{"line":1966,"address":[5329543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1967,"address":[5329558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1968,"address":[6317782,6317760],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1969,"address":[5329573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1970,"address":[5329672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1971,"address":[5329717,5329815,5329921],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1973,"address":[5330054,5330246],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1974,"address":[5330140,5330393],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1975,"address":[5330297,5330484,5330449],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1987,"address":[5330576,5331919],"length":1,"stats":{"Line":3},"fn_name":"test_global_right_del"},{"line":1988,"address":[5330583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1989,"address":[5330598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1991,"address":[6317856,6317878],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1992,"address":[5330613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1993,"address":[5330730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1995,"address":[5330778,5330879,5330985],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1997,"address":[5331118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1998,"address":[5331270,5331461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1999,"address":[5331618,5331359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2000,"address":[5331766,5331512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2001,"address":[5331670,5331822,5331857],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2011,"address":[5331952,5332959],"length":1,"stats":{"Line":3},"fn_name":"test_left_aligned_ins"},{"line":2012,"address":[5331959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2013,"address":[5331974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2014,"address":[6317952,6317974],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":2015,"address":[5331989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2016,"address":[5332088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2017,"address":[5332133,5332231,5332337],"length":1,"stats":{"Line":3},"fn_name":null},{"line":2019,"address":[5332470,5332662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2020,"address":[5332556,5332809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2021,"address":[5332713,5332900,5332865],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2031,"address":[5334866,5332992],"length":1,"stats":{"Line":3},"fn_name":"test_aligner_new"},{"line":2032,"address":[5332999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2033,"address":[5333014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2034,"address":[6318048,6318070],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":2035,"address":[5333029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2037,"address":[5333069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2038,"address":[5333373,5333117],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2039,"address":[5333255,5333573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2040,"address":[5333632,5333465,5333699],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2045,"address":[5333638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2046,"address":[5333746,5333938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2047,"address":[5334127,5333832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2048,"address":[5334183,5334031,5334247],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2053,"address":[5334189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2054,"address":[5334486,5334294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2055,"address":[5334675,5334380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2056,"address":[5334766,5334579,5334731],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2063,"address":[5334896,5335272],"length":1,"stats":{"Line":3},"fn_name":"test_semiglobal_simple"},{"line":2064,"address":[5334903],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2065,"address":[5334918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2067,"address":[6318166,6318144],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":2068,"address":[5334933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2069,"address":[5334967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2071,"address":[5335012,5335139,5335214],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2078,"address":[5335296,5335670],"length":1,"stats":{"Line":3},"fn_name":"test_insert_only_semiglobal"},{"line":2079,"address":[5335303],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2080,"address":[5335318],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2082,"address":[6318262,6318240],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":2083,"address":[5335333],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2084,"address":[5335367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2086,"address":[5335612,5335537,5335410],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2090,"address":[5335696,5336072],"length":1,"stats":{"Line":3},"fn_name":"test_insert_in_between_semiglobal"},{"line":2091,"address":[5335703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2092,"address":[5335718],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2094,"address":[6318336,6318358],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":2095,"address":[5335733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2096,"address":[5335767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2098,"address":[5336014,5335812,5335939],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2105,"address":[5336544,5336096],"length":1,"stats":{"Line":3},"fn_name":"test_xclip_prefix_custom"},{"line":2106,"address":[5336103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2107,"address":[5336118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2109,"address":[6318432,6318454],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":2110,"address":[5336133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2112,"address":[5336178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2113,"address":[5336230],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2115,"address":[5336278,5336408,5336483],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2119,"address":[5337024,5336576],"length":1,"stats":{"Line":3},"fn_name":"test_yclip_prefix_custom"},{"line":2120,"address":[5336583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2121,"address":[5336598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2123,"address":[6318528,6318550],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":2124,"address":[5336613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2126,"address":[5336658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2127,"address":[5336710],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2129,"address":[5336963,5336758,5336888],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2133,"address":[5337527,5337056],"length":1,"stats":{"Line":3},"fn_name":"test_xclip_suffix_custom"},{"line":2134,"address":[5337063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2135,"address":[5337078],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2137,"address":[6318624,6318646],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":2138,"address":[5337093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2140,"address":[5337161],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2141,"address":[5337213],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2143,"address":[5337261,5337466,5337391],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2147,"address":[5338023,5337552],"length":1,"stats":{"Line":3},"fn_name":"test_yclip_suffix_custom"},{"line":2148,"address":[5337559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2149,"address":[5337574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2151,"address":[6318742,6318720],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":2152,"address":[5337589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2154,"address":[5337657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2155,"address":[5337709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2157,"address":[5337962,5337757,5337887],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2161,"address":[5338048,5338777],"length":1,"stats":{"Line":3},"fn_name":"test_longer_string_all_operations"},{"line":2162,"address":[5338055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2163,"address":[5338070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2165,"address":[6318838,6318816],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":2166,"address":[5338085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2168,"address":[5338153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2169,"address":[5338205],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2171,"address":[5338354,5338460,5338253],"length":1,"stats":{"Line":3},"fn_name":null},{"line":2172,"address":[5338711,5338593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2176,"address":[5338800,5339299],"length":1,"stats":{"Line":3},"fn_name":"test_yclip_suffix_only"},{"line":2177,"address":[5338807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2178,"address":[5338822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2179,"address":[5338837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2186,"address":[5338945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2187,"address":[5338996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2188,"address":[5339195,5339041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2192,"address":[5339328,5339838],"length":1,"stats":{"Line":3},"fn_name":"test_yclip_prefix_only"},{"line":2193,"address":[5339335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2194,"address":[5339350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2195,"address":[5339365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2202,"address":[5339473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2203,"address":[5339524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2204,"address":[5339734,5339569],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2208,"address":[5339872,5340393],"length":1,"stats":{"Line":3},"fn_name":"test_traceback_outside_band"},{"line":2209,"address":[5339879],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2210,"address":[5339894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2211,"address":[5339909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2218,"address":[5340019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2219,"address":[5340031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2220,"address":[5340043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2221,"address":[5340092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2222,"address":[5340289,5340135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2226,"address":[5341119,5340416],"length":1,"stats":{"Line":3},"fn_name":"test_deletions_ouside_band"},{"line":2227,"address":[5340423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2228,"address":[5340438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2229,"address":[5340453],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2237,"address":[5340572],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2238,"address":[5340584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2239,"address":[5340596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2240,"address":[5340650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2241,"address":[5340929,5340698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2242,"address":[5341060,5340833,5341025],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2269,"address":[5341152,5341855],"length":1,"stats":{"Line":3},"fn_name":"test_insertion_ouside_band"},{"line":2270,"address":[5341159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2271,"address":[5341174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2273,"address":[5341189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2282,"address":[5341308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2283,"address":[5341320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2284,"address":[5341332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2285,"address":[5341386],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2286,"address":[5341665,5341434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2287,"address":[5341796,5341569,5341761],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2318,"address":[5342416,5341888],"length":1,"stats":{"Line":3},"fn_name":"test_insertion_after_clip"},{"line":2319,"address":[5341895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2320,"address":[5341910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2322,"address":[5341925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2330,"address":[5342035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2331,"address":[5342047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2332,"address":[5342059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2333,"address":[5342110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2334,"address":[5342312,5342155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2338,"address":[5342975,5342448],"length":1,"stats":{"Line":3},"fn_name":"test_only_clips"},{"line":2339,"address":[5342455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2340,"address":[5342470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2341,"address":[5342485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2349,"address":[5342596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2350,"address":[5342608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2351,"address":[5342620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2352,"address":[5342669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2353,"address":[5342714,5342871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2357,"address":[5343008,5343609],"length":1,"stats":{"Line":3},"fn_name":"test_zero_score_clips"},{"line":2358,"address":[5343015],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2359,"address":[5343030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2360,"address":[5343045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2361,"address":[5343057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2363,"address":[5343069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2370,"address":[5343244],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2371,"address":[5343296],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2372,"address":[5343342,5343502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2381,"address":[5343778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2382,"address":[5343833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2383,"address":[5343879,5344039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2392,"address":[5344299],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2393,"address":[5344354],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2394,"address":[5344400,5344560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2403,"address":[5344778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2404,"address":[5344833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2405,"address":[5345039,5344879],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":961,"coverable":1096},{"path":["/","home","todd","rust-bio","src","alignment","pairwise","mod.rs"],"content":"// Copyright 2014-2015 Johannes Köster, Vadim Nazarov, Patrick Marks\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Calculate alignments with a generalized variant of the Smith Waterman algorithm.\n//! Complexity: O(n * m) for strings of length m and n.\n//!\n//! For quick computation of alignments and alignment scores there are 6 simple functions.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::alignment::pairwise::*;\n//! use bio::alignment::AlignmentOperation::*;\n//! use bio::scores::blosum62;\n//!\n//! let x = b\"ACCGTGGAT\";\n//! let y = b\"AAAAACCGTTGAT\";\n//! let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n//! // gap open score: -5, gap extension score: -1\n//! let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n//! let alignment = aligner.semiglobal(x, y);\n//! // x is global (target sequence) and y is local (reference sequence)\n//! assert_eq!(alignment.ystart, 4);\n//! assert_eq!(alignment.xstart, 0);\n//! assert_eq!(\n//!     alignment.operations,\n//!     [Match, Match, Match, Match, Match, Subst, Match, Match, Match]\n//! );\n//!\n//! // You can use predefined scoring matrices such as BLOSUM62\n//! let x = b\"LSPADKTNVKAA\";\n//! let y = b\"PEEKSAV\";\n//! // gap open score: -10, gap extension score: -1\n//! let mut aligner = Aligner::with_capacity(x.len(), y.len(), -10, -1, \u0026blosum62);\n//! let alignment = aligner.local(x, y);\n//! assert_eq!(alignment.xstart, 2);\n//! assert_eq!(alignment.xend, 9);\n//! assert_eq!(alignment.ystart, 0);\n//! assert_eq!(alignment.yend, 7);\n//! assert_eq!(\n//!     alignment.operations,\n//!     [Match, Subst, Subst, Match, Subst, Subst, Match]\n//! );\n//! assert_eq!(alignment.score, 16);\n//!\n//! // If you don't know sizes of future sequences, you could\n//! // use Aligner::new().\n//! // Global alignment:\n//! let mut aligner = Aligner::new(-5, -1, \u0026score);\n//! let x = b\"ACCGTGGAT\";\n//! let y = b\"AAAAACCGTTGAT\";\n//! let alignment = aligner.global(x, y);\n//! assert_eq!(alignment.ystart, 0);\n//! assert_eq!(alignment.xstart, 0);\n//! assert_eq!(aligner.local(x, y).score, 7);\n//!\n//! // In addition to the standard modes (Global, Semiglobal and Local), a custom alignment\n//! // mode is supported which supports a user-specified clipping penalty. Clipping is a\n//! // special boundary condition where you are allowed to clip off the beginning/end of\n//! // the sequence for a fixed penalty. As a starting example, we can use the custom mode\n//! // for achieving the three standard modes as follows.\n//!\n//! // scoring for semiglobal mode\n//! let scoring = Scoring::new(-5, -1, \u0026score) // Gap open, gap extend and match score function\n//!     .xclip(MIN_SCORE) // Clipping penalty for x set to 'negative infinity', hence global in x\n//!     .yclip(0); // Clipping penalty for y set to 0, hence local in y\n//! let mut aligner = Aligner::with_scoring(scoring);\n//! let alignment = aligner.custom(x, y); // The custom aligner invocation\n//! assert_eq!(alignment.ystart, 4);\n//! assert_eq!(alignment.xstart, 0);\n//! // Note that in the custom mode, the clips are explicitly mentioned in the operations\n//! assert_eq!(\n//!     alignment.operations,\n//!     [\n//!         Yclip(4),\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Subst,\n//!         Match,\n//!         Match,\n//!         Match\n//!     ]\n//! );\n//!\n//! // scoring for global mode\n//! // scoring can also be created using from_scores if the match and mismatch scores are constants\n//! let scoring = Scoring::from_scores(-5, -1, 1, -1) // Gap open, extend, match, mismatch score\n//!     .xclip(MIN_SCORE) // Clipping penalty for x set to 'negative infinity', hence global in x\n//!     .yclip(MIN_SCORE); // Clipping penalty for y set to 'negative infinity', hence global in y\n//! let mut aligner = Aligner::with_scoring(scoring);\n//! let alignment = aligner.custom(x, y); // The custom aligner invocation\n//! assert_eq!(alignment.ystart, 0);\n//! assert_eq!(alignment.xstart, 0);\n//! // Note that in the custom mode, the clips are explicitly mentioned in the operations\n//! assert_eq!(\n//!     alignment.operations,\n//!     [Del, Del, Del, Del, Match, Match, Match, Match, Match, Subst, Match, Match, Match]\n//! );\n//!\n//! // Similarly if the clip penalties are both set to 0, we have local alignment mode. The scoring\n//! // struct also lets users set different penalties for prefix/suffix clipping, thereby letting\n//! // users have the flexibility to create a wide variety of boundary conditions. The xclip() and\n//! // yclip() methods sets the prefix and suffix penalties to be equal. The scoring struct can be\n//! // explicitly constructed for full flexibility.\n//!\n//! // The following example considers a modification of the semiglobal mode where you are allowed\n//! // to skip a prefix of the target sequence x, for a penalty of -10, but you have to consume\n//! // the rest of the string in the alignment\n//!\n//! let scoring = Scoring {\n//!     gap_open: -5,\n//!     gap_extend: -1,\n//!     match_fn: |a: u8, b: u8| if a == b { 1i32 } else { -3i32 },\n//!     match_scores: Some((1, -3)),\n//!     xclip_prefix: -10,\n//!     xclip_suffix: MIN_SCORE,\n//!     yclip_prefix: 0,\n//!     yclip_suffix: 0,\n//! };\n//! let x = b\"GGGGGGACGTACGTACGT\";\n//! let y = b\"AAAAACGTACGTACGTAAAA\";\n//! let mut aligner = Aligner::with_capacity_and_scoring(x.len(), y.len(), scoring);\n//! let alignment = aligner.custom(x, y);\n//! println!(\"{}\", alignment.pretty(x, y));\n//! assert_eq!(alignment.score, 2);\n//! assert_eq!(\n//!     alignment.operations,\n//!     [\n//!         Yclip(4),\n//!         Xclip(6),\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Yclip(4)\n//!     ]\n//! );\n//! ```\n\nuse std::cmp::max;\nuse std::i32;\nuse std::iter::repeat;\n\nuse crate::alignment::{Alignment, AlignmentMode, AlignmentOperation};\nuse crate::utils::TextSlice;\n\npub mod banded;\n\n/// Value to use as a 'negative infinity' score. Should be close to `i32::MIN`,\n/// but avoid underflow when used with reasonable scoring parameters or even\n/// adding two negative infinities. Use ~ `0.4 * i32::MIN`\npub const MIN_SCORE: i32 = -858_993_459;\n\n/// Trait required to instantiate a Scoring instance\npub trait MatchFunc {\n    fn score(\u0026self, a: u8, b: u8) -\u003e i32;\n}\n\n/// A concrete data structure which implements trait MatchFunc with constant\n/// match and mismatch scores\n#[derive(Debug, Clone)]\npub struct MatchParams {\n    pub match_score: i32,\n    pub mismatch_score: i32,\n}\n\nimpl MatchParams {\n    /// Create new MatchParams instance with given match and mismatch scores\n    ///\n    /// # Arguments\n    ///\n    /// * `match_score` - the score for a match (should not be negative)\n    /// * `mismatch_score` - the score for a mismatch (should not be positive)\n    pub fn new(match_score: i32, mismatch_score: i32) -\u003e Self {\n        assert!(match_score \u003e= 0, \"match_score can't be negative\");\n        assert!(mismatch_score \u003c= 0, \"mismatch_score can't be positive\");\n        MatchParams {\n            match_score,\n            mismatch_score,\n        }\n    }\n}\n\nimpl MatchFunc for MatchParams {\n    #[inline]\n    fn score(\u0026self, a: u8, b: u8) -\u003e i32 {\n        if a == b {\n            self.match_score\n        } else {\n            self.mismatch_score\n        }\n    }\n}\n\n/// The trait Matchfunc is also implemented for Fn(u8, u8) -\u003e i32 so that Scoring\n/// can be instantiated using closures and custom user defined functions\nimpl\u003cF\u003e MatchFunc for F\nwhere\n    F: Fn(u8, u8) -\u003e i32,\n{\n    fn score(\u0026self, a: u8, b: u8) -\u003e i32 {\n        (self)(a, b)\n    }\n}\n\n/// Details of scoring are encapsulated in this structure.\n///\n/// An [affine gap score model](https://en.wikipedia.org/wiki/Gap_penalty#Affine)\n/// is used so that the gap score for a length `k` is:\n/// `GapScore(k) = gap_open + gap_extend * k`\n#[derive(Debug, Clone)]\npub struct Scoring\u003cF: MatchFunc\u003e {\n    pub gap_open: i32,\n    pub gap_extend: i32,\n    pub match_fn: F,\n    pub match_scores: Option\u003c(i32, i32)\u003e,\n    pub xclip_prefix: i32,\n    pub xclip_suffix: i32,\n    pub yclip_prefix: i32,\n    pub yclip_suffix: i32,\n}\n\nimpl Scoring\u003cMatchParams\u003e {\n    /// Create new Scoring instance with given gap open, gap extend penalties\n    /// match and mismatch scores. The clip penalties are set to `MIN_SCORE` by default\n    ///\n    /// # Arguments\n    ///\n    /// * `gap_open` - the score for opening a gap (should not be positive)\n    /// * `gap_extend` - the score for extending a gap (should not be positive)\n    /// * `match_score` - the score for a match\n    /// * `mismatch_score` - the score for a mismatch\n    pub fn from_scores(\n        gap_open: i32,\n        gap_extend: i32,\n        match_score: i32,\n        mismatch_score: i32,\n    ) -\u003e Self {\n        assert!(gap_open \u003c= 0, \"gap_open can't be positive\");\n        assert!(gap_extend \u003c= 0, \"gap_extend can't be positive\");\n\n        Scoring {\n            gap_open,\n            gap_extend,\n            match_fn: MatchParams::new(match_score, mismatch_score),\n            match_scores: Some((match_score, mismatch_score)),\n            xclip_prefix: MIN_SCORE,\n            xclip_suffix: MIN_SCORE,\n            yclip_prefix: MIN_SCORE,\n            yclip_suffix: MIN_SCORE,\n        }\n    }\n}\n\nimpl\u003cF: MatchFunc\u003e Scoring\u003cF\u003e {\n    /// Create new Scoring instance with given gap open, gap extend penalties\n    /// and the score function. The clip penalties are set to [`MIN_SCORE`](constant.MIN_SCORE.html) by default\n    ///\n    /// # Arguments\n    ///\n    /// * `gap_open` - the score for opening a gap (should not be positive)\n    /// * `gap_extend` - the score for extending a gap (should not be positive)\n    /// * `match_fn` - function that returns the score for substitutions\n    ///    (see also [`bio::alignment::pairwise::Scoring`](struct.Scoring.html))\n    pub fn new(gap_open: i32, gap_extend: i32, match_fn: F) -\u003e Self {\n        assert!(gap_open \u003c= 0, \"gap_open can't be positive\");\n        assert!(gap_extend \u003c= 0, \"gap_extend can't be positive\");\n\n        Scoring {\n            gap_open,\n            gap_extend,\n            match_fn,\n            match_scores: None,\n            xclip_prefix: MIN_SCORE,\n            xclip_suffix: MIN_SCORE,\n            yclip_prefix: MIN_SCORE,\n            yclip_suffix: MIN_SCORE,\n        }\n    }\n\n    /// Sets the prefix and suffix clipping penalties for x to the input value\n    ///\n    /// # Arguments\n    ///\n    /// * `penalty` - Clipping penalty for x (both prefix and suffix, should not be positive)\n    ///\n    /// ```rust\n    /// use bio::alignment::pairwise::{Scoring, MIN_SCORE};\n    /// let scoring = Scoring::from_scores(0, -2, 1, -2).xclip(-5);\n    /// assert!(scoring.xclip_prefix == -5);\n    /// assert!(scoring.yclip_prefix == MIN_SCORE);\n    /// assert!(scoring.xclip_suffix == -5);\n    /// assert!(scoring.yclip_suffix == MIN_SCORE);\n    /// ```\n    pub fn xclip(mut self, penalty: i32) -\u003e Self {\n        assert!(penalty \u003c= 0, \"Clipping penalty can't be positive\");\n        self.xclip_prefix = penalty;\n        self.xclip_suffix = penalty;\n        self\n    }\n\n    /// Sets the prefix clipping penalty for x to the input value\n    ///\n    /// # Arguments\n    ///\n    /// * `penalty` - Prefix clipping penalty for x (should not be positive)\n    ///\n    /// # Example\n    /// ```rust\n    /// use bio::alignment::pairwise::{Scoring, MIN_SCORE};\n    /// let scoring = Scoring::from_scores(0, -2, 1, -2).xclip_prefix(-5);\n    /// assert!(scoring.xclip_prefix == -5);\n    /// assert!(scoring.yclip_prefix == MIN_SCORE);\n    /// assert!(scoring.xclip_suffix == MIN_SCORE);\n    /// assert!(scoring.yclip_suffix == MIN_SCORE);\n    /// ```\n    pub fn xclip_prefix(mut self, penalty: i32) -\u003e Self {\n        assert!(penalty \u003c= 0, \"Clipping penalty can't be positive\");\n        self.xclip_prefix = penalty;\n        self\n    }\n\n    /// Sets the suffix clipping penalty for x to the input value\n    ///\n    /// # Arguments\n    ///\n    /// * `penalty` - Suffix clipping penalty for x (should not be positive)\n    ///\n    /// ```rust\n    /// use bio::alignment::pairwise::{Scoring, MIN_SCORE};\n    /// let scoring = Scoring::from_scores(0, -2, 1, -2).xclip_suffix(-5);\n    /// assert!(scoring.xclip_prefix == MIN_SCORE);\n    /// assert!(scoring.yclip_prefix == MIN_SCORE);\n    /// assert!(scoring.xclip_suffix == -5);\n    /// assert!(scoring.yclip_suffix == MIN_SCORE);\n    /// ```\n    pub fn xclip_suffix(mut self, penalty: i32) -\u003e Self {\n        assert!(penalty \u003c= 0, \"Clipping penalty can't be positive\");\n        self.xclip_suffix = penalty;\n        self\n    }\n\n    /// Sets the prefix and suffix clipping penalties for y to the input value\n    ///\n    /// # Arguments\n    ///\n    /// * `penalty` - Clipping penalty for y (both prefix and suffix, should not be positive)\n    ///\n    /// ```rust\n    /// use bio::alignment::pairwise::{Scoring, MIN_SCORE};\n    /// let scoring = Scoring::from_scores(0, -2, 1, -2).yclip(-5);\n    /// assert!(scoring.xclip_prefix == MIN_SCORE);\n    /// assert!(scoring.yclip_prefix == -5);\n    /// assert!(scoring.xclip_suffix == MIN_SCORE);\n    /// assert!(scoring.yclip_suffix == -5);\n    /// ```\n    pub fn yclip(mut self, penalty: i32) -\u003e Self {\n        assert!(penalty \u003c= 0, \"Clipping penalty can't be positive\");\n        self.yclip_prefix = penalty;\n        self.yclip_suffix = penalty;\n        self\n    }\n\n    /// Sets the prefix clipping penalty for y to the input value\n    ///\n    /// # Arguments\n    ///\n    /// * `penalty` - Prefix clipping penalty for y (should not be positive)\n    ///\n    /// ```rust\n    /// use bio::alignment::pairwise::{Scoring, MIN_SCORE};\n    /// let scoring = Scoring::from_scores(0, -2, 1, -2).yclip_prefix(-5);\n    /// assert!(scoring.xclip_prefix == MIN_SCORE);\n    /// assert!(scoring.yclip_prefix == -5);\n    /// assert!(scoring.xclip_suffix == MIN_SCORE);\n    /// assert!(scoring.yclip_suffix == MIN_SCORE);\n    /// ```\n    pub fn yclip_prefix(mut self, penalty: i32) -\u003e Self {\n        assert!(penalty \u003c= 0, \"Clipping penalty can't be positive\");\n        self.yclip_prefix = penalty;\n        self\n    }\n\n    /// Sets the suffix clipping penalty for y to the input value\n    ///\n    /// # Arguments\n    ///\n    /// * `penalty` - Suffix clipping penalty for y (should not be positive)\n    ///\n    /// ```rust\n    /// use bio::alignment::pairwise::{Scoring, MIN_SCORE};\n    /// let scoring = Scoring::from_scores(0, -2, 1, -2).yclip_suffix(-5);\n    /// assert!(scoring.xclip_prefix == MIN_SCORE);\n    /// assert!(scoring.yclip_prefix == MIN_SCORE);\n    /// assert!(scoring.xclip_suffix == MIN_SCORE);\n    /// assert!(scoring.yclip_suffix == -5);\n    /// ```\n    pub fn yclip_suffix(mut self, penalty: i32) -\u003e Self {\n        assert!(penalty \u003c= 0, \"Clipping penalty can't be positive\");\n        self.yclip_suffix = penalty;\n        self\n    }\n}\n\n/// A generalized Smith-Waterman aligner.\n///\n/// `M(i,j)` is the best score such that `x[i]` and `y[j]` ends in a match (or substitution)\n/// ```ignore\n///              .... A   G  x_i\n///              .... C   G  y_j\n/// ```\n/// `I(i,j)` is the best score such that `x[i]` is aligned with a gap\n/// ```ignore\n///              .... A   G  x_i\n///              .... G  y_j  -\n/// ```\n/// This is interpreted as an insertion into `x` w.r.t reference `y`\n///\n/// `D(i,j)` is the best score such that `y[j]` is aligned with a gap\n/// ```ignore\n///              .... A  x_i  -\n///              .... G   G  y_j\n/// ```\n/// This is interpreted as a deletion from `x` w.r.t reference `y`\n///\n/// `S(i,j)` is the best score for prefixes `x[0..i]`, `y[0..j]`\n///\n/// To save space, only two columns of these matrices are stored at\n/// any point - the current column and the previous one. Moreover\n/// `M(i,j)` is not explicitly stored\n///\n/// `Lx` is the optimal x suffix clipping lengths from each position of the\n/// sequence y\n///\n/// `Ly` is the optimal y suffix clipping lengths from each position of the\n/// sequence x\n///\n/// `Sn` is the last column of the matrix. This is needed to keep track of\n/// suffix clipping scores\n///\n/// `traceback` - see [`bio::alignment::pairwise::TracebackCell`](struct.TracebackCell.html)\n///\n/// `scoring` - see [`bio::alignment::pairwise::Scoring`](struct.Scoring.html)\n#[allow(non_snake_case)]\npub struct Aligner\u003cF: MatchFunc\u003e {\n    I: [Vec\u003ci32\u003e; 2],\n    D: [Vec\u003ci32\u003e; 2],\n    S: [Vec\u003ci32\u003e; 2],\n    Lx: Vec\u003cusize\u003e,\n    Ly: Vec\u003cusize\u003e,\n    Sn: Vec\u003ci32\u003e,\n    traceback: Traceback,\n    scoring: Scoring\u003cF\u003e,\n}\n\nconst DEFAULT_ALIGNER_CAPACITY: usize = 200;\n\nimpl\u003cF: MatchFunc\u003e Aligner\u003cF\u003e {\n    /// Create new aligner instance with given gap open and gap extend penalties\n    /// and the score function.\n    ///\n    /// # Arguments\n    ///\n    /// * `gap_open` - the score for opening a gap (should be negative)\n    /// * `gap_extend` - the score for extending a gap (should be negative)\n    /// * `match_fn` - function that returns the score for substitutions\n    ///    (see also [`bio::alignment::pairwise::Scoring`](struct.Scoring.html))\n    pub fn new(gap_open: i32, gap_extend: i32, match_fn: F) -\u003e Self {\n        Aligner::with_capacity(\n            DEFAULT_ALIGNER_CAPACITY,\n            DEFAULT_ALIGNER_CAPACITY,\n            gap_open,\n            gap_extend,\n            match_fn,\n        )\n    }\n\n    /// Create new aligner instance. The size hints help to\n    /// avoid unnecessary memory allocations.\n    ///\n    /// # Arguments\n    ///\n    /// * `m` - the expected size of x\n    /// * `n` - the expected size of y\n    /// * `gap_open` - the score for opening a gap (should be negative)\n    /// * `gap_extend` - the score for extending a gap (should be negative)\n    /// * `match_fn` - function that returns the score for substitutions\n    ///    (see also [`bio::alignment::pairwise::Scoring`](struct.Scoring.html))\n    pub fn with_capacity(m: usize, n: usize, gap_open: i32, gap_extend: i32, match_fn: F) -\u003e Self {\n        assert!(gap_open \u003c= 0, \"gap_open can't be positive\");\n        assert!(gap_extend \u003c= 0, \"gap_extend can't be positive\");\n\n        Aligner {\n            I: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            D: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            S: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            Lx: Vec::with_capacity(n + 1),\n            Ly: Vec::with_capacity(m + 1),\n            Sn: Vec::with_capacity(m + 1),\n            traceback: Traceback::with_capacity(m, n),\n            scoring: Scoring::new(gap_open, gap_extend, match_fn),\n        }\n    }\n\n    /// Create new aligner instance with given the scoring struct\n    ///\n    /// # Arguments\n    ///\n    /// * `scoring` - the scoring struct (see bio::alignment::pairwise::Scoring)\n    pub fn with_scoring(scoring: Scoring\u003cF\u003e) -\u003e Self {\n        Aligner::with_capacity_and_scoring(\n            DEFAULT_ALIGNER_CAPACITY,\n            DEFAULT_ALIGNER_CAPACITY,\n            scoring,\n        )\n    }\n\n    /// Create new aligner instance with scoring and size hint. The size hints help to\n    /// avoid unnecessary memory allocations.\n    ///\n    /// # Arguments\n    ///\n    /// * `m` - the expected size of x\n    /// * `n` - the expected size of y\n    /// * `scoring` - the scoring struct\n    pub fn with_capacity_and_scoring(m: usize, n: usize, scoring: Scoring\u003cF\u003e) -\u003e Self {\n        assert!(scoring.gap_open \u003c= 0, \"gap_open can't be positive\");\n        assert!(scoring.gap_extend \u003c= 0, \"gap_extend can't be positive\");\n        assert!(\n            scoring.xclip_prefix \u003c= 0,\n            \"Clipping penalty (x prefix) can't be positive\"\n        );\n        assert!(\n            scoring.xclip_suffix \u003c= 0,\n            \"Clipping penalty (x suffix) can't be positive\"\n        );\n        assert!(\n            scoring.yclip_prefix \u003c= 0,\n            \"Clipping penalty (y prefix) can't be positive\"\n        );\n        assert!(\n            scoring.yclip_suffix \u003c= 0,\n            \"Clipping penalty (y suffix) can't be positive\"\n        );\n\n        Aligner {\n            I: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            D: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            S: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            Lx: Vec::with_capacity(n + 1),\n            Ly: Vec::with_capacity(m + 1),\n            Sn: Vec::with_capacity(m + 1),\n            traceback: Traceback::with_capacity(m, n),\n            scoring,\n        }\n    }\n\n    /// The core function to compute the alignment\n    ///\n    /// # Arguments\n    ///\n    /// * `x` - Textslice\n    /// * `y` - Textslice\n    pub fn custom(\u0026mut self, x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) -\u003e Alignment {\n        let (m, n) = (x.len(), y.len());\n        self.traceback.init(m, n);\n\n        // Set the initial conditions\n        // We are repeating some work, but that's okay!\n        for k in 0..2 {\n            self.I[k].clear();\n            self.D[k].clear();\n            self.S[k].clear();\n\n            self.D[k].extend(repeat(MIN_SCORE).take(m + 1));\n            self.I[k].extend(repeat(MIN_SCORE).take(m + 1));\n            self.S[k].extend(repeat(MIN_SCORE).take(m + 1));\n\n            self.S[k][0] = 0;\n\n            if k == 0 {\n                let mut tb = TracebackCell::new();\n                tb.set_all(TB_START);\n                self.traceback.set(0, 0, tb);\n                self.Lx.clear();\n                self.Lx.extend(repeat(0usize).take(n + 1));\n                self.Ly.clear();\n                self.Ly.extend(repeat(0usize).take(m + 1));\n                self.Sn.clear();\n                self.Sn.extend(repeat(MIN_SCORE).take(m + 1));\n                self.Sn[0] = self.scoring.yclip_suffix;\n                self.Ly[0] = n;\n            }\n\n            for i in 1..=m {\n                let mut tb = TracebackCell::new();\n                tb.set_all(TB_START);\n                if i == 1 {\n                    self.I[k][i] = self.scoring.gap_open + self.scoring.gap_extend;\n                    tb.set_i_bits(TB_START);\n                } else {\n                    // Insert all i characters\n                    let i_score = self.scoring.gap_open + self.scoring.gap_extend * (i as i32);\n                    let c_score =\n                        self.scoring.xclip_prefix + self.scoring.gap_open + self.scoring.gap_extend; // Clip then insert\n                    if i_score \u003e c_score {\n                        self.I[k][i] = i_score;\n                        tb.set_i_bits(TB_INS);\n                    } else {\n                        self.I[k][i] = c_score;\n                        tb.set_i_bits(TB_XCLIP_PREFIX);\n                    }\n                }\n\n                if i == m {\n                    tb.set_s_bits(TB_XCLIP_SUFFIX);\n                } else {\n                    self.S[k][i] = MIN_SCORE;\n                }\n\n                if self.I[k][i] \u003e self.S[k][i] {\n                    self.S[k][i] = self.I[k][i];\n                    tb.set_s_bits(TB_INS);\n                }\n\n                if self.scoring.xclip_prefix \u003e self.S[k][i] {\n                    self.S[k][i] = self.scoring.xclip_prefix;\n                    tb.set_s_bits(TB_XCLIP_PREFIX);\n                }\n\n                // Track the score if we do a suffix clip (x) after this character\n                if i != m \u0026\u0026 self.S[k][i] + self.scoring.xclip_suffix \u003e self.S[k][m] {\n                    self.S[k][m] = self.S[k][i] + self.scoring.xclip_suffix;\n                    self.Lx[0] = m - i;\n                }\n\n                if k == 0 {\n                    self.traceback.set(i, 0, tb);\n                }\n                // Track the score if we do suffix clip (y) from here\n                if self.S[k][i] + self.scoring.yclip_suffix \u003e self.Sn[i] {\n                    self.Sn[i] = self.S[k][i] + self.scoring.yclip_suffix;\n                    self.Ly[i] = n;\n                }\n            }\n        }\n\n        for j in 1..=n {\n            let curr = j % 2;\n            let prev = 1 - curr;\n\n            {\n                // Handle i = 0 case\n                let mut tb = TracebackCell::new();\n                self.I[curr][0] = MIN_SCORE;\n\n                if j == 1 {\n                    self.D[curr][0] = self.scoring.gap_open + self.scoring.gap_extend;\n                    tb.set_d_bits(TB_START);\n                } else {\n                    // Delete all j characters\n                    let d_score = self.scoring.gap_open + self.scoring.gap_extend * (j as i32);\n                    let c_score =\n                        self.scoring.yclip_prefix + self.scoring.gap_open + self.scoring.gap_extend;\n                    if d_score \u003e c_score {\n                        self.D[curr][0] = d_score;\n                        tb.set_d_bits(TB_DEL);\n                    } else {\n                        self.D[curr][0] = c_score;\n                        tb.set_d_bits(TB_YCLIP_PREFIX);\n                    }\n                }\n                if self.D[curr][0] \u003e self.scoring.yclip_prefix {\n                    self.S[curr][0] = self.D[curr][0];\n                    tb.set_s_bits(TB_DEL);\n                } else {\n                    self.S[curr][0] = self.scoring.yclip_prefix;\n                    tb.set_s_bits(TB_YCLIP_PREFIX);\n                }\n\n                if j == n \u0026\u0026 self.Sn[0] \u003e self.S[curr][0] {\n                    // Check if the suffix clip score is better\n                    self.S[curr][0] = self.Sn[0];\n                    tb.set_s_bits(TB_YCLIP_SUFFIX);\n                // Track the score if we do suffix clip (y) from here\n                } else if self.S[curr][0] + self.scoring.yclip_suffix \u003e self.Sn[0] {\n                    self.Sn[0] = self.S[curr][0] + self.scoring.yclip_suffix;\n                    self.Ly[0] = n - j;\n                }\n\n                self.traceback.set(0, j, tb);\n            }\n\n            for i in 1..=m {\n                self.S[curr][i] = MIN_SCORE;\n            }\n\n            let q = y[j - 1];\n            let xclip_score = self.scoring.xclip_prefix\n                + max(\n                    self.scoring.yclip_prefix,\n                    self.scoring.gap_open + self.scoring.gap_extend * (j as i32),\n                );\n            for i in 1..m + 1 {\n                let p = x[i - 1];\n                let mut tb = TracebackCell::new();\n\n                let m_score = self.S[prev][i - 1] + self.scoring.match_fn.score(p, q);\n\n                let i_score = self.I[curr][i - 1] + self.scoring.gap_extend;\n                let s_score = self.S[curr][i - 1] + self.scoring.gap_open + self.scoring.gap_extend;\n                let best_i_score;\n                if i_score \u003e s_score {\n                    best_i_score = i_score;\n                    tb.set_i_bits(TB_INS);\n                } else {\n                    best_i_score = s_score;\n                    tb.set_i_bits(self.traceback.get(i - 1, j).get_s_bits());\n                }\n\n                let d_score = self.D[prev][i] + self.scoring.gap_extend;\n                let s_score = self.S[prev][i] + self.scoring.gap_open + self.scoring.gap_extend;\n                let best_d_score;\n                if d_score \u003e s_score {\n                    best_d_score = d_score;\n                    tb.set_d_bits(TB_DEL);\n                } else {\n                    best_d_score = s_score;\n                    tb.set_d_bits(self.traceback.get(i, j - 1).get_s_bits());\n                }\n\n                tb.set_s_bits(TB_XCLIP_SUFFIX);\n                let mut best_s_score = self.S[curr][i];\n\n                if m_score \u003e best_s_score {\n                    best_s_score = m_score;\n                    tb.set_s_bits(if p == q { TB_MATCH } else { TB_SUBST });\n                }\n\n                if best_i_score \u003e best_s_score {\n                    best_s_score = best_i_score;\n                    tb.set_s_bits(TB_INS);\n                }\n\n                if best_d_score \u003e best_s_score {\n                    best_s_score = best_d_score;\n                    tb.set_s_bits(TB_DEL);\n                }\n\n                if xclip_score \u003e best_s_score {\n                    best_s_score = xclip_score;\n                    tb.set_s_bits(TB_XCLIP_PREFIX);\n                }\n\n                let yclip_score = self.scoring.yclip_prefix\n                    + self.scoring.gap_open\n                    + self.scoring.gap_extend * (i as i32);\n                if yclip_score \u003e best_s_score {\n                    best_s_score = yclip_score;\n                    tb.set_s_bits(TB_YCLIP_PREFIX);\n                }\n\n                self.S[curr][i] = best_s_score;\n                self.I[curr][i] = best_i_score;\n                self.D[curr][i] = best_d_score;\n\n                // Track the score if we do suffix clip (x) from here\n                if self.S[curr][i] + self.scoring.xclip_suffix \u003e self.S[curr][m] {\n                    self.S[curr][m] = self.S[curr][i] + self.scoring.xclip_suffix;\n                    self.Lx[j] = m - i;\n                }\n\n                // Track the score if we do suffix clip (y) from here\n                if self.S[curr][i] + self.scoring.yclip_suffix \u003e self.Sn[i] {\n                    self.Sn[i] = self.S[curr][i] + self.scoring.yclip_suffix;\n                    self.Ly[i] = n - j;\n                }\n\n                self.traceback.set(i, j, tb);\n            }\n        }\n\n        // Handle suffix clipping in the j=n case\n        for i in 0..=m {\n            let j = n;\n            let curr = j % 2;\n            if self.Sn[i] \u003e self.S[curr][i] {\n                self.S[curr][i] = self.Sn[i];\n                self.traceback.get_mut(i, j).set_s_bits(TB_YCLIP_SUFFIX);\n            }\n            if self.S[curr][i] + self.scoring.xclip_suffix \u003e self.S[curr][m] {\n                self.S[curr][m] = self.S[curr][i] + self.scoring.xclip_suffix;\n                self.Lx[j] = m - i;\n                self.traceback.get_mut(m, j).set_s_bits(TB_XCLIP_SUFFIX);\n            }\n        }\n\n        // Since there could be a change in the last column of S,\n        // recompute the last column of I as this could also change\n        for i in 1..=m {\n            let j = n;\n            let curr = j % 2;\n            let s_score = self.S[curr][i - 1] + self.scoring.gap_open + self.scoring.gap_extend;\n            if s_score \u003e self.I[curr][i] {\n                self.I[curr][i] = s_score;\n                let s_bit = self.traceback.get(i - 1, j).get_s_bits();\n                self.traceback.get_mut(i, j).set_i_bits(s_bit);\n            }\n            if s_score \u003e self.S[curr][i] {\n                self.S[curr][i] = s_score;\n                self.traceback.get_mut(i, j).set_s_bits(TB_INS);\n                if self.S[curr][i] + self.scoring.xclip_suffix \u003e self.S[curr][m] {\n                    self.S[curr][m] = self.S[curr][i] + self.scoring.xclip_suffix;\n                    self.Lx[j] = m - i;\n                    self.traceback.get_mut(m, j).set_s_bits(TB_XCLIP_SUFFIX);\n                }\n            }\n        }\n\n        let mut i = m;\n        let mut j = n;\n        let mut operations = Vec::with_capacity(x.len());\n        let mut xstart: usize = 0usize;\n        let mut ystart: usize = 0usize;\n        let mut xend = m;\n        let mut yend = n;\n\n        let mut last_layer = self.traceback.get(i, j).get_s_bits();\n\n        loop {\n            let next_layer: u16;\n            match last_layer {\n                TB_START =\u003e break,\n                TB_INS =\u003e {\n                    operations.push(AlignmentOperation::Ins);\n                    next_layer = self.traceback.get(i, j).get_i_bits();\n                    i -= 1;\n                }\n                TB_DEL =\u003e {\n                    operations.push(AlignmentOperation::Del);\n                    next_layer = self.traceback.get(i, j).get_d_bits();\n                    j -= 1;\n                }\n                TB_MATCH =\u003e {\n                    operations.push(AlignmentOperation::Match);\n                    next_layer = self.traceback.get(i - 1, j - 1).get_s_bits();\n                    i -= 1;\n                    j -= 1;\n                }\n                TB_SUBST =\u003e {\n                    operations.push(AlignmentOperation::Subst);\n                    next_layer = self.traceback.get(i - 1, j - 1).get_s_bits();\n                    i -= 1;\n                    j -= 1;\n                }\n                TB_XCLIP_PREFIX =\u003e {\n                    operations.push(AlignmentOperation::Xclip(i));\n                    xstart = i;\n                    i = 0;\n                    next_layer = self.traceback.get(0, j).get_s_bits();\n                }\n                TB_XCLIP_SUFFIX =\u003e {\n                    operations.push(AlignmentOperation::Xclip(self.Lx[j]));\n                    i -= self.Lx[j];\n                    xend = i;\n                    next_layer = self.traceback.get(i, j).get_s_bits();\n                }\n                TB_YCLIP_PREFIX =\u003e {\n                    operations.push(AlignmentOperation::Yclip(j));\n                    ystart = j;\n                    j = 0;\n                    next_layer = self.traceback.get(i, 0).get_s_bits();\n                }\n                TB_YCLIP_SUFFIX =\u003e {\n                    operations.push(AlignmentOperation::Yclip(self.Ly[i]));\n                    j -= self.Ly[i];\n                    yend = j;\n                    next_layer = self.traceback.get(i, j).get_s_bits();\n                }\n                _ =\u003e panic!(\"Dint expect this!\"),\n            }\n            last_layer = next_layer;\n        }\n\n        operations.reverse();\n        Alignment {\n            score: self.S[n % 2][m],\n            ystart,\n            xstart,\n            yend,\n            xend,\n            ylen: n,\n            xlen: m,\n            operations,\n            mode: AlignmentMode::Custom,\n        }\n    }\n\n    /// Calculate global alignment of x against y.\n    pub fn global(\u0026mut self, x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) -\u003e Alignment {\n        // Store the current clip penalties\n        let clip_penalties = [\n            self.scoring.xclip_prefix,\n            self.scoring.xclip_suffix,\n            self.scoring.yclip_prefix,\n            self.scoring.yclip_suffix,\n        ];\n\n        // Temporarily Over-write the clip penalties\n        self.scoring.xclip_prefix = MIN_SCORE;\n        self.scoring.xclip_suffix = MIN_SCORE;\n        self.scoring.yclip_prefix = MIN_SCORE;\n        self.scoring.yclip_suffix = MIN_SCORE;\n\n        // Compute the alignment\n        let mut alignment = self.custom(x, y);\n        alignment.mode = AlignmentMode::Global;\n\n        // Set the clip penalties to the original values\n        self.scoring.xclip_prefix = clip_penalties[0];\n        self.scoring.xclip_suffix = clip_penalties[1];\n        self.scoring.yclip_prefix = clip_penalties[2];\n        self.scoring.yclip_suffix = clip_penalties[3];\n\n        alignment\n    }\n\n    /// Calculate semiglobal alignment of x against y (x is global, y is local).\n    pub fn semiglobal(\u0026mut self, x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) -\u003e Alignment {\n        // Store the current clip penalties\n        let clip_penalties = [\n            self.scoring.xclip_prefix,\n            self.scoring.xclip_suffix,\n            self.scoring.yclip_prefix,\n            self.scoring.yclip_suffix,\n        ];\n\n        // Temporarily Over-write the clip penalties\n        self.scoring.xclip_prefix = MIN_SCORE;\n        self.scoring.xclip_suffix = MIN_SCORE;\n        self.scoring.yclip_prefix = 0;\n        self.scoring.yclip_suffix = 0;\n\n        // Compute the alignment\n        let mut alignment = self.custom(x, y);\n        alignment.mode = AlignmentMode::Semiglobal;\n\n        // Filter out Xclip and Yclip from alignment.operations\n        alignment.filter_clip_operations();\n\n        // Set the clip penalties to the original values\n        self.scoring.xclip_prefix = clip_penalties[0];\n        self.scoring.xclip_suffix = clip_penalties[1];\n        self.scoring.yclip_prefix = clip_penalties[2];\n        self.scoring.yclip_suffix = clip_penalties[3];\n\n        alignment\n    }\n\n    /// Calculate local alignment of x against y.\n    pub fn local(\u0026mut self, x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) -\u003e Alignment {\n        // Store the current clip penalties\n        let clip_penalties = [\n            self.scoring.xclip_prefix,\n            self.scoring.xclip_suffix,\n            self.scoring.yclip_prefix,\n            self.scoring.yclip_suffix,\n        ];\n\n        // Temporarily Over-write the clip penalties\n        self.scoring.xclip_prefix = 0;\n        self.scoring.xclip_suffix = 0;\n        self.scoring.yclip_prefix = 0;\n        self.scoring.yclip_suffix = 0;\n\n        // Compute the alignment\n        let mut alignment = self.custom(x, y);\n        alignment.mode = AlignmentMode::Local;\n\n        // Filter out Xclip and Yclip from alignment.operations\n        alignment.filter_clip_operations();\n\n        // Set the clip penalties to the original values\n        self.scoring.xclip_prefix = clip_penalties[0];\n        self.scoring.xclip_suffix = clip_penalties[1];\n        self.scoring.yclip_prefix = clip_penalties[2];\n        self.scoring.yclip_suffix = clip_penalties[3];\n\n        alignment\n    }\n}\n\n/// Packed representation of one cell of a Smith-Waterman traceback matrix.\n/// Stores the I, D and S traceback matrix values in two bytes.\n/// Possible traceback moves include : start, insert, delete, match, substitute,\n/// prefix clip and suffix clip for x \u0026 y. So we need 4 bits each for matrices I, D, S\n/// to keep track of these 9 moves.\n#[derive(Copy, Clone)]\npub struct TracebackCell {\n    v: u16,\n}\n\nimpl Default for TracebackCell {\n    fn default() -\u003e Self {\n        TracebackCell { v: 0 }\n    }\n}\n\n// Traceback bit positions (LSB)\nconst I_POS: u8 = 0; // Meaning bits 0,1,2,3 corresponds to I and so on\nconst D_POS: u8 = 4;\nconst S_POS: u8 = 8;\n\n// Traceback moves\nconst TB_START: u16 = 0b0000;\nconst TB_INS: u16 = 0b0001;\nconst TB_DEL: u16 = 0b0010;\nconst TB_SUBST: u16 = 0b0011;\nconst TB_MATCH: u16 = 0b0100;\n\nconst TB_XCLIP_PREFIX: u16 = 0b0101; // prefix clip of x\nconst TB_XCLIP_SUFFIX: u16 = 0b0110; // suffix clip of x\nconst TB_YCLIP_PREFIX: u16 = 0b0111; // prefix clip of y\nconst TB_YCLIP_SUFFIX: u16 = 0b1000; // suffix clip of y\n\nconst TB_MAX: u16 = 0b1000; // Useful in checking that the\n                            // TB value we got is a valid one\n\nimpl TracebackCell {\n    /// Initialize a blank traceback cell\n    #[inline(always)]\n    pub fn new() -\u003e TracebackCell {\n        Default::default()\n    }\n\n    /// Sets 4 bits [pos, pos+4) with the 4 LSBs of value\n    #[inline(always)]\n    fn set_bits(\u0026mut self, pos: u8, value: u16) {\n        let bits: u16 = (0b1111) \u003c\u003c pos;\n        assert!(\n            value \u003c= TB_MAX,\n            \"Expected a value \u003c= TB_MAX while setting traceback bits\"\n        );\n        self.v = (self.v \u0026 !bits) // First clear the bits\n            | (value \u003c\u003c pos) // And set the bits\n    }\n\n    #[inline(always)]\n    pub fn set_i_bits(\u0026mut self, value: u16) {\n        // Traceback corresponding to matrix I\n        self.set_bits(I_POS, value);\n    }\n\n    #[inline(always)]\n    pub fn set_d_bits(\u0026mut self, value: u16) {\n        // Traceback corresponding to matrix D\n        self.set_bits(D_POS, value);\n    }\n\n    #[inline(always)]\n    pub fn set_s_bits(\u0026mut self, value: u16) {\n        // Traceback corresponding to matrix S\n        self.set_bits(S_POS, value);\n    }\n\n    // Gets 4 bits [pos, pos+4) of v\n    #[inline(always)]\n    fn get_bits(self, pos: u8) -\u003e u16 {\n        (self.v \u003e\u003e pos) \u0026 (0b1111)\n    }\n\n    #[inline(always)]\n    pub fn get_i_bits(self) -\u003e u16 {\n        self.get_bits(I_POS)\n    }\n\n    #[inline(always)]\n    pub fn get_d_bits(self) -\u003e u16 {\n        self.get_bits(D_POS)\n    }\n\n    #[inline(always)]\n    pub fn get_s_bits(self) -\u003e u16 {\n        self.get_bits(S_POS)\n    }\n\n    /// Set all matrices to the same value.\n    pub fn set_all(\u0026mut self, value: u16) {\n        self.set_i_bits(value);\n        self.set_d_bits(value);\n        self.set_s_bits(value);\n    }\n}\n\n/// Internal traceback.\nstruct Traceback {\n    rows: usize,\n    cols: usize,\n    matrix: Vec\u003cTracebackCell\u003e,\n}\n\nimpl Traceback {\n    fn with_capacity(m: usize, n: usize) -\u003e Self {\n        let rows = m + 1;\n        let cols = n + 1;\n        Traceback {\n            rows,\n            cols,\n            matrix: Vec::with_capacity(rows * cols),\n        }\n    }\n\n    fn init(\u0026mut self, m: usize, n: usize) {\n        self.matrix.clear();\n        let mut start = TracebackCell::new();\n        start.set_all(TB_START);\n        // set every cell to start\n        self.resize(m, n, start);\n    }\n\n    #[inline(always)]\n    fn set(\u0026mut self, i: usize, j: usize, v: TracebackCell) {\n        debug_assert!(i \u003c self.rows);\n        debug_assert!(j \u003c self.cols);\n        self.matrix[i * self.cols + j] = v;\n    }\n\n    #[inline(always)]\n    fn get(\u0026self, i: usize, j: usize) -\u003e \u0026TracebackCell {\n        debug_assert!(i \u003c self.rows);\n        debug_assert!(j \u003c self.cols);\n        \u0026self.matrix[i * self.cols + j]\n    }\n\n    fn get_mut(\u0026mut self, i: usize, j: usize) -\u003e \u0026mut TracebackCell {\n        debug_assert!(i \u003c self.rows);\n        debug_assert!(j \u003c self.cols);\n        \u0026mut self.matrix[i * self.cols + j]\n    }\n\n    fn resize(\u0026mut self, m: usize, n: usize, v: TracebackCell) {\n        self.rows = m + 1;\n        self.cols = n + 1;\n        self.matrix.resize(self.rows * self.cols, v);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::alignment::AlignmentOperation::*;\n    use crate::scores::blosum62;\n\n    #[test]\n    fn traceback_cell() {\n        let mut tb = TracebackCell::new();\n\n        tb.set_all(TB_SUBST);\n        assert_eq!(tb.get_i_bits(), TB_SUBST);\n        assert_eq!(tb.get_d_bits(), TB_SUBST);\n        assert_eq!(tb.get_s_bits(), TB_SUBST);\n\n        tb.set_d_bits(TB_INS);\n        assert_eq!(tb.get_d_bits(), TB_INS);\n\n        tb.set_i_bits(TB_XCLIP_PREFIX);\n        assert_eq!(tb.get_d_bits(), TB_INS);\n        assert_eq!(tb.get_i_bits(), TB_XCLIP_PREFIX);\n\n        tb.set_d_bits(TB_DEL);\n        assert_eq!(tb.get_d_bits(), TB_DEL);\n        assert_eq!(tb.get_i_bits(), TB_XCLIP_PREFIX);\n\n        tb.set_s_bits(TB_YCLIP_SUFFIX);\n        assert_eq!(tb.get_d_bits(), TB_DEL);\n        assert_eq!(tb.get_i_bits(), TB_XCLIP_PREFIX);\n        assert_eq!(tb.get_s_bits(), TB_YCLIP_SUFFIX);\n    }\n\n    #[test]\n    fn test_semiglobal() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, score);\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    // Test case for underflow of the SW score.\n    #[test]\n    fn test_semiglobal_gap_open_lt_mismatch() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -5i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -1, -1, score);\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Del, Match, Ins, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_global_affine_ins() {\n        let x = b\"ACGAGAACA\";\n        let y = b\"ACGACA\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, score);\n        let alignment = aligner.global(x, y);\n\n        println!(\"aln:\\n{}\", alignment.pretty(x, y));\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Ins, Ins, Ins, Match, Match, Match]\n        );\n    }\n\n    #[test]\n    fn test_global_affine_ins2() {\n        let x = b\"AGATAGATAGATAGGGAGTTGTGTAGATGATCCACAGT\";\n        let y = b\"AGATAGATAGATGTAGATGATCCACAGT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, score);\n        let alignment = aligner.global(x, y);\n\n        println!(\"aln:\\n{}\", alignment.pretty(x, y));\n\n        let mut correct = Vec::new();\n        correct.extend(repeat(Match).take(11));\n        correct.extend(repeat(Ins).take(10));\n        correct.extend(repeat(Match).take(17));\n\n        assert_eq!(alignment.operations, correct);\n    }\n\n    #[test]\n    fn test_local_affine_ins2() {\n        let x = b\"ACGTATCATAGATAGATAGGGTTGTGTAGATGATCCACAG\";\n        let y = b\"CGTATCATAGATAGATGTAGATGATCCACAGT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, score);\n        let alignment = aligner.local(x, y);\n        assert_eq!(alignment.xstart, 1);\n        assert_eq!(alignment.ystart, 0);\n    }\n\n    #[test]\n    fn test_local() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, score);\n        let alignment = aligner.local(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_global() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, score);\n        let alignment = aligner.global(x, y);\n\n        println!(\"\\naln:\\n{}\", alignment.pretty(x, y));\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Del, Del, Del, Del, Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_blosum62() {\n        let x = b\"AAAA\";\n        let y = b\"AAAA\";\n        let score = \u0026blosum62;\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, score);\n        let alignment = aligner.global(x, y);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.score, 16);\n        assert_eq!(alignment.operations, [Match, Match, Match, Match]);\n    }\n\n    #[test]\n    fn test_blosum62_local() {\n        let x = b\"LSPADKTNVKAA\";\n        let y = b\"PEEKSAV\";\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -10, -1, \u0026blosum62);\n        let alignment = aligner.local(x, y);\n        assert_eq!(alignment.xstart, 2);\n        assert_eq!(alignment.xend, 9);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.yend, 7);\n        assert_eq!(\n            alignment.operations,\n            [Match, Subst, Subst, Match, Subst, Subst, Match]\n        );\n        assert_eq!(alignment.score, 16);\n    }\n\n    #[test]\n    fn test_issue11() {\n        let y = b\"TACC\"; //GTGGAC\";\n        let x = b\"AAAAACC\"; //GTTGACGCAA\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let alignment = aligner.global(x, y);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Ins, Ins, Ins, Subst, Match, Match, Match]\n        );\n    }\n\n    #[test]\n    fn test_issue12_1() {\n        let x = b\"CCGGCA\";\n        let y = b\"ACCGTTGACGC\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.ystart, 1);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Subst, Subst, Subst]\n        );\n    }\n\n    #[test]\n    fn test_issue12_2() {\n        let y = b\"CCGGCA\";\n        let x = b\"ACCGTTGACGC\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.ystart, 0);\n\n        assert_eq!(\n            alignment.operations,\n            [Subst, Match, Ins, Ins, Ins, Ins, Ins, Ins, Subst, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_issue12_3() {\n        let y = b\"CCGTCCGGCAA\";\n        let x = b\"AAAAACCGTTGACGCAA\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let alignment = aligner.semiglobal(x, y);\n\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [\n                Ins, Ins, Ins, Ins, Ins, Ins, Match, Subst, Subst, Match, Subst, Subst, Subst,\n                Match, Match, Match, Match,\n            ]\n        );\n\n        let mut aligner = Aligner::with_capacity(y.len(), x.len(), -5, -1, \u0026score);\n        let alignment = aligner.semiglobal(y, x);\n\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Subst, Subst, Match, Subst, Subst, Subst, Match, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_left_aligned_del() {\n        let x = b\"GTGCATCATGTG\";\n        let y = b\"GTGCATCATCATGTG\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let alignment = aligner.global(x, y);\n        println!(\"\\naln:\\n{}\", alignment.pretty(x, y));\n\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [\n                Match, Match, Match, Del, Del, Del, Match, Match, Match, Match, Match, Match,\n                Match, Match, Match,\n            ]\n        );\n    }\n\n    // Test that trailing deletions are correctly handled\n    // in global mode\n    #[test]\n    fn test_global_right_del() {\n        let x = b\"AACCACGTACGTGGGGGGA\";\n        let y = b\"CCACGTACGT\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let alignment = aligner.global(x, y);\n\n        println!(\"\\naln:\\n{}\", alignment.pretty(x, y));\n\n        println!(\"score:{}\", alignment.score);\n        assert_eq!(alignment.score, -9);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [\n                Ins, Ins, Match, Match, Match, Match, Match, Match, Match, Match, Match, Match,\n                Ins, Ins, Ins, Ins, Ins, Ins, Ins,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_left_aligned_ins() {\n        let x = b\"GTGCATCATCATGTG\";\n        let y = b\"GTGCATCATGTG\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let alignment = aligner.global(x, y);\n        println!(\"\\naln:\\n{}\", alignment.pretty(x, y));\n\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [\n                Match, Match, Match, Ins, Ins, Ins, Match, Match, Match, Match, Match, Match,\n                Match, Match, Match,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_aligner_new() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::new(-5, -1, \u0026score);\n\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n\n        let alignment = aligner.local(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n\n        let alignment = aligner.global(x, y);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Del, Del, Del, Del, Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_semiglobal_simple() {\n        let x = b\"GAAAACCGTTGAT\";\n        let y = b\"ACCGTGGATGGG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::new(-5, -1, \u0026score);\n        let alignment = aligner.semiglobal(x, y);\n\n        assert_eq!(\n            alignment.operations,\n            [Ins, Ins, Ins, Ins, Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_insert_only_semiglobal() {\n        let x = b\"TTTT\";\n        let y = b\"AAAA\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let mut aligner = Aligner::new(-5, -1, \u0026score);\n        let alignment = aligner.semiglobal(x, y);\n\n        assert_eq!(alignment.operations, [Ins, Ins, Ins, Ins]);\n    }\n\n    #[test]\n    fn test_insert_in_between_semiglobal() {\n        let x = b\"GGGGG\";\n        let y = b\"GGTAGGG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let mut aligner = Aligner::new(-5, -1, \u0026score);\n        let alignment = aligner.semiglobal(x, y);\n\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Del, Del, Match, Match, Match]\n        );\n    }\n\n    #[test]\n    fn test_xclip_prefix_custom() {\n        let x = b\"GGGGGGATG\";\n        let y = b\"ATG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).xclip(-5);\n\n        let mut aligner = Aligner::with_scoring(scoring);\n        let alignment = aligner.custom(x, y);\n\n        assert_eq!(alignment.operations, [Xclip(6), Match, Match, Match]);\n    }\n\n    #[test]\n    fn test_yclip_prefix_custom() {\n        let y = b\"GGGGGGATG\";\n        let x = b\"ATG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).yclip(-5);\n\n        let mut aligner = Aligner::with_scoring(scoring);\n        let alignment = aligner.custom(x, y);\n\n        assert_eq!(alignment.operations, [Yclip(6), Match, Match, Match]);\n    }\n\n    #[test]\n    fn test_xclip_suffix_custom() {\n        let x = b\"GAAAA\";\n        let y = b\"CG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).xclip(-5).yclip(0);\n\n        let mut aligner = Aligner::with_scoring(scoring);\n        let alignment = aligner.custom(x, y);\n\n        assert_eq!(alignment.operations, [Yclip(1), Match, Xclip(4)]);\n    }\n\n    #[test]\n    fn test_yclip_suffix_custom() {\n        let y = b\"GAAAA\";\n        let x = b\"CG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).yclip(-5).xclip(0);\n\n        let mut aligner = Aligner::with_scoring(scoring);\n        let alignment = aligner.custom(x, y);\n\n        assert_eq!(alignment.operations, [Xclip(1), Match, Yclip(4)]);\n    }\n\n    #[test]\n    fn test_xclip_prefix_suffix() {\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let scoring1 = Scoring::new(-5, -1, \u0026score).xclip(-5);\n        let scoring2 = Scoring::new(-5, -1, \u0026score)\n            .xclip_prefix(-5)\n            .xclip_suffix(-5);\n\n        assert_eq!(scoring1.xclip_prefix, scoring2.xclip_prefix);\n        assert_eq!(scoring1.xclip_suffix, scoring2.xclip_suffix);\n    }\n\n    #[test]\n    fn test_yclip_prefix_suffix() {\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let scoring1 = Scoring::new(-5, -1, \u0026score).yclip(-5);\n        let scoring2 = Scoring::new(-5, -1, \u0026score)\n            .yclip_prefix(-5)\n            .yclip_suffix(-5);\n\n        assert_eq!(scoring1.yclip_prefix, scoring2.yclip_prefix);\n        assert_eq!(scoring1.yclip_suffix, scoring2.yclip_suffix);\n    }\n\n    #[test]\n    fn test_longer_string_all_operations() {\n        let x = b\"TTTTTGGGGGGATGGCCCCCCTTTTTTTTTTGGGAAAAAAAAAGGGGGG\";\n        let y = b\"GGGGGGATTTCCCCCCCCCTTTTTTTTTTAAAAAAAAA\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).xclip(-5).yclip(0);\n\n        let mut aligner = Aligner::with_scoring(scoring);\n        let alignment = aligner.custom(x, y);\n\n        println!(\"{}\", alignment.pretty(x, y));\n        assert_eq!(alignment.score, 7);\n    }\n\n    #[test]\n    fn test_scoring_from_scores() {\n        let y = b\"GGGGGGATG\";\n        let x = b\"ATG\";\n\n        let scoring = Scoring::from_scores(-5, -1, 1, -1).yclip(-5);\n\n        let mut aligner = Aligner::with_scoring(scoring);\n        let alignment = aligner.custom(x, y);\n\n        assert_eq!(alignment.operations, [Yclip(6), Match, Match, Match]);\n    }\n\n    #[test]\n    fn test_only_clips() {\n        let x = b\"GGAAAAAAAAAAAAA\";\n        let y = b\"TTTTAATTTGTGTAAAAAATAATA\";\n        let base_score = Scoring::from_scores(-4, -4, 4, -7);\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            xclip_suffix: 0,\n            yclip_suffix: 0,\n            ..base_score\n        };\n        let mut al = Aligner::with_scoring(scoring);\n        let alignment = al.custom(x, y);\n        assert_eq!(alignment.score, 0);\n    }\n\n    #[test]\n    fn test_zero_score_clips() {\n        let x = b\"AA\";\n        let y = b\"CC\";\n        let base_score = Scoring::from_scores(-1, -1, 1, -1);\n        {\n            let scoring = Scoring {\n                xclip_prefix: 0,\n                yclip_prefix: 0,\n                ..base_score.clone()\n            };\n            let mut al = Aligner::with_scoring(scoring);\n            let alignment = al.custom(x, y);\n            assert_eq!(alignment.score, 0);\n        }\n\n        {\n            let scoring = Scoring {\n                xclip_prefix: 0,\n                yclip_suffix: 0,\n                ..base_score.clone()\n            };\n            let mut al = Aligner::with_scoring(scoring);\n            let alignment = al.custom(x, y);\n            assert_eq!(alignment.score, 0);\n        }\n\n        {\n            let scoring = Scoring {\n                xclip_suffix: 0,\n                yclip_prefix: 0,\n                ..base_score.clone()\n            };\n            let mut al = Aligner::with_scoring(scoring);\n            let alignment = al.custom(x, y);\n            assert_eq!(alignment.score, 0);\n        }\n\n        {\n            let scoring = Scoring {\n                xclip_suffix: 0,\n                yclip_suffix: 0,\n                ..base_score\n            };\n            let mut al = Aligner::with_scoring(scoring);\n            let alignment = al.custom(x, y);\n            assert_eq!(alignment.score, 0);\n        }\n    }\n}\n","traces":[{"line":187,"address":[4802336],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":188,"address":[4802355,4802385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":189,"address":[4802443,4802473,4802371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[4802480],"length":1,"stats":{"Line":1},"fn_name":"score"},{"line":200,"address":[4802506,4802521],"length":1,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[4802527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[4802514],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":246,"address":[4802544],"length":1,"stats":{"Line":1},"fn_name":"from_scores"},{"line":252,"address":[4802622,4802592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[4802608,4802676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[4802660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[4802743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":99},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":99},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":598,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":133},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":99},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":98},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":98},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":656,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":133},"fn_name":null},{"line":662,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":670,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":671,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":672,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":675,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":677,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":679,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":101},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":99},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":713,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":131},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":723,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":724,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":726,"address":[],"length":0,"stats":{"Line":94},"fn_name":null},{"line":727,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":731,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":97},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":741,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":745,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":746,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":749,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":754,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":755,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":758,"address":[],"length":0,"stats":{"Line":57},"fn_name":null},{"line":759,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":763,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":764,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":765,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":768,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":769,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":770,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":771,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":772,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":778,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":781,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":782,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":787,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":788,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":789,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":115},"fn_name":null},{"line":798,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":800,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":806,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":807,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":813,"address":[],"length":0,"stats":{"Line":118},"fn_name":null},{"line":814,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":815,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":77},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":819,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":820,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":822,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":824,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":825,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":828,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":835,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":836,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":837,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":838,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":839,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":843,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":844,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":845,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":846,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":847,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":848,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":849,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":850,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":852,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":853,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":854,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":855,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":857,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":858,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":859,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":860,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":861,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":863,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":864,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":865,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":866,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":867,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":869,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":870,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":871,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":872,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":873,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":875,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":876,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":877,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":879,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":881,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":882,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":883,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":884,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":885,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":887,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":888,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":889,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":890,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":891,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":893,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":895,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":898,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":900,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":915,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":917,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":918,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":919,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":923,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":924,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":925,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":926,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":929,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":930,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":933,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":934,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":935,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":936,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":938,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":942,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":944,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":945,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":946,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":947,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":948,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":952,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":953,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":954,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":955,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":958,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":959,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":962,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":965,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":966,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":967,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":968,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":970,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":974,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":976,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":977,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":978,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":979,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":980,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":984,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":985,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":986,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":987,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":990,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":991,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":994,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":997,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":998,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":999,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1000,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1002,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1017,"address":[4802848],"length":1,"stats":{"Line":1},"fn_name":"default"},{"line":1045,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1046,"address":[4803899],"length":1,"stats":{"Line":229},"fn_name":null},{"line":1051,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1052,"address":[4802968,4803172,4803406,4803370,4802935,4803139],"length":1,"stats":{"Line":1254},"fn_name":null},{"line":1053,"address":[4802960,4803164,4803023,4803242,4803398,4803476],"length":1,"stats":{"Line":214},"fn_name":null},{"line":1054,"address":[4803157,4802953,4803391],"length":1,"stats":{"Line":218},"fn_name":null},{"line":1057,"address":[4803317,4803098,4803212,4803551,4803446,4803003],"length":1,"stats":{"Line":2533},"fn_name":null},{"line":1058,"address":[4803015,4803053,4803225,4803272,4803459,4803506],"length":1,"stats":{"Line":1260},"fn_name":null},{"line":1062,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1064,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1068,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1070,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1074,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1076,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1081,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1082,"address":[],"length":0,"stats":{"Line":424},"fn_name":null},{"line":1086,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1087,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1091,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1092,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1096,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1097,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1101,"address":[4802880],"length":1,"stats":{"Line":1},"fn_name":"set_all"},{"line":1102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1116,"address":[4803568],"length":1,"stats":{"Line":1},"fn_name":"with_capacity"},{"line":1117,"address":[4803646,4803597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1118,"address":[4803686,4803707,4803628],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1122,"address":[4803691,4803741],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1126,"address":[4803856],"length":1,"stats":{"Line":1},"fn_name":"init"},{"line":1127,"address":[4803889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1128,"address":[4803905],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1129,"address":[4803910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1131,"address":[4803937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1136,"address":[],"length":0,"stats":{"Line":227},"fn_name":null},{"line":1137,"address":[],"length":0,"stats":{"Line":231},"fn_name":null},{"line":1138,"address":[],"length":0,"stats":{"Line":459},"fn_name":null},{"line":1142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1143,"address":[],"length":0,"stats":{"Line":409},"fn_name":null},{"line":1144,"address":[],"length":0,"stats":{"Line":412},"fn_name":null},{"line":1145,"address":[],"length":0,"stats":{"Line":823},"fn_name":null},{"line":1148,"address":[4803952],"length":1,"stats":{"Line":2},"fn_name":"get_mut"},{"line":1149,"address":[4804023,4803986],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1150,"address":[4804008,4804093],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1151,"address":[4804133,4804063],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1154,"address":[4804256],"length":1,"stats":{"Line":1},"fn_name":"resize"},{"line":1155,"address":[4804350,4804298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1156,"address":[4804332,4804390,4804426],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1157,"address":[4804394,4804470],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1168,"address":[4478485,4478480],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1169,"address":[5581132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1171,"address":[5581140],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1172,"address":[5581468,5581248,5581158],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1173,"address":[5581516,5581442,5581348,5581728],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1174,"address":[5581608,5581776,5582074,5581702],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1176,"address":[5582056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1177,"address":[5582522,5582122,5582216],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1179,"address":[5582504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1180,"address":[5582570,5582880,5582664],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1181,"address":[5583220,5582928,5582764,5582854],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1183,"address":[5583202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1184,"address":[5583268,5583554,5583356],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1185,"address":[5583602,5583450,5583534,5583882],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1187,"address":[5583870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1188,"address":[5583930,5584018,5584216],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1189,"address":[5584196,5584458,5584112,5584264],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1190,"address":[5584350,5584506,5584438,5584610],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1194,"address":[4478512,4478517],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1195,"address":[5584679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1196,"address":[5584694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1197,"address":[4478544,4478566],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1198,"address":[5584709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1199,"address":[5584786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1200,"address":[5584831,5585066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1201,"address":[5584960,5585254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1202,"address":[5585158,5585345,5585310],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1210,"address":[4478608,4478613],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1211,"address":[5585447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1212,"address":[5585462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1213,"address":[4478640,4478662],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1214,"address":[5585477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1215,"address":[5585552],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1216,"address":[5585597,5585832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1217,"address":[5586020,5585726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1218,"address":[5586111,5585924,5586076],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1225,"address":[4478704,4478709],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1226,"address":[5586215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1227,"address":[5586230],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1228,"address":[4478758,4478736],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1229,"address":[5586245],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1230,"address":[5586322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1232,"address":[5586465,5586367,5586571],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1233,"address":[5586704,5586827],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1240,"address":[4478805,4478800],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1241,"address":[5586919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1242,"address":[5586934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1243,"address":[4478854,4478832],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1244,"address":[5586949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1245,"address":[5587026],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1247,"address":[5587275,5587071,5587169],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1249,"address":[5587408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1250,"address":[5587427,5587565],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1251,"address":[5587572],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1252,"address":[5587676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1254,"address":[5587908,5587780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1258,"address":[4478901,4478896],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1259,"address":[5588023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1260,"address":[5588038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1261,"address":[4478950,4478928],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1262,"address":[5588053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1263,"address":[5588130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1264,"address":[5588175,5588402],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1265,"address":[5588304,5588523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1269,"address":[4478992,4478997],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1270,"address":[5588615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1271,"address":[5588630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1272,"address":[4479024,4479046],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1273,"address":[5588645],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1274,"address":[5588722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1275,"address":[5589002,5588767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1276,"address":[5588896,5589190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1277,"address":[5589246,5589094,5589281],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1284,"address":[4479088,4479093],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1285,"address":[5589383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1286,"address":[5589398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1287,"address":[4479120,4479142],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1288,"address":[5589413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1289,"address":[5589490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1291,"address":[5589739,5589535,5589633],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1292,"address":[5589872,5590064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1293,"address":[5589958,5590210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1294,"address":[5590300,5590115,5590266],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1301,"address":[4479184,4479189],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1302,"address":[5590391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1303,"address":[5590406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1304,"address":[5590421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1305,"address":[5590436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1306,"address":[5590520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1307,"address":[5590794,5590559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1308,"address":[5590688,5590991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1309,"address":[5590886,5591139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1310,"address":[5591043,5591195,5591230],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1314,"address":[4479216,4479221],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1315,"address":[5591319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1316,"address":[5591334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1317,"address":[5591349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1318,"address":[5591433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1319,"address":[5591717,5591478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1320,"address":[5591611,5591911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1321,"address":[5591809,5592069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1322,"address":[5592217,5591963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1323,"address":[5592121,5592273,5592379],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1327,"address":[5592279,5592454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1331,"address":[4479248,4479253],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1332,"address":[5592551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1333,"address":[5592566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1334,"address":[4479280,4479302],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1335,"address":[5592581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1336,"address":[5592663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1337,"address":[5592708,5592943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1338,"address":[5592837,5593130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1339,"address":[5593186,5593035,5593220],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1346,"address":[4479349,4479344],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1347,"address":[5593319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1348,"address":[5593334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1349,"address":[4479398,4479376],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1350,"address":[5593349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1351,"address":[5593431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1352,"address":[5593476,5593711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1353,"address":[5593609,5593898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1354,"address":[5593954,5593988,5593803],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1361,"address":[4479440,4479445],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1362,"address":[5594087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1363,"address":[5594102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1364,"address":[4479472,4479494],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1365,"address":[5594117],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1366,"address":[5594199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1367,"address":[5594244,5594479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1368,"address":[5594666,5594377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1370,"address":[5594722,5594571,5594756],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1377,"address":[4479541,4479536],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1378,"address":[5594855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1379,"address":[5594870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1380,"address":[4479568,4479590],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1381,"address":[5594885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1382,"address":[5594967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1384,"address":[5595012,5595237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1385,"address":[5595333,5595141,5595380],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1393,"address":[5595339,5595427],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1394,"address":[5595499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1396,"address":[5595774,5595547],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1397,"address":[5595679,5595905,5595871],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1404,"address":[4479632,4479637],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1405,"address":[5596039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1406,"address":[5596054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1407,"address":[4479664,4479686],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1408,"address":[5596069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1409,"address":[5596151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1410,"address":[5596294,5596196,5596400],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1412,"address":[5596725,5596533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1413,"address":[5596619,5596872],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1414,"address":[5596928,5596776,5596963],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1426,"address":[4479728,4479733],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1427,"address":[5597063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1428,"address":[5597078],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1430,"address":[4479760,4479782],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1431,"address":[5597093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1432,"address":[5597178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1434,"address":[5597433,5597327,5597226],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1436,"address":[5597566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1437,"address":[5597909,5597718],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1438,"address":[5597807,5598066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1439,"address":[5598213,5597960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1440,"address":[5598118,5598303,5598269],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1450,"address":[4479824,4479829],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1451,"address":[5598407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1452,"address":[5598422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1453,"address":[4479878,4479856],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1454,"address":[5598437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1455,"address":[5598519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1456,"address":[5598564,5598768,5598662],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1458,"address":[5599093,5598901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1459,"address":[5599240,5598987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1460,"address":[5599296,5599331,5599144],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1470,"address":[4479920,4479925],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1471,"address":[5599431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1472,"address":[5599446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1473,"address":[4479952,4479974],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1474,"address":[5599461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1476,"address":[5599492],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1477,"address":[5599796,5599540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1478,"address":[5599993,5599678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1479,"address":[5600052,5600116,5599888],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1484,"address":[5600058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1485,"address":[5600355,5600163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1486,"address":[5600249,5600544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1487,"address":[5600448,5600600,5600664],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1492,"address":[5600606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1493,"address":[5600903,5600711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1494,"address":[5600797,5601091],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1495,"address":[5601147,5600996,5601181],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1502,"address":[4480016,4480021],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1503,"address":[5601319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1504,"address":[5601334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1506,"address":[4480048,4480070],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1507,"address":[5601349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1508,"address":[5601374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1510,"address":[5601545,5601419,5601619],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1517,"address":[4480112,4480117],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1518,"address":[5601719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1519,"address":[5601734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1521,"address":[4480144,4480166],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1522,"address":[5601749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1523,"address":[5601774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1525,"address":[5601943,5602017,5601817],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1529,"address":[4480208,4480213],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1530,"address":[5602119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1531,"address":[5602134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1533,"address":[4480240,4480262],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1534,"address":[5602149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1535,"address":[5602174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1537,"address":[5602419,5602345,5602219],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1544,"address":[4480309,4480304],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1545,"address":[5602519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1546,"address":[5602534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1548,"address":[4480336,4480358],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1549,"address":[5602549],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1551,"address":[5602594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1552,"address":[5602638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1554,"address":[5602889,5602815,5602686],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1558,"address":[4480400,4480405],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1559,"address":[5602983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1560,"address":[5602998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1562,"address":[4480454,4480432],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1563,"address":[5603013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1565,"address":[5603058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1566,"address":[5603102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1568,"address":[5603150,5603279,5603353],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1572,"address":[4480496,4480501],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1573,"address":[5603447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1574,"address":[5603462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1576,"address":[4480550,4480528],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1577,"address":[5603477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1579,"address":[5603545],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1580,"address":[5603589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1582,"address":[5603840,5603766,5603637],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1586,"address":[4480597,4480592],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1587,"address":[5603943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1588,"address":[5603958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1590,"address":[4480646,4480624],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1591,"address":[5603973],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1593,"address":[5604041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1594,"address":[5604085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1596,"address":[5604262,5604133,5604336],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1600,"address":[4480688,4480693],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1602,"address":[5604439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1603,"address":[5604484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1607,"address":[5604759,5604564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1608,"address":[5604656,5604824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1612,"address":[4480720,4480725],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1614,"address":[5604887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1615,"address":[5604932],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1619,"address":[5605012,5605207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1620,"address":[5605272,5605104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1624,"address":[4480757,4480752],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1625,"address":[5605335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1626,"address":[5605350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1628,"address":[4480784,4480806],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":1629,"address":[5605365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1631,"address":[5605433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1632,"address":[5605477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1634,"address":[5605626,5605732,5605525],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1635,"address":[5605981,5605865],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1639,"address":[4480848,4480853],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1640,"address":[5606087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1641,"address":[5606102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1643,"address":[5606117],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1645,"address":[5606166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1646,"address":[5606210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1648,"address":[5606463,5606258,5606388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1652,"address":[4480885,4480880],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1653,"address":[5606567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1654,"address":[5606582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1655,"address":[5606597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1662,"address":[5606707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1663,"address":[5606748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1664,"address":[5606948,5606793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1668,"address":[4480917,4480912],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1669,"address":[5607095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1670,"address":[5607110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1671,"address":[5607125],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1678,"address":[5607300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1679,"address":[5607344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1680,"address":[5607390,5607550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1689,"address":[5607826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1690,"address":[5607873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1691,"address":[5607919,5608079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1700,"address":[5608339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1701,"address":[5608386],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1702,"address":[5608432,5608592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1711,"address":[5608810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1712,"address":[5608857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1713,"address":[5608903,5609063],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":627,"coverable":698},{"path":["/","home","todd","rust-bio","src","alignment","poa.rs"],"content":"// Copyright 2017-2018 Brett Bowman, Jeff Knaggs\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Partial-Order Alignment for fast alignment and consensus of multiple homologous sequences.\n//!\n//! For the original concept and theory, see:\n//! * Lee, Christopher, Catherine Grasso, and Mark F. Sharlow. \"Multiple sequence alignment using\n//! partial order graphs.\" Bioinformatics 18.3 (2002): 452-464.\n//! * Lee, Christopher. \"Generating consensus sequences from partial order multiple sequence\n//! alignment graphs.\" Bioinformatics 19.8 (2003): 999-1008.\n//!\n//! For a modern reference implementation, see poapy:\n//! https://github.com/ljdursi/poapy\n//!\n//! # Example\n//!\n//! ```\n//! use bio::alignment::pairwise::Scoring;\n//! use bio::alignment::poa::*;\n//!\n//! let x = b\"AAAAAAA\";\n//! let y = b\"AABBBAA\";\n//! let z = b\"AABCBAA\";\n//!\n//! let scoring = Scoring::new(-1, 0, |a: u8, b: u8| if a == b { 1i32 } else { -1i32 });\n//! let mut aligner = Aligner::new(scoring, x);\n//! // z differs from x in 3 locations\n//! assert_eq!(aligner.global(z).alignment().score, 1);\n//! aligner.global(y).add_to_graph();\n//! // z differs from x and y's partial order alignment by 1 base\n//! assert_eq!(aligner.global(z).alignment().score, 5);\n//! ```\n\nuse std::cmp::{max, Ordering};\n\nuse crate::utils::TextSlice;\n\nuse crate::alignment::pairwise::{MatchFunc, Scoring};\n\nuse petgraph::graph::NodeIndex;\nuse petgraph::visit::Topo;\n\nuse petgraph::{Directed, Graph, Incoming};\n\npub const MIN_SCORE: i32 = -858_993_459; // negative infinity; see alignment/pairwise/mod.rs\npub type POAGraph = Graph\u003cu8, i32, Directed, usize\u003e;\n\n// Unlike with a total order we may have arbitrary successors in the\n// traceback matrix. I have not yet figured out what the best level of\n// detail to store is, so Match and Del operations remember In and Out\n// nodes on the reference graph.\n#[derive(Debug, Clone)]\npub enum AlignmentOperation {\n    Match(Option\u003c(usize, usize)\u003e),\n    Del(Option\u003c(usize, usize)\u003e),\n    Ins(Option\u003cusize\u003e),\n}\n\npub struct Alignment {\n    pub score: i32,\n    //    xstart: Edge,\n    operations: Vec\u003cAlignmentOperation\u003e,\n}\n\n#[derive(Debug, Clone)]\npub struct TracebackCell {\n    score: i32,\n    op: AlignmentOperation,\n}\n\nimpl Ord for TracebackCell {\n    fn cmp(\u0026self, other: \u0026TracebackCell) -\u003e Ordering {\n        self.score.cmp(\u0026other.score)\n    }\n}\n\nimpl PartialOrd for TracebackCell {\n    fn partial_cmp(\u0026self, other: \u0026TracebackCell) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\nimpl PartialEq for TracebackCell {\n    fn eq(\u0026self, other: \u0026TracebackCell) -\u003e bool {\n        self.score == other.score\n    }\n}\n\n//impl Default for TracebackCell { }\n\nimpl Eq for TracebackCell {}\n\npub struct Traceback {\n    rows: usize,\n    cols: usize,\n\n    // store the last visited node in topological order so that\n    // we can index into the end of the alignment when we backtrack\n    last: NodeIndex\u003cusize\u003e,\n    matrix: Vec\u003cVec\u003cTracebackCell\u003e\u003e,\n}\n\nimpl Traceback {\n    /// Create a Traceback matrix with given maximum sizes\n    ///\n    /// # Arguments\n    ///\n    /// * `m` - the number of nodes in the DAG\n    /// * `n` - the length of the query sequence\n    fn with_capacity(m: usize, n: usize) -\u003e Self {\n        let matrix = vec![\n            vec![\n                TracebackCell {\n                    score: 0,\n                    op: AlignmentOperation::Match(None)\n                };\n                n + 1\n            ];\n            m + 1\n        ];\n        Traceback {\n            rows: m,\n            cols: n,\n            last: NodeIndex::new(0),\n            matrix,\n        }\n    }\n\n    /// Populate the edges of the traceback matrix\n    fn initialize_scores(\u0026mut self, gap_open: i32) {\n        for (i, row) in self\n            .matrix\n            .iter_mut()\n            .enumerate()\n            .take(self.rows + 1)\n            .skip(1)\n        {\n            // TODO: these should be -1 * distance from head node\n            row[0] = TracebackCell {\n                score: (i as i32) * gap_open, // gap_open penalty\n                op: AlignmentOperation::Del(None),\n            };\n        }\n        for j in 1..=self.cols {\n            self.matrix[0][j] = TracebackCell {\n                score: (j as i32) * gap_open,\n                op: AlignmentOperation::Ins(None),\n            };\n        }\n    }\n\n    fn new() -\u003e Self {\n        Traceback {\n            rows: 0,\n            cols: 0,\n            last: NodeIndex::new(0),\n            matrix: Vec::new(),\n        }\n    }\n\n    fn set(\u0026mut self, i: usize, j: usize, cell: TracebackCell) {\n        self.matrix[i][j] = cell;\n    }\n\n    fn get(\u0026self, i: usize, j: usize) -\u003e \u0026TracebackCell {\n        \u0026self.matrix[i][j]\n    }\n\n    pub fn print(\u0026self, g: \u0026Graph\u003cu8, i32, Directed, usize\u003e, query: TextSlice) {\n        let (m, n) = (g.node_count(), query.len());\n        print!(\".\\t\");\n        for base in query.iter().take(n) {\n            print!(\"{:?}\\t\", *base);\n        }\n        for i in 0..m {\n            print!(\"\\n{:?}\\t\", g.raw_nodes()[i].weight);\n            for j in 0..n {\n                print!(\"{}.\\t\", self.get(i + 1, j + 1).score);\n            }\n        }\n        println!();\n    }\n\n    pub fn alignment(\u0026self) -\u003e Alignment {\n        // optimal AlignmentOperation path\n        let mut ops: Vec\u003cAlignmentOperation\u003e = vec![];\n\n        // Now backtrack through the matrix to construct an optimal path\n        let mut i = self.last.index() + 1;\n        let mut j = self.cols;\n\n        while i \u003e 0 \u0026\u0026 j \u003e 0 {\n            // push operation and edge corresponding to (one of the) optimal\n            // routes\n            ops.push(self.matrix[i][j].op.clone());\n            match self.matrix[i][j].op {\n                AlignmentOperation::Match(Some((p, _))) =\u003e {\n                    i = p + 1;\n                    j -= 1;\n                }\n                AlignmentOperation::Del(Some((p, _))) =\u003e {\n                    i = p + 1;\n                }\n                AlignmentOperation::Ins(Some(p)) =\u003e {\n                    i = p + 1;\n                    j -= 1;\n                }\n                AlignmentOperation::Match(None) =\u003e {\n                    break;\n                }\n                AlignmentOperation::Del(None) =\u003e {\n                    j -= 1;\n                }\n                AlignmentOperation::Ins(None) =\u003e {\n                    i -= 1;\n                }\n            }\n        }\n\n        ops.reverse();\n\n        Alignment {\n            score: self.matrix[self.last.index() + 1][self.cols].score,\n            operations: ops,\n        }\n    }\n}\n\n/// A partially ordered aligner builder\n///\n/// Uses consuming builder pattern for constructing partial order alignments with method chaining\npub struct Aligner\u003cF: MatchFunc\u003e {\n    traceback: Traceback,\n    query: Vec\u003cu8\u003e,\n    poa: Poa\u003cF\u003e,\n}\n\nimpl\u003cF: MatchFunc\u003e Aligner\u003cF\u003e {\n    /// Create new instance.\n    pub fn new(scoring: Scoring\u003cF\u003e, reference: TextSlice) -\u003e Self {\n        Aligner {\n            traceback: Traceback::new(),\n            query: reference.to_vec(),\n            poa: Poa::from_string(scoring, reference),\n        }\n    }\n\n    /// Add the alignment of the last query to the graph.\n    pub fn add_to_graph(\u0026mut self) -\u003e \u0026mut Self {\n        let alignment = self.traceback.alignment();\n        self.poa.add_alignment(\u0026alignment, \u0026self.query);\n        self\n    }\n\n    /// Return alignment of last added query against the graph.\n    pub fn alignment(\u0026self) -\u003e Alignment {\n        self.traceback.alignment()\n    }\n\n    /// Globally align a given query against the graph.\n    pub fn global(\u0026mut self, query: TextSlice) -\u003e \u0026mut Self {\n        self.query = query.to_vec();\n        self.traceback = self.poa.global(query);\n        self\n    }\n\n    /// Return alignment graph.\n    pub fn graph(\u0026self) -\u003e \u0026POAGraph {\n        \u0026self.poa.graph\n    }\n}\n\n/// A partially ordered alignment graph\n///\n/// A directed acyclic graph datastructure that represents the topology of a\n/// traceback matrix.\npub struct Poa\u003cF: MatchFunc\u003e {\n    scoring: Scoring\u003cF\u003e,\n    pub graph: POAGraph,\n}\n\nimpl\u003cF: MatchFunc\u003e Poa\u003cF\u003e {\n    /// Create a new aligner instance from the directed acyclic graph of another.\n    ///\n    /// # Arguments\n    ///\n    /// * `scoring` - the score struct\n    /// * `poa` - the partially ordered reference alignment\n    pub fn new(scoring: Scoring\u003cF\u003e, graph: POAGraph) -\u003e Self {\n        Poa { scoring, graph }\n    }\n\n    /// Create a new POA graph from an initial reference sequence and alignment penalties.\n    ///\n    /// # Arguments\n    ///\n    /// * `scoring` - the score struct\n    /// * `reference` - a reference TextSlice to populate the initial reference graph\n    pub fn from_string(scoring: Scoring\u003cF\u003e, seq: TextSlice) -\u003e Self {\n        let mut graph: Graph\u003cu8, i32, Directed, usize\u003e =\n            Graph::with_capacity(seq.len(), seq.len() - 1);\n        let mut prev: NodeIndex\u003cusize\u003e = graph.add_node(seq[0]);\n        let mut node: NodeIndex\u003cusize\u003e;\n        for base in seq.iter().skip(1) {\n            node = graph.add_node(*base);\n            graph.add_edge(prev, node, 1);\n            prev = node;\n        }\n\n        Poa { scoring, graph }\n    }\n\n    /// A global Needleman-Wunsch aligner on partially ordered graphs.\n    ///\n    /// # Arguments\n    /// * `query` - the query TextSlice to align against the internal graph member\n    pub fn global(\u0026self, query: TextSlice) -\u003e Traceback {\n        assert!(self.graph.node_count() != 0);\n\n        // dimensions of the traceback matrix\n        let (m, n) = (self.graph.node_count(), query.len());\n        let mut traceback = Traceback::with_capacity(m, n);\n        traceback.initialize_scores(self.scoring.gap_open);\n\n        traceback.set(\n            0,\n            0,\n            TracebackCell {\n                score: 0,\n                op: AlignmentOperation::Match(None),\n            },\n        );\n\n        // construct the score matrix (O(n^2) space)\n        let mut topo = Topo::new(\u0026self.graph);\n        while let Some(node) = topo.next(\u0026self.graph) {\n            // reference base and index\n            let r = self.graph.raw_nodes()[node.index()].weight; // reference base at previous index\n            let i = node.index() + 1;\n            traceback.last = node;\n            // iterate over the predecessors of this node\n            let prevs: Vec\u003cNodeIndex\u003cusize\u003e\u003e =\n                self.graph.neighbors_directed(node, Incoming).collect();\n            // query base and its index in the DAG (traceback matrix rows)\n            for (j_p, q) in query.iter().enumerate() {\n                let j = j_p + 1;\n                // match and deletion scores for the first reference base\n                let max_cell = if prevs.is_empty() {\n                    TracebackCell {\n                        score: traceback.get(0, j - 1).score + self.scoring.match_fn.score(r, *q),\n                        op: AlignmentOperation::Match(None),\n                    }\n                } else {\n                    let mut max_cell = TracebackCell {\n                        score: MIN_SCORE,\n                        op: AlignmentOperation::Match(None),\n                    };\n                    for prev_node in \u0026prevs {\n                        let i_p: usize = prev_node.index() + 1; // index of previous node\n                        max_cell = max(\n                            max_cell,\n                            max(\n                                TracebackCell {\n                                    score: traceback.get(i_p, j - 1).score\n                                        + self.scoring.match_fn.score(r, *q),\n                                    op: AlignmentOperation::Match(Some((i_p - 1, i - 1))),\n                                },\n                                TracebackCell {\n                                    score: traceback.get(i_p, j).score + self.scoring.gap_open,\n                                    op: AlignmentOperation::Del(Some((i_p - 1, i))),\n                                },\n                            ),\n                        );\n                    }\n                    max_cell\n                };\n\n                let score = max(\n                    max_cell,\n                    TracebackCell {\n                        score: traceback.get(i, j - 1).score + self.scoring.gap_open,\n                        op: AlignmentOperation::Ins(Some(i - 1)),\n                    },\n                );\n                traceback.set(i, j, score);\n            }\n        }\n\n        traceback\n    }\n\n    /// Experimental: return sequence of traversed edges\n    ///\n    /// Only supports alignments for sequences that have already been added,\n    /// so all operations must be Match.\n    pub fn edges(\u0026self, aln: Alignment) -\u003e Vec\u003cusize\u003e {\n        let mut path: Vec\u003cusize\u003e = vec![];\n        let mut prev: NodeIndex\u003cusize\u003e = NodeIndex::new(0);\n        let mut _i: usize = 0;\n        for op in aln.operations {\n            match op {\n                AlignmentOperation::Match(None) =\u003e {\n                    _i += 1;\n                }\n                AlignmentOperation::Match(Some((_, p))) =\u003e {\n                    let node = NodeIndex::new(p);\n                    let edge = self.graph.find_edge(prev, node).unwrap();\n                    path.push(edge.index());\n                    prev = NodeIndex::new(p);\n                    _i += 1;\n                }\n                AlignmentOperation::Ins(None) =\u003e {}\n                AlignmentOperation::Ins(Some(_)) =\u003e {}\n                AlignmentOperation::Del(_) =\u003e {}\n            }\n        }\n        path\n    }\n\n    /// Incorporate a new sequence into a graph from an alignment\n    ///\n    /// # Arguments\n    ///\n    /// * `aln` - The alignment of the new sequence to the graph\n    /// * `seq` - The sequence being incorporated\n    pub fn add_alignment(\u0026mut self, aln: \u0026Alignment, seq: TextSlice) {\n        let mut prev: NodeIndex\u003cusize\u003e = NodeIndex::new(0);\n        let mut i: usize = 0;\n        for op in aln.operations.iter() {\n            match op {\n                AlignmentOperation::Match(None) =\u003e {\n                    i += 1;\n                }\n                AlignmentOperation::Match(Some((_, p))) =\u003e {\n                    let node = NodeIndex::new(*p);\n                    if (seq[i] != self.graph.raw_nodes()[*p].weight) \u0026\u0026 (seq[i] != b'X') {\n                        let node = self.graph.add_node(seq[i]);\n                        self.graph.add_edge(prev, node, 1);\n                        prev = node;\n                    } else {\n                        // increment node weight\n                        match self.graph.find_edge(prev, node) {\n                            Some(edge) =\u003e {\n                                *self.graph.edge_weight_mut(edge).unwrap() += 1;\n                            }\n                            None =\u003e {\n                                // where the previous node was newly added\n                                self.graph.add_edge(prev, node, 1);\n                            }\n                        }\n                        prev = NodeIndex::new(*p);\n                    }\n                    i += 1;\n                }\n                AlignmentOperation::Ins(None) =\u003e {\n                    i += 1;\n                }\n                AlignmentOperation::Ins(Some(_)) =\u003e {\n                    let node = self.graph.add_node(seq[i]);\n                    self.graph.add_edge(prev, node, 1);\n                    prev = node;\n                    i += 1;\n                }\n                AlignmentOperation::Del(_) =\u003e {} // we should only have to skip over deleted nodes\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::alignment::pairwise::Scoring;\n    use petgraph::graph::NodeIndex;\n\n    #[test]\n    fn test_init_graph() {\n        // sanity check for String -\u003e Graph\n\n        let scoring = Scoring::new(-1, 0, |a: u8, b: u8| if a == b { 1i32 } else { -1i32 });\n        let poa = Poa::from_string(scoring, b\"123456789\");\n        assert!(poa.graph.is_directed());\n        assert_eq!(poa.graph.node_count(), 9);\n        assert_eq!(poa.graph.edge_count(), 8);\n    }\n\n    #[test]\n    fn test_alignment() {\n        let scoring = Scoring::new(-1, 0, |a: u8, b: u8| if a == b { 1i32 } else { -1i32 });\n        // examples from the POA paper\n        //let _seq1 = b\"PKMIVRPQKNETV\";\n        //let _seq2 = b\"THKMLVRNETIM\";\n        let poa = Poa::from_string(scoring, b\"GATTACA\");\n        let alignment = poa.global(b\"GCATGCU\").alignment();\n        assert_eq!(alignment.score, 0);\n\n        let alignment = poa.global(b\"GCATGCUx\").alignment();\n        assert_eq!(alignment.score, -1);\n\n        let alignment = poa.global(b\"xCATGCU\").alignment();\n        assert_eq!(alignment.score, -2);\n    }\n\n    #[test]\n    fn test_branched_alignment() {\n        let scoring = Scoring::new(-1, 0, |a: u8, b: u8| if a == b { 1i32 } else { -1i32 });\n        let seq1 = b\"TTTTT\";\n        let seq2 = b\"TTATT\";\n        let mut poa = Poa::from_string(scoring, seq1);\n        let head: NodeIndex\u003cusize\u003e = NodeIndex::new(1);\n        let tail: NodeIndex\u003cusize\u003e = NodeIndex::new(2);\n        let node1 = poa.graph.add_node(b'A');\n        let node2 = poa.graph.add_node(b'A');\n        poa.graph.add_edge(head, node1, 1);\n        poa.graph.add_edge(node1, node2, 1);\n        poa.graph.add_edge(node2, tail, 1);\n        let alignment = poa.global(seq2).alignment();\n        assert_eq!(alignment.score, 3);\n    }\n\n    #[test]\n    fn test_alt_branched_alignment() {\n        let scoring = Scoring::new(-1, 0, |a: u8, b: u8| if a == b { 1i32 } else { -1i32 });\n\n        let seq1 = b\"TTCCTTAA\";\n        let seq2 = b\"TTTTGGAA\";\n        let mut poa = Poa::from_string(scoring, seq1);\n        let head: NodeIndex\u003cusize\u003e = NodeIndex::new(1);\n        let tail: NodeIndex\u003cusize\u003e = NodeIndex::new(2);\n        let node1 = poa.graph.add_node(b'A');\n        let node2 = poa.graph.add_node(b'A');\n        poa.graph.add_edge(head, node1, 1);\n        poa.graph.add_edge(node1, node2, 1);\n        poa.graph.add_edge(node2, tail, 1);\n        let alignment = poa.global(seq2).alignment();\n        poa.add_alignment(\u0026alignment, seq2);\n        assert_eq!(poa.graph.edge_count(), 14);\n        assert!(poa\n            .graph\n            .contains_edge(NodeIndex::new(5), NodeIndex::new(10)));\n        assert!(poa\n            .graph\n            .contains_edge(NodeIndex::new(11), NodeIndex::new(6)));\n    }\n\n    #[test]\n    fn test_insertion_on_branch() {\n        let scoring = Scoring::new(-1, 0, |a: u8, b: u8| if a == b { 1i32 } else { -1i32 });\n\n        let seq1 = b\"TTCCGGTTTAA\";\n        let seq2 = b\"TTGGTATGGGAA\";\n        let seq3 = b\"TTGGTTTGCGAA\";\n        let mut poa = Poa::from_string(scoring, seq1);\n        let head: NodeIndex\u003cusize\u003e = NodeIndex::new(1);\n        let tail: NodeIndex\u003cusize\u003e = NodeIndex::new(2);\n        let node1 = poa.graph.add_node(b'C');\n        let node2 = poa.graph.add_node(b'C');\n        let node3 = poa.graph.add_node(b'C');\n        poa.graph.add_edge(head, node1, 1);\n        poa.graph.add_edge(node1, node2, 1);\n        poa.graph.add_edge(node2, node3, 1);\n        poa.graph.add_edge(node3, tail, 1);\n        let alignment = poa.global(seq2).alignment();\n        assert_eq!(alignment.score, 2);\n        poa.add_alignment(\u0026alignment, seq2);\n        let alignment2 = poa.global(seq3).alignment();\n\n        assert_eq!(alignment2.score, 10);\n    }\n\n    #[test]\n    fn test_poa_method_chaining() {\n        let scoring = Scoring::new(-1, 0, |a: u8, b: u8| if a == b { 1i32 } else { -1i32 });\n        let mut aligner = Aligner::new(scoring, b\"TTCCGGTTTAA\");\n        aligner\n            .global(b\"TTGGTATGGGAA\")\n            .add_to_graph()\n            .global(b\"TTGGTTTGCGAA\")\n            .add_to_graph();\n        assert_eq!(aligner.alignment().score, 10);\n    }\n}\n","traces":[{"line":74,"address":[4699568],"length":1,"stats":{"Line":2},"fn_name":"cmp"},{"line":75,"address":[4699582],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[4699616],"length":1,"stats":{"Line":0},"fn_name":"partial_cmp"},{"line":81,"address":[4699630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[4699664],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":87,"address":[4699677],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[4699696,4700113],"length":1,"stats":{"Line":1},"fn_name":"with_capacity"},{"line":113,"address":[4700049,4699739,4699988,4700128],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[4699906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[4699819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[4699747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[4699885,4699932],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[4699967,4700017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[4700091],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[4700304],"length":1,"stats":{"Line":1},"fn_name":"initialize_scores"},{"line":133,"address":[4700652,4700335,4700968,4700488,4700434],"length":1,"stats":{"Line":5},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[4700410,4700458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[4700820,4700950],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[4700721,4700915],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[4700748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[4701107,4700620,4701405,4701410,4700973],"length":1,"stats":{"Line":5},"fn_name":null},{"line":147,"address":[4701227,4701366],"length":1,"stats":{"Line":4},"fn_name":null},{"line":148,"address":[4701144,4701326],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[4701171],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[4701424],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":158,"address":[4701438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[4701453],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[4701536],"length":1,"stats":{"Line":2},"fn_name":"set"},{"line":164,"address":[4701583],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[4701696],"length":1,"stats":{"Line":2},"fn_name":"get"},{"line":168,"address":[4701720],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[4701792],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":172,"address":[4701882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[4702006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[4702476,4702318,4702073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[4702350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[4702258,4702494,4703002,4702612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[4702649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[4703312,4703012,4702872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[4703049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[4703317,4702562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[4703344,4704878,4704893],"length":1,"stats":{"Line":2},"fn_name":"alignment"},{"line":188,"address":[4703383],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[4703539,4703405,4703517],"length":1,"stats":{"Line":4},"fn_name":null},{"line":192,"address":[4703525],"length":1,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[4703537,4703571],"length":1,"stats":{"Line":4},"fn_name":null},{"line":197,"address":[4703636],"length":1,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[4703898,4704119,4703780,4704280,4704170,4704331,4704492],"length":1,"stats":{"Line":7},"fn_name":null},{"line":199,"address":[4703868,4703905,4704379],"length":1,"stats":{"Line":6},"fn_name":null},{"line":200,"address":[4704446,4704391],"length":1,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[4704420,4704484,4704497],"length":1,"stats":{"Line":4},"fn_name":null},{"line":203,"address":[4703930,4704239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[4704251,4704285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[4703955,4704006],"length":1,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[4704018,4704073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[4704111,4704047,4704124],"length":1,"stats":{"Line":3},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[4704336,4704208,4704323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[4704175,4703968,4704162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[4704530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[4704594],"length":1,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":340,"address":[5758071,5758197,5746531,5742839,5742965,5750339,5757955,5750455,5746647,5750581,5754389,5746773,5742723,5754263,5754147],"length":1,"stats":{"Line":10},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":361,"address":[5744485,5744381,5751997,5752101,5755805,5755909,5759613,5748189,5748293,5759717],"length":1,"stats":{"Line":5},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":479,"address":[9349104,9349654],"length":1,"stats":{"Line":3},"fn_name":"test_init_graph"},{"line":482,"address":[9349111],"length":1,"stats":{"Line":1},"fn_name":null},{"line":483,"address":[9349128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[9349186,9349268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[9349429,9349305,9349253],"length":1,"stats":{"Line":2},"fn_name":null},{"line":486,"address":[9349404,9349486,9349602],"length":1,"stats":{"Line":2},"fn_name":null},{"line":490,"address":[9350756,9349680],"length":1,"stats":{"Line":3},"fn_name":"test_alignment"},{"line":491,"address":[9349687],"length":1,"stats":{"Line":3},"fn_name":null},{"line":495,"address":[9349704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":496,"address":[9349757,9349857],"length":1,"stats":{"Line":2},"fn_name":null},{"line":497,"address":[9349901,9350074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":499,"address":[9350141,9350032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":500,"address":[9350203,9350376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":502,"address":[9350334,9350444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":503,"address":[9350662,9350506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":507,"address":[9351480,9350784],"length":1,"stats":{"Line":3},"fn_name":"test_branched_alignment"},{"line":508,"address":[9350791],"length":1,"stats":{"Line":3},"fn_name":null},{"line":509,"address":[9350808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[9350823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[9350838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[9350896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[9350929,9350986],"length":1,"stats":{"Line":2},"fn_name":null},{"line":514,"address":[9351004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[9351042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":516,"address":[9351090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[9351117],"length":1,"stats":{"Line":1},"fn_name":null},{"line":518,"address":[9351144],"length":1,"stats":{"Line":1},"fn_name":null},{"line":519,"address":[9351151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[9351261,9351417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[9351504,9352544],"length":1,"stats":{"Line":3},"fn_name":"test_alt_branched_alignment"},{"line":525,"address":[9351511],"length":1,"stats":{"Line":3},"fn_name":null},{"line":527,"address":[9351531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":528,"address":[9351546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":529,"address":[9351561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":530,"address":[9351625],"length":1,"stats":{"Line":1},"fn_name":null},{"line":531,"address":[9351658,9351718],"length":1,"stats":{"Line":2},"fn_name":null},{"line":532,"address":[9351739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[9351780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":534,"address":[9351831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[9351861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[9351891],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[9351898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[9352011],"length":1,"stats":{"Line":1},"fn_name":null},{"line":539,"address":[9352094,9352251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":540,"address":[9352337,9352393],"length":1,"stats":{"Line":1},"fn_name":null},{"line":542,"address":[9352307,9352226],"length":1,"stats":{"Line":2},"fn_name":null},{"line":543,"address":[9352458,9352496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":545,"address":[9352428,9352378],"length":1,"stats":{"Line":2},"fn_name":null},{"line":549,"address":[9353702,9352576],"length":1,"stats":{"Line":3},"fn_name":"test_insertion_on_branch"},{"line":550,"address":[9352583],"length":1,"stats":{"Line":3},"fn_name":null},{"line":552,"address":[9352600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":553,"address":[9352615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":554,"address":[9352630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":555,"address":[9352645],"length":1,"stats":{"Line":1},"fn_name":null},{"line":556,"address":[9352703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":557,"address":[9352793,9352736],"length":1,"stats":{"Line":2},"fn_name":null},{"line":558,"address":[9352811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":559,"address":[9352849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[9352887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":561,"address":[9352935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":562,"address":[9352962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":563,"address":[9352989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":564,"address":[9353016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[9353023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":566,"address":[9353133,9353306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":567,"address":[9353264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":568,"address":[9353357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":570,"address":[9353623,9353467],"length":1,"stats":{"Line":1},"fn_name":null},{"line":574,"address":[9353728,9354175],"length":1,"stats":{"Line":3},"fn_name":"test_poa_method_chaining"},{"line":575,"address":[9353735],"length":1,"stats":{"Line":3},"fn_name":null},{"line":576,"address":[9353752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[9353899,9353805],"length":1,"stats":{"Line":2},"fn_name":null},{"line":582,"address":[9353951],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":199,"coverable":254},{"path":["/","home","todd","rust-bio","src","alignment","sparse.rs"],"content":"// Copyright 2014-2015 Patrick Marks\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Calculate 'sparse' alignments from kmer matches. Can be much faster than\n//! Smith-Waterman for long string, when a large enough k is used.\n//! Complexity: O(n * log(n)) for a pair of strings with n k-kmer matches. This\n//! approach is useful for generating an approximate 'backbone' alignments\n//! between two long sequences, for example in long-read alignment or\n//! genome-genome alignment. The backbone alignment can be used as-is, or can serve\n//! as a guide for a banded alignment.  By tuning k so that len(query) + len(reference) \u003c 4^k,\n//! the number of false positive kmer matches is kept small, resulting in very\n//! fast run times for long strings.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::alignment::sparse::*;\n//!\n//! let s1 =   b\"ACGTACGATAGGTA\";\n//! let s2 = b\"TTACGTACGATAGGTATT\";\n//! let k = 8;\n//! let matches = find_kmer_matches(s1, s2, k);\n//! let sparse_al = lcskpp(\u0026matches, k);\n//! let match_path: Vec\u003c(u32,u32)\u003e = sparse_al.path.iter().map(|i| matches[*i]).collect();\n//! assert_eq!(match_path, vec![(0,2), (1,3), (2,4), (3,5), (4,6), (5,7), (6,8)]);\n//! assert_eq!(sparse_al.score, 14);\n\nuse crate::data_structures::bit_tree::MaxBitTree;\nuse fxhash::FxHasher;\nuse std::cmp::{max, min};\nuse std::collections::HashMap;\nuse std::hash::BuildHasherDefault;\n\npub type HashMapFx\u003cK, V\u003e = HashMap\u003cK, V, BuildHasherDefault\u003cFxHasher\u003e\u003e;\n\n/// Result of a sparse alignment\n#[derive(Debug, PartialEq, Eq)]\npub struct SparseAlignmentResult {\n    /// LCSk++ path, represented as vector of indices into the input matches vector.\n    pub path: Vec\u003cusize\u003e,\n    // Score of the path, which is the number of bases covered by the matched kmers.\n    pub score: u32,\n    // Full DP vector, which can generally be ignored. (It may be useful for testing purposes).\n    pub dp_vector: Vec\u003c(u32, i32)\u003e,\n}\n\n/// Sparse DP routine for Longest Common Subsequence in length k substrings.  Also known of LCSk++\n/// From LCSk++: Practical similarity metric for long strings. Filip Pavetić, Goran Žužić, Mile Šikić\n/// Paper here :https://arxiv.org/abs/1407.2407.  Original implementation here:\n/// https://github.com/fpavetic/lcskpp\n///\n/// # Arguments\n///\n/// * `matches` - a vector of tuples indicating the (string1 position, string2 position) kmer\n///   matches between the strings\n/// * `k` - the kmer length used for matching\n///\n/// # Return value\n///\n/// The method returns a `SparseAlignmentResult` struct with the following fields:\n/// * `path` is the LCSk++ path, represented as vector of indices into the input matches vector.\n/// * `score` is the score of the path, which is the number of bases covered by the matched kmers.\n/// * `dp_vector` is the full DP vector, which can generally be ignored. (It may be useful for\n///   testing purposes).\npub fn lcskpp(matches: \u0026[(u32, u32)], k: usize) -\u003e SparseAlignmentResult {\n    if matches.is_empty() {\n        return SparseAlignmentResult {\n            path: Vec::new(),\n            score: 0,\n            dp_vector: Vec::new(),\n        };\n    }\n\n    let k = k as u32;\n\n    // incoming matches must be sorted to let us find the predecessor kmers by binary search.\n    for i in 1..matches.len() {\n        assert!(matches[i - 1] \u003c matches[i]);\n    }\n\n    let mut events: Vec\u003c(u32, u32, u32)\u003e = Vec::new();\n    let mut n = 0;\n\n    for (idx, \u0026(x, y)) in matches.iter().enumerate() {\n        events.push((x, y, (idx + matches.len()) as u32));\n        events.push((x + k, y + k, idx as u32));\n\n        n = max(n, x + k);\n        n = max(n, y + k);\n    }\n    events.sort_unstable();\n\n    let mut max_col_dp: MaxBitTree\u003c(u32, u32)\u003e = MaxBitTree::new(n as usize);\n    let mut dp: Vec\u003c(u32, i32)\u003e = Vec::with_capacity(events.len());\n    let mut best_dp = (k, 0);\n\n    dp.resize(events.len(), (0, 0));\n\n    for ev in events {\n        let p = (ev.2 % matches.len() as u32) as usize;\n        let j = ev.1;\n        let is_start = ev.2 \u003e= (matches.len() as u32);\n\n        if is_start {\n            dp[p] = (k, -1);\n            let (best_value, best_position) = max_col_dp.get(j as usize);\n            if best_value \u003e 0 {\n                dp[p] = (k + best_value, best_position as i32);\n                best_dp = max(best_dp, (dp[p].0, p as i32));\n            }\n        } else {\n            // See if this kmer continues a different kmer\n            if ev.0 \u003e k \u0026\u0026 ev.1 \u003e k {\n                if let Ok(cont_idx) = matches.binary_search(\u0026(ev.0 - k - 1, ev.1 - k - 1)) {\n                    let prev_score = dp[cont_idx].0;\n                    let candidate = (prev_score + 1, cont_idx as i32);\n                    dp[p] = max(dp[p], candidate);\n                    best_dp = max(best_dp, (dp[p].0, p as i32));\n                }\n            }\n\n            max_col_dp.set(ev.1 as usize, (dp[p].0, p as u32));\n        }\n    }\n\n    let mut traceback = Vec::new();\n    let (best_score, mut prev_match) = best_dp;\n    while prev_match \u003e= 0 {\n        traceback.push(prev_match as usize);\n        prev_match = dp[prev_match as usize].1;\n    }\n    traceback.reverse();\n    SparseAlignmentResult {\n        path: traceback,\n        score: best_score,\n        dp_vector: dp,\n    }\n}\n\n#[derive(PartialEq, Eq, Ord, PartialOrd, Default, Copy, Clone)]\nstruct PrevPtr {\n    plane: u32,\n    score: u32,\n    d: u32,\n    id: usize,\n    x: u32,\n    y: u32,\n}\n\nimpl PrevPtr {\n    pub fn new(score: u32, x: u32, y: u32, id: usize, gap_extend: u32) -\u003e PrevPtr {\n        let d = x + y;\n        PrevPtr {\n            plane: score + (d * gap_extend),\n            score,\n            d,\n            id,\n            x,\n            y,\n        }\n    }\n}\n\n/// Sparse DP routine generalizing LCSk++ method above to penalize alignment gaps.\n/// A gap is an unknown combination of mismatch, insertion and deletions, and incurs\n/// a penalty of gap_open + d * gap_extend, where d is the distance along the diagonal of the gap.\n/// # Arguments\n///\n/// * `matches` - a vector of tuples indicating the (string1 position, string2 position) kmer\n///   matches between the strings\n/// * `k` - the kmer length used for matching\n/// * `match_score` - reward for each matched base\n/// * `gap_open` - score of opening a gap, including a mismatch gap. Must be negative.\n/// * `gap_extend` - score for extending a gap along the diagonal. Must be negative.\n///\n/// # Return value\n///\n/// The method returns a `SparseAlignmentResult` struct with the following fields:\n/// * `path` is the SDP path, represented as vector of indices into the input matches vector.\n/// * `score` is the score of the path, which is the number of bases covered by the matched kmers.\n/// * `dp_vector` is the full DP vector, which can generally be ignored. (It may be useful for\n///   testing purposes).\npub fn sdpkpp(\n    matches: \u0026[(u32, u32)],\n    k: usize,\n    match_score: u32,\n    gap_open: i32,\n    gap_extend: i32,\n) -\u003e SparseAlignmentResult {\n    if matches.is_empty() {\n        return SparseAlignmentResult {\n            path: Vec::new(),\n            score: 0,\n            dp_vector: Vec::new(),\n        };\n    }\n\n    let k = k as u32;\n    if gap_open \u003e 0 || gap_extend \u003e 0 {\n        panic!(\"gap parameters cannot be positive\")\n    }\n    let _gap_open = (-gap_open) as u32;\n    let _gap_extend = (-gap_extend) as u32;\n\n    // incoming matches must be sorted to let us find the predecessor kmers by binary search.\n    for i in 1..matches.len() {\n        assert!(matches[i - 1] \u003c matches[i]);\n    }\n\n    let mut events: Vec\u003c(u32, u32, u32)\u003e = Vec::new();\n    let mut n = 0;\n\n    for (idx, \u0026(x, y)) in matches.iter().enumerate() {\n        events.push((x, y, (idx + matches.len()) as u32));\n        events.push((x + k, y + k, idx as u32));\n\n        n = max(n, x + k);\n        n = max(n, y + k);\n    }\n    events.sort_unstable();\n\n    let mut max_col_dp: MaxBitTree\u003cPrevPtr\u003e = MaxBitTree::new(n as usize);\n    let mut dp: Vec\u003c(u32, i32)\u003e = Vec::with_capacity(events.len());\n    let mut best_dp = (k, 0);\n\n    dp.resize(events.len(), (0, 0));\n\n    for ev in events {\n        let p = (ev.2 % matches.len() as u32) as usize;\n        let j = ev.1;\n        let is_start = ev.2 \u003e= (matches.len() as u32);\n\n        if is_start {\n            // Default case -- chain starts at this node\n            dp[p] = (k * match_score, -1);\n\n            // Find best previous chain, and extend.\n            let best_prev = max_col_dp.get(j as usize);\n            if best_prev.score \u003e 0 {\n                let prev_x = best_prev.x;\n                let prev_y = best_prev.y;\n                let cur_x = ev.0;\n                let cur_y = ev.1;\n                let gap = max(cur_x - prev_x, cur_y - prev_y);\n                let gap_penalty = if gap \u003e 0 {\n                    _gap_open + gap * _gap_extend\n                } else {\n                    0\n                };\n\n                let reward = k * match_score;\n                let new_score = (best_prev.score + reward).saturating_sub(gap_penalty);\n\n                dp[p] = max(dp[p], (new_score, best_prev.id as i32));\n                best_dp = max(best_dp, (dp[p].0, p as i32));\n            }\n        } else {\n            // See if this kmer continues a different kmer\n            if ev.0 \u003e k \u0026\u0026 ev.1 \u003e k {\n                if let Ok(cont_idx) = matches.binary_search(\u0026(ev.0 - k - 1, ev.1 - k - 1)) {\n                    let prev_score = dp[cont_idx].0;\n                    let candidate = (prev_score + match_score, cont_idx as i32);\n                    dp[p] = max(dp[p], candidate);\n                    best_dp = max(best_dp, (dp[p].0, p as i32));\n                }\n            }\n\n            let prev_frag = PrevPtr::new(dp[p].0, ev.0, ev.1, p, _gap_extend);\n            max_col_dp.set(ev.1 as usize, prev_frag);\n        }\n    }\n\n    let mut traceback = Vec::new();\n    let (best_score, mut prev_match) = best_dp;\n    while prev_match \u003e= 0 {\n        traceback.push(prev_match as usize);\n        prev_match = dp[prev_match as usize].1;\n    }\n    traceback.reverse();\n    SparseAlignmentResult {\n        path: traceback,\n        score: best_score,\n        dp_vector: dp,\n    }\n}\n\npub fn sdpkpp_union_lcskpp_path(\n    matches: \u0026[(u32, u32)],\n    k: usize,\n    match_score: u32,\n    gap_open: i32,\n    gap_extend: i32,\n) -\u003e Vec\u003cusize\u003e {\n    if matches.is_empty() {\n        return Vec::new();\n    }\n    let lcskpp_al = lcskpp(matches, k);\n    let sdpkpp_al = sdpkpp(matches, k, match_score, gap_open, gap_extend);\n    let pre_lcskpp = lcskpp_al\n        .path\n        .binary_search(\u0026sdpkpp_al.path[0])\n        .unwrap_or(0);\n    let post_lcskpp = match lcskpp_al\n        .path\n        .binary_search(\u0026sdpkpp_al.path.last().unwrap())\n    {\n        Ok(ind) =\u003e ind + 1,\n        Err(_) =\u003e lcskpp_al.path.len(),\n    };\n\n    let mut path_union = Vec::new();\n    for i in 0..pre_lcskpp {\n        path_union.push(lcskpp_al.path[i]);\n    }\n    for i in 0..sdpkpp_al.path.len() {\n        path_union.push(sdpkpp_al.path[i]);\n    }\n    for i in post_lcskpp..lcskpp_al.path.len() {\n        path_union.push(lcskpp_al.path[i]);\n    }\n\n    path_union\n}\n\n/// Find all matches of length k between two strings, using a q-gram\n/// index. For very long reference strings, it may be more efficient to use and\n/// FMD index to generate the matches. Note that this method is mainly for\n/// demonstration \u0026 testing purposes.  For aligning many query sequences\n/// against the same reference, you should reuse the QGramIndex of the reference.\npub fn find_kmer_matches(seq1: \u0026[u8], seq2: \u0026[u8], k: usize) -\u003e Vec\u003c(u32, u32)\u003e {\n    if seq1.len() \u003c seq2.len() {\n        let set = hash_kmers(seq1, k);\n        find_kmer_matches_seq1_hashed(\u0026set, seq2, k)\n    } else {\n        let set = hash_kmers(\u0026seq2, k);\n        find_kmer_matches_seq2_hashed(seq1, \u0026set, k)\n    }\n}\n\n/// Creates a HashMap containing all the k-mers in the sequence. FxHasher is used\n/// as the hash function instead of the inbuilt one. A good rolling hash function\n/// should speed up the code.\npub fn hash_kmers(seq: \u0026[u8], k: usize) -\u003e HashMapFx\u003c\u0026[u8], Vec\u003cu32\u003e\u003e {\n    let slc = seq;\n    let mut set: HashMapFx\u003c\u0026[u8], Vec\u003cu32\u003e\u003e = HashMapFx::default();\n    for i in 0..(slc.len() + 1).saturating_sub(k) {\n        set.entry(\u0026slc[i..i + k])\n            .or_insert_with(Vec::new)\n            .push(i as u32);\n    }\n    set\n}\n\n// Find all matches of length k between two strings where the first string is\n// already hashed by using the function sparse::hash_kmers\npub fn find_kmer_matches_seq1_hashed(\n    seq1_set: \u0026HashMapFx\u003c\u0026[u8], Vec\u003cu32\u003e\u003e,\n    seq2: \u0026[u8],\n    k: usize,\n) -\u003e Vec\u003c(u32, u32)\u003e {\n    let mut matches = Vec::new();\n\n    for i in 0..(seq2.len() + 1).saturating_sub(k) {\n        let slc = \u0026seq2[i..i + k];\n        if let Some(matches1) = seq1_set.get(slc) {\n            for pos1 in matches1 {\n                matches.push((*pos1, i as u32));\n            }\n        }\n    }\n\n    matches.sort_unstable();\n    matches\n}\n\n// Find all matches of length k between two strings where the second string is\n// already hashed by using the function sparse::hash_kmers\npub fn find_kmer_matches_seq2_hashed(\n    seq1: \u0026[u8],\n    seq2_set: \u0026HashMapFx\u003c\u0026[u8], Vec\u003cu32\u003e\u003e,\n    k: usize,\n) -\u003e Vec\u003c(u32, u32)\u003e {\n    let mut matches = Vec::new();\n\n    for i in 0..(seq1.len() + 1).saturating_sub(k) {\n        let slc = \u0026seq1[i..i + k];\n\n        if let Some(matches1) = seq2_set.get(slc) {\n            for pos1 in matches1 {\n                matches.push((i as u32, *pos1));\n            }\n        }\n    }\n\n    matches.sort_unstable();\n    matches\n}\n\npub fn expand_kmer_matches(\n    seq1: \u0026[u8],\n    seq2: \u0026[u8],\n    k: usize,\n    sorted_matches: \u0026[(u32, u32)],\n    allowed_mismatches: usize,\n) -\u003e Vec\u003c(u32, u32)\u003e {\n    // incoming matches must be sorted.\n    for i in 1..sorted_matches.len() {\n        assert!(sorted_matches[i - 1] \u003c sorted_matches[i]);\n    }\n\n    let mut last_match_along_diagonal: HashMapFx\u003ci32, (i32, i32)\u003e = HashMapFx::default();\n    let mut left_expanded_matches: Vec\u003c(u32, u32)\u003e = sorted_matches.to_owned();\n\n    for \u0026this_match in sorted_matches.iter() {\n        let diag = (this_match.0 as i32) - (this_match.1 as i32);\n        let min_xy = min(this_match.0, this_match.1) as i32;\n        let default_last_match = (\n            this_match.0 as i32 - min_xy - 1,\n            this_match.1 as i32 - min_xy - 1,\n        );\n        let last_match = last_match_along_diagonal\n            .get(\u0026diag)\n            .cloned()\n            .unwrap_or(default_last_match);\n\n        let mut n_mismatches = 0;\n        let mut curr_pos = (this_match.0 as i32 - 1, this_match.1 as i32 - 1);\n        loop {\n            if last_match \u003e= curr_pos {\n                break;\n            }\n            n_mismatches += if seq1[curr_pos.0 as usize] == seq2[curr_pos.1 as usize] {\n                0\n            } else {\n                1\n            };\n            if n_mismatches \u003e allowed_mismatches {\n                break;\n            }\n            left_expanded_matches.push((curr_pos.0 as u32, curr_pos.1 as u32));\n            curr_pos = (curr_pos.0 - 1, curr_pos.1 - 1);\n        }\n        // We need to check until 1 position after this match, when we start our search from\n        // the next kmer match along this diagonal\n        last_match_along_diagonal.insert(diag, (this_match.0 as i32, this_match.1 as i32));\n    }\n\n    left_expanded_matches.sort_unstable();\n    let mut expanded_matches = left_expanded_matches.clone();\n    left_expanded_matches.reverse();\n\n    let mut next_match_along_diagonal: HashMapFx\u003ci32, (u32, u32)\u003e = HashMapFx::default();\n\n    for \u0026this_match in \u0026left_expanded_matches {\n        let diag = (this_match.0 as i32) - (this_match.1 as i32);\n        let max_inc = (min(\n            seq1.len() as u32 - this_match.0,\n            seq2.len() as u32 - this_match.1,\n        ) as u32)\n            .saturating_sub(k as u32 - 1);\n        let next_match = next_match_along_diagonal\n            .get(\u0026diag)\n            .cloned()\n            .unwrap_or((this_match.0 + max_inc, this_match.1 + max_inc));\n\n        let mut n_mismatches = 0;\n        let mut curr_pos = (this_match.0 + 1, this_match.1 + 1);\n        loop {\n            // println!(\" This : ({},{}), Current : ({},{}), Next : ({}, {}), Miss : {}\",\n            // this_match.0, this_match.1, curr_pos.0, curr_pos.1, next_match.0, next_match.1, n_mismatches);\n            if curr_pos \u003e= next_match {\n                break;\n            }\n            n_mismatches +=\n                if seq1[curr_pos.0 as usize + k - 1] == seq2[curr_pos.1 as usize + k - 1] {\n                    0\n                } else {\n                    1\n                };\n            if n_mismatches \u003e allowed_mismatches {\n                break;\n            }\n            expanded_matches.push(curr_pos);\n            curr_pos = (curr_pos.0 + 1, curr_pos.1 + 1);\n        }\n\n        next_match_along_diagonal.insert(diag, this_match);\n    }\n    expanded_matches.sort_unstable();\n    expanded_matches\n}\n\n#[cfg(test)]\nmod sparse_alignment {\n    use super::find_kmer_matches;\n\n    #[test]\n    pub fn test_find_kmer_matches() {\n        let s1 = b\"ACGTACGATAGATCCGTACGTAACAGTACAGTATATCAGTTATATGCGATA\";\n        let s2 = b\"TTACGTACGATAGATCCGTACGTAACATTTTTGTACAGTATATCAGTTATATGCGA\";\n        let k = 8;\n        //let s1 = \"  ACGTACGATAGATCCGTACGTAACA     GTACAGTATATCAGTTATATGCGATA\";\n        //let s2 = \"TTACGTACGATAGATCCGTACGTAACATTTTTGTACAGTATATCAGTTATATGCGA\";\n\n        let hits = find_kmer_matches(s1, s2, k);\n        assert_eq!(hits.len(), (25 - k + 1) + (24 - k + 1));\n        //println!(\"hits: {:?}\", hits);\n    }\n\n    #[test]\n    pub fn test_lcskpp0() {\n        let s1 = b\"ACGTACGATAGGTA\";\n        let s2 = b\"TTACGTACGATAGGTATT\";\n        let k = 8;\n        let matches = super::find_kmer_matches(s1, s2, k);\n        let res = super::lcskpp(\u0026matches, k);\n        let match_path: Vec\u003c(u32, u32)\u003e = res.path.iter().map(|i| matches[*i]).collect();\n        assert_eq!(\n            match_path,\n            vec![(0, 2), (1, 3), (2, 4), (3, 5), (4, 6), (5, 7), (6, 8)]\n        );\n        assert_eq!(res.score, 14);\n    }\n\n    pub fn strict_compare_lcskpp_sdpkpp(s1: \u0026[u8], s2: \u0026[u8]) {\n        let k = 8;\n        let matches = super::find_kmer_matches(s1, s2, k);\n        let res1 = super::lcskpp(\u0026matches, k);\n        let res2 = super::sdpkpp(\u0026matches, k, 1, 0, 0);\n\n        assert_eq!(res1, res2);\n    }\n\n    #[test]\n    pub fn test_sdp() {\n        let s1 = b\"ACGTACGATAGGTA\";\n        let s2 = b\"TTACGTACGATAGGTATT\";\n        strict_compare_lcskpp_sdpkpp(s1, s2);\n    }\n\n    #[test]\n    pub fn test_lcskpp1() {\n        let s1 = b\"ACGTACGATAGATCCGTACGTAACAGTACAGTATATCAGTTATATGCGATA\";\n        let s2 = b\"TTACGTACGATAGATCCGTACGTAACATTTTTGTACAGTATATCAGTTATATGCGA\";\n        let k = 8;\n\n        let matches = super::find_kmer_matches(s1, s2, k);\n        let res = super::lcskpp(\u0026matches, k);\n\n        // For debugging:\n        //for (idx, (ev, (score, prev))) in evs.iter().zip(dps.clone()).enumerate() {\n        //    println!(\"idx: {:?}\\tev: {:?}\\tscore: {:?}\\t prev: {:?}\", idx, ev, score, prev);\n        //}\n        //println!(\"tb: {:?}\", tb);\n\n        // Should have 25bp group of matches plus a 24 bp group of matches\n        assert_eq!(res.score, 25 + 24);\n    }\n\n    #[test]\n    pub fn test_sdp1() {\n        let s1 = b\"ACGTACGATAGATCCGTACGTAACAGTACAGTATATCAGTTATATGCGATA\";\n        let s2 = b\"TTACGTACGATAGATCCGTACGTAACATTTTTGTACAGTATATCAGTTATATGCGA\";\n        strict_compare_lcskpp_sdpkpp(s1, s2);\n    }\n\n    #[test]\n    pub fn test_lcskpp2() {\n        // Match the same string -- should get a diagonal traceback, despite lots of off-diagonal\n        // homology\n        let s1 = b\"ACGTACGATAGATCCGACGTACGTACGTTCAGTTATATGACGTACGTACGTAACATTTTTGTA\";\n        let k = 5;\n\n        let matches = super::find_kmer_matches(s1, s1, k);\n        let res = super::lcskpp(\u0026matches, k);\n\n        // For debugging:\n        //for (idx, (ev, (score, prev))) in evs.iter().zip(dps.clone()).enumerate() {\n        //    println!(\"idx: {:?}\\tev: {:?}\\tscore: {:?}\\t prev: {:?}\", idx, ev, score, prev);\n        //}\n        //println!(\"tb: {:?}\", tb);\n\n        assert_eq!(res.score, s1.len() as u32);\n\n        for i in 0..res.path.len() {\n            assert_eq!(matches[res.path[i] as usize], (i as u32, i as u32));\n        }\n    }\n\n    #[test]\n    pub fn test_sdp2() {\n        let s1 = b\"ACGTACGATAGATCCGACGTACGTACGTTCAGTTATATGACGTACGTACGTAACATTTTTGTA\";\n        strict_compare_lcskpp_sdpkpp(s1, s1);\n    }\n\n    // Test case from local SV caller alignments.\n    // The query sequence ends in 1-2 copies of tandem repeat element\n    // The target sequence end in \u003e2 copies of the element\n    // Without a gap penalty (i.e. LCSk++), the alignment of the\n    // TRs is arbitrary, and way the implementation breaks ties may introduce\n    // a gap while maintaining the same score.\n    // The SDP code with gap open \u0026 extend penalties should resolve this.\n    const QUERY_REPEAT: \u0026[u8] = b\"CCTCCCATCTCCACCCACCCTATCCAACCCTGGGGTGGCAGGTCATGAGTGA\\\nCAGCCCCAAGGACACCAAGGGATGAAGCTTCTCCTGTGCTGAGATCCTTCTCGGACTTTCTGAGAGGCCACGCAGAACAGGAGGCCCCATCTCC\\\nCGTTCTTACTCAGAAGCTGTCAGCAGGGCTGGGCTCAAGATGAACCCGTGGCCGGCCCCACTCCCCAGCTCTTGCTTCAGGGCCTCACGTTTCG\\\nCCCCCTGAGGCCTGGGGGCTCCGTCCTCACGGCTGGAGGGGCTCTCAGAACATCTGGTG\";\n\n    const TARGET_REPEAT: \u0026[u8] = b\"CCTCCCATCTCCACCCACCCTATCCAACCCTGGGGTGGCAG\\\nGTCATGAGTGACAGCCCCAAGGACACCAAGGGATGAAGCTTCTCCTGTGCTGAGATCCTTCTCGGACTTTCTGAGAGGCCACGC\\\nAGAACAGGAGGCCCCATCTCCCGTTCTTACTCAGAAGCTGTCAGCAGGGCTGGGCTCAAGATGAACCCGTGGCCGGCCCCACTC\\\nCCCAGCTCTTGCTTCAGGGCCTCACGTTTCGCCCCCTGAGGCCTGGGGGCTCCGTCCTCACGGCTGGAGGGGCTCTCAGAACAT\\\nCTGGTGGGCTCCGTCCTCACGGCTGGAGGGGCTCTCAGAACATCTGGTGGGCTCCGTCCTCACGGCTGGAGGGGCTCTCAGAAC\\\nATCTGGTGGGCTCCGTCCTCACGGCTGGAGGGGCTCTCAGAACATCTGGTGCACGGCTCCCAACTCTCTTCCGGCCAAGGATCC\\\nCGTGTTCCTGAAATGTCTTTCTACCAAACACAGTTGCTGTGTAACCACTCATTTCATTTTCCTAATTTGTGTTGATCCAGGACA\\\nCGGGAGGAGACCTGGGCAGCGGCGGACTCATTGCAGGTCGCTCTGCGGTGAGGACGCCACAGGCAC\";\n\n    #[test]\n    fn test_lcskpp_tandem_repeat() {\n        let k = 8;\n        let matches = super::find_kmer_matches(QUERY_REPEAT, TARGET_REPEAT, k);\n        let res = super::lcskpp(\u0026matches, k);\n\n        // For debugging:\n        //for (idx, (ev, (score, prev))) in evs.iter().zip(dps.clone()).enumerate() {\n        //    println!(\"idx: {:?}\\tev: {:?}\\tscore: {:?}\\t prev: {:?}\", idx, ev, score, prev);\n        //}\n        //println!(\"tb: {:?}\", tb);\n\n        assert_eq!(res.score, QUERY_REPEAT.len() as u32);\n\n        // NOTE -- this test will fail, because LCSk++ introduces a gap in the placement of the TR\n        // Corrected with gap scoring in SDP\n        /*\n        for i in 0..res.path.len() {\n            assert_eq!(matches[res.path[i] as usize], (i as u32, i as u32));\n        }\n        */\n    }\n\n    #[test]\n    fn test_sdpkpp_tandem_repeat() {\n        let k = 8;\n        let matches = super::find_kmer_matches(\u0026QUERY_REPEAT, \u0026TARGET_REPEAT, k);\n        let res = super::sdpkpp(\u0026matches, k, 1, -1, -1);\n\n        // For debugging:\n        /*\n        for (idx, (ev, (score, prev))) in evs.iter().zip(dps.clone()).enumerate() {\n            println!(\"idx: {:?}\\tev: {:?}\\tscore: {:?}\\t prev: {:?}\", idx, ev, score, prev);\n        }\n        println!(\"tb: {:?}\", tb);\n        */\n\n        assert_eq!(res.score, QUERY_REPEAT.len() as u32);\n\n        for i in 0..res.path.len() {\n            assert_eq!(matches[res.path[i] as usize], (i as u32, i as u32));\n        }\n    }\n\n    #[test]\n    fn test_sdpkpp_same() {\n        let x = b\"ACGTACGTAC\";\n        let y = b\"ACGTACGTAC\";\n        let matches = super::find_kmer_matches(x, y, 10);\n        let res = super::sdpkpp(\u0026matches, 10, 1, -1, -1);\n        assert_eq!(res.path, [0]);\n        assert_eq!(res.score, 10);\n\n        let x = b\"ACGTACGTACA\";\n        let y = b\"ACGTACGTACA\";\n        let matches = super::find_kmer_matches(x, y, 10);\n        let res = super::sdpkpp(\u0026matches, 10, 1, -1, -1);\n        assert_eq!(res.path, [0, 1]);\n        assert_eq!(res.score, 11);\n\n        let x = b\"ACGTACGTACACGTACGTAC\";\n        let y = b\"ACGTACGTAC\";\n        let matches = super::find_kmer_matches(x, y, 10);\n        let res = super::sdpkpp(\u0026matches, 10, 1, -1, -1);\n        assert_eq!(res.path, [0]);\n        assert_eq!(res.score, 10);\n    }\n\n    #[test]\n    fn test_lcskpp_same() {\n        let x = b\"ACGTACGTAC\";\n        let y = b\"ACGTACGTAC\";\n        let matches = super::find_kmer_matches(x, y, 10);\n        let res = super::lcskpp(\u0026matches, 10);\n        assert_eq!(res.path, [0]);\n        assert_eq!(res.score, 10);\n\n        let x = b\"ACGTACGTACA\";\n        let y = b\"ACGTACGTACA\";\n        let matches = super::find_kmer_matches(x, y, 10);\n        let res = super::lcskpp(\u0026matches, 10);\n        assert_eq!(res.path, [0, 1]);\n        assert_eq!(res.score, 11);\n\n        let x = b\"ACGTACGTACACGTACGTAC\";\n        let y = b\"ACGTACGTAC\";\n        let matches = super::find_kmer_matches(x, y, 10);\n        let res = super::lcskpp(\u0026matches, 10);\n        assert_eq!(res.path, [0]);\n        assert_eq!(res.score, 10);\n    }\n\n    #[test]\n    fn test_expanded_matches() {\n        let x = b\"GGGCAAAAAA\";\n        let y = b\"GGGGAAAAAA\";\n        let matches = super::find_kmer_matches(x, y, 6);\n        assert_eq!(matches, vec![(4, 4)]);\n\n        let expanded_matches = super::expand_kmer_matches(x, y, 6, \u0026matches, 1);\n        assert_eq!(\n            expanded_matches,\n            (0..5)\n                .into_iter()\n                .map(|x| (x, x))\n                .collect::\u003cVec\u003c(u32, u32)\u003e\u003e()\n        );\n\n        let x = b\"TTTTTTGGGCAAAAAA\";\n        let y = b\"TTTTTTGGGGAAAAAA\";\n        let matches = super::find_kmer_matches(x, y, 6);\n        assert_eq!(matches, vec![(0, 0), (1, 1), (2, 2), (3, 3), (10, 10)]);\n\n        let expanded_matches = super::expand_kmer_matches(x, y, 6, \u0026matches, 1);\n        assert_eq!(\n            expanded_matches,\n            (0..11)\n                .into_iter()\n                .map(|x| (x, x))\n                .collect::\u003cVec\u003c(u32, u32)\u003e\u003e()\n        );\n\n        let x = b\"TTTTTTCCGCAAAAAA\";\n        let y = b\"TTTTTTGGGGAAAAAA\";\n        let matches = super::find_kmer_matches(x, y, 6);\n        assert_eq!(matches, vec![(0, 0), (10, 10)]);\n\n        let expanded_matches = super::expand_kmer_matches(x, y, 6, \u0026matches, 1);\n        assert_eq!(\n            expanded_matches,\n            vec![(0, 0), (1, 1), (8, 8), (9, 9), (10, 10)]\n        );\n\n        let x = b\"TTTTTTCGGCAAAAAA\";\n        let y = b\"TTTTTTGGGGAAAAAA\";\n        let matches = super::find_kmer_matches(x, y, 6);\n        assert_eq!(matches, vec![(0, 0), (10, 10)]);\n\n        let expanded_matches = super::expand_kmer_matches(x, y, 6, \u0026matches, 1);\n        assert_eq!(\n            expanded_matches,\n            vec![\n                (0, 0),\n                (1, 1),\n                (2, 2),\n                (3, 3),\n                (7, 7),\n                (8, 8),\n                (9, 9),\n                (10, 10),\n            ]\n        );\n\n        let x = b\"AAAAAACGGG\";\n        let y = b\"AAAAAAGGGG\";\n        let matches = super::find_kmer_matches(x, y, 6);\n        assert_eq!(matches, vec![(0, 0)]);\n        let expanded_matches = super::expand_kmer_matches(x, y, 6, \u0026matches, 1);\n        assert_eq!(\n            expanded_matches,\n            (0..5)\n                .into_iter()\n                .map(|x| (x, x))\n                .collect::\u003cVec\u003c(u32, u32)\u003e\u003e()\n        );\n    }\n}\n","traces":[{"line":67,"address":[5166823,5166480],"length":1,"stats":{"Line":1},"fn_name":"lcskpp"},{"line":68,"address":[5166573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[5166705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[5166664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[5166678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[5166638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[5166645,5166862,5167334,5167031],"length":1,"stats":{"Line":5},"fn_name":null},{"line":80,"address":[5167071,5167339],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[5167004],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[5167385],"length":1,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[5167396,5167505,5167738,5168459],"length":1,"stats":{"Line":15},"fn_name":null},{"line":87,"address":[5167838],"length":1,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[5168019],"length":1,"stats":{"Line":4},"fn_name":null},{"line":90,"address":[5168223],"length":1,"stats":{"Line":4},"fn_name":null},{"line":91,"address":[5168348],"length":1,"stats":{"Line":4},"fn_name":null},{"line":93,"address":[5167678,5168480],"length":1,"stats":{"Line":8},"fn_name":null},{"line":95,"address":[5168491],"length":1,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[5168519],"length":1,"stats":{"Line":4},"fn_name":null},{"line":97,"address":[5168624],"length":1,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[5168642],"length":1,"stats":{"Line":4},"fn_name":null},{"line":101,"address":[5169958,5169094,5169054,5168777],"length":1,"stats":{"Line":12},"fn_name":null},{"line":102,"address":[5169214,5169384],"length":1,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[5169327],"length":1,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[5169348,5169432],"length":1,"stats":{"Line":8},"fn_name":null},{"line":106,"address":[5169449,5170990],"length":1,"stats":{"Line":5},"fn_name":null},{"line":107,"address":[5169486],"length":1,"stats":{"Line":4},"fn_name":null},{"line":108,"address":[5169554],"length":1,"stats":{"Line":4},"fn_name":null},{"line":109,"address":[5169623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[5169647],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[5169776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[5169460,5169963],"length":1,"stats":{"Line":5},"fn_name":null},{"line":116,"address":[5170446,5170021,5170917],"length":1,"stats":{"Line":5},"fn_name":null},{"line":117,"address":[5170409,5170513],"length":1,"stats":{"Line":4},"fn_name":null},{"line":118,"address":[5170601,5170522],"length":1,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[5170639,5170567],"length":1,"stats":{"Line":4},"fn_name":null},{"line":120,"address":[5170765],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[5170456,5170940],"length":1,"stats":{"Line":5},"fn_name":null},{"line":128,"address":[5170995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[5171014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[5171219,5171046],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[5171094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[5171121,5171209],"length":1,"stats":{"Line":5},"fn_name":null},{"line":134,"address":[5171056,5171234],"length":1,"stats":{"Line":5},"fn_name":null},{"line":153,"address":[5171424],"length":1,"stats":{"Line":3},"fn_name":"new"},{"line":154,"address":[5171482,5171522],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[5171669,5171699,5171507,5171560],"length":1,"stats":{"Line":5},"fn_name":null},{"line":185,"address":[5172087,5171712],"length":1,"stats":{"Line":2},"fn_name":"sdpkpp"},{"line":192,"address":[5171851],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[5171969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[5171928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[5171942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[5171907],"length":1,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[5172125,5171914],"length":1,"stats":{"Line":4},"fn_name":null},{"line":202,"address":[5172181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[5172225,5172257,5172167],"length":1,"stats":{"Line":4},"fn_name":null},{"line":205,"address":[5172344,5172243,5172310],"length":1,"stats":{"Line":4},"fn_name":null},{"line":208,"address":[5172382,5172551,5172328,5172854],"length":1,"stats":{"Line":8},"fn_name":null},{"line":209,"address":[5172591,5172859],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[5172524],"length":1,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[5172905],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[5172916,5173258,5173025,5173979],"length":1,"stats":{"Line":8},"fn_name":null},{"line":216,"address":[5173358],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[5173539],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[5173743],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[5173868],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[5174000,5173198],"length":1,"stats":{"Line":5},"fn_name":null},{"line":224,"address":[5174011],"length":1,"stats":{"Line":3},"fn_name":null},{"line":225,"address":[5174039],"length":1,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[5174144],"length":1,"stats":{"Line":3},"fn_name":null},{"line":228,"address":[5174162],"length":1,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[5174574,5174297,5176204,5174614],"length":1,"stats":{"Line":7},"fn_name":null},{"line":231,"address":[5174734,5174904],"length":1,"stats":{"Line":3},"fn_name":null},{"line":232,"address":[5174847],"length":1,"stats":{"Line":2},"fn_name":null},{"line":233,"address":[5174868,5174952],"length":1,"stats":{"Line":5},"fn_name":null},{"line":235,"address":[5174969,5177270],"length":1,"stats":{"Line":6},"fn_name":null},{"line":237,"address":[5175012],"length":1,"stats":{"Line":2},"fn_name":null},{"line":240,"address":[5175137],"length":1,"stats":{"Line":3},"fn_name":null},{"line":241,"address":[5175168],"length":1,"stats":{"Line":3},"fn_name":null},{"line":242,"address":[5175183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[5175197],"length":1,"stats":{"Line":3},"fn_name":null},{"line":244,"address":[5175218],"length":1,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[5175232],"length":1,"stats":{"Line":3},"fn_name":null},{"line":246,"address":[5175253],"length":1,"stats":{"Line":2},"fn_name":null},{"line":247,"address":[5175415,5175431,5175545],"length":1,"stats":{"Line":8},"fn_name":null},{"line":248,"address":[5175450,5175547],"length":1,"stats":{"Line":2},"fn_name":null},{"line":250,"address":[5175420],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[5175647,5175594],"length":1,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[5175624,5175687,5175738],"length":1,"stats":{"Line":5},"fn_name":null},{"line":256,"address":[5175793],"length":1,"stats":{"Line":3},"fn_name":null},{"line":257,"address":[5176022],"length":1,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[5174980,5176209],"length":1,"stats":{"Line":6},"fn_name":null},{"line":262,"address":[5176683,5177145,5176267],"length":1,"stats":{"Line":7},"fn_name":null},{"line":263,"address":[5176742,5176649],"length":1,"stats":{"Line":5},"fn_name":null},{"line":264,"address":[5176751,5176829],"length":1,"stats":{"Line":3},"fn_name":null},{"line":265,"address":[5176867,5176795],"length":1,"stats":{"Line":5},"fn_name":null},{"line":266,"address":[5176993],"length":1,"stats":{"Line":2},"fn_name":null},{"line":270,"address":[5177171,5176693],"length":1,"stats":{"Line":5},"fn_name":null},{"line":271,"address":[5177202],"length":1,"stats":{"Line":3},"fn_name":null},{"line":275,"address":[5177275],"length":1,"stats":{"Line":2},"fn_name":null},{"line":276,"address":[5177294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[5177326,5177497],"length":1,"stats":{"Line":4},"fn_name":null},{"line":278,"address":[5177374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[5177487,5177401],"length":1,"stats":{"Line":5},"fn_name":null},{"line":281,"address":[5177512,5177336],"length":1,"stats":{"Line":5},"fn_name":null},{"line":289,"address":[5179820,5179835,5177712],"length":1,"stats":{"Line":0},"fn_name":"sdpkpp_union_lcskpp_path"},{"line":296,"address":[5177851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[5177925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[5177901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[5177995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[5178021,5178241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[5178135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[5178643,5178763,5178561,5178332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[5178405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[5178645,5178626,5178755,5178765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[5178682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[5178728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[5179161,5179068,5178805,5178949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[5179100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[5179041,5179171,5179473,5179380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[5179412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[5179796,5179703,5179488,5179340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[5179735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[5179661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[5179840,5180111],"length":1,"stats":{"Line":2},"fn_name":"find_kmer_matches"},{"line":333,"address":[5179922],"length":1,"stats":{"Line":2},"fn_name":null},{"line":334,"address":[5180015],"length":1,"stats":{"Line":1},"fn_name":null},{"line":335,"address":[5180036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[5179974],"length":1,"stats":{"Line":2},"fn_name":null},{"line":338,"address":[5180159],"length":1,"stats":{"Line":2},"fn_name":null},{"line":345,"address":[5180224,5180957,5180942],"length":1,"stats":{"Line":1},"fn_name":"hash_kmers"},{"line":346,"address":[5180286],"length":1,"stats":{"Line":2},"fn_name":null},{"line":347,"address":[5180302],"length":1,"stats":{"Line":2},"fn_name":null},{"line":348,"address":[5180318,5180683,5180456,5180937],"length":1,"stats":{"Line":6},"fn_name":null},{"line":349,"address":[5180720,5180926],"length":1,"stats":{"Line":4},"fn_name":null},{"line":351,"address":[5180924],"length":1,"stats":{"Line":2},"fn_name":null},{"line":358,"address":[5182020,5180960,5182035],"length":1,"stats":{"Line":1},"fn_name":"find_kmer_matches_seq1_hashed"},{"line":363,"address":[5181050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":365,"address":[5181794,5181480,5181228,5181072],"length":1,"stats":{"Line":3},"fn_name":null},{"line":366,"address":[5181517],"length":1,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[5181691,5181890,5181792],"length":1,"stats":{"Line":3},"fn_name":null},{"line":368,"address":[5181765,5181809,5181978,5181905],"length":1,"stats":{"Line":4},"fn_name":null},{"line":369,"address":[5181937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[5181442,5181993],"length":1,"stats":{"Line":2},"fn_name":null},{"line":380,"address":[5182048,5183108,5183123],"length":1,"stats":{"Line":1},"fn_name":"find_kmer_matches_seq2_hashed"},{"line":385,"address":[5182138],"length":1,"stats":{"Line":2},"fn_name":null},{"line":387,"address":[5182882,5182568,5182160,5182316],"length":1,"stats":{"Line":5},"fn_name":null},{"line":388,"address":[5182605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[5182978,5182880,5182779],"length":1,"stats":{"Line":6},"fn_name":null},{"line":391,"address":[5183066,5182853,5182993,5182897],"length":1,"stats":{"Line":4},"fn_name":null},{"line":392,"address":[5183025],"length":1,"stats":{"Line":2},"fn_name":null},{"line":397,"address":[5183081,5182530],"length":1,"stats":{"Line":3},"fn_name":null},{"line":401,"address":[5188143,5183136],"length":1,"stats":{"Line":1},"fn_name":"expand_kmer_matches"},{"line":409,"address":[5183306,5183800,5183497],"length":1,"stats":{"Line":3},"fn_name":null},{"line":410,"address":[5183805,5183537],"length":1,"stats":{"Line":1},"fn_name":null},{"line":413,"address":[5183478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":414,"address":[5183851],"length":1,"stats":{"Line":1},"fn_name":null},{"line":416,"address":[5184194,5183886,5183976,5184063,5185609],"length":1,"stats":{"Line":5},"fn_name":null},{"line":417,"address":[5184251,5184315],"length":1,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[5184361,5184295],"length":1,"stats":{"Line":2},"fn_name":null},{"line":419,"address":[5184576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[5184368,5184471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[5184453,5184511,5184628],"length":1,"stats":{"Line":2},"fn_name":null},{"line":423,"address":[5184669,5184777,5184590],"length":1,"stats":{"Line":3},"fn_name":null},{"line":426,"address":[5184763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[5184858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[5184974,5184870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":430,"address":[5184972,5185723],"length":1,"stats":{"Line":2},"fn_name":null},{"line":431,"address":[5185007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":434,"address":[5185214,5185368,5185064,5185449,5185382],"length":1,"stats":{"Line":4},"fn_name":null},{"line":435,"address":[5185370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":437,"address":[5185356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[5185437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[5185482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":443,"address":[5185728,5185614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[5185111,5185564],"length":1,"stats":{"Line":2},"fn_name":null},{"line":450,"address":[5185777,5184150],"length":1,"stats":{"Line":2},"fn_name":null},{"line":451,"address":[5185796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":452,"address":[5185823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":454,"address":[5185932],"length":1,"stats":{"Line":1},"fn_name":null},{"line":456,"address":[5185951,5187885,5186067,5186182],"length":1,"stats":{"Line":4},"fn_name":null},{"line":457,"address":[5186239,5186307],"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[5186663,5186487],"length":1,"stats":{"Line":2},"fn_name":null},{"line":459,"address":[5186355,5186409,5186285],"length":1,"stats":{"Line":2},"fn_name":null},{"line":460,"address":[5186457,5186507,5186387],"length":1,"stats":{"Line":2},"fn_name":null},{"line":462,"address":[5186623,5186548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":463,"address":[5187011,5186670,5186909],"length":1,"stats":{"Line":3},"fn_name":null},{"line":466,"address":[5186812,5186963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":468,"address":[5187025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[5187037,5187131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[5187129,5187989],"length":1,"stats":{"Line":2},"fn_name":null},{"line":473,"address":[5187164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":476,"address":[5187759,5187698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[5187215,5187305,5187684],"length":1,"stats":{"Line":3},"fn_name":null},{"line":478,"address":[5187686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[5187672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":482,"address":[5187747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[5187800],"length":1,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[5187890,5187994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":489,"address":[5187255,5187840],"length":1,"stats":{"Line":2},"fn_name":null},{"line":491,"address":[5186146,5188043],"length":1,"stats":{"Line":2},"fn_name":null},{"line":492,"address":[5188054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[6280832,6280837],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":501,"address":[6323127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":502,"address":[6323142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[6323157],"length":1,"stats":{"Line":1},"fn_name":null},{"line":507,"address":[6323169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":508,"address":[6323657,6323305,6323215],"length":1,"stats":{"Line":2},"fn_name":null},{"line":513,"address":[6280864,6280869],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":514,"address":[6323751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[6323766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":516,"address":[6323781],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[6323793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":518,"address":[6323839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":519,"address":[6280910,6280896],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":520,"address":[6324451,6324574],"length":1,"stats":{"Line":2},"fn_name":null},{"line":522,"address":[6324117],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[6324690,6324804],"length":1,"stats":{"Line":1},"fn_name":null},{"line":527,"address":[6323088,6322576],"length":1,"stats":{"Line":1},"fn_name":"strict_compare_lcskpp_sdpkpp"},{"line":528,"address":[6322627],"length":1,"stats":{"Line":1},"fn_name":null},{"line":529,"address":[6322639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":530,"address":[6322660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":531,"address":[6322752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[6323018,6322862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[6280965,6280960],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":538,"address":[6324916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":539,"address":[6324928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":540,"address":[6324940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":544,"address":[6280992,6280997],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":545,"address":[6324983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":546,"address":[6324998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":547,"address":[6325013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":549,"address":[6325025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":550,"address":[6325071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":559,"address":[6325158,6325260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":563,"address":[6281029,6281024],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":564,"address":[6325396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[6325408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":566,"address":[6325420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":570,"address":[6281061,6281056],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":573,"address":[6325463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":574,"address":[6325478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":576,"address":[6325490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[6325536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":585,"address":[6325635,6325854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":587,"address":[6326318,6325817,6325910,6326097],"length":1,"stats":{"Line":4},"fn_name":null},{"line":588,"address":[6326134,6326332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":593,"address":[6281088,6281093],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":594,"address":[6326433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":595,"address":[6326444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":620,"address":[6281120,6281125],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":621,"address":[6326487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":622,"address":[6326499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":623,"address":[6326545],"length":1,"stats":{"Line":1},"fn_name":null},{"line":631,"address":[6326833,6326632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":643,"address":[6281157,6281152],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":644,"address":[6326935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[6326947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":646,"address":[6327002],"length":1,"stats":{"Line":1},"fn_name":null},{"line":656,"address":[6327128,6327347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":658,"address":[6327403,6327590,6327812,6327310],"length":1,"stats":{"Line":4},"fn_name":null},{"line":659,"address":[6327827,6327627],"length":1,"stats":{"Line":1},"fn_name":null},{"line":664,"address":[6281184,6281189],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":665,"address":[6327927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":666,"address":[6327942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":667,"address":[6327957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":668,"address":[6328000],"length":1,"stats":{"Line":1},"fn_name":null},{"line":669,"address":[6328393,6328134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":670,"address":[6328280,6328511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":672,"address":[6328439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":673,"address":[6328454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":674,"address":[6328482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":675,"address":[6328568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":676,"address":[6328690,6328925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":677,"address":[6328824,6329041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":679,"address":[6328972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":680,"address":[6328987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":681,"address":[6329021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":682,"address":[6329101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":683,"address":[6329458,6329223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":684,"address":[6329530,6329357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":688,"address":[6281221,6281216],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":689,"address":[6329687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":690,"address":[6329702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":691,"address":[6329717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":692,"address":[6329760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":693,"address":[6330126,6329873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":694,"address":[6330238,6330019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":696,"address":[6330172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":697,"address":[6330187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":698,"address":[6330215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":699,"address":[6330295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":700,"address":[6330396,6330631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":701,"address":[6330747,6330530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":703,"address":[6330678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":704,"address":[6330693],"length":1,"stats":{"Line":1},"fn_name":null},{"line":705,"address":[6330727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":706,"address":[6330807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":707,"address":[6330908,6331142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":708,"address":[6331042,6331213],"length":1,"stats":{"Line":1},"fn_name":null},{"line":712,"address":[6281248,6281253],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":713,"address":[6331383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":714,"address":[6331398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":715,"address":[6331413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":716,"address":[6331465,6331677],"length":1,"stats":{"Line":2},"fn_name":null},{"line":718,"address":[6331807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":719,"address":[6332095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":721,"address":[6331914,6332080],"length":1,"stats":{"Line":2},"fn_name":null},{"line":723,"address":[6281293,6281280],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":727,"address":[6332316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":728,"address":[6332331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":729,"address":[6332366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":730,"address":[6332774,6332386],"length":1,"stats":{"Line":2},"fn_name":null},{"line":732,"address":[6332905],"length":1,"stats":{"Line":1},"fn_name":null},{"line":733,"address":[6333193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":735,"address":[6333012,6333178],"length":1,"stats":{"Line":2},"fn_name":null},{"line":737,"address":[6281325,6281312],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":741,"address":[6333414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":742,"address":[6333429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":743,"address":[6333464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":744,"address":[6333484,6333738],"length":1,"stats":{"Line":2},"fn_name":null},{"line":746,"address":[6333869],"length":1,"stats":{"Line":1},"fn_name":null},{"line":747,"address":[6334374,6334239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":749,"address":[6333986],"length":1,"stats":{"Line":1},"fn_name":null},{"line":752,"address":[6334497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":753,"address":[6334512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":754,"address":[6334547],"length":1,"stats":{"Line":1},"fn_name":null},{"line":755,"address":[6334567,6334821],"length":1,"stats":{"Line":2},"fn_name":null},{"line":757,"address":[6334952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":758,"address":[6335448,6335571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":760,"address":[6335261,6335069],"length":1,"stats":{"Line":2},"fn_name":null},{"line":761,"address":[6335085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":762,"address":[6335107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":763,"address":[6335129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":764,"address":[6335151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":765,"address":[6335173],"length":1,"stats":{"Line":1},"fn_name":null},{"line":766,"address":[6335195],"length":1,"stats":{"Line":1},"fn_name":null},{"line":767,"address":[6335217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":768,"address":[6335239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":772,"address":[6335688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":773,"address":[6335703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":774,"address":[6335738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":775,"address":[6335958,6335758],"length":1,"stats":{"Line":2},"fn_name":null},{"line":776,"address":[6336083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":777,"address":[6336335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":779,"address":[6336178,6336320],"length":1,"stats":{"Line":2},"fn_name":null},{"line":781,"address":[6281357,6281344],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"}],"covered":320,"coverable":346},{"path":["/","home","todd","rust-bio","src","alphabets","dna.rs"],"content":"// Copyright 2014-2015 Johannes Köster, Peer Aramillo Irizar.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation of the DNA alphabet.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::alphabets;\n//! let alphabet = alphabets::dna::alphabet();\n//! assert!(alphabet.is_word(b\"GATTACA\"));\n//! assert!(alphabet.is_word(b\"gattaca\"));\n//! assert!(!alphabet.is_word(b\"ACGU\"));\n//! ```\n\nuse std::borrow::Borrow;\n\nuse crate::alphabets::Alphabet;\n\n/// The DNA alphabet (uppercase and lowercase).\npub fn alphabet() -\u003e Alphabet {\n    Alphabet::new(b\"ACGTacgt\")\n}\n\n/// The DNA alphabet including N (uppercase and lowercase).\npub fn n_alphabet() -\u003e Alphabet {\n    Alphabet::new(b\"ACGTNacgtn\")\n}\n\n/// The IUPAC DNA alphabet (uppercase and lowercase).\npub fn iupac_alphabet() -\u003e Alphabet {\n    Alphabet::new(b\"ACGTRYSWKMBDHVNZacgtryswkmbdhvnz\")\n}\n\nlazy_static! {\n    static ref COMPLEMENT: [u8; 256] = {\n        let mut comp = [0; 256];\n        for (v, a) in comp.iter_mut().enumerate() {\n            *a = v as u8;\n        }\n        for (\u0026a, \u0026b) in b\"AGCTYRWSKMDVHBN\".iter().zip(b\"TCGARYWSMKHBDVN\".iter()) {\n            comp[a as usize] = b;\n            comp[a as usize + 32] = b + 32;  // lowercase variants\n        }\n        comp\n    };\n}\n\n/// Return complement of given DNA alphabet character (IUPAC alphabet supported).\n///\n/// Casing of input character is preserved, e.g. `t` → `a`, but `T` → `A`.\n/// All `N`s remain as they are.\n///\n/// ```\n/// use bio::alphabets::dna;\n///\n/// assert_eq!(dna::complement(65), 84); // A → T\n/// assert_eq!(dna::complement(99), 103); // c → g\n/// assert_eq!(dna::complement(78), 78); // N → N\n/// assert_eq!(dna::complement(89), 82); // Y → R\n/// assert_eq!(dna::complement(115), 115); // s → s\n/// ```\npub fn complement(a: u8) -\u003e u8 {\n    COMPLEMENT[a as usize]\n}\n\n/// Calculate reverse complement of given text (IUPAC alphabet supported).\n///\n/// Casing of characters is preserved, e.g. `b\"NaCgT\"` → `b\"aCgTN\"`.\n/// All `N`s remain as they are.\n///\n/// ```\n/// use bio::alphabets::dna;\n///\n/// assert_eq!(dna::revcomp(b\"ACGTN\"), b\"NACGT\");\n/// assert_eq!(dna::revcomp(b\"GaTtaCA\"), b\"TGtaAtC\");\n/// assert_eq!(dna::revcomp(b\"AGCTYRWSKMDVHBN\"), b\"NVDBHKMSWYRAGCT\");\n/// ```\npub fn revcomp\u003cC, T\u003e(text: T) -\u003e Vec\u003cu8\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: IntoIterator\u003cItem = C\u003e,\n    T::IntoIter: DoubleEndedIterator,\n{\n    text.into_iter()\n        .rev()\n        .map(|a| complement(*a.borrow()))\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_word() {\n        assert!(alphabet().is_word(b\"GATTACA\"));\n    }\n\n    #[test]\n    fn is_no_word() {\n        assert!(!alphabet().is_word(b\"gaUUaca\"));\n    }\n\n    #[test]\n    fn symbol_is_no_word() {\n        assert!(!alphabet().is_word(b\"#\"));\n    }\n\n    #[test]\n    fn number_is_no_word() {\n        assert!(!alphabet().is_word(b\"42\"));\n    }\n}\n","traces":[{"line":23,"address":[4949584],"length":1,"stats":{"Line":1},"fn_name":"alphabet"},{"line":28,"address":[4949616],"length":1,"stats":{"Line":1},"fn_name":"n_alphabet"},{"line":33,"address":[4949648],"length":1,"stats":{"Line":0},"fn_name":"iupac_alphabet"},{"line":39,"address":[4509348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[4509365,4509632,4509698],"length":1,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[4509696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4510037,4509506,4509703],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[4509839,4509892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4509872,4509919,4510047],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[4949680],"length":1,"stats":{"Line":1},"fn_name":"complement"},{"line":66,"address":[4949785,4949695,4949762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[9087856],"length":1,"stats":{"Line":1},"fn_name":"revcomp\u003c\u0026u8,\u0026[u8; 10]\u003e"},{"line":87,"address":[9087888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[9088003,9087984],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}\u003c\u0026u8,\u0026[u8; 10]\u003e"},{"line":98,"address":[4529584,4529673],"length":1,"stats":{"Line":3},"fn_name":"is_word"},{"line":99,"address":[4529588,4529689,4529700,4529730],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[4529744,4529835],"length":1,"stats":{"Line":3},"fn_name":"is_no_word"},{"line":104,"address":[4529862,4529851,4529892,4529748],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[4529995,4529904],"length":1,"stats":{"Line":3},"fn_name":"symbol_is_no_word"},{"line":109,"address":[4530011,4530022,4530052,4529908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[4530064,4530155],"length":1,"stats":{"Line":3},"fn_name":"number_is_no_word"},{"line":114,"address":[4530212,4530182,4530068,4530171],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":21,"coverable":22},{"path":["/","home","todd","rust-bio","src","alphabets","mod.rs"],"content":"// Copyright 2014-2015 Johannes Köster, Peer Aramillo Irizar.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation of alphabets and useful utilities.\n//!\n//! # Example\n//!\n//! ```rust\n//! use bio::alphabets;\n//! let alphabet = alphabets::dna::alphabet();\n//! assert!(alphabet.is_word(b\"AACCTgga\"));\n//! assert!(!alphabet.is_word(b\"AXYZ\"));\n//! ```\n\nuse std::borrow::Borrow;\nuse std::mem;\n\nuse bit_set::BitSet;\nuse vec_map::VecMap;\n\npub mod dna;\npub mod protein;\npub mod rna;\n\npub type SymbolRanks = VecMap\u003cu8\u003e;\n\n/// Representation of an alphabet.\n#[derive(Debug, PartialEq)]\npub struct Alphabet {\n    pub symbols: BitSet,\n}\n\nimpl Alphabet {\n    /// Create new alphabet from given symbols.\n    ///\n    /// Complexity: O(n), where n is the number of symbols in the alphabet.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// // Create an alphabet (note that a DNA alphabet is already available in bio::alphabets::dna).\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"ACGTacgt\");\n    /// // Check whether a given text is a word over the alphabet.\n    /// assert!(dna_alphabet.is_word(b\"GAttACA\"));\n    /// ```\n    pub fn new\u003cC, T\u003e(symbols: T) -\u003e Self\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        let mut s = BitSet::new();\n        s.extend(symbols.into_iter().map(|c| *c.borrow() as usize));\n\n        Alphabet { symbols: s }\n    }\n\n    /// Insert symbol into alphabet.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let mut dna_alphabet = alphabets::Alphabet::new(b\"ACGTacgt\");\n    /// assert!(!dna_alphabet.is_word(b\"N\"));\n    /// dna_alphabet.insert(78);\n    /// assert!(dna_alphabet.is_word(b\"N\"));\n    /// ```\n    pub fn insert(\u0026mut self, a: u8) {\n        self.symbols.insert(a as usize);\n    }\n\n    /// Check if given text is a word over the alphabet.\n    ///\n    /// Complexity: O(n), where n is the length of the text.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"ACGTacgt\");\n    /// assert!(dna_alphabet.is_word(b\"GAttACA\"));\n    /// assert!(!dna_alphabet.is_word(b\"42\"));\n    /// ```\n    pub fn is_word\u003cC, T\u003e(\u0026self, text: T) -\u003e bool\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        text.into_iter()\n            .all(|c| self.symbols.contains(*c.borrow() as usize))\n    }\n\n    /// Return lexicographically maximal symbol.\n    ///\n    /// Complexity: O(n), where n is the number of symbols in the alphabet.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"acgtACGT\");\n    /// assert_eq!(dna_alphabet.max_symbol(), Some(116)); // max symbol is \"t\"\n    /// let empty_alphabet = alphabets::Alphabet::new(b\"\");\n    /// assert_eq!(empty_alphabet.max_symbol(), None);\n    /// ```\n    pub fn max_symbol(\u0026self) -\u003e Option\u003cu8\u003e {\n        self.symbols.iter().max().map(|a| a as u8)\n    }\n\n    /// Return size of the alphabet.\n    ///\n    /// Upper and lower case representations of the same character\n    /// are counted as distinct characters.\n    ///\n    /// Complexity: O(n), where n is the number of symbols in the alphabet.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"acgtACGT\");\n    /// assert_eq!(dna_alphabet.len(), 8);\n    /// ```\n    pub fn len(\u0026self) -\u003e usize {\n        self.symbols.len()\n    }\n\n    /// Is this alphabet empty?\n    ///\n    /// Complexity: O(n), where n is the number of symbols in the alphabet.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"acgtACGT\");\n    /// assert!(!dna_alphabet.is_empty());\n    /// let empty_alphabet = alphabets::Alphabet::new(b\"\");\n    /// assert!(empty_alphabet.is_empty());\n    /// ```\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.symbols.is_empty()\n    }\n\n    /// Return a new alphabet taking the intersect between this and other.\n    ///\n    /// # Example\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let alpha_a = alphabets::Alphabet::new(b\"acgtACGT\");\n    /// let alpha_b = alphabets::Alphabet::new(b\"atcgMVP\");\n    /// let intersect_alpha = alpha_a.intersection(\u0026alpha_b);\n    ///\n    /// assert_eq!(intersect_alpha, alphabets::Alphabet::new(b\"atcg\"));\n    /// ```\n    pub fn intersection(\u0026self, other: \u0026Alphabet) -\u003e Self {\n        return Alphabet {\n            symbols: self.symbols.intersection(\u0026other.symbols).collect(),\n        };\n    }\n\n    /// Return a new alphabet taking the difference between this and other.\n    ///\n    /// # Example\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"acgtACGT\");\n    /// let dna_alphabet_upper = alphabets::Alphabet::new(b\"ACGT\");\n    /// let dna_lower = dna_alphabet.difference(\u0026dna_alphabet_upper);\n    ///\n    /// assert_eq!(dna_lower, alphabets::Alphabet::new(b\"atcg\"));\n    /// ```\n    pub fn difference(\u0026self, other: \u0026Alphabet) -\u003e Self {\n        return Alphabet {\n            symbols: self.symbols.difference(\u0026other.symbols).collect(),\n        };\n    }\n\n    /// Return a new alphabet taking the union between this and other.\n    ///\n    /// # Example\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"ATCG\");\n    /// let tokenize_alpha = alphabets::Alphabet::new(b\"?|\");\n    /// let alpha = dna_alphabet.union(\u0026tokenize_alpha);\n    ///\n    /// assert_eq!(alpha, alphabets::Alphabet::new(b\"ATCG?|\"));\n    /// ```\n    pub fn union(\u0026self, other: \u0026Alphabet) -\u003e Self {\n        return Alphabet {\n            symbols: self.symbols.union(\u0026other.symbols).collect(),\n        };\n    }\n}\n\n/// Tools based on transforming the alphabet symbols to their lexicographical ranks.\n///\n/// Lexicographical rank is computed using `u8` representations,\n/// i.e. ASCII codes, of the input characters.\n/// For example, assuming that the alphabet consists of the symbols `A`, `C`, `G`, and `T`, this\n/// will yield ranks `0`, `1`, `2`, `3` for them, respectively.\n///\n/// `RankTransform` can be used in to perform bit encoding for texts over a\n/// given alphabet via `bio::data_structures::bitenc`.\n#[derive(Serialize, Deserialize)]\npub struct RankTransform {\n    pub ranks: SymbolRanks,\n}\n\nimpl RankTransform {\n    /// Construct a new `RankTransform`.\n    ///\n    /// Complexity: O(n), where n is the number of symbols in the alphabet.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"acgtACGT\");\n    /// let dna_ranks = alphabets::RankTransform::new(\u0026dna_alphabet);\n    /// ```\n    pub fn new(alphabet: \u0026Alphabet) -\u003e Self {\n        let mut ranks = VecMap::new();\n        for (r, c) in alphabet.symbols.iter().enumerate() {\n            ranks.insert(c, r as u8);\n        }\n\n        RankTransform { ranks }\n    }\n\n    /// Get the rank of symbol `a`.\n    ///\n    /// This method panics for characters not contained in the alphabet.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"acgtACGT\");\n    /// let dna_ranks = alphabets::RankTransform::new(\u0026dna_alphabet);\n    /// assert_eq!(dna_ranks.get(65), 0); // \"A\"\n    /// assert_eq!(dna_ranks.get(116), 7); // \"t\"\n    /// ```\n    pub fn get(\u0026self, a: u8) -\u003e u8 {\n        *self.ranks.get(a as usize).expect(\"Unexpected character.\")\n    }\n\n    /// Transform a given `text` into a vector of rank values.\n    ///\n    /// Complexity: O(n), where n is the length of the text.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"ACGTacgt\");\n    /// let dna_ranks = alphabets::RankTransform::new(\u0026dna_alphabet);\n    /// let text = b\"aAcCgGtT\";\n    /// assert_eq!(dna_ranks.transform(text), vec![4, 0, 5, 1, 6, 2, 7, 3]);\n    /// ```\n    pub fn transform\u003cC, T\u003e(\u0026self, text: T) -\u003e Vec\u003cu8\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        text.into_iter()\n            .map(|c| {\n                *self\n                    .ranks\n                    .get(*c.borrow() as usize)\n                    .expect(\"Unexpected character in text.\")\n            })\n            .collect()\n    }\n\n    /// Iterate over q-grams (substrings of length q) of given `text`. The q-grams are encoded\n    /// as `usize` by storing the symbol ranks in log2(|A|) bits (with |A| being the alphabet size).\n    ///\n    /// If q is larger than usize::BITS / log2(|A|), this method fails with an assertion.\n    ///\n    /// Complexity: O(n), where n is the length of the text.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"ACGTacgt\");\n    /// let dna_ranks = alphabets::RankTransform::new(\u0026dna_alphabet);\n    ///\n    /// let q_grams: Vec\u003cusize\u003e = dna_ranks.qgrams(2, b\"ACGT\").collect();\n    /// assert_eq!(q_grams, vec![1, 10, 19]);\n    /// ```\n    pub fn qgrams\u003cC, T\u003e(\u0026self, q: u32, text: T) -\u003e QGrams\u003c'_, C, T::IntoIter\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        let bits = (self.ranks.len() as f32).log2().ceil() as u32;\n        assert!(\n            (bits * q) as usize \u003c= mem::size_of::\u003cusize\u003e() * 8,\n            \"Expecting q to be smaller than usize / log2(|A|)\"\n        );\n\n        let mut qgrams = QGrams {\n            text: text.into_iter(),\n            ranks: self,\n            bits,\n            mask: (1 \u003c\u003c (q * bits)) - 1,\n            qgram: 0,\n        };\n\n        for _ in 0..q - 1 {\n            qgrams.next();\n        }\n\n        qgrams\n    }\n\n    /// Restore alphabet from transform.\n    ///\n    /// Complexity: O(n), where n is the number of symbols in the alphabet.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"acgtACGT\");\n    /// let dna_ranks = alphabets::RankTransform::new(\u0026dna_alphabet);\n    /// assert_eq!(dna_ranks.alphabet().symbols, dna_alphabet.symbols);\n    /// ```\n    pub fn alphabet(\u0026self) -\u003e Alphabet {\n        let mut symbols = BitSet::with_capacity(self.ranks.len());\n        symbols.extend(self.ranks.keys());\n        Alphabet { symbols }\n    }\n\n    /// Compute the number of bits required to encode the largest rank value.\n    ///\n    /// For example, the alphabet `b\"ACGT\"` with 4 symbols has the maximal rank\n    /// 3, which can be encoded in 2 bits.\n    ///\n    /// This value can be used to create a `data_structures::bitenc::BitEnc`\n    /// bit encoding tailored to the given alphabet.\n    ///\n    /// Complexity: O(n), where n is the number of symbols in the alphabet.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"ACGT\");\n    /// let dna_ranks = alphabets::RankTransform::new(\u0026dna_alphabet);\n    /// assert_eq!(dna_ranks.get_width(), 2);\n    /// let dna_n_alphabet = alphabets::Alphabet::new(b\"ACGTN\");\n    /// let dna_n_ranks = alphabets::RankTransform::new(\u0026dna_n_alphabet);\n    /// assert_eq!(dna_n_ranks.get_width(), 3);\n    /// ```\n    pub fn get_width(\u0026self) -\u003e usize {\n        (self.ranks.len() as f32).log2().ceil() as usize\n    }\n}\n\n/// Iterator over q-grams.\npub struct QGrams\u003c'a, C, T\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    text: T,\n    ranks: \u0026'a RankTransform,\n    bits: u32,\n    mask: usize,\n    qgram: usize,\n}\n\nimpl\u003c'a, C, T\u003e QGrams\u003c'a, C, T\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    /// Push a new character into the current qgram.\n    fn qgram_push(\u0026mut self, a: u8) {\n        self.qgram \u003c\u003c= self.bits;\n        self.qgram |= a as usize;\n        self.qgram \u0026= self.mask;\n    }\n}\n\nimpl\u003c'a, C, T\u003e Iterator for QGrams\u003c'a, C, T\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    type Item = usize;\n\n    fn next(\u0026mut self) -\u003e Option\u003cusize\u003e {\n        match self.text.next() {\n            Some(a) =\u003e {\n                let b = self.ranks.get(*a.borrow());\n                self.qgram_push(b);\n                Some(self.qgram)\n            }\n            None =\u003e None,\n        }\n    }\n}\n\n/// Returns the english ascii lower case alphabet.\npub fn english_ascii_lower_alphabet() -\u003e Alphabet {\n    Alphabet::new(\u0026b\"abcdefghijklmnopqrstuvwxyz\"[..])\n}\n\n/// Returns the english ascii upper case alphabet.\npub fn english_ascii_upper_alphabet() -\u003e Alphabet {\n    Alphabet::new(\u0026b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"[..])\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_alphabet_eq() {\n        assert_eq!(Alphabet::new(b\"ATCG\"), Alphabet::new(b\"ATCG\"));\n        assert_eq!(Alphabet::new(b\"ATCG\"), Alphabet::new(b\"TAGC\"));\n        assert_ne!(Alphabet::new(b\"ATCG\"), Alphabet::new(b\"ATC\"));\n    }\n}\n","traces":[{"line":50,"address":[4786620,4786956,4786285,4786976,4785936,4786304,4786640,4787292],"length":1,"stats":{"Line":7},"fn_name":"new\u003c\u0026u8,\u0026[u8]\u003e"},{"line":55,"address":[4786670,4785982,4786334,4787006],"length":1,"stats":{"Line":7},"fn_name":null},{"line":56,"address":[4786361,4786697,4787113,4786511,4787326,4787408,4787614,4787600,4786441,4786777,4786020,4787033,4787312,4787504,4787518,4786847,4787183,4787422,4786106,4786176],"length":1,"stats":{"Line":36},"fn_name":"{{closure}}\u003c\u0026u8,\u0026[u8; 10]\u003e"},{"line":75,"address":[4969456],"length":1,"stats":{"Line":2},"fn_name":"insert"},{"line":76,"address":[4969472],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[9417344,9417472,9417216,9417728,9417567,9417695,9417600,9417439,9417315,9417823],"length":1,"stats":{"Line":7},"fn_name":"is_word\u003c\u0026u8,\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":97,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":115,"address":[4969488],"length":1,"stats":{"Line":1},"fn_name":"max_symbol"},{"line":116,"address":[4969500],"length":1,"stats":{"Line":3},"fn_name":null},{"line":134,"address":[4969584],"length":1,"stats":{"Line":1},"fn_name":"len"},{"line":135,"address":[4969593],"length":1,"stats":{"Line":3},"fn_name":null},{"line":152,"address":[4969616],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":153,"address":[4969625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[4969664],"length":1,"stats":{"Line":0},"fn_name":"intersection"},{"line":169,"address":[4969731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[4969694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[4969776],"length":1,"stats":{"Line":0},"fn_name":"difference"},{"line":187,"address":[4969835],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[4969799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[4969888],"length":1,"stats":{"Line":0},"fn_name":"union"},{"line":205,"address":[4969947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[4969911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[4970000,4970426,4970441],"length":1,"stats":{"Line":3},"fn_name":"new"},{"line":239,"address":[4970030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[4970127,4970046,4970421,4970334],"length":1,"stats":{"Line":10},"fn_name":null},{"line":241,"address":[4970398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[4970448],"length":1,"stats":{"Line":2},"fn_name":"get"},{"line":264,"address":[4970464],"length":1,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[4787728,4788850],"length":1,"stats":{"Line":3},"fn_name":"qgrams\u003c\u0026u8,\u0026[u8]\u003e"},{"line":319,"address":[4787989,4787820],"length":1,"stats":{"Line":6},"fn_name":null},{"line":320,"address":[4788241,4788158],"length":1,"stats":{"Line":3},"fn_name":null},{"line":321,"address":[4788061,4788087,4788166],"length":1,"stats":{"Line":3},"fn_name":null},{"line":326,"address":[4788206],"length":1,"stats":{"Line":3},"fn_name":null},{"line":329,"address":[4788538,4788403,4788285],"length":1,"stats":{"Line":6},"fn_name":null},{"line":333,"address":[4788845,4788807,4788575,4788522,4788698],"length":1,"stats":{"Line":15},"fn_name":null},{"line":334,"address":[4788828],"length":1,"stats":{"Line":3},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[4970786,4970528,4970771],"length":1,"stats":{"Line":0},"fn_name":"alphabet"},{"line":354,"address":[4970564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[4970594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[4970800],"length":1,"stats":{"Line":0},"fn_name":"get_width"},{"line":382,"address":[4970809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[4788880],"length":1,"stats":{"Line":2},"fn_name":"qgram_push\u003c\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":406,"address":[4788904,4788985,4789015],"length":1,"stats":{"Line":2},"fn_name":null},{"line":407,"address":[4788957],"length":1,"stats":{"Line":2},"fn_name":null},{"line":408,"address":[4788968],"length":1,"stats":{"Line":2},"fn_name":null},{"line":419,"address":[4789024,4789233],"length":1,"stats":{"Line":2},"fn_name":"next\u003c\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":420,"address":[4789080,4789069,4789038],"length":1,"stats":{"Line":4},"fn_name":null},{"line":421,"address":[4789049,4789090],"length":1,"stats":{"Line":4},"fn_name":null},{"line":422,"address":[4789190,4789100],"length":1,"stats":{"Line":4},"fn_name":null},{"line":423,"address":[4789194],"length":1,"stats":{"Line":2},"fn_name":null},{"line":424,"address":[4789213],"length":1,"stats":{"Line":2},"fn_name":null},{"line":426,"address":[4789071],"length":1,"stats":{"Line":2},"fn_name":null},{"line":432,"address":[4971008],"length":1,"stats":{"Line":0},"fn_name":"english_ascii_lower_alphabet"},{"line":433,"address":[4971022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[4971088],"length":1,"stats":{"Line":0},"fn_name":"english_ascii_upper_alphabet"},{"line":438,"address":[4971102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[4871008,4871295],"length":1,"stats":{"Line":3},"fn_name":"test_alphabet_eq"},{"line":447,"address":[4871015],"length":1,"stats":{"Line":1},"fn_name":null},{"line":448,"address":[4871310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[4871613],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":41,"coverable":68},{"path":["/","home","todd","rust-bio","src","alphabets","protein.rs"],"content":"// Copyright 2015 Peer Aramillo Irizar.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation of the protein alphabet.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::alphabets;\n//! let alphabet = alphabets::protein::alphabet();\n//! assert!(alphabet.is_word(b\"DEQsga\"));\n//! assert!(!alphabet.is_word(b\"BzJ\"));\n//! ```\n\nuse crate::alphabets::Alphabet;\n\n/// Returns the standard protein alphabet, containing the 20 common amino acids.\npub fn alphabet() -\u003e Alphabet {\n    Alphabet::new(\u0026b\"ARNDCEQGHILKMFPSTWYVarndceqghilkmfpstwyv\"[..])\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_word() {\n        assert!(alphabet().is_word(b\"PRSkl\"));\n    }\n\n    #[test]\n    fn is_no_word() {\n        assert!(!alphabet().is_word(b\"Bb\"));\n    }\n\n    #[test]\n    fn symbol_is_no_word() {\n        assert!(!alphabet().is_word(b\"#\"));\n    }\n\n    #[test]\n    fn number_is_no_word() {\n        assert!(!alphabet().is_word(b\"42\"));\n    }\n}\n","traces":[{"line":20,"address":[4824192],"length":1,"stats":{"Line":1},"fn_name":"alphabet"},{"line":21,"address":[4824206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[6281465,6281376],"length":1,"stats":{"Line":3},"fn_name":"is_word"},{"line":30,"address":[6281492,6281522,6281380,6281481],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[6281536,6281627],"length":1,"stats":{"Line":3},"fn_name":"is_no_word"},{"line":35,"address":[6281643,6281540,6281654,6281684],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[6281787,6281696],"length":1,"stats":{"Line":3},"fn_name":"symbol_is_no_word"},{"line":40,"address":[6281803,6281700,6281844,6281814],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[6281947,6281856],"length":1,"stats":{"Line":3},"fn_name":"number_is_no_word"},{"line":45,"address":[6281963,6281860,6281974,6282004],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","todd","rust-bio","src","alphabets","rna.rs"],"content":"// Copyright 2017 Ryan Hagenson.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation of the RNA alphabet.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::alphabets;\n//! let alphabet = alphabets::rna::alphabet();\n//! assert!(alphabet.is_word(b\"GAUUACA\"));\n//! assert!(alphabet.is_word(b\"gauuaca\"));\n//! assert!(!alphabet.is_word(b\"ACGT\"));\n//! ```\n\nuse std::borrow::Borrow;\n\nuse crate::alphabets::Alphabet;\n\n/// The RNA alphabet (uppercase and lowercase).\npub fn alphabet() -\u003e Alphabet {\n    Alphabet::new(b\"ACGUacgu\")\n}\n\n/// The RNA alphabet including N (uppercase and lowercase).\npub fn n_alphabet() -\u003e Alphabet {\n    Alphabet::new(b\"ACGUNacgun\")\n}\n\n/// The IUPAC RNA alphabet (uppercase and lowercase).\npub fn iupac_alphabet() -\u003e Alphabet {\n    Alphabet::new(b\"ACGURYSWKMBDHVNZacguryswkmbdhvnz\")\n}\n\nlazy_static! {\n    static ref COMPLEMENT: [u8; 256] = {\n        let mut comp = [0; 256];\n        for (v, a) in comp.iter_mut().enumerate() {\n            *a = v as u8;\n        }\n        for (\u0026a, \u0026b) in b\"AGCUYRWSKMDVHBNZ\".iter().zip(b\"UCGARYWSMKHBDVNZ\".iter()) {\n            comp[a as usize] = b;\n            comp[a as usize + 32] = b + 32;  // lowercase variants\n        }\n        comp\n    };\n}\n\n/// Return complement of given RNA alphabet character (IUPAC alphabet supported).\n///\n/// Casing of input character is preserved, e.g. `u` → `a`, but `U` → `A`.\n/// All `N`s and `Z`s remain as they are.\n///\n/// ```\n/// use bio::alphabets::rna;\n///\n/// assert_eq!(rna::complement(65), 85); // A → U\n/// assert_eq!(rna::complement(103), 99); // g → c\n/// assert_eq!(rna::complement(89), 82); // Y → R\n/// assert_eq!(rna::complement(115), 115); // s → s\n/// assert_eq!(rna::complement(78), 78); // N → N\n/// ```\npub fn complement(a: u8) -\u003e u8 {\n    COMPLEMENT[a as usize]\n}\n\n/// Calculate reverse complement of given text (IUPAC alphabet supported).\n///\n/// Casing of characters is preserved, e.g. `b\"uAGg\"` → `b\"cCUa\"`.\n/// All `N`s and `Z`s remain as they are.\n///\n/// ```\n/// use bio::alphabets::rna;\n///\n/// assert_eq!(rna::revcomp(b\"ACGUN\"), b\"NACGU\");\n/// assert_eq!(rna::revcomp(b\"GaUuaCA\"), b\"UGuaAuC\");\n/// assert_eq!(rna::revcomp(b\"AGCUYRWSKMDVHBNZ\"), b\"ZNVDBHKMSWYRAGCU\");\npub fn revcomp\u003cC, T\u003e(text: T) -\u003e Vec\u003cu8\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: IntoIterator\u003cItem = C\u003e,\n    T::IntoIter: DoubleEndedIterator,\n{\n    text.into_iter()\n        .rev()\n        .map(|a| complement(*a.borrow()))\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_word() {\n        assert!(alphabet().is_word(b\"GAUUACA\"));\n    }\n\n    #[test]\n    fn is_no_word() {\n        assert!(!alphabet().is_word(b\"gaTTaca\"));\n    }\n\n    #[test]\n    fn symbol_is_no_word() {\n        assert!(!alphabet().is_word(b\"#\"));\n    }\n\n    #[test]\n    fn number_is_no_word() {\n        assert!(!alphabet().is_word(b\"42\"));\n    }\n\n    #[test]\n    fn test_reverse_complement() {\n        assert_eq!(revcomp(b\"GAUUACA\"), b\"UGUAAUC\");\n    }\n}\n","traces":[{"line":23,"address":[4949792],"length":1,"stats":{"Line":1},"fn_name":"alphabet"},{"line":28,"address":[4949824],"length":1,"stats":{"Line":0},"fn_name":"n_alphabet"},{"line":33,"address":[4949856],"length":1,"stats":{"Line":0},"fn_name":"iupac_alphabet"},{"line":39,"address":[4508308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[4508592,4508658,4508325],"length":1,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[4508656],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4508466,4508663,4508997],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[4508799,4508852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4509007,4508832,4508879],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[4949888],"length":1,"stats":{"Line":1},"fn_name":"complement"},{"line":66,"address":[4949970,4949903,4949993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[9088160],"length":1,"stats":{"Line":1},"fn_name":"revcomp\u003c\u0026u8,\u0026[u8; 7]\u003e"},{"line":86,"address":[9088192],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[9088288,9088307],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}\u003c\u0026u8,\u0026[u8; 7]\u003e"},{"line":97,"address":[4874905,4874816],"length":1,"stats":{"Line":3},"fn_name":"is_word"},{"line":98,"address":[4874962,4874921,4874932,4874820],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[4874976,4875067],"length":1,"stats":{"Line":3},"fn_name":"is_no_word"},{"line":103,"address":[4875083,4875094,4874980,4875124],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[4875136,4875227],"length":1,"stats":{"Line":3},"fn_name":"symbol_is_no_word"},{"line":108,"address":[4875254,4875284,4875243,4875140],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[4875296,4875387],"length":1,"stats":{"Line":3},"fn_name":"number_is_no_word"},{"line":113,"address":[4875414,4875444,4875300,4875403],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[4875456,4875653],"length":1,"stats":{"Line":3},"fn_name":"test_reverse_complement"},{"line":118,"address":[4875463],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":22,"coverable":24},{"path":["/","home","todd","rust-bio","src","data_structures","annot_map.rs"],"content":"//! Efficient container for locations annotated across a set of named\n//! reference sequences.\n//!\n//! # Example\n//!\n//! ```\n//! extern crate bio_types;\n//! use bio::data_structures::annot_map::AnnotMap;\n//! use bio_types::annot::contig::Contig;\n//! use bio_types::strand::ReqStrand;\n//!\n//! // Insert a String annotation into the annotation map at a specified location.\n//! let mut genes: AnnotMap\u003cString, String\u003e = AnnotMap::new();\n//! let tma22 = Contig::new(\n//!     \"chrX\".to_owned(),\n//!     461829,\n//!     462426 - 461829,\n//!     ReqStrand::Forward,\n//! );\n//! genes.insert_at(\"TMA22\".to_owned(), \u0026tma22);\n//!\n//! // Find annotations that overlap a specific query\n//! let query = Contig::new(\"chrX\".to_owned(), 462400, 100, ReqStrand::Forward);\n//! let hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n//! assert_eq!(hits, vec![\"TMA22\"]);\n//! ```\n\nuse std::collections::HashMap;\nuse std::hash::Hash;\n\nuse crate::data_structures::interval_tree;\nuse crate::data_structures::interval_tree::{IntervalTree, IntervalTreeIterator};\nuse crate::utils::Interval;\nuse bio_types::annot::loc::Loc;\n\n/// Efficient container for querying annotations, using `HashMap` and\n/// `IntervalTree`.\n///\n/// The container is parameterized over the type of the reference\n/// sequence names `R` (which is often a `String`) and the type of the\n/// contained objects `T`.\n///\n/// The container finds annotations that overlap a specific query\n/// location. Overlaps are identified without regard for strandedness\n/// and without regard for e.g. spliced-out introns within the\n/// annotation or the query.\n///\n/// Thus, the overlapping annotations identified by querying a\n/// `AnnotMap` may need further filtering.\n#[derive(Debug, Clone)]\npub struct AnnotMap\u003cR, T\u003e\nwhere\n    R: Hash + Eq,\n{\n    refid_itrees: HashMap\u003cR, IntervalTree\u003cisize, T\u003e\u003e,\n}\n\nimpl\u003cR, T\u003e Default for AnnotMap\u003cR, T\u003e\nwhere\n    R: Eq + Hash,\n{\n    fn default() -\u003e Self {\n        AnnotMap {\n            refid_itrees: HashMap::new(),\n        }\n    }\n}\n\nimpl\u003cR, T\u003e AnnotMap\u003cR, T\u003e\nwhere\n    R: Eq + Hash,\n{\n    /// Create a new, empty `AnnotMap`. Used in conjunction with `insert_at`\n    /// or `insert_loc`.\n    pub fn new() -\u003e Self {\n        Default::default()\n    }\n\n    /// Insert an object into the container at a specified location (`Loc`).\n    ///\n    /// # Arguments\n    ///\n    /// * `data` - any type of data to be inserted at the location / region\n    /// * `location` - any object with the `Loc` trait implemented, determining\n    ///   the Range at which to insert the `data`\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// extern crate bio_types;\n    /// use bio::data_structures::annot_map::AnnotMap;\n    /// use bio_types::annot::contig::Contig;\n    /// use bio_types::strand::ReqStrand;\n    ///\n    /// let mut genes: AnnotMap\u003cString, String\u003e = AnnotMap::new();\n    /// let tma22 = Contig::new(\n    ///     \"chrX\".to_owned(),\n    ///     461829,\n    ///     462426 - 461829,\n    ///     ReqStrand::Forward,\n    /// );\n    /// genes.insert_at(\"TMA22\".to_owned(), \u0026tma22);\n    /// ```\n    pub fn insert_at\u003cL\u003e(\u0026mut self, data: T, location: \u0026L)\n    where\n        R: Eq + Hash + Clone,\n        L: Loc\u003cRefID = R\u003e,\n    {\n        let itree = self\n            .refid_itrees\n            .entry(location.refid().clone())\n            .or_insert_with(IntervalTree::new);\n        let rng = location.start()..(location.start() + (location.length() as isize));\n        itree.insert(rng, data);\n    }\n\n    /// Create an `Iterator` that will visit all entries that overlap\n    /// a query location.\n    pub fn find\u003c'a, L\u003e(\u0026'a self, location: \u0026'a L) -\u003e AnnotMapIterator\u003c'a, R, T\u003e\n    where\n        L: Loc\u003cRefID = R\u003e,\n    {\n        if let Some(itree) = self.refid_itrees.get(location.refid()) {\n            let interval = location.start()..(location.start() + (location.length() as isize));\n            let itree_iter = itree.find(interval);\n            AnnotMapIterator {\n                itree_iter: Some(itree_iter),\n                refid: location.refid(),\n            }\n        } else {\n            AnnotMapIterator {\n                itree_iter: None,\n                refid: location.refid(),\n            }\n        }\n    }\n}\n\nimpl\u003cR, T\u003e AnnotMap\u003cR, T\u003e\nwhere\n    R: Eq + Hash + Clone,\n    T: Loc\u003cRefID = R\u003e,\n{\n    /// Insert an object with the `Loc` trait into the container at\n    /// its location.\n    ///\n    /// This inserts all of `data` at the Range of length `data.length()`\n    /// that starts at `data.start()`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// extern crate bio_types;\n    /// use bio::data_structures::annot_map::AnnotMap;\n    /// use bio_types::annot::contig::Contig;\n    /// use bio_types::strand::ReqStrand;\n    ///\n    /// let mut gene_locs = AnnotMap::new();\n    /// let tma19 = Contig::new(\n    ///     String::from(\"chrXI\"),\n    ///     334412,\n    ///     (334916 - 334412),\n    ///     ReqStrand::Reverse,\n    /// );\n    /// let assert_copy = tma19.clone();\n    /// gene_locs.insert_loc(tma19);\n    /// // Find annotations that overlap a specific query\n    /// let query = Contig::new(String::from(\"chrXI\"), 334400, 100, ReqStrand::Reverse);\n    /// let hits: Vec\u003c\u0026Contig\u003cString, ReqStrand\u003e\u003e = gene_locs.find(\u0026query).map(|e| e.data()).collect();\n    /// assert_eq!(hits, vec![\u0026assert_copy]);\n    /// ```\n    pub fn insert_loc(\u0026mut self, data: T) {\n        let itree = self\n            .refid_itrees\n            .entry(data.refid().clone())\n            .or_insert_with(IntervalTree::new);\n        let rng = data.start()..(data.start() + (data.length() as isize));\n        itree.insert(rng, data);\n    }\n}\n\n/// A view of one annotation in a `AnnotMap` container.\n#[derive(Debug, Clone)]\npub struct Entry\u003c'a, R, T\u003e\nwhere\n    R: Eq + Hash,\n{\n    itree_entry: interval_tree::Entry\u003c'a, isize, T\u003e,\n    refid: \u0026'a R,\n}\n\nimpl\u003c'a, R, T\u003e Entry\u003c'a, R, T\u003e\nwhere\n    R: Eq + Hash,\n{\n    /// Return a reference to the data value in the `AnnotMap`.\n    pub fn data(\u0026self) -\u003e \u0026'a T {\n        self.itree_entry.data()\n    }\n\n    /// Return a reference to the interval spanned by the annotation.\n    pub fn interval(\u0026self) -\u003e \u0026'a Interval\u003cisize\u003e {\n        self.itree_entry.interval()\n    }\n\n    /// Return a reference to the identifier of the annotated reference sequence.\n    pub fn refid(\u0026self) -\u003e \u0026'a R {\n        self.refid\n    }\n}\n\n/// An iterator over annotation entries (of type `Entry`) in a\n/// `AnnotMap`.\n///\n/// This struct is created by the `find` function on `AnnotMap`.\npub struct AnnotMapIterator\u003c'a, R, T\u003e\nwhere\n    R: Eq + Hash,\n{\n    itree_iter: Option\u003cIntervalTreeIterator\u003c'a, isize, T\u003e\u003e,\n    refid: \u0026'a R,\n}\n\nimpl\u003c'a, R, T\u003e Iterator for AnnotMapIterator\u003c'a, R, T\u003e\nwhere\n    R: 'a + Eq + Hash,\n    T: 'a,\n{\n    type Item = Entry\u003c'a, R, T\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        match self.itree_iter {\n            Some(ref mut iter) =\u003e match iter.next() {\n                Some(next_itree) =\u003e Some(Entry {\n                    itree_entry: next_itree,\n                    refid: self.refid,\n                }),\n                None =\u003e None,\n            },\n            None =\u003e None,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use bio_types::annot::contig::Contig;\n    use bio_types::strand::ReqStrand;\n\n    #[test]\n    fn lookup() {\n        let mut genes: AnnotMap\u003cString, String\u003e = AnnotMap::new();\n        genes.insert_at(\n            \"TMA22\".to_owned(),\n            \u0026Contig::new(\n                \"chrX\".to_owned(),\n                461829,\n                462426 - 461829,\n                ReqStrand::Forward,\n            ),\n        );\n        genes.insert_at(\n            \"TMA19\".to_owned(),\n            \u0026Contig::new(\n                \"chrXI\".to_owned(),\n                334412,\n                334916 - 334412,\n                ReqStrand::Reverse,\n            ),\n        );\n\n        let query = Contig::new(\"chrX\".to_owned(), 462400, 100, ReqStrand::Forward);\n        let hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        assert_eq!(hits, vec![\"TMA22\"]);\n\n        let query = Contig::new(\"chrXI\".to_owned(), 334400, 100, ReqStrand::Forward);\n        let hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        assert_eq!(hits, vec![\"TMA19\"]);\n\n        let query = Contig::new(\"chrXI\".to_owned(), 334916, 100, ReqStrand::Forward);\n        let hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        assert!(hits.is_empty());\n\n        let query = Contig::new(\"chrX\".to_owned(), 461729, 100, ReqStrand::Forward);\n        let hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        assert!(hits.is_empty());\n\n        let query = Contig::new(\"chrXI\".to_owned(), 462400, 100, ReqStrand::Forward);\n        let hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        assert!(hits.is_empty());\n\n        let query = Contig::new(\"NotFound\".to_owned(), 0, 0, ReqStrand::Forward);\n        let hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        assert!(hits.is_empty());\n    }\n\n    #[test]\n    fn overlaps() {\n        let mut genes: AnnotMap\u003cString, String\u003e = AnnotMap::new();\n\n        genes.insert_at(\n            \"a\".to_owned(),\n            \u0026Contig::new(\"chr01\".to_owned(), 1000, 1000, ReqStrand::Forward),\n        );\n        genes.insert_at(\n            \"b\".to_owned(),\n            \u0026Contig::new(\"chr01\".to_owned(), 1300, 1000, ReqStrand::Forward),\n        );\n        genes.insert_at(\n            \"c\".to_owned(),\n            \u0026Contig::new(\"chr01\".to_owned(), 1700, 1000, ReqStrand::Forward),\n        );\n        genes.insert_at(\n            \"d\".to_owned(),\n            \u0026Contig::new(\"chr01\".to_owned(), 2200, 1000, ReqStrand::Forward),\n        );\n\n        let query = Contig::new(\"chr01\".to_owned(), 1050, 100, ReqStrand::Forward);\n        let mut hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        hits.sort();\n        assert_eq!(hits, vec![\"a\"]);\n\n        let query = Contig::new(\"chr01\".to_owned(), 1450, 100, ReqStrand::Forward);\n        let mut hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        hits.sort();\n        assert_eq!(hits, vec![\"a\", \"b\"]);\n\n        let query = Contig::new(\"chr01\".to_owned(), 1850, 100, ReqStrand::Forward);\n        let mut hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        hits.sort();\n        assert_eq!(hits, vec![\"a\", \"b\", \"c\"]);\n\n        let query = Contig::new(\"chr01\".to_owned(), 2250, 100, ReqStrand::Forward);\n        let mut hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        hits.sort();\n        assert_eq!(hits, vec![\"b\", \"c\", \"d\"]);\n\n        let query = Contig::new(\"chr01\".to_owned(), 2650, 100, ReqStrand::Forward);\n        let mut hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        hits.sort();\n        assert_eq!(hits, vec![\"c\", \"d\"]);\n    }\n}\n","traces":[{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[9380638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[9381151,9380720],"length":1,"stats":{"Line":1},"fn_name":"insert_at\u003calloc::string::String,alloc::string::String,bio_types::annot::contig::Contig\u003calloc::string::String, bio_types::strand::ReqStrand\u003e\u003e"},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[9380790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[9381111,9380933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[9381049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[9381184,9381434],"length":1,"stats":{"Line":1},"fn_name":"find\u003calloc::string::String,alloc::string::String,bio_types::annot::contig::Contig\u003calloc::string::String, bio_types::strand::ReqStrand\u003e\u003e"},{"line":123,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[9192384,9195408],"length":1,"stats":{"Line":3},"fn_name":"lookup"},{"line":254,"address":[9192391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[9192632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[9192417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[9192521],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[9192441,9192505],"length":1,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[9192513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[9192934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[9192744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[9192814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[9192771],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[9192806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[9193046],"length":1,"stats":{"Line":1},"fn_name":null},{"line":275,"address":[6100144,6100164],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":276,"address":[9193424,9193247],"length":1,"stats":{"Line":2},"fn_name":null},{"line":278,"address":[9193545],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[6100192,6100212],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":280,"address":[9193746,9193923],"length":1,"stats":{"Line":2},"fn_name":null},{"line":282,"address":[9194045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[6100260,6100240],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":284,"address":[9194333,9194244],"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[9194366,9194306],"length":1,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[6100288,6100308],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":288,"address":[9194538,9194627],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[9194600,9194660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":291,"address":[6100356,6100336],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":292,"address":[9194832,9194921],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[9194894,9194954],"length":1,"stats":{"Line":2},"fn_name":null},{"line":295,"address":[6100404,6100384],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":296,"address":[9195198,9195121],"length":1,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[6100432,6100437],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":301,"address":[9195447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[9195664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[9195460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[9195487,9195554],"length":1,"stats":{"Line":2},"fn_name":null},{"line":307,"address":[9195895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":308,"address":[9195726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[9195753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[9196126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[9195957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[9195984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[9196357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":316,"address":[9196188],"length":1,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[9196215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[9196419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":321,"address":[6100464,6100484],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":322,"address":[9196621],"length":1,"stats":{"Line":1},"fn_name":null},{"line":323,"address":[9196723],"length":1,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[9197002],"length":1,"stats":{"Line":1},"fn_name":null},{"line":326,"address":[6100512,6100532],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":327,"address":[9197204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[9197306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[9197605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":331,"address":[6100560,6100580],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":332,"address":[9197807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[9197894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":335,"address":[9198194],"length":1,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[6100608,6100628],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":337,"address":[9198396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":338,"address":[9198483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[9198783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[6100676,6100656],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":342,"address":[9198985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[9199072],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":89,"coverable":103},{"path":["/","home","todd","rust-bio","src","data_structures","bit_tree.rs"],"content":"// Copyright 2014-2015 Patrick Marks\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! BIT-tree (Binary Indexed Trees, aka Fenwick Tree) maintains a prefix-sum or\n//! prefix-max that can be efficiently queried and updated. From: Peter M. Fenwick (1994). \"A new data structure for cumulative frequency tables\". Software: Practice and Experience. 24 (3): 327–336.\n//! Implementation outlined here: https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/\n//!\n//! Time Complexity: O(log n) where `n = tree.len()`.\n//! Memory Complexity: O(n) where `n = tree.len()`.\n//! # Example for a max bit tree\n//!\n//! ```\n//! use bio::data_structures::bit_tree::*;\n//!\n//! let mut bit = MaxBitTree::new(10);\n//! bit.set(0, (1,0));\n//! bit.set(1, (0,1));\n//! bit.set(2, (2,2));\n//! bit.set(3, (4,3));\n//!\n//! assert_eq!(bit.get(0), (1, 0));\n//! assert_eq!(bit.get(1), (1, 0));\n//! assert_eq!(bit.get(2), (2, 2));\n//! assert_eq!(bit.get(3), (4, 3));\n//! assert_eq!(bit.get(4), (4, 3));\n\nuse std::cmp::max;\nuse std::marker::PhantomData;\nuse std::ops::Add;\n\n/// Fenwick tree prefix operator\npub trait PrefixOp\u003cT\u003e {\n    fn operation(t1: T, t2: T) -\u003e T;\n}\n\n/// In a max bit tree or Fenwick Tree, get(i) will return the largest element e that has been added\n/// to the bit tree with set(j, e), where j \u003c= i. Initially all positions have\n/// the value T::default(). Note that a set cannot be 'undone' by inserting\n/// a smaller element at the same index.\n/// Time Complexity: O(n) to build a new tree or O(log n) for get() and set() operations,\n/// where `n = tree.len()`.\npub struct FenwickTree\u003cT: Default + Ord, Op: PrefixOp\u003cT\u003e\u003e {\n    tree: Vec\u003cT\u003e,\n    phantom: PhantomData\u003cOp\u003e,\n}\n\nimpl\u003cT: Ord + Default + Copy, Op: PrefixOp\u003cT\u003e\u003e FenwickTree\u003cT, Op\u003e {\n    /// Create a new bit tree with len elements\n    pub fn new(len: usize) -\u003e FenwickTree\u003cT, Op\u003e {\n        // Pad length by one. The first element is unused.\n        // Done this way to make the tree structure work correctly.\n        FenwickTree {\n            tree: vec![T::default(); len + 1],\n            phantom: PhantomData,\n        }\n    }\n\n    /// Returns the largest element e that has been added\n    /// to the bit tree with set(j, e), where j \u003c= i.\n    pub fn get(\u0026self, idx: usize) -\u003e T {\n        let mut idx = idx + 1;\n        let mut sum = T::default();\n        while idx \u003e 0 {\n            sum = Op::operation(sum, self.tree[idx]);\n            idx -= (idx as isize \u0026 -(idx as isize)) as usize;\n        }\n\n        sum\n    }\n\n    /// Set the value `val` at position `idx`; `val` will\n    /// be returned for any get(j) where j \u003e= idx, if\n    /// it is the maximum value inserted between 0 and j.\n    /// Inserting a value val2 after inserting val1 where val1 \u003e val2\n    /// will have no effect.\n    pub fn set(\u0026mut self, idx: usize, val: T) {\n        let mut idx = idx + 1;\n        while idx \u003c self.tree.len() {\n            self.tree[idx] = Op::operation(self.tree[idx], val);\n            idx += (idx as isize \u0026 -(idx as isize)) as usize;\n        }\n    }\n}\n\npub struct MaxOp;\nimpl\u003cT: Copy + Ord\u003e PrefixOp\u003cT\u003e for MaxOp {\n    fn operation(t1: T, t2: T) -\u003e T {\n        max(t1, t2)\n    }\n}\n\n/// Fenwick tree specialized for prefix-max\npub type MaxBitTree\u003cT\u003e = FenwickTree\u003cT, MaxOp\u003e;\n\npub struct SumOp;\nimpl\u003cT: Copy + Add\u003e PrefixOp\u003cT\u003e for SumOp\nwhere\n    T: Add\u003cOutput = T\u003e,\n{\n    fn operation(t1: T, t2: T) -\u003e T {\n        t1 + t2\n    }\n}\n\n/// Fenwick tree specialized for prefix-sum\npub type SumBitTree\u003cT\u003e = FenwickTree\u003cT, SumOp\u003e;\n\n#[cfg(test)]\nmod test_bit_tree {\n    use super::MaxBitTree;\n\n    #[test]\n    pub fn test_bit_tree() {\n        let mut bit = MaxBitTree::new(10);\n\n        bit.set(0, (1, 0));\n        bit.set(1, (1, 1));\n        bit.set(2, (2, 2));\n        bit.set(3, (3, 3));\n        bit.set(4, (2, 4));\n        bit.set(5, (2, 5));\n        bit.set(6, (4, 6));\n        bit.set(7, (5, 7));\n\n        assert_eq!(bit.get(0), (1, 0));\n        assert_eq!(bit.get(1), (1, 1));\n        assert_eq!(bit.get(2), (2, 2));\n        assert_eq!(bit.get(3), (3, 3));\n        assert_eq!(bit.get(4), (3, 3));\n        assert_eq!(bit.get(5), (3, 3));\n        assert_eq!(bit.get(6), (4, 6));\n        assert_eq!(bit.get(7), (5, 7));\n    }\n}\n","traces":[{"line":51,"address":[5286704,5286864],"length":1,"stats":{"Line":7},"fn_name":"new\u003c(u32, u32),bio::data_structures::bit_tree::MaxOp\u003e"},{"line":55,"address":[5286728,5286888],"length":1,"stats":{"Line":8},"fn_name":null},{"line":62,"address":[4592752,4593120,4592272],"length":1,"stats":{"Line":7},"fn_name":"get\u003cbio::alignment::sparse::PrevPtr,bio::data_structures::bit_tree::MaxOp\u003e"},{"line":63,"address":[4593180,4592812,4592310,4592348,4593139,4592771],"length":1,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[4593165,4592341,4592797],"length":1,"stats":{"Line":7},"fn_name":null},{"line":65,"address":[4593073,4592842,4592702,4593210,4593441,4592378],"length":1,"stats":{"Line":12},"fn_name":null},{"line":66,"address":[5287624,5287161],"length":1,"stats":{"Line":7},"fn_name":null},{"line":67,"address":[5287866,5287461,5287338,5287836,5287491,5287711],"length":1,"stats":{"Line":5},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[5287872,5288272],"length":1,"stats":{"Line":4},"fn_name":"set\u003c(u32, u32),bio::data_structures::bit_tree::MaxOp\u003e"},{"line":79,"address":[5288305,5287907,5288333,5287935],"length":1,"stats":{"Line":8},"fn_name":null},{"line":80,"address":[5288331,5288368,5287933,5288748,5287970,5288232],"length":1,"stats":{"Line":16},"fn_name":null},{"line":81,"address":[5288417,5288016],"length":1,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[5288237,5288633,5288783,5288117,5288267,5288753],"length":1,"stats":{"Line":7},"fn_name":null},{"line":89,"address":[5288896,5288784],"length":1,"stats":{"Line":5},"fn_name":"operation\u003cbio::alignment::sparse::PrevPtr\u003e"},{"line":90,"address":[5288795,5288916],"length":1,"stats":{"Line":7},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[9179317,9179312],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":116,"address":[8988199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[8988217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[8988270],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[8988366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[8988422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[8988478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[8988534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[8988590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[8988646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[8988929,8988714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[8989165,8988888,8988989],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[8989124,8989226,8989402],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[8989633,8989463,8989361],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[8989840,8989688,8989598],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[8990047,8989895,8989811],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[8990254,8990018,8990102],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[8990309,8990442,8990225],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":33,"coverable":36},{"path":["/","home","todd","rust-bio","src","data_structures","bitenc.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A fixed-width bit encoding implementation. This allows to store a sequence of values over\n//! a reduced alphabet by packing them bit-encoded into a sequence of bytes.\n//!\n//! Similar behaviour can be achieved using a `PackedVec` from the [packedvec](https://docs.rs/packedvec) crate.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::data_structures::bitenc::BitEnc;\n//! let mut bitenc = BitEnc::new(2);\n//! bitenc.push(0);\n//! bitenc.push(2);\n//! bitenc.push(1);\n//! let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n//! assert_eq!(values, [0, 2, 1]);\n//! ```\n//!\n//! BitEnc can be used in combination with `alphabets::RankTransform`\n//! to generate rank-encoded values, like 2-bit encoded DNA bases,\n//! and store these using `BitEnc`.\n//!\n//! ```\n//! use bio::alphabets;\n//! use bio::data_structures::bitenc::BitEnc;\n//!\n//! let dna_alphabet = alphabets::Alphabet::new(b\"ACGT\");\n//! let dna_ranks = alphabets::RankTransform::new(\u0026dna_alphabet);\n//!\n//! // Compute the number of bits required for the largest rank\n//! let mut bit_enc = BitEnc::new(dna_ranks.get_width());\n//!\n//! let text = b\"GATTACA\";\n//! assert_eq!(dna_ranks.transform(text), [2, 0, 3, 3, 0, 1, 0]);\n//! ```\n\n/// A sequence of bitencoded values.\n///\n/// Space complexity: O(⌈(n * width) / k⌉) * 32 bit, where n is the length of the input\n/// sequence and `k = 32 - (32 % width)`  is the number of bits in each\n/// 32-bit block that can be used to store values.\n/// For values that are not a divider of 32, some bits will remain unused.\n/// For example for `width = 7` only `4 * 7 = 28` bits are used.\n/// Five 7-bit values are stored in 2 blocks.\n#[derive(Serialize, Deserialize, PartialEq, Eq, Hash)]\npub struct BitEnc {\n    storage: Vec\u003cu32\u003e,\n    width: usize,\n    mask: u32,\n    len: usize,\n    usable_bits_per_block: usize,\n}\n\n/// Create a mask with `width` 1-bits.\nfn mask(width: usize) -\u003e u32 {\n    (1 \u003c\u003c width) - 1\n}\n\nimpl BitEnc {\n    /// Create a new instance with a given encoding width (e.g. width=2 for using two bits per value).\n    /// Supports widths up to 8 bits per character, i.e. `1 \u003c= width \u003c= 8`.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    /// let bitenc = BitEnc::new(3);\n    /// ```\n    pub fn new(width: usize) -\u003e Self {\n        assert!(width \u003c= 8, \"Only encoding widths up to 8 supported\");\n        BitEnc {\n            storage: Vec::new(),\n            width,\n            mask: mask(width),\n            len: 0,\n            usable_bits_per_block: 32 - 32 % width,\n        }\n    }\n\n    /// Create a new instance with a given capacity and encoding width\n    /// (e.g. width=2 for using two bits per value).\n    /// Supports widths up to 8 bits per character, i.e. `1 \u003c= width \u003c= 8`.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let bitenc = BitEnc::with_capacity(3, 42);\n    /// ```\n    pub fn with_capacity(width: usize, n: usize) -\u003e Self {\n        assert!(width \u003c= 8, \"Only encoding widths up to 8 supported\");\n        BitEnc {\n            storage: Vec::with_capacity(n * width / 32),\n            width,\n            mask: mask(width),\n            len: 0,\n            usable_bits_per_block: 32 - 32 % width,\n        }\n    }\n\n    /// Append a character to the current bit-encoding.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let mut bitenc = BitEnc::new(4);\n    /// bitenc.push(0b0000);\n    /// bitenc.push(0b1000);\n    /// bitenc.push(0b1010);\n    /// // The three characters added above are encoded into one u32 entry.\n    /// let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n    /// assert_eq!(values, [0b0000, 0b1000, 0b1010]);\n    /// ```\n    pub fn push(\u0026mut self, value: u8) {\n        let (block, bit) = self.addr(self.len);\n        if bit == 0 {\n            self.storage.push(0);\n        }\n        self.set_by_addr(block, bit, value);\n        self.len += 1;\n    }\n\n    /// Append the given `value` to the encoding `n` times.\n    ///\n    /// The added values comprise 0 to 1 blocks that need to be filled up\n    /// from previous steps, 0 to m blocks that are\n    /// completely filled with the value and 0 to 1 blocks\n    /// that are only partially filled.\n    ///\n    /// Complexity: O(n)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let mut bitenc = BitEnc::new(8);\n    /// // Width: 8 → 4 values per block\n    /// // | __ __ __ __ | Denotes one block with 4 empty slots\n    ///\n    /// bitenc.push_values(5, 0b101010);\n    /// // This adds one full and one partial block.\n    /// // | 42 42 42 42 | __ __ __ 42 |\n    ///\n    /// let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n    /// assert_eq!(values, [42, 42, 42, 42, 42]);\n    ///\n    /// bitenc.push_values(1, 23);\n    /// // This only fills up an existing block;\n    /// // | 42 42 42 42 | __ __ 23 42 |\n    ///\n    /// let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n    /// assert_eq!(values, [42, 42, 42, 42, 42, 23]);\n    ///\n    /// bitenc.push_values(6, 17);\n    /// // Fills up the current block, adds a whole new one but does not create a partial block.\n    /// // | 42 42 42 42 | 17 17 23 42 | 17 17 17 17 |\n    ///\n    /// let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n    /// assert_eq!(values, [42, 42, 42, 42, 42, 23, 17, 17, 17, 17, 17, 17]);\n    /// ```\n    pub fn push_values(\u0026mut self, mut n: usize, value: u8) {\n        // Fill up the previous block.\n        // Example: After adding 3 values with a width\n        // of 8, 8 out out 32 bits in the first block\n        // can still be used.\n        {\n            // Check if there are remaining free slots\n            // in the current block, i.e. if the bit offset\n            // within the block is non-zero\n            let (block, bit) = self.addr(self.len);\n            if bit \u003e 0 {\n                // insert as many values as required to fill\n                // up the previous block and decrease the number\n                // left to insert accordingly\n                // The take(n) assures this iterator stops before\n                // an overflow of n can occur, if less symbols are\n                // added than open slots in the block.\n                for bit in (bit..32).step_by(self.width).take(n) {\n                    self.set_by_addr(block, bit, value);\n                    n -= 1;\n                    self.len += 1;\n                }\n            }\n        }\n\n        // If symbols remain to be inserted after\n        // filling up the current block divide them into\n        // full and partial blocks to add them.\n        if n \u003e 0 {\n            // Create a full value block containing\n            // as many copies of value as possible.\n            let mut value_block = 0;\n            {\n                let mut v = u32::from(value);\n                for _ in 0..32 / self.width {\n                    value_block |= v;\n                    v \u003c\u003c= self.width;\n                }\n            }\n\n            // Append as many full value blocks as needed\n            // to reach the last block\n            let i = self.len + n;\n            let (block, bit) = self.addr(i);\n            self.storage.resize(block, value_block);\n\n            if bit \u003e 0 {\n                // add the remaining values to a final block\n                // let shifted_block = value_block \u003e\u003e (32 - bit);\n                let shifted_block = value_block \u003e\u003e (self.usable_bits_per_block - bit);\n                self.storage.push(shifted_block);\n            }\n\n            self.len = i;\n        }\n    }\n\n    /// Replace the current value as position `i` with the given value.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let mut bitenc = BitEnc::new(4);\n    /// bitenc.push_values(4, 0b1111);\n    /// bitenc.set(2, 0b0000);\n    ///\n    /// let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n    /// assert_eq!(values, [0b1111, 0b1111, 0b0000, 0b1111]);\n    /// ```\n    pub fn set(\u0026mut self, i: usize, value: u8) {\n        let (block, bit) = self.addr(i);\n        self.set_by_addr(block, bit, value);\n    }\n\n    /// Get the value at position `i`.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let mut bitenc = BitEnc::new(4);\n    /// for value in 1..=4 {\n    ///     bitenc.push(value);\n    /// }\n    ///\n    /// let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n    /// assert_eq!(values, [0b0001, 0b0010, 0b0011, 0b0100]);\n    /// ```\n    pub fn get(\u0026self, i: usize) -\u003e Option\u003cu8\u003e {\n        if i \u003e= self.len {\n            None\n        } else {\n            let (block, bit) = self.addr(i);\n            Some(self.get_by_addr(block, bit))\n        }\n    }\n\n    /// Iterate over stored values (values will be unpacked into bytes).\n    ///\n    /// Complexity: O(n), where n is the number of encoded values\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// // Fill bitenc with 1, 2, 3, and 4.\n    /// let mut bitenc = BitEnc::new(4);\n    /// for value in 1..=4 {\n    ///     bitenc.push(value);\n    /// }\n    ///\n    /// // Collect iterator for comparison\n    /// let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n    /// assert_eq!(values, [0b0001, 0b0010, 0b0011, 0b0100]);\n    /// ```\n    pub fn iter(\u0026self) -\u003e BitEncIter\u003c'_\u003e {\n        BitEncIter { bitenc: self, i: 0 }\n    }\n\n    /// Clear the sequence.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let mut bitenc = BitEnc::new(2);\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.len(), 1);\n    /// bitenc.clear();\n    /// assert_eq!(bitenc.len(), 0);\n    /// ```\n    pub fn clear(\u0026mut self) {\n        self.storage.clear();\n        self.len = 0;\n    }\n\n    /// Get the value stored in the given `block` at `bit`.\n    fn get_by_addr(\u0026self, block: usize, bit: usize) -\u003e u8 {\n        ((self.storage[block] \u003e\u003e bit) \u0026 self.mask) as u8\n    }\n\n    /// Replace the value in the given `block` at `bit` with the given `value`.\n    fn set_by_addr(\u0026mut self, block: usize, bit: usize, value: u8) {\n        let mask = self.mask \u003c\u003c bit;\n        self.storage[block] |= mask;\n        self.storage[block] ^= mask;\n        self.storage[block] |= (u32::from(value) \u0026 self.mask) \u003c\u003c bit;\n    }\n\n    /// Get the block and start bit for the `i`th encoded value.\n    fn addr(\u0026self, i: usize) -\u003e (usize, usize) {\n        let k = i * self.width;\n        (\n            k / self.usable_bits_per_block,\n            k % self.usable_bits_per_block,\n        )\n    }\n\n    /// Get the number of symbols encoded.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let mut bitenc = BitEnc::new(8);\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.len(), 1);\n    /// bitenc.push(2);\n    /// bitenc.push(2);\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.len(), 4);\n    /// // Add another 2 to create a second block\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.len(), 5);\n    /// ```\n    #[deprecated(\n        since = \"0.33.0\",\n        note = \"Please use the more specific `nr_blocks` and `nr_symbols` functions instead.\"\n    )]\n    pub fn len(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    /// Get the number of blocks used by the encoding.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let mut bitenc = BitEnc::new(8);\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.nr_blocks(), 1);\n    /// // Add enough 2s to completely fill the first block\n    /// bitenc.push(2);\n    /// bitenc.push(2);\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.nr_blocks(), 1);\n    /// // Add another 2 to create a second block\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.nr_blocks(), 2);\n    /// ```    \n    pub fn nr_blocks(\u0026self) -\u003e usize {\n        self.storage.len()\n    }\n\n    /// Get the number of symbols encoded.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let mut bitenc = BitEnc::new(8);\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.nr_symbols(), 1);\n    /// bitenc.push(2);\n    /// bitenc.push(2);\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.nr_symbols(), 4);\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.nr_symbols(), 5);\n    /// ```    \n    pub fn nr_symbols(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    /// Is the encoded sequence empty?\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let mut bitenc = BitEnc::new(2);\n    /// assert!(bitenc.is_empty());\n    /// bitenc.push(2);\n    /// assert!(!bitenc.is_empty());\n    /// bitenc.clear();\n    /// assert!(bitenc.is_empty());\n    /// ```\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.len == 0\n    }\n}\n\n/// Iterator over values of a bitencoded sequence (values will be unpacked into bytes).\n/// Used to implement the `iter` method of `BitEnc`.\npub struct BitEncIter\u003c'a\u003e {\n    bitenc: \u0026'a BitEnc,\n    i: usize,\n}\n\nimpl\u003c'a\u003e Iterator for BitEncIter\u003c'a\u003e {\n    type Item = u8;\n\n    fn next(\u0026mut self) -\u003e Option\u003cu8\u003e {\n        let value = self.bitenc.get(self.i);\n        self.i += 1;\n        value\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::BitEnc;\n\n    #[test]\n    fn test_bitenc() {\n        let mut bitenc = BitEnc::new(2);\n        bitenc.push(0);\n        bitenc.push(2);\n        bitenc.push(1);\n        let mut values: Vec\u003cu8\u003e = bitenc.iter().collect();\n        assert_eq!(values, [0, 2, 1]);\n        bitenc.set(1, 3);\n        values = bitenc.iter().collect();\n        assert_eq!(values, [0, 3, 1]);\n    }\n\n    #[test]\n    fn test_push_values() {\n        let mut bitenc = BitEnc::new(2);\n        bitenc.push_values(32, 0);\n        assert_eq!(bitenc.storage, [0, 0]);\n    }\n\n    #[test]\n    fn test_push_values_edge_cases() {\n        //! This is a slight variation of the methods doc test,\n        //! which also creates a new partial block in the last step\n        //! and an additonal full block of 17s.\n        //! As this bloats the result vectors, this was not included\n        //! in the doc test.\n        //! Additionally, this test uses a width of 7 bits, which leave\n        //! some bits unused.\n\n        let mut bitenc = BitEnc::new(7);\n        // Width: 7 → 4 values per block\n        // | __ __ __ __ | Denotes one block with 4 empty slots and 4 leftover bits\n\n        bitenc.push_values(5, 0b101010);\n        // This adds one full and one partial block.\n        // | 42 42 42 42 | __ __ __ 42 |\n\n        let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n        assert_eq!(values, [42, 42, 42, 42, 42]);\n        assert_eq!(bitenc.nr_blocks(), 2);\n        assert_eq!(bitenc.nr_symbols(), 5);\n\n        bitenc.push_values(1, 23);\n        // This only fills up an existing block;\n        // | 42 42 42 42 | __ __ 23 42 |\n        let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n        assert_eq!(values, [42, 42, 42, 42, 42, 23]);\n        assert_eq!(bitenc.nr_blocks(), 2);\n        assert_eq!(bitenc.nr_symbols(), 6);\n\n        bitenc.push_values(12, 17);\n        // Fills up the current block, adds a whole new one AND create a partial block.\n        // | 42 42 42 42 | 17 17 23 42 | 17 17 17 17 | 17 17 17 17 | __ __ 17 17 |\n\n        let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n        assert_eq!(\n            values,\n            [42, 42, 42, 42, 42, 23, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17]\n        );\n        assert_eq!(bitenc.nr_blocks(), 5);\n        assert_eq!(bitenc.nr_symbols(), 18);\n    }\n\n    #[test]\n    fn test_issue29() {\n        for w in 2..9 {\n            let mut vec = BitEnc::with_capacity(w, 1000);\n            for i in 0..1000 {\n                println!(\"Push {}\", i);\n                vec.push(1);\n            }\n        }\n    }\n}\n","traces":[{"line":59,"address":[5300432],"length":1,"stats":{"Line":1},"fn_name":"mask"},{"line":60,"address":[5300441,5300534,5300564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[5300895,5300576,5300907],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":76,"address":[5300600,5300626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[5300613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[5300661],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[5300679,5300729,5300865],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[5301321,5300912,5301309],"length":1,"stats":{"Line":1},"fn_name":"with_capacity"},{"line":100,"address":[5300946,5300986],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[5301021,5300969],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[5301073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[5301141,5301279,5301091],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[5301328],"length":1,"stats":{"Line":1},"fn_name":"push"},{"line":128,"address":[5301353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[5301444,5301413,5301392],"length":1,"stats":{"Line":3},"fn_name":null},{"line":130,"address":[5301403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[5301434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[5301451,5301488,5301518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[5301520],"length":1,"stats":{"Line":1},"fn_name":"push_values"},{"line":184,"address":[5301561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[5301811,5301606],"length":1,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[5301978,5301830,5301627],"length":1,"stats":{"Line":3},"fn_name":null},{"line":193,"address":[5301862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[5301870,5301934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[5301983,5301974,5301912],"length":1,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[5302013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[5302033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[5302044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[5302304,5302398,5302064],"length":1,"stats":{"Line":3},"fn_name":null},{"line":210,"address":[5302328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[5302349,5302403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[5302266,5302443,5302468],"length":1,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[5302513,5302451],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[5302529],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[5302720,5302547],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[5302568,5302690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[5302682],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[5302732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":246,"address":[5302752],"length":1,"stats":{"Line":1},"fn_name":"set"},{"line":247,"address":[5302780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[5302823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[5302848],"length":1,"stats":{"Line":1},"fn_name":"get"},{"line":267,"address":[5302972,5302970,5302872],"length":1,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[5302905],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[5302888,5302938],"length":1,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[5302948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[5302976],"length":1,"stats":{"Line":1},"fn_name":"iter"},{"line":313,"address":[5303024],"length":1,"stats":{"Line":0},"fn_name":"clear"},{"line":314,"address":[5303038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[5303049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[5303072],"length":1,"stats":{"Line":1},"fn_name":"get_by_addr"},{"line":320,"address":[5303175,5303205,5303101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":324,"address":[5303216],"length":1,"stats":{"Line":1},"fn_name":"set_by_addr"},{"line":325,"address":[5303331,5303263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":326,"address":[5303380,5303311],"length":1,"stats":{"Line":2},"fn_name":null},{"line":327,"address":[5303384],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[5303419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[5303568],"length":1,"stats":{"Line":1},"fn_name":"addr"},{"line":333,"address":[5303643,5303590],"length":1,"stats":{"Line":2},"fn_name":null},{"line":335,"address":[5303683,5303621,5303723],"length":1,"stats":{"Line":4},"fn_name":null},{"line":336,"address":[5303828,5303701,5303763,5303798],"length":1,"stats":{"Line":3},"fn_name":null},{"line":364,"address":[5303840],"length":1,"stats":{"Line":0},"fn_name":"len"},{"line":365,"address":[5303845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[5303856],"length":1,"stats":{"Line":1},"fn_name":"nr_blocks"},{"line":390,"address":[5303865],"length":1,"stats":{"Line":1},"fn_name":null},{"line":412,"address":[5303888],"length":1,"stats":{"Line":1},"fn_name":"nr_symbols"},{"line":413,"address":[5303893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":432,"address":[5303904],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":433,"address":[5303909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[5303936],"length":1,"stats":{"Line":1},"fn_name":"next"},{"line":448,"address":[5303953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[5303989,5304036,5304066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[9179344,9179349],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":460,"address":[9559831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":461,"address":[9559853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":462,"address":[9559870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":463,"address":[9559924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[9559936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":465,"address":[9559992,9560155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":466,"address":[9560138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":467,"address":[9560206,9560397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":468,"address":[9560476,9560517,9560313],"length":1,"stats":{"Line":2},"fn_name":null},{"line":472,"address":[9179381,9179376],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":473,"address":[9560631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":474,"address":[9560658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[9560670,9560773,9560800],"length":1,"stats":{"Line":2},"fn_name":null},{"line":479,"address":[9179408,9179413],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":488,"address":[9560871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":492,"address":[9560907],"length":1,"stats":{"Line":1},"fn_name":null},{"line":496,"address":[9561015,9560922],"length":1,"stats":{"Line":2},"fn_name":null},{"line":497,"address":[9561030,9561215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":498,"address":[9561181,9561269,9561411],"length":1,"stats":{"Line":2},"fn_name":null},{"line":499,"address":[9561377,9561471,9561612],"length":1,"stats":{"Line":2},"fn_name":null},{"line":501,"address":[9561589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":504,"address":[9561672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":505,"address":[9561925,9561740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":506,"address":[9562113,9561891,9561980],"length":1,"stats":{"Line":2},"fn_name":null},{"line":507,"address":[9562170,9562299,9562085],"length":1,"stats":{"Line":2},"fn_name":null},{"line":509,"address":[9562282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[9562359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":514,"address":[9562579,9562415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":518,"address":[9562758,9562554,9562631],"length":1,"stats":{"Line":2},"fn_name":null},{"line":519,"address":[9562938,9562733,9562815],"length":1,"stats":{"Line":2},"fn_name":null},{"line":523,"address":[9179440,9179445],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":524,"address":[9563191,9563661,9563079,9563656],"length":1,"stats":{"Line":3},"fn_name":null},{"line":525,"address":[9563220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":526,"address":[9563441,9563235,9563355,9563636],"length":1,"stats":{"Line":4},"fn_name":null},{"line":527,"address":[9563477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":528,"address":[9563629],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":102,"coverable":110},{"path":["/","home","todd","rust-bio","src","data_structures","bwt.rs"],"content":"// Copyright 2014-2016 Johannes Köster, Taylor Cramer.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! The [Burrows-Wheeler-Transform](https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.6774) and related data structures.\n//! The implementation is based on the lecture notes\n//! \"Algorithmen auf Sequenzen\", Kopczynski, Marschall, Martin and Rahmann, 2008 - 2015.\n\nuse std::iter::repeat;\n\nuse crate::alphabets::Alphabet;\nuse crate::data_structures::suffix_array::RawSuffixArraySlice;\nuse crate::utils::prescan;\n\npub type BWT = Vec\u003cu8\u003e;\npub type BWTSlice = [u8];\npub type Less = Vec\u003cusize\u003e;\npub type BWTFind = Vec\u003cusize\u003e;\n\n/// Calculate Burrows-Wheeler-Transform of the given text of length n.\n/// Complexity: O(n).\n///\n/// # Arguments\n///\n/// * `text` - the text ended by sentinel symbol (being lexicographically smallest)\n/// * `pos` - the suffix array for the text\n///\n/// # Example\n///\n/// ```\n/// use bio::data_structures::bwt::bwt;\n/// use bio::data_structures::suffix_array::suffix_array;\n/// let text = b\"GCCTTAACATTATTACGCCTA$\";\n/// let pos = suffix_array(text);\n/// let bwt = bwt(text, \u0026pos);\n/// assert_eq!(bwt, b\"ATTATTCAGGACCC$CTTTCAA\");\n/// ```\npub fn bwt(text: \u0026[u8], pos: RawSuffixArraySlice) -\u003e BWT {\n    assert_eq!(text.len(), pos.len());\n    let n = text.len();\n    let mut bwt: BWT = repeat(0).take(n).collect();\n    for r in 0..n {\n        let p = pos[r];\n        bwt[r] = if p \u003e 0 { text[p - 1] } else { text[n - 1] };\n    }\n\n    bwt\n}\n\n/// Calculate the inverse of a BWT of length n, which is the original text.\n/// Complexity: O(n).\n///\n/// This only works if the last sentinel in the original text is unique\n/// and lexicographically the smallest.\n///\n/// # Arguments\n///\n/// * `bwt` - the BWT\npub fn invert_bwt(bwt: \u0026BWTSlice) -\u003e Vec\u003cu8\u003e {\n    let alphabet = Alphabet::new(bwt);\n    let n = bwt.len();\n    let bwtfind = bwtfind(bwt, \u0026alphabet);\n    let mut inverse = Vec::with_capacity(n);\n\n    let mut r = bwtfind[0];\n    for _ in 0..n {\n        r = bwtfind[r];\n        inverse.push(bwt[r]);\n    }\n\n    inverse\n}\n\n/// An occurrence array implementation.\n#[derive(Serialize, Deserialize)]\npub struct Occ {\n    occ: Vec\u003cVec\u003cusize\u003e\u003e,\n    k: u32,\n}\n\nimpl Occ {\n    /// Calculate occ array with sampling from BWT of length n.\n    /// Time complexity: O(n).\n    /// Space complexity: O(n / k * A) with A being the alphabet size.\n    /// Alphabet size is determined on the fly from the BWT.\n    /// For large texts, it is therefore advisable to transform\n    /// the text before calculating the BWT (see alphabets::rank_transform).\n    ///\n    /// # Arguments\n    ///\n    /// * `bwt` - the BWT\n    /// * `k` - the sampling rate: every k-th entry will be stored\n    pub fn new(bwt: \u0026BWTSlice, k: u32, alphabet: \u0026Alphabet) -\u003e Self {\n        let n = bwt.len();\n        let m = alphabet\n            .max_symbol()\n            .expect(\"Expecting non-empty alphabet.\") as usize\n            + 1;\n        let mut occ = Vec::with_capacity(n / k as usize);\n        let mut curr_occ: Vec\u003cusize\u003e = repeat(0).take(m).collect();\n        for (i, \u0026c) in bwt.iter().enumerate() {\n            curr_occ[c as usize] += 1;\n            if i % k as usize == 0 {\n                occ.push(curr_occ.clone());\n            }\n        }\n\n        Occ { occ, k }\n    }\n\n    /// Get occurrence count of symbol a in BWT[..r+1].\n    /// Complexity: O(k).\n    pub fn get(\u0026self, bwt: \u0026BWTSlice, r: usize, a: u8) -\u003e usize {\n        // NOTE:\n        //\n        // Retrieving byte match counts in this function is critical to the performance of FM Index.\n        //\n        // The below manual count code is roughly equivalent to:\n        // ```\n        // let count = bwt[(i * self.k) + 1..r + 1]\n        //     .iter()\n        //     .filter(|\u0026\u0026c| c == a)\n        //     .count();\n        // self.occ[i][a as usize] + count\n        // ```\n        //\n        // But there are a couple of reasons to do this manually:\n        // 1) As of 2016, versions of rustc/LLVM vectorize this manual loop more reliably\n        //    than the iterator adapter version.\n        // 2) Manually accumulating the byte match count in a single chunk can allows\n        //    us to use a `u32` for that count, which has faster arithmetic on common arches.\n        //    This does necessitate storing `k` as a u32.\n        //\n        // See the conversation in these issues for some of the history here:\n        //\n        // https://github.com/rust-bio/rust-bio/pull/74\n        // https://github.com/rust-bio/rust-bio/pull/76\n\n        // self.k is our sampling rate, so find the checkpoints either side of r.\n        let lo_checkpoint = r / self.k as usize;\n        // Get the occurences at the low checkpoint\n        let lo_occ = self.occ[lo_checkpoint][a as usize];\n\n        // If the sampling rate is infrequent it is worth checking if there is a closer\n        // hi checkpoint.\n        if self.k \u003e 64 {\n            let hi_checkpoint = lo_checkpoint + 1;\n            if let Some(hi_occs) = self.occ.get(hi_checkpoint) {\n                let hi_occ = hi_occs[a as usize];\n\n                // Its possible that there are no occurences between the low and high\n                // checkpoint in which case we bail early.\n                if lo_occ == hi_occ {\n                    return lo_occ;\n                }\n\n                // If r is closer to the high checkpoint, count backwards from there.\n                let hi_idx = hi_checkpoint * self.k as usize;\n                if (hi_idx - r) \u003c (self.k as usize / 2) {\n                    let hi_occ = hi_occs[a as usize];\n                    return hi_occ - bytecount::count(\u0026bwt[r + 1..=hi_idx], a) as usize;\n                }\n            }\n        }\n\n        // Otherwise the default case is to count from the low checkpoint.\n        let lo_idx = lo_checkpoint * self.k as usize;\n        bytecount::count(\u0026bwt[lo_idx + 1..=r], a) as usize + lo_occ\n    }\n}\n\n/// Calculate the less array for a given BWT. Complexity O(n).\npub fn less(bwt: \u0026BWTSlice, alphabet: \u0026Alphabet) -\u003e Less {\n    let m = alphabet\n        .max_symbol()\n        .expect(\"Expecting non-empty alphabet.\") as usize\n        + 2;\n    let mut less: Less = repeat(0).take(m).collect();\n    for \u0026c in bwt.iter() {\n        less[c as usize] += 1;\n    }\n    // calculate +-prescan\n    prescan(\u0026mut less[..], 0, |a, b| a + b);\n\n    less\n}\n\n/// Calculate the bwtfind array needed for inverting the BWT. Complexity O(n).\npub fn bwtfind(bwt: \u0026BWTSlice, alphabet: \u0026Alphabet) -\u003e BWTFind {\n    let n = bwt.len();\n    let mut less = less(bwt, alphabet);\n\n    let mut bwtfind: BWTFind = repeat(0).take(n).collect();\n    for (r, \u0026c) in bwt.iter().enumerate() {\n        bwtfind[less[c as usize]] = r;\n        less[c as usize] += 1;\n    }\n\n    bwtfind\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{bwt, bwtfind, invert_bwt, Occ};\n    use crate::alphabets::dna;\n    use crate::alphabets::Alphabet;\n    use crate::data_structures::suffix_array::suffix_array;\n    use crate::data_structures::wavelet_matrix::WaveletMatrix;\n\n    #[test]\n    fn test_bwtfind() {\n        let text = b\"cabca$\";\n        let alphabet = Alphabet::new(b\"abc$\");\n        let pos = suffix_array(text);\n        let bwt = bwt(text, \u0026pos);\n        let bwtfind = bwtfind(\u0026bwt, \u0026alphabet);\n        assert_eq!(bwtfind, vec![5, 0, 3, 4, 1, 2]);\n    }\n\n    #[test]\n    fn test_invert_bwt() {\n        let text = b\"cabca$\";\n        let pos = suffix_array(text);\n        let bwt = bwt(text, \u0026pos);\n        let inverse = invert_bwt(\u0026bwt);\n        assert_eq!(inverse, text);\n    }\n\n    #[test]\n    fn test_occ() {\n        let bwt = vec![1u8, 3u8, 3u8, 1u8, 2u8, 0u8];\n        let alphabet = Alphabet::new(\u0026[0u8, 1u8, 2u8, 3u8]);\n        let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n        assert_eq!(occ.occ, [[0, 1, 0, 0], [0, 2, 0, 2]]);\n        assert_eq!(occ.get(\u0026bwt, 4, 2u8), 1);\n        assert_eq!(occ.get(\u0026bwt, 4, 3u8), 2);\n    }\n\n    #[test]\n    fn test_occwm() {\n        let text = b\"GCCTTAACATTATTACGCCTA$\";\n        let alphabet = dna::n_alphabet();\n        let sa = suffix_array(text);\n        let bwt = bwt(text, \u0026sa);\n        let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n        let wm = WaveletMatrix::new(\u0026bwt);\n\n        for c in vec![b'A', b'C', b'G', b'T', b'$'] {\n            for p in 0..text.len() {\n                assert_eq!(occ.get(\u0026bwt, p, c) as u64, wm.rank(c, p as u64));\n            }\n        }\n    }\n}\n","traces":[{"line":39,"address":[9632932,9631840,9632917],"length":1,"stats":{"Line":1},"fn_name":"bwt"},{"line":40,"address":[9631943,9632117],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[9632086],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[9632165],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[9632465,9632364,9632912,9632232],"length":1,"stats":{"Line":13},"fn_name":null},{"line":44,"address":[9632502,9632559],"length":1,"stats":{"Line":4},"fn_name":null},{"line":45,"address":[9632541,9632584],"length":1,"stats":{"Line":6},"fn_name":null},{"line":60,"address":[9633639,9632944],"length":1,"stats":{"Line":1},"fn_name":"invert_bwt"},{"line":61,"address":[9632987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[9633007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[9633062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[9633116],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[9633213,9633127],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[9633335,9633622,9633224,9633453],"length":1,"stats":{"Line":4},"fn_name":null},{"line":68,"address":[9633477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[9633540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[9634048,9634155],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[9636272,9637000,9636985],"length":1,"stats":{"Line":1},"fn_name":"less"},{"line":175,"address":[9636473,9636351],"length":1,"stats":{"Line":3},"fn_name":null},{"line":179,"address":[9636457,9636513],"length":1,"stats":{"Line":4},"fn_name":null},{"line":180,"address":[9636809,9636564,9636679,9636911],"length":1,"stats":{"Line":9},"fn_name":null},{"line":181,"address":[9636916,9636848],"length":1,"stats":{"Line":3},"fn_name":null},{"line":184,"address":[5260771,5260752],"length":1,"stats":{"Line":12},"fn_name":"{{closure}}"},{"line":190,"address":[9637827,9637008],"length":1,"stats":{"Line":1},"fn_name":"bwtfind"},{"line":191,"address":[9637086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[9637123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[9637140,9637250],"length":1,"stats":{"Line":4},"fn_name":null},{"line":195,"address":[9637544,9637267,9637364,9637790],"length":1,"stats":{"Line":8},"fn_name":null},{"line":196,"address":[9637618],"length":1,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[9637716,9637795],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[6389840,6390545],"length":1,"stats":{"Line":3},"fn_name":"test_bwtfind"},{"line":213,"address":[6389847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[6389862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[6389879],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[6389903,6389982],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[6390041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[6390148,6390362],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[9179504,9179509],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":223,"address":[6390583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[6390595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[6390615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[6390727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[6390971,6390821],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[9179541,9179536],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":232,"address":[6391079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[6391135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[6391258,6391157],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[6391310,6391482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[6391557,6391713,6391440],"length":1,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[6391671,6391794,6391931],"length":1,"stats":{"Line":2},"fn_name":null},{"line":241,"address":[6392048,6393487],"length":1,"stats":{"Line":3},"fn_name":"test_occwm"},{"line":242,"address":[6392055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[6392070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[6392083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[6392110,6392207],"length":1,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[6392272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[6392398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[6392806,6392516,6392830,6392630,6393067],"length":1,"stats":{"Line":4},"fn_name":null},{"line":250,"address":[6393072,6393339,6392862],"length":1,"stats":{"Line":3},"fn_name":null},{"line":251,"address":[6393109,6393353],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":74,"coverable":86},{"path":["/","home","todd","rust-bio","src","data_structures","fmindex.rs"],"content":"// Copyright 2014-2016 Johannes Köster, Taylor Cramer.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! The [Full-text index in Minute space index (FM-index)](https://doi.org/10.1109/SFCS.2000.892127) and\n//! the FMD-Index for finding suffix array intervals matching a given pattern in linear time.\n//!\n//! # Examples\n//!\n//! ## Generate\n//!\n//! ```\n//! use bio::alphabets::dna;\n//! use bio::data_structures::bwt::{bwt, less, Occ};\n//! use bio::data_structures::fmindex::{FMIndex, FMIndexable};\n//! use bio::data_structures::suffix_array::suffix_array;\n//!\n//! let text = b\"GCCTTAACATTATTACGCCTA$\";\n//! let alphabet = dna::n_alphabet();\n//! let sa = suffix_array(text);\n//! let bwt = bwt(text, \u0026sa);\n//! let less = less(\u0026bwt, \u0026alphabet);\n//! let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n//! let fm = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n//! ```\n//!\n//! ## Enclose in struct\n//!\n//! `FMIndex` was designed to not forcibly own the BWT and auxiliary data structures.\n//! It can take a reference (`\u0026`), owned structs or any of the more complex pointer types.\n//!\n//! ```\n//! use bio::alphabets::dna;\n//! use bio::data_structures::bwt::{bwt, less, Less, Occ, BWT};\n//! use bio::data_structures::fmindex::{FMIndex, FMIndexable};\n//! use bio::data_structures::suffix_array::suffix_array;\n//! use bio::utils::TextSlice;\n//!\n//! pub struct Example {\n//!     fmindex: FMIndex\u003cBWT, Less, Occ\u003e,\n//! }\n//!\n//! impl Example {\n//!     pub fn new(text: TextSlice) -\u003e Self {\n//!         let alphabet = dna::n_alphabet();\n//!         let sa = suffix_array(text);\n//!         let bwt = bwt(text, \u0026sa);\n//!         let less = less(\u0026bwt, \u0026alphabet);\n//!         let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n//!         let fm = FMIndex::new(bwt, less, occ);\n//!         Example { fmindex: fm }\n//!     }\n//! }\n//! ```\n\nuse std::borrow::Borrow;\nuse std::iter::DoubleEndedIterator;\n\nuse crate::alphabets::dna;\nuse crate::data_structures::bwt::{Less, Occ, BWT};\nuse crate::data_structures::suffix_array::SuffixArray;\nuse std::mem::swap;\n\n/// A suffix array interval.\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\npub struct Interval {\n    pub lower: usize,\n    pub upper: usize,\n}\n\nimpl Interval {\n    pub fn occ\u003cSA: SuffixArray\u003e(\u0026self, sa: \u0026SA) -\u003e Vec\u003cusize\u003e {\n        (self.lower..self.upper)\n            .map(|pos| sa.get(pos).expect(\"Interval out of range of suffix array\"))\n            .collect()\n    }\n}\n\npub trait FMIndexable {\n    /// Get occurrence count of symbol a in BWT[..r+1].\n    fn occ(\u0026self, r: usize, a: u8) -\u003e usize;\n    /// Also known as\n    fn less(\u0026self, a: u8) -\u003e usize;\n    fn bwt(\u0026self) -\u003e \u0026BWT;\n\n    /// Perform backward search, yielding suffix array\n    /// interval denoting exact occurrences of the given pattern of length m in the text.\n    /// Complexity: O(m).\n    ///\n    /// # Arguments\n    ///\n    /// * `pattern` - the pattern to search\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets::dna;\n    /// use bio::data_structures::bwt::{bwt, less, Occ};\n    /// use bio::data_structures::fmindex::{FMIndex, FMIndexable};\n    /// use bio::data_structures::suffix_array::suffix_array;\n    ///\n    /// let text = b\"GCCTTAACATTATTACGCCTA$\";\n    /// let alphabet = dna::n_alphabet();\n    /// let sa = suffix_array(text);\n    /// let bwt = bwt(text, \u0026sa);\n    /// let less = less(\u0026bwt, \u0026alphabet);\n    /// let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n    /// let fm = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n    ///\n    /// let pattern = b\"TTA\";\n    /// let sai = fm.backward_search(pattern.iter());\n    ///\n    /// let positions = sai.occ(\u0026sa);\n    ///\n    /// assert_eq!(positions, [3, 12, 9]);\n    /// ```\n    fn backward_search\u003c'b, P: Iterator\u003cItem = \u0026'b u8\u003e + DoubleEndedIterator\u003e(\n        \u0026self,\n        pattern: P,\n    ) -\u003e Interval {\n        let (mut l, mut r) = (0, self.bwt().len() - 1);\n        for \u0026a in pattern.rev() {\n            let less = self.less(a);\n            l = less + if l \u003e 0 { self.occ(l - 1, a) } else { 0 };\n            r = less + self.occ(r, a) - 1;\n\n            // The symbol was not found if we end up with an empty interval.\n            // Terminate the LF-mapping process.\n            if l == r {\n                break;\n            }\n        }\n\n        Interval {\n            lower: l,\n            upper: r + 1,\n        }\n    }\n}\n\n/// The Fast Index in Minute space (FM-Index, Ferragina and Manzini, 2000) for finding suffix array\n/// intervals matching a given pattern.\n#[derive(Serialize, Deserialize)]\npub struct FMIndex\u003cDBWT: Borrow\u003cBWT\u003e, DLess: Borrow\u003cLess\u003e, DOcc: Borrow\u003cOcc\u003e\u003e {\n    bwt: DBWT,\n    less: DLess,\n    occ: DOcc,\n}\n\nimpl\u003cDBWT: Borrow\u003cBWT\u003e, DLess: Borrow\u003cLess\u003e, DOcc: Borrow\u003cOcc\u003e\u003e FMIndexable\n    for FMIndex\u003cDBWT, DLess, DOcc\u003e\n{\n    fn occ(\u0026self, r: usize, a: u8) -\u003e usize {\n        self.occ.borrow().get(self.bwt.borrow(), r, a)\n    }\n    fn less(\u0026self, a: u8) -\u003e usize {\n        self.less.borrow()[a as usize]\n    }\n    /// Provide a reference to the underlying BWT.\n    fn bwt(\u0026self) -\u003e \u0026BWT {\n        self.bwt.borrow()\n    }\n}\n\nimpl\u003cDBWT: Borrow\u003cBWT\u003e, DLess: Borrow\u003cLess\u003e, DOcc: Borrow\u003cOcc\u003e\u003e FMIndex\u003cDBWT, DLess, DOcc\u003e {\n    /// Construct a new instance of the FM index.\n    ///\n    /// # Arguments\n    ///\n    /// * `bwt` - the BWT\n    /// * `less` - the less array of the BWT\n    /// * `occ` - the occurence array of the BWT\n    pub fn new(bwt: DBWT, less: DLess, occ: DOcc) -\u003e Self {\n        FMIndex { bwt, less, occ }\n    }\n}\n\n/// A bi-interval on suffix array of the forward and reverse strand of a DNA text.\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\npub struct BiInterval {\n    lower: usize,\n    lower_rev: usize,\n    size: usize,\n    match_size: usize,\n}\n\nimpl BiInterval {\n    pub fn forward(\u0026self) -\u003e Interval {\n        Interval {\n            upper: self.lower + self.size,\n            lower: self.lower,\n        }\n    }\n    pub fn revcomp(\u0026self) -\u003e Interval {\n        Interval {\n            upper: self.lower_rev + self.size,\n            lower: self.lower_rev,\n        }\n    }\n\n    fn swapped(\u0026self) -\u003e BiInterval {\n        BiInterval {\n            lower: self.lower_rev,\n            lower_rev: self.lower,\n            size: self.size,\n            match_size: self.match_size,\n        }\n    }\n}\n\n/// The FMD-Index for linear time search of supermaximal exact matches on forward and reverse\n/// strand of DNA texts (Li, 2012).\n#[derive(Serialize, Deserialize)]\npub struct FMDIndex\u003cDBWT: Borrow\u003cBWT\u003e, DLess: Borrow\u003cLess\u003e, DOcc: Borrow\u003cOcc\u003e\u003e {\n    fmindex: FMIndex\u003cDBWT, DLess, DOcc\u003e,\n}\n\nimpl\u003cDBWT: Borrow\u003cBWT\u003e, DLess: Borrow\u003cLess\u003e, DOcc: Borrow\u003cOcc\u003e\u003e FMIndexable\n    for FMDIndex\u003cDBWT, DLess, DOcc\u003e\n{\n    fn occ(\u0026self, r: usize, a: u8) -\u003e usize {\n        self.fmindex.occ(r, a)\n    }\n\n    fn less(\u0026self, a: u8) -\u003e usize {\n        self.fmindex.less(a)\n    }\n\n    /// Provide a reference to the underlying BWT.\n    fn bwt(\u0026self) -\u003e \u0026BWT {\n        self.fmindex.bwt()\n    }\n}\n\nimpl\u003cDBWT: Borrow\u003cBWT\u003e, DLess: Borrow\u003cLess\u003e, DOcc: Borrow\u003cOcc\u003e\u003e From\u003cFMIndex\u003cDBWT, DLess, DOcc\u003e\u003e\n    for FMDIndex\u003cDBWT, DLess, DOcc\u003e\n{\n    /// Construct a new instance of the FMD index (see Heng Li (2012) Bioinformatics).\n    /// This expects a BWT that was created from a text over the DNA alphabet with N\n    /// (`alphabets::dna::n_alphabet()`) consisting of the\n    /// concatenation with its reverse complement, separated by the sentinel symbol `$`.\n    /// I.e., let T be the original text and R be its reverse complement.\n    /// Then, the expected text is T$R$. Further, multiple concatenated texts are allowed, e.g.\n    /// T1$R1$T2$R2$T3$R3$.\n    fn from(fmindex: FMIndex\u003cDBWT, DLess, DOcc\u003e) -\u003e FMDIndex\u003cDBWT, DLess, DOcc\u003e {\n        let mut alphabet = dna::n_alphabet();\n        alphabet.insert(b'$');\n        assert!(\n            alphabet.is_word(fmindex.bwt()),\n            \"Expecting BWT over the DNA alphabet (including N) with the sentinel $.\"\n        );\n\n        FMDIndex { fmindex }\n    }\n}\n\nimpl\u003cDBWT: Borrow\u003cBWT\u003e, DLess: Borrow\u003cLess\u003e, DOcc: Borrow\u003cOcc\u003e\u003e FMDIndex\u003cDBWT, DLess, DOcc\u003e {\n    /// Find supermaximal exact matches (of length \u003e= l) of given pattern that overlap position i in the pattern.\n    /// Complexity O(m) with pattern of length m.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets::dna;\n    /// use bio::data_structures::bwt::{bwt, less, Occ};\n    /// use bio::data_structures::fmindex::{FMDIndex, FMIndex};\n    /// use bio::data_structures::suffix_array::suffix_array;\n    ///\n    /// let text = b\"ATTC$GAAT$\";\n    /// let alphabet = dna::n_alphabet();\n    /// let sa = suffix_array(text);\n    /// let bwt = bwt(text, \u0026sa);\n    /// let less = less(\u0026bwt, \u0026alphabet);\n    /// let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n    /// let fm = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n    /// let fmdindex = FMDIndex::from(fm);\n    ///\n    /// let pattern = b\"ATT\";\n    /// let intervals = fmdindex.smems(pattern, 2, 0);\n    ///\n    /// let forward_positions = intervals[0].0.forward().occ(\u0026sa);\n    /// let revcomp_positions = intervals[0].0.revcomp().occ(\u0026sa);\n    /// let pattern_position = intervals[0].1;\n    /// let smem_len = intervals[0].2;\n    ///\n    /// assert_eq!(forward_positions, [0]);\n    /// assert_eq!(revcomp_positions, [6]);\n    /// assert_eq!(pattern_position, 0);\n    /// assert_eq!(smem_len, 3);\n    /// ```\n    pub fn smems(\u0026self, pattern: \u0026[u8], i: usize, l: usize) -\u003e Vec\u003c(BiInterval, usize, usize)\u003e {\n        let curr = \u0026mut Vec::new(); // pairs (biinterval, current match length)\n        let prev = \u0026mut Vec::new(); // \"\"\"\n        let mut matches = Vec::new(); // triples (biinterval, position on pattern, smem length)\n\n        let mut match_len = 0;\n        let mut interval = self.init_interval_with(pattern[i]);\n        if interval.size != 0 {\n            match_len += 1;\n        }\n\n        for \u0026a in pattern[i + 1..].iter() {\n            // forward extend interval\n            let forward_interval = self.forward_ext(\u0026interval, a);\n\n            // if size changed, add last interval to list\n            if interval.size != forward_interval.size {\n                curr.push((interval, match_len));\n            }\n            // if new interval size is zero, stop, as no further forward extension is possible\n            if forward_interval.size == 0 {\n                break;\n            }\n            interval = forward_interval;\n            match_len += 1;\n        }\n        // add the last non-zero interval\n        curr.push((interval, match_len));\n        // reverse intervals such that longest comes first\n        curr.reverse();\n\n        swap(curr, prev);\n        let mut j = pattern.len() as isize;\n\n        for k in (-1..i as isize).rev() {\n            let a = if k == -1 { b'$' } else { pattern[k as usize] };\n            curr.clear();\n            // size of the last confirmed interval\n            let mut last_size = -1;\n\n            for (interval, match_len) in prev.iter() {\n                // backward extend interval\n                let forward_interval = self.backward_ext(interval, a);\n\n                if (forward_interval.size == 0 || k == -1) \u0026\u0026\n                        // interval could not be extended further\n                        // if no interval has been extended this iteration,\n                        // interval is maximal and can be added to the matches\n                        curr.is_empty() \u0026\u0026 k \u003c j \u0026\u0026\n                        match_len \u003e= \u0026l\n                {\n                    j = k;\n                    matches.push((*interval, (k + 1) as usize, *match_len));\n                }\n                // add _interval to curr (will be further extended next iteration)\n                if forward_interval.size != 0 \u0026\u0026 forward_interval.size as isize != last_size {\n                    last_size = forward_interval.size as isize;\n                    curr.push((forward_interval, match_len + 1));\n                }\n            }\n            if curr.is_empty() {\n                break;\n            }\n            swap(curr, prev);\n        }\n\n        matches\n    }\n\n    /// Find all supermaximal exact matches (of length \u003e= l) of given pattern.\n    /// Complexity O(m^2) with pattern of length m.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets::dna;\n    /// use bio::data_structures::bwt::{bwt, less, Occ};\n    /// use bio::data_structures::fmindex::{FMDIndex, FMIndex};\n    /// use bio::data_structures::suffix_array::suffix_array;\n    ///\n    /// let text = b\"ATTCGGGG$CCCCGAAT$\";\n    /// let alphabet = dna::n_alphabet();\n    /// let sa = suffix_array(text);\n    /// let bwt = bwt(text, \u0026sa);\n    /// let less = less(\u0026bwt, \u0026alphabet);\n    /// let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n    /// let fm = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n    /// let fmdindex = FMDIndex::from(fm);\n    ///\n    /// let pattern = b\"ATTGGGG\";\n    /// let intervals = fmdindex.all_smems(pattern, 0);\n    /// assert_eq!(intervals.len(), 2);\n    ///\n    /// let solutions = vec![[0,14,0,3], [4,9,3,4]];\n    /// for (i, interval) in intervals.iter().enumerate() {\n    ///     let forward_positions = interval.0.forward().occ(\u0026sa);\n    ///     let revcomp_positions = interval.0.revcomp().occ(\u0026sa);\n    ///     let pattern_position = interval.1;\n    ///     let smem_len = interval.2;\n    ///     assert_eq!([forward_positions[0], revcomp_positions[0], pattern_position, smem_len], solutions[i]);\n    /// }\n    /// ```\n    pub fn all_smems(\u0026self, pattern: \u0026[u8], l: usize) -\u003e Vec\u003c(BiInterval, usize, usize)\u003e {\n        let mut smems = Vec::new();\n        let mut i0 = 0;\n        while i0 \u003c pattern.len() {\n            let mut curr_smems = self.smems(pattern, i0, l);\n            let mut next_i0 = i0 + 1; // this always works since:\n                                      // if we have a SMEM overlapping i0, it is at least 1bp long.\n                                      // If we don't have a smem, then we'll reiterate from i0+1\n            for (_, p, l) in curr_smems.iter() {\n                if p + l \u003e next_i0 {\n                    next_i0 = p + l;\n                }\n            }\n            i0 = next_i0;\n            smems.append(\u0026mut curr_smems);\n        }\n        smems\n    }\n\n    /// Initialize interval with given start character.\n    pub fn init_interval_with(\u0026self, a: u8) -\u003e BiInterval {\n        let comp_a = dna::complement(a);\n        let lower = self.fmindex.less(a);\n\n        BiInterval {\n            lower,\n            lower_rev: self.fmindex.less(comp_a),\n            size: self.fmindex.less(a + 1) - lower,\n            match_size: 1,\n        }\n    }\n\n    /// Initialize interval for empty pattern. The interval points at the whole suffix array.\n    pub fn init_interval(\u0026self) -\u003e BiInterval {\n        BiInterval {\n            lower: 0,\n            lower_rev: 0,\n            size: self.fmindex.bwt.borrow().len(),\n            match_size: 0,\n        }\n    }\n\n    /// Backward extension of given interval with given character.\n    pub fn backward_ext(\u0026self, interval: \u0026BiInterval, a: u8) -\u003e BiInterval {\n        let mut s = 0;\n        let mut o = 0;\n        let mut l = interval.lower_rev;\n        // Interval [l(c(aP)), u(c(aP))] is a subinterval of [l(c(P)), u(c(P))] for each a,\n        // starting with the lexicographically smallest ($),\n        // then c(T) = A, c(G) = C, c(C) = G, N, c(A) = T, ...\n        // Hence, we calculate lower revcomp bounds by iterating over\n        // symbols and updating from previous one.\n        for \u0026b in b\"$TGCNAtgcna\".iter() {\n            l += s;\n            o = if interval.lower == 0 {\n                0\n            } else {\n                self.fmindex.occ(interval.lower - 1, b)\n            };\n            // calculate size\n            s = self.fmindex.occ(interval.lower + interval.size - 1, b) - o;\n            if b == a {\n                break;\n            }\n        }\n        // calculate lower bound\n        let k = self.fmindex.less(a) + o;\n\n        BiInterval {\n            lower: k,\n            lower_rev: l,\n            size: s,\n            match_size: interval.match_size + 1,\n        }\n    }\n\n    pub fn forward_ext(\u0026self, interval: \u0026BiInterval, a: u8) -\u003e BiInterval {\n        let comp_a = dna::complement(a);\n\n        self.backward_ext(\u0026interval.swapped(), comp_a).swapped()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::alphabets::dna;\n    use crate::data_structures::bwt::{bwt, less, Occ};\n    use crate::data_structures::suffix_array::suffix_array;\n\n    #[test]\n    fn test_fmindex() {\n        let text = b\"GCCTTAACATTATTACGCCTA$\";\n        let alphabet = dna::n_alphabet();\n        let sa = suffix_array(text);\n        let bwt = bwt(text, \u0026sa);\n        let less = less(\u0026bwt, \u0026alphabet);\n        let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n        let fm = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n\n        let pattern = b\"TTA\";\n        let sai = fm.backward_search(pattern.iter());\n\n        let positions = sai.occ(\u0026sa);\n\n        assert_eq!(positions, [3, 12, 9]);\n    }\n\n    #[test]\n    fn test_fmindex_not_found() {\n        let text = b\"GCCTTAACATTATTACGCCTA$\";\n        let alphabet = dna::n_alphabet();\n        let sa = suffix_array(text);\n        let bwt = bwt(text, \u0026sa);\n        let less = less(\u0026bwt, \u0026alphabet);\n        let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n        let fm = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n\n        let pattern = b\"TTT\";\n        let sai = fm.backward_search(pattern.iter());\n\n        let positions = sai.occ(\u0026sa);\n\n        assert_eq!(positions, []);\n    }\n\n    #[test]\n    fn test_smems() {\n        let orig_text = b\"GCCTTAACAT\";\n        let revcomp_text = dna::revcomp(orig_text);\n        let text_builder: Vec\u003c\u0026[u8]\u003e = vec![orig_text, b\"$\", \u0026revcomp_text[..], b\"$\"];\n        let text = text_builder.concat();\n\n        let alphabet = dna::n_alphabet();\n        let sa = suffix_array(\u0026text);\n        let bwt = bwt(\u0026text, \u0026sa);\n        let less = less(\u0026bwt, \u0026alphabet);\n        let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n\n        let fmindex = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n        let fmdindex = FMDIndex::from(fmindex);\n        {\n            let pattern = b\"AA\";\n            let intervals = fmdindex.smems(pattern, 0, 0);\n            let forward = intervals[0].0.forward();\n            let revcomp = intervals[0].0.revcomp();\n            let pattern_position = intervals[0].1;\n            let smem_len = intervals[0].2;\n            assert_eq!(forward.occ(\u0026sa), [5, 16]);\n            assert_eq!(revcomp.occ(\u0026sa), [3, 14]);\n            assert_eq!(pattern_position, 0);\n            assert_eq!(smem_len, 2);\n        }\n        {\n            let pattern = b\"CTTAA\";\n            let intervals = fmdindex.smems(pattern, 1, 0);\n            assert_eq!(intervals[0].0.forward().occ(\u0026sa), [2]);\n            assert_eq!(intervals[0].0.revcomp().occ(\u0026sa), [14]);\n            assert_eq!(intervals[0].1, 0);\n            assert_eq!(intervals[0].2, 5);\n            assert_eq!(intervals[0].0.match_size, 5);\n        }\n        {\n            let pattern = b\"CTTAA\";\n            let intervals = fmdindex.smems(pattern, 1, 7);\n            assert!(intervals.is_empty());\n        }\n    }\n\n    #[test]\n    fn test_all_smems() {\n        let text = b\"ATTCGGGG$CCCCGAAT$\";\n        let alphabet = dna::n_alphabet();\n        let sa = suffix_array(text);\n        let bwt = bwt(text, \u0026sa);\n        let less = less(\u0026bwt, \u0026alphabet);\n        let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n        let fm = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n        let fmdindex = FMDIndex::from(fm);\n\n        {\n            let pattern = b\"ATTGGGG\";\n            let intervals = fmdindex.all_smems(pattern, 0);\n            assert_eq!(intervals.len(), 2);\n            let solutions = vec![[0, 14, 0, 3], [4, 9, 3, 4]];\n            for (i, interval) in intervals.iter().enumerate() {\n                let forward_positions = interval.0.forward().occ(\u0026sa);\n                let revcomp_positions = interval.0.revcomp().occ(\u0026sa);\n                let pattern_position = interval.1;\n                let smem_len = interval.2;\n                assert_eq!(\n                    [\n                        forward_positions[0],\n                        revcomp_positions[0],\n                        pattern_position,\n                        smem_len\n                    ],\n                    solutions[i]\n                );\n            }\n        }\n    }\n\n    #[test]\n    fn test_init_interval() {\n        let text = b\"ACGT$TGCA$\";\n\n        let alphabet = dna::n_alphabet();\n        let sa = suffix_array(text);\n        let bwt = bwt(text, \u0026sa);\n        let less = less(\u0026bwt, \u0026alphabet);\n        let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n\n        let fmindex = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n        let fmdindex = FMDIndex::from(fmindex);\n        let pattern = b\"T\";\n        let interval = fmdindex.init_interval_with(pattern[0]);\n\n        assert_eq!(interval.forward().occ(\u0026sa), [3, 5]);\n        assert_eq!(interval.revcomp().occ(\u0026sa), [8, 0]);\n\n        let empty = fmdindex.init_interval();\n        let extended = fmdindex.backward_ext(\u0026empty, pattern[0]);\n        assert_eq!(extended, interval);\n        let extended = fmdindex.forward_ext(\u0026empty, pattern[0]);\n        assert_eq!(extended, interval);\n    }\n\n    #[test]\n    fn test_issue39() {\n        let reads = b\"GGCGTGGTGGCTTATGCCTGTAATCCCAGCACTTTGGGAGGTCGAAGTGGGCGG$CCGC\\\n                       CCACTTCGACCTCCCAAAGTGCTGGGATTACAGGCATAAGCCACCACGCC$CGAAGTGG\\\n                       GCGGATCACTTGAGGTCAGGAGTTGGAGACTAGCCTGGCCAACACGATGAAACCCCGTC\\\n                       TCTAATA$TATTAGAGACGGGGTTTCATCGTGTTGGCCAGGCTAGTCTCCAACTCCTGA\\\n                       CCTCAAGTGATCCGCCCACTTCG$AGCTCGAAAAATGTTTGCTTATTTTGGTAAAATTA\\\n                       TTCATTGACTATGCTCAGAAATCAAGCAAACTGTCCATATTTCATTTTTTG$CAAAAAA\\\n                       TGAAATATGGACAGTTTGCTTGATTTCTGAGCATAGTCAATGAATAATTTTACCAAAAT\\\n                       AAGCAAACATTTTTCGAGCT$AGCTCGAAAAATGTTTGCTTATTTTGGTAAAATTATTC\\\n                       ATTGACTATGCTCAGAAATCAAGCAAACTGTCCATATTTCATTTTTTGAAATTACATAT\\\n                       $ATATGTAATTTCAAAAAATGAAATATGGACAGTTTGCTTGATTTCTGAGCATAGTCAA\\\n                       TGAATAATTTTACCAAAATAAGCAAACATTTTTCGAGCT$TAAAATTTCCTCTGACAGT\\\n                       GTAAAAGAGATCTTCATACAAAAATCAGAATTTATATAGTCTCTTTCCAAAAGACCATA\\\n                       AAACCAATCAGTTAATAGTTGAT$ATCAACTATTAACTGATTGGTTTTATGGTCTTTTG\\\n                       GAAAGAGACTATATAAATTCTGATTTTTGTATGAAGATCTCTTTTACACTGTCAGAGGA\\\n                       AATTTTA$CACCTATCTACCCTGAATCTAAGTGCTAACAGGAAAGGATGCCAGATTGCA\\\n                       TGCCTGCTGATAAAGCCACAGTTTGGACTGTCACTCAATCACCATCGTTC$GAACGATG\\\n                       GTGATTGAGTGACAGTCCAAACTGTGGCTTTATCAGCAGGCATGCAATCTGGCATCCTT\\\n                       TCCTGTTAGCACTTAGATTCAGGGTAGATAGGTG$CATCGTTCCTCCTGTGACTCAGTA\\\n                       TAACAAGATTGGGAGAATACTCTACAGTTCCTGATTCCCCCACAG$CTGTGGGGGAATC\\\n                       AGGAACTGTAGAGTATTCTCCCAATCTTGTTATACTGAGTCACAGGAGGAACGATG$TG\\\n                       TAAATTCTGAGAAAAATTTGCAGGTCTTTCTTCAGGAGCATGTAATCTCTTGCTCTCTT\\\n                       TGTTATCTATCTATAGTACTGTAGGTTATCTGGAGTTGCT$AGCAACTCCAGATAACCT\\\n                       ACAGTACTATAGATAGATAACAAAGAGAGCAAGAGATTACATGCTCCTGAAGAAAGACC\\\n                       TGCAAATTTTTCTCAGAATTTACA$CACTTCTCCTTGTCTTTACAGACTGGTTTTGCAC\\\n                       TGGGAAATCCTTTCACCAGTCAGCCCAGTTAGAGATTCTG$CAGAATCTCTAACTGGGC\\\n                       TGACTGGTGAAAGGATTTCCCAGTGCAAAACCAGTCTGTAAAGACAAGGAGAAGTG$AA\\\n                       TGGAGGTATATAAATTATCTGGCAAAGTGACATATCCTGACACATTCTCCAGGATAGAT\\\n                       CAAATGTTAGGTCACAAAGAGAGTCTTAACAAAATT$AATTTTGTTAAGACTCTCTTTG\\\n                       TGACCTAACATTTGATCTATCCTGGAGAATGTGTCAGGATATGTCACTTTGCCAGATAA\\\n                       TTTATATACCTCCATT$TTAATTTTGTTAAGACTCTCTTTGTGACCTAACATTTGATCT\\\n                       ATCCTGGAGAATGTGTCAGGATATGTCACTTTGCCAGATAATTTATATACCTCCATTTT\\\n                       $AAAATGGAGGTATATAAATTATCTGGCAAAGTGACATATCCTGACACATTCTCCAGGA\\\n                       TAGATCAAATGTTAGGTCACAAAGAGAGTCTTAACAAAATTAA$TTCTTCTTTGACTCA\\\n                       TTGGTTGTTCAATAGTATGTTGTTTAATTTCCATATATTTGTAAATGTTTCCGTTTTCC\\\n                       TTCTACTATTGAATTTTTGCTTCATC$GATGAAGCAAAAATTCAATAGTAGAAGGAAAA\\\n                       CGGAAACATTTACAAATATATGGAAATTAAACAACATACTATTGAACAACCAATGAGTC\\\n                       AAAGAAGAA$AGGAAAACGGAAACATTTACAAATATATGGAAATTAAACAACATACTAT\\\n                       TGAACAACCAATGAGTCAAAGAAGAAATCAAAAAGAATATTAGAAAAC$GTTTTCTAAT\\\n                       ATTCTTTTTGATTTCTTCTTTGACTCATTGGTTGTTCAATAGTATGTTGTTTAATTTCC\\\n                       ATATATTTGTAAATGTTTCCGTTTTCCT$TTAGAAAACAAGCTGACAAAAAAATAAAAA\\\n                       AACACAACATAGCAAAACTTAGAAATGCAGCAAAGGCAGTACTAAAGAGGGAAATTTAT\\\n                       AGCAATAAATGC$GCATTTATTGCTATAAATTTCCCTCTTTAGTACTGCCTTTGCTGCA\\\n                       TTTCTAAGTTTTGCTATGTTGTGTTTTTTTATTTTTTTGTCAGCTTGTTTTCTAA$TTT\\\n                       ATTGCTATAAATTTCCCTCTTTAGTACTGCCTTTGCTGCATTTCTAAGTTTTGCTATGT\\\n                       TGTGTTTTTTTATTTTTTTGTCAGCTTGTTTTCTA$TAGAAAACAAGCTGACAAAAAAA\\\n                       TAAAAAAACACAACATAGCAAAACTTAGAAATGCAGCAAAGGCAGTACTAAAGAGGGAA\\\n                       ATTTATAGCAATAAA$TCTTTCTTCTTTTTTAAGGTAGGCATTTATTGCTATAAATTTC\\\n                       CCTCTTTAGTACTGCCTTTG$CAAAGGCAGTACTAAAGAGGGAAATTTATAGCAATAAA\\\n                       TGCCTACCTTAAAAAAGAAGAAAGA$\";\n\n        let alphabet = dna::n_alphabet();\n        let sa = suffix_array(reads);\n        let bwt = bwt(reads, \u0026sa);\n        let less = less(\u0026bwt, \u0026alphabet);\n        let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n\n        let fmindex = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n        let fmdindex = FMDIndex::from(fmindex);\n\n        let read = b\"GGCGTGGTGGCTTATGCCTGTAATCCCAGCACTTTGGGAGGTCGAAGTGGGCGG\";\n        let read_pos = 0;\n\n        for i in 0..read.len() {\n            println!(\"i {}\", i);\n            let intervals = fmdindex.smems(read, i, 0);\n            println!(\"{:?}\", intervals);\n            let matches = intervals\n                .iter()\n                .flat_map(|interval| interval.0.forward().occ(\u0026sa))\n                .collect::\u003cVec\u003cusize\u003e\u003e();\n            assert_eq!(matches, vec![read_pos]);\n        }\n    }\n}\n","traces":[{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[4920463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[4920500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[4920531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":399,"address":[4923657,4923589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":485,"address":[5731408,5731413],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":486,"address":[9503415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[9503430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[9503440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":489,"address":[9503467,9503549],"length":1,"stats":{"Line":2},"fn_name":null},{"line":490,"address":[9503614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":491,"address":[9503717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":492,"address":[9503857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":494,"address":[9503864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":495,"address":[9503879,9503969],"length":1,"stats":{"Line":2},"fn_name":null},{"line":497,"address":[9504042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":499,"address":[9504215,9504057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[5731440,5731445],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":504,"address":[9504375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":505,"address":[9504390],"length":1,"stats":{"Line":1},"fn_name":null},{"line":506,"address":[9504400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":507,"address":[9504427,9504509],"length":1,"stats":{"Line":2},"fn_name":null},{"line":508,"address":[9504574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[9504677],"length":1,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[9504817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[9504824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[9504929,9504839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":515,"address":[9505002],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[9505017,9505175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[5731472,5731477],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":522,"address":[9505335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":523,"address":[9505350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[9505380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":525,"address":[9505606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":527,"address":[9505733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":528,"address":[9505843,9505740],"length":1,"stats":{"Line":2},"fn_name":null},{"line":529,"address":[9506082,9505887],"length":1,"stats":{"Line":2},"fn_name":null},{"line":530,"address":[9506089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":531,"address":[9506210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[9506368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":534,"address":[9506375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[9506470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[9506511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[9506651,9506521],"length":1,"stats":{"Line":2},"fn_name":null},{"line":539,"address":[9506667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":540,"address":[9506773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":541,"address":[9506830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":542,"address":[9506911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":543,"address":[9507174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":544,"address":[9507414,9507616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":545,"address":[9507506,9507699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":548,"address":[9507751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":549,"address":[9507798],"length":1,"stats":{"Line":1},"fn_name":null},{"line":550,"address":[9507935,9507805],"length":1,"stats":{"Line":2},"fn_name":null},{"line":551,"address":[9508215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[9508720,9508555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":553,"address":[9508676,9508777,9508903],"length":1,"stats":{"Line":2},"fn_name":null},{"line":554,"address":[9508960,9508859,9509067],"length":1,"stats":{"Line":2},"fn_name":null},{"line":557,"address":[9509119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":558,"address":[9509167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":559,"address":[9509262,9509182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":564,"address":[5731509,5731504],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":565,"address":[9509463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":566,"address":[9509478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":567,"address":[9509491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":568,"address":[9509615,9509518],"length":1,"stats":{"Line":2},"fn_name":null},{"line":569,"address":[9509680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":570,"address":[9509801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":571,"address":[9509959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":572,"address":[9509966],"length":1,"stats":{"Line":1},"fn_name":null},{"line":575,"address":[9510061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":576,"address":[9510102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[9510486,9510117],"length":1,"stats":{"Line":1},"fn_name":null},{"line":578,"address":[9510299],"length":1,"stats":{"Line":1},"fn_name":null},{"line":579,"address":[9510873,9510545,9510683,9511601],"length":1,"stats":{"Line":4},"fn_name":null},{"line":580,"address":[9510947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[9511032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":582,"address":[9511158],"length":1,"stats":{"Line":1},"fn_name":null},{"line":583,"address":[9511175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":584,"address":[9511535,9511425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":586,"address":[9511192],"length":1,"stats":{"Line":1},"fn_name":null},{"line":587,"address":[9511243,9511347],"length":1,"stats":{"Line":2},"fn_name":null},{"line":591,"address":[9511382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":598,"address":[5731536,5731541],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":599,"address":[9511751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":601,"address":[9511766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":602,"address":[9511779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":603,"address":[9511903,9511806],"length":1,"stats":{"Line":2},"fn_name":null},{"line":604,"address":[9511968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":605,"address":[9512089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":607,"address":[9512247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":608,"address":[9512254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":609,"address":[9512349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":610,"address":[9512364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":612,"address":[9512402],"length":1,"stats":{"Line":1},"fn_name":null},{"line":613,"address":[9512710],"length":1,"stats":{"Line":1},"fn_name":null},{"line":615,"address":[9513021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":616,"address":[9513028],"length":1,"stats":{"Line":1},"fn_name":null},{"line":617,"address":[9513211,9513074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":618,"address":[9513163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":619,"address":[9513380,9513266],"length":1,"stats":{"Line":1},"fn_name":null},{"line":623,"address":[5731573,5731568],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":624,"address":[9513543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":674,"address":[9513558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":675,"address":[9513571],"length":1,"stats":{"Line":1},"fn_name":null},{"line":676,"address":[9513695,9513598],"length":1,"stats":{"Line":2},"fn_name":null},{"line":677,"address":[9513760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":678,"address":[9513881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":680,"address":[9514039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":681,"address":[9514046],"length":1,"stats":{"Line":1},"fn_name":null},{"line":683,"address":[9514141],"length":1,"stats":{"Line":1},"fn_name":null},{"line":684,"address":[9514156],"length":1,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[9514390,9514168,9515284],"length":1,"stats":{"Line":3},"fn_name":null},{"line":687,"address":[9514430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":688,"address":[9514574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":689,"address":[9514630,9514791],"length":1,"stats":{"Line":2},"fn_name":null},{"line":690,"address":[9514818,9514900],"length":1,"stats":{"Line":2},"fn_name":null},{"line":692,"address":[5731642,5731600],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":694,"address":[9514951,9515129],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":219,"coverable":231},{"path":["/","home","todd","rust-bio","src","data_structures","interpolation_table.rs"],"content":"// Copyright 2018 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Fast lookup table for arbitrary floating point functions.\n//! # Examples\n//! ## Easy:\n//! ```\n//! use bio::data_structures::interpolation_table::*;\n//!\n//! let table = InterpolationTable::new(0.0, 10.0, 5, |x| x.powf(2.0));\n//! assert_eq!(table.get(3.0), 9.0);\n//! assert_eq!(table.get(5.0), 25.0);\n//! ```\n//! ## More complicated:\n//! ```\n//! extern crate approx;\n//! fn main() {\n//!     use bio::data_structures::interpolation_table::*;\n//!     use approx::assert_relative_eq;\n//!\n//!     let table = InterpolationTable::new(0.0, 10.0, 5, |x| x.ln_1p());\n//!     for \u0026x in \u0026[0.02, 0.04, 0.45678686, 0.23875, 1.45345e-6] {\n//!         assert_relative_eq!(table.get(x), x.ln_1p(), epsilon = 0.00001);\n//!     }\n//! }\n\n#[inline]\npub fn interpolate(a: f64, b: f64, fraction: f64) -\u003e f64 {\n    a * (1.0 - fraction) + b * fraction\n}\n\n/// Fast lookup table for arbitrary floating point functions.\n/// This can be used to e.g., provide fast lookups of distribution values.\n/// Input values are sampled with a given precision and results are stored in a vector.\n/// During lookup, infimum and supremum of a given value are calculated and the result is\n/// interpolated.\npub struct InterpolationTable\u003cF: Fn(f64) -\u003e f64\u003e {\n    inner: Vec\u003cf64\u003e,\n    func: F,\n    offset: usize,\n    min_x: f64,\n    max_x: f64,\n    shift: f64,\n}\n\nimpl\u003cF: Fn(f64) -\u003e f64\u003e InterpolationTable\u003cF\u003e {\n    /// Create a new `InterpolationTable`.\n    ///\n    /// # Arguments\n    ///\n    /// * `min_x` - minimum sample value\n    /// * `max_x` - maximum sample value\n    /// * `frac_digits` - number of fraction digits to store in sample\n    /// * `func` - Function to emulate.\n    ///\n    /// If given value is outside of min_x and max_x, the lookup falls back to applying the\n    /// function itself.\n    /// The table size grows with the number of fraction digits.\n    /// Space Complexity: O(m * 10^n), where `m = max_x - min_x` and `n = frac_digits`\n    pub fn new(min_x: f64, max_x: f64, frac_digits: i32, func: F) -\u003e Self {\n        let shift = 10.0_f64.powi(frac_digits);\n        let offset = (min_x * shift) as usize;\n        let mut table = InterpolationTable {\n            inner: Vec::new(),\n            func,\n            min_x,\n            max_x,\n            shift,\n            offset,\n        };\n\n        let mut i = table.index(min_x);\n        while i \u003c table.index(max_x) {\n            let x = i as f64 / shift;\n            table.inner.push((table.func)(x));\n            i += 1;\n        }\n\n        table\n    }\n\n    /// Return lower bound index for given f64.\n    #[inline]\n    fn index(\u0026self, x: f64) -\u003e usize {\n        (x * self.shift) as usize - self.offset\n    }\n\n    /// Lookup given value in table, and interpolate the result between the sampled values if\n    /// necessary. This provides an approximation that is better the more fraction digits are\n    /// used to generate this table.\n    /// Time Complexity for lookup: O(1) if `min_x \u003c= x \u003c max_x` and O(func(x)) otherwise.\n    pub fn get(\u0026self, x: f64) -\u003e f64 {\n        if x \u003c self.min_x || x \u003e= self.max_x {\n            (self.func)(x)\n        } else {\n            let i = self.index(x);\n            // interpolate\n            let fraction = (x * self.shift - i as f64) / self.shift;\n            interpolate(self.inner[i], self.inner[i + 1], fraction)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_interpolation_table() {\n        let table = InterpolationTable::new(0.0, 10.0, 5, |x| x.ln_1p());\n\n        for \u0026x in \u0026[0.02, 0.04, 0.45678686, 0.23875, 1.45345e-6] {\n            assert_relative_eq!(table.get(x), x.ln_1p(), epsilon = 0.00001);\n        }\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[9178005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[9464706,9464016],"length":1,"stats":{"Line":1},"fn_name":"new\u003cclosure-0\u003e"},{"line":63,"address":[9464081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[9464139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[9464238],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[4317824,4319236],"length":1,"stats":{"Line":3},"fn_name":"test_interpolation_table"},{"line":112,"address":[4317838],"length":1,"stats":{"Line":3},"fn_name":null},{"line":114,"address":[4318066,4317977,4318408,4317867],"length":1,"stats":{"Line":4},"fn_name":null},{"line":115,"address":[4318120,4318413],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":22,"coverable":24},{"path":["/","home","todd","rust-bio","src","data_structures","interval_tree","array_backed_interval_tree.rs"],"content":"//! Interval tree, a data structure for efficiently storing and searching intervals.\n//!\n//! This implementation is based on the sorted array version as described/given in\n//! https://github.com/lh3/cgranges / https://github.com/lh3/cgranges/blob/master/cpp/IITree.h\n//!\n//! It uses the same conventions as `crate::data_structures::interval_tree::IntervalTree`.\n//! Note that if you do not use the `ArrayBackedIntervalTree::from_iter` constructor, you have to call `index(\u0026mut self)`\n//! first before `find()`-ing overlaps.\n//!\n//! # Example\n//! ```\n//! use bio::data_structures::interval_tree::ArrayBackedIntervalTree;\n//! use bio::utils::Interval;\n//! use std::iter::FromIterator;\n//!\n//! let mut tree = ArrayBackedIntervalTree::new();\n//! tree.insert(12..34, 0);\n//! tree.insert(0..23, 1);\n//! tree.insert(34..56, 2);\n//! // since we did at least one manual insert, we have to index the tree\n//! tree.index();\n//! let i1 = \u0026tree.find(22..25)[0];\n//! assert_eq!(i1.interval().start, 0);\n//! assert_eq!(i1.interval().end, 23);\n//! assert_eq!(i1.data(), \u00261u32);\n//!\n//! let tree =\n//!     ArrayBackedIntervalTree::from_iter(vec![(12..34, 0), (0..23, 1), (34..56, 2)].into_iter());\n//! // no call to `index` needed here, since that happens in `from_iter` already\n//! let i2 = \u0026tree.find(22..25)[1];\n//! assert_eq!(i2.interval().start, 12);\n//! assert_eq!(i2.interval().end, 34);\n//! assert_eq!(i2.data(), \u00260u32);\n//! ```\n\nuse crate::utils::Interval;\nuse std::cmp::min;\nuse std::iter::FromIterator;\n\n/// A `find` query on the interval tree does not directly return references to the intervals in the\n/// tree but wraps the fields `interval` and `data` in an `Entry`.\n#[derive(PartialEq, Eq, Debug, Clone)]\nstruct InternalEntry\u003cN: Ord + Clone + Copy, D\u003e {\n    data: D,\n    interval: Interval\u003cN\u003e,\n    max: N,\n}\n\n/// A `find` query on the interval tree does not directly return references to the nodes in the tree, but\n/// wraps the fields `interval` and `data` in an `Entry`.\n#[derive(PartialEq, Eq, Debug, Clone)]\npub struct Entry\u003c'a, N: Ord + Clone, D\u003e {\n    data: \u0026'a D,\n    interval: \u0026'a Interval\u003cN\u003e,\n}\n\nimpl\u003c'a, N: Ord + Clone + 'a, D: 'a\u003e Entry\u003c'a, N, D\u003e {\n    /// Get a reference to the data for this entry\n    pub fn data(\u0026self) -\u003e \u0026'a D {\n        self.data\n    }\n\n    /// Get a reference to the interval for this entry\n    pub fn interval(\u0026self) -\u003e \u0026'a Interval\u003cN\u003e {\n        self.interval\n    }\n}\n\nimpl\u003cN: Ord + Clone + Copy, D\u003e Default for ArrayBackedIntervalTree\u003cN, D\u003e {\n    fn default() -\u003e Self {\n        ArrayBackedIntervalTree {\n            entries: vec![],\n            max_level: 0,\n            indexed: false,\n        }\n    }\n}\n\npub struct ArrayBackedIntervalTree\u003cN: Ord + Clone + Copy, D\u003e {\n    entries: Vec\u003cInternalEntry\u003cN, D\u003e\u003e,\n    max_level: usize,\n    indexed: bool,\n}\n\nimpl\u003cN, D, V\u003e FromIterator\u003c(V, D)\u003e for ArrayBackedIntervalTree\u003cN, D\u003e\nwhere\n    V: Into\u003cInterval\u003cN\u003e\u003e,\n    N: Ord + Clone + Copy,\n    D: Clone,\n{\n    fn from_iter\u003cT: IntoIterator\u003cItem = (V, D)\u003e\u003e(iter: T) -\u003e Self {\n        let mut tree = Self::new();\n        iter.into_iter()\n            .for_each(|(interval, data)| tree.insert(interval, data));\n        tree.index();\n        tree\n    }\n}\n\nimpl\u003cN: Ord + Clone + Copy, D: Clone\u003e ArrayBackedIntervalTree\u003cN, D\u003e {\n    pub fn new() -\u003e Self {\n        Default::default()\n    }\n\n    pub fn insert\u003cI: Into\u003cInterval\u003cN\u003e\u003e\u003e(\u0026mut self, interval: I, data: D) {\n        let interval = interval.into();\n        let max = interval.end;\n        self.entries.push(InternalEntry {\n            interval,\n            data,\n            max,\n        });\n        self.indexed = false;\n    }\n\n    pub fn index(\u0026mut self) {\n        if !self.indexed {\n            self.entries.sort_by_key(|e| e.interval.start);\n            self.index_core();\n            self.indexed = true;\n        }\n    }\n\n    fn index_core(\u0026mut self) {\n        let a = \u0026mut self.entries;\n        if a.is_empty() {\n            return;\n        }\n\n        let n = a.len();\n        let mut last_i = 0;\n        let mut last_value = a[0].max;\n        (0..n).step_by(2).for_each(|i| {\n            last_i = i;\n            a[i].max = a[i].interval.end;\n            last_value = a[i].max;\n        });\n        let mut k = 1;\n        while (1 \u003c\u003c k) \u003c n {\n            // process internal nodes in the bottom-up order\n            let x = 1 \u003c\u003c (k - 1);\n            let i0 = (x \u003c\u003c 1) - 1; // i0 is the first node\n            let step = x \u003c\u003c 2;\n            for i in (i0..n).step_by(step) {\n                // traverse all nodes at level k\n                let end_left = a[i - x].max; // max value of the left child\n                let end_right = if i + x \u003c n { a[i + x].max } else { last_value }; // max value of the right child\n                let end = max3(a[i].interval.end, end_left, end_right);\n                a[i].max = end;\n            }\n            last_i = if (last_i \u003e\u003e k \u0026 1) \u003e 0 {\n                last_i - x\n            } else {\n                last_i + x\n            };\n            if last_i \u003c n \u0026\u0026 a[last_i].max \u003e last_value {\n                last_value = a[last_i].max\n            }\n            k += 1;\n        }\n        self.max_level = k - 1;\n    }\n\n    /// Find overlapping intervals in the index.\n    /// Returns a vector of entries, consisting of the interval and its associated data.\n    ///\n    /// # Arguments\n    ///\n    /// * `interval` - The interval for which overlaps are to be found in the index. Can also be a `Range`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if this `IITree` instance has not been indexed yet.\n    pub fn find\u003cI: Into\u003cInterval\u003cN\u003e\u003e\u003e(\u0026self, interval: I) -\u003e Vec\u003cEntry\u003cN, D\u003e\u003e {\n        let mut buf = Vec::with_capacity(512);\n        self.find_into(interval, \u0026mut buf);\n        buf\n    }\n\n    /// Find overlapping intervals in the index\n    ///\n    /// # Arguments\n    ///\n    /// * `interval` - The interval for which overlaps are to be found in the index. Can also be a `Range`.\n    /// * `results` - A reusable buffer vector for storing the results.\n    ///\n    /// # Panics\n    ///\n    /// Panics if this `IITree` instance has not been indexed yet.\n    pub fn find_into\u003c'b, 'a: 'b, I: Into\u003cInterval\u003cN\u003e\u003e\u003e(\n        \u0026'a self,\n        interval: I,\n        results: \u0026'b mut Vec\u003cEntry\u003c'a, N, D\u003e\u003e,\n    ) {\n        if !self.indexed {\n            panic!(\"This IITree has not been indexed yet. Call `index()` first.\")\n        }\n\n        let interval = interval.into();\n        let (start, end) = (interval.start, interval.end);\n        let n = self.entries.len() as usize;\n        let a = \u0026self.entries;\n        results.clear();\n        let mut stack = [StackCell::empty(); 64];\n        // push the root; this is a top down traversal\n        stack[0].k = self.max_level;\n        stack[0].x = (1 \u003c\u003c self.max_level) - 1;\n        stack[0].w = false;\n        let mut t = 1;\n        while t \u003e 0 {\n            t -= 1;\n            let StackCell { k, x, w } = stack[t];\n            if k \u003c= 3 {\n                // we are in a small subtree; traverse every node in this subtree\n                let i0 = x \u003e\u003e k \u003c\u003c k;\n                let i1 = min(i0 + (1 \u003c\u003c (k + 1)) - 1, n);\n                for (i, node) in a.iter().enumerate().take(i1).skip(i0) {\n                    if node.interval.start \u003e= end {\n                        break;\n                    }\n                    if start \u003c node.interval.end {\n                        // if overlap, append to `results`\n                        results.push(Entry {\n                            interval: \u0026self.entries[i].interval,\n                            data: \u0026self.entries[i].data,\n                        });\n                    }\n                }\n            } else if !w {\n                // if left child not processed\n                let y = x - (1 \u003c\u003c (k - 1)); // the left child of x; NB: y may be out of range (i.e. y\u003e=n)\n                stack[t].k = k;\n                stack[t].x = x;\n                stack[t].w = true; // re-add node x, but mark the left child having been processed\n                t += 1;\n                if y \u003e= n || a[y].max \u003e start {\n                    // push the left child if y is out of range or may overlap with the query\n                    stack[t].k = k - 1;\n                    stack[t].x = y;\n                    stack[t].w = false;\n                    t += 1;\n                }\n            } else if x \u003c n \u0026\u0026 a[x].interval.start \u003c end {\n                // need to push the right child\n                if start \u003c a[x].interval.end {\n                    results.push(Entry {\n                        interval: \u0026self.entries[x].interval,\n                        data: \u0026self.entries[x].data,\n                    });\n                }\n                stack[t].k = k - 1;\n                stack[t].x = x + (1 \u003c\u003c (k - 1));\n                stack[t].w = false;\n                t += 1;\n            }\n        }\n    }\n}\n\nfn max3\u003cT: Ord\u003e(a: T, b: T, c: T) -\u003e T {\n    a.max(b.max(c))\n}\n\n#[derive(Clone, Copy)]\nstruct StackCell {\n    // node\n    x: usize,\n    // level\n    k: usize,\n    // false if left child hasn't been processed\n    w: bool,\n}\n\nimpl StackCell {\n    fn empty() -\u003e Self {\n        Self {\n            x: 0,\n            k: 0,\n            w: false,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::data_structures::interval_tree::ArrayBackedIntervalTree;\n\n    #[test]\n    fn test_example() {\n        let mut tree = ArrayBackedIntervalTree::new();\n        tree.insert(12..34, 0);\n        tree.insert(0..23, 1);\n        tree.insert(34..56, 2);\n        tree.index();\n        let overlap = tree.find(22..25);\n\n        let e1 = Entry {\n            interval: \u0026(0..23).into(),\n            data: \u00261,\n        };\n        let e2 = Entry {\n            interval: \u0026(12..34).into(),\n            data: \u00260,\n        };\n        let expected = vec![e1, e2];\n        assert_eq!(overlap, expected);\n    }\n}\n","traces":[{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[6286267,6286324,6286215],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":146,"address":[6286676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[6286810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[6290418,6290632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[6290797,6290868,6290924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[6292576,6292706],"length":1,"stats":{"Line":1},"fn_name":"max3\u003ci32\u003e"},{"line":261,"address":[6292720,6292718,6292618],"length":1,"stats":{"Line":2},"fn_name":"eq\u003ci32,i32\u003e"},{"line":275,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[9029520,9030326],"length":1,"stats":{"Line":3},"fn_name":"test_example"},{"line":291,"address":[9029527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[9029537],"length":1,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[9029575],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[9029653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[9029699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[9029706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[9029759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[9029867,9029967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":306,"address":[9030022],"length":1,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[9030102,9030256],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":82,"coverable":119},{"path":["/","home","todd","rust-bio","src","data_structures","interval_tree","avl_interval_tree.rs"],"content":"//! Interval tree, a data structure for efficiently storing and searching intervals.\n//!\n//! This data structure uses an `Interval` type to define the intervals. It is implemented by\n//! wrapping the `std::ops::Range` in a newtype. An interval must have a positive with and the interval bounds\n//! may be specified by any type satisfies both the `std::cmp::Ord` and `Clone` trait. Because\n//! `Interval` implements `From\u003cRange\u003e` you can also uses normal `Range` arguments in the\n//! `insert` and `find` functions. This implicit conversion will panic if a negative-width range is\n//! supplied.\n//!\n//! Upon inserting an interval may be associated with a data value. The intervals are stored in\n//! an augmented AVL-tree which allows for efficient inserting and querying.\n//!\n//! # Example\n//! ```\n//! use bio::data_structures::interval_tree::IntervalTree;\n//! use bio::utils::Interval;\n//!\n//! let mut tree = IntervalTree::new();\n//! tree.insert(11..20, \"Range_1\");\n//! tree.insert(25..30, \"Range_2\");\n//! for r in tree.find(15..25) {\n//!     assert_eq!(r.interval().start, 11);\n//!     assert_eq!(r.interval().end, 20);\n//!     assert_eq!(r.interval(), \u0026(Interval::from(11..20)));\n//!     assert_eq!(r.data(), \u0026\"Range_1\");\n//! }\n//! ```\n\nuse crate::utils::Interval;\nuse std::cmp;\nuse std::iter::FromIterator;\nuse std::mem;\n/// An interval tree for storing intervals with data\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct IntervalTree\u003cN: Ord + Clone, D\u003e {\n    root: Option\u003cNode\u003cN, D\u003e\u003e,\n}\n\nimpl\u003cN: Ord + Clone, D\u003e Default for IntervalTree\u003cN, D\u003e {\n    fn default() -\u003e Self {\n        Self { root: None }\n    }\n}\n\n/// A `find` query on the interval tree does not directly return references to the nodes in the tree, but\n/// wraps the fields `interval` and `data` in an `Entry`.\n#[derive(PartialEq, Eq, Debug, Clone)]\npub struct Entry\u003c'a, N: Ord + Clone, D\u003e {\n    data: \u0026'a D,\n    interval: \u0026'a Interval\u003cN\u003e,\n}\n\nimpl\u003c'a, N: Ord + Clone + 'a, D: 'a\u003e Entry\u003c'a, N, D\u003e {\n    /// Get a reference to the data for this entry\n    pub fn data(\u0026self) -\u003e \u0026'a D {\n        self.data\n    }\n\n    /// Get a reference to the interval for this entry\n    pub fn interval(\u0026self) -\u003e \u0026'a Interval\u003cN\u003e {\n        self.interval\n    }\n}\n\n/// An `IntervalTreeIterator` is returned by `Intervaltree::find` and iterates over the entries\n/// overlapping the query\npub struct IntervalTreeIterator\u003c'a, N: Ord + Clone, D\u003e {\n    nodes: Vec\u003c\u0026'a Node\u003cN, D\u003e\u003e,\n    interval: Interval\u003cN\u003e,\n}\n\nimpl\u003c'a, N: Ord + Clone + 'a, D: 'a\u003e Iterator for IntervalTreeIterator\u003c'a, N, D\u003e {\n    type Item = Entry\u003c'a, N, D\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cEntry\u003c'a, N, D\u003e\u003e {\n        loop {\n            let candidate = match self.nodes.pop() {\n                None =\u003e return None,\n                Some(node) =\u003e node,\n            };\n\n            // stop traversal if the query interval is beyond the current node and all children\n            if self.interval.start \u003c candidate.max {\n                if let Some(ref left) = candidate.left {\n                    self.nodes.push(left);\n                }\n\n                // don't traverse right if the query interval is completely before the current\n                // interval\n                if self.interval.end \u003e candidate.interval.start {\n                    if let Some(ref right) = candidate.right {\n                        self.nodes.push(right);\n                    }\n\n                    // overlap is only possible if both tests pass\n                    if intersect(\u0026self.interval, \u0026candidate.interval) {\n                        return Some(Entry {\n                            data: \u0026candidate.value,\n                            interval: \u0026candidate.interval,\n                        });\n                    }\n                }\n            }\n        }\n    }\n}\n\n/// A `find_mut` query on the interval tree does not directly return references to the nodes in the tree, but\n/// wraps the fields `interval` and `data` in an `EntryMut`. Only the data part can be mutably accessed\n/// using the `data` method\n#[derive(PartialEq, Eq, Debug)]\npub struct EntryMut\u003c'a, N: Ord + Clone, D\u003e {\n    data: \u0026'a mut D,\n    interval: \u0026'a Interval\u003cN\u003e,\n}\n\nimpl\u003c'a, N: Ord + Clone + 'a, D: 'a\u003e EntryMut\u003c'a, N, D\u003e {\n    /// Get a mutable reference to the data for this entry\n    pub fn data(\u0026'a mut self) -\u003e \u0026'a mut D {\n        \u0026mut self.data\n    }\n\n    /// Get a reference to the interval for this entry\n    pub fn interval(\u0026self) -\u003e \u0026'a Interval\u003cN\u003e {\n        self.interval\n    }\n}\n\n/// An `IntervalTreeIteratorMut` is returned by `Intervaltree::find_mut` and iterates over the entries\n/// overlapping the query allowing mutable access to the data `D`, not the `Interval`.\npub struct IntervalTreeIteratorMut\u003c'a, N: Ord + Clone, D\u003e {\n    nodes: Vec\u003c\u0026'a mut Node\u003cN, D\u003e\u003e,\n    interval: Interval\u003cN\u003e,\n}\n\nimpl\u003c'a, N: Ord + Clone + 'a, D: 'a\u003e Iterator for IntervalTreeIteratorMut\u003c'a, N, D\u003e {\n    type Item = EntryMut\u003c'a, N, D\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cEntryMut\u003c'a, N, D\u003e\u003e {\n        loop {\n            let candidate = match self.nodes.pop() {\n                None =\u003e return None,\n                Some(node) =\u003e node,\n            };\n\n            // stop traversal if the query interval is beyond the current node and all children\n            if self.interval.start \u003c candidate.max {\n                if let Some(ref mut left) = candidate.left {\n                    self.nodes.push(left);\n                }\n\n                // don't traverse right if the query interval is completely before the current interval\n                if self.interval.end \u003e candidate.interval.start {\n                    if let Some(ref mut right) = candidate.right {\n                        self.nodes.push(right);\n                    }\n\n                    // overlap is only possible if both tests pass\n                    if intersect(\u0026self.interval, \u0026candidate.interval) {\n                        return Some(EntryMut {\n                            data: \u0026mut candidate.value,\n                            interval: \u0026candidate.interval,\n                        });\n                    }\n                }\n            }\n        }\n    }\n}\n\nimpl\u003cN: Clone + Ord, D\u003e IntervalTree\u003cN, D\u003e {\n    /// Creates a new empty `IntervalTree`\n    pub fn new() -\u003e Self {\n        Default::default()\n    }\n\n    /// Inserts an `Interval` into the tree and associates it with `data`\n    pub fn insert\u003cI: Into\u003cInterval\u003cN\u003e\u003e\u003e(\u0026mut self, interval: I, data: D) {\n        let interval = interval.into();\n        match self.root {\n            Some(ref mut n) =\u003e n.insert(interval, data),\n            None =\u003e self.root = Some(Node::new(interval, data)),\n        };\n    }\n\n    /// Uses the provided `Interval` to find overlapping intervals in the tree and returns an\n    /// `IntervalTreeIterator`\n    pub fn find\u003cI: Into\u003cInterval\u003cN\u003e\u003e\u003e(\u0026self, interval: I) -\u003e IntervalTreeIterator\u003c'_, N, D\u003e {\n        let interval = interval.into();\n        match self.root {\n            Some(ref n) =\u003e IntervalTreeIterator {\n                nodes: vec![n],\n                interval,\n            },\n            None =\u003e {\n                let nodes = vec![];\n                IntervalTreeIterator { nodes, interval }\n            }\n        }\n    }\n\n    /// Uses the provided `Interval` to find overlapping intervals in the tree and returns an\n    /// `IntervalTreeIteratorMut` that allows mutable access to the `data`\n    pub fn find_mut\u003cI: Into\u003cInterval\u003cN\u003e\u003e\u003e(\n        \u0026mut self,\n        interval: I,\n    ) -\u003e IntervalTreeIteratorMut\u003c'_, N, D\u003e {\n        let interval = interval.into();\n        match self.root {\n            Some(ref mut n) =\u003e IntervalTreeIteratorMut {\n                nodes: vec![n],\n                interval,\n            },\n            None =\u003e {\n                let nodes = vec![];\n                IntervalTreeIteratorMut { nodes, interval }\n            }\n        }\n    }\n}\n\nimpl\u003cN: Clone + Ord, D, R: Into\u003cInterval\u003cN\u003e\u003e\u003e FromIterator\u003c(R, D)\u003e for IntervalTree\u003cN, D\u003e {\n    fn from_iter\u003cI: IntoIterator\u003cItem = (R, D)\u003e\u003e(iter: I) -\u003e Self {\n        let mut tree = IntervalTree::new();\n        for r in iter {\n            tree.insert(r.0, r.1);\n        }\n        tree\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct Node\u003cN: Ord + Clone, D\u003e {\n    // actual interval data\n    interval: Interval\u003cN\u003e,\n    value: D,\n    // tree metadata\n    max: N,\n    height: i64,\n    left: Option\u003cBox\u003cNode\u003cN, D\u003e\u003e\u003e,\n    right: Option\u003cBox\u003cNode\u003cN, D\u003e\u003e\u003e,\n}\n\nimpl\u003cN: Ord + Clone, D\u003e Node\u003cN, D\u003e {\n    fn new(interval: Interval\u003cN\u003e, data: D) -\u003e Self {\n        let max = interval.end.clone();\n        Node {\n            interval,\n            max,\n            height: 1,\n            value: data,\n            left: None,\n            right: None,\n        }\n    }\n\n    fn insert(\u0026mut self, interval: Interval\u003cN\u003e, data: D) {\n        if interval.start \u003c= self.interval.start {\n            if let Some(ref mut son) = self.left {\n                son.insert(interval, data);\n            } else {\n                self.left = Some(Box::new(Node::new(interval, data)));\n            }\n        } else if let Some(ref mut son) = self.right {\n            son.insert(interval, data);\n        } else {\n            self.right = Some(Box::new(Node::new(interval, data)));\n        }\n        self.repair();\n    }\n\n    fn update_height(\u0026mut self) {\n        let left_h = self.left.as_ref().map_or(0, |n| n.height);\n        let right_h = self.right.as_ref().map_or(0, |n| n.height);\n        self.height = 1 + cmp::max(left_h, right_h);\n    }\n\n    fn update_max(\u0026mut self) {\n        self.max = self.interval.end.clone();\n        if let Some(ref n) = self.left {\n            if self.max \u003c n.max {\n                self.max = n.max.clone();\n            }\n        }\n        if let Some(ref n) = self.right {\n            if self.max \u003c n.max {\n                self.max = n.max.clone();\n            }\n        }\n    }\n\n    fn repair(\u0026mut self) {\n        let left_h = self.left.as_ref().map_or(0, |n| n.height);\n        let right_h = self.right.as_ref().map_or(0, |n| n.height);\n        // each case - update both height and max\n        if (left_h - right_h).abs() \u003c= 1 {\n            self.update_height();\n            self.update_max();\n        } else if right_h \u003e left_h {\n            {\n                let right = self\n                    .right\n                    .as_mut()\n                    .expect(\"Invalid tree: leaf is taller than its sibling.\");\n                let right_left_h = right.left.as_ref().map_or(0, |n| n.height);\n                let right_right_h = right.right.as_ref().map_or(0, |n| n.height);\n                if right_left_h \u003e right_right_h {\n                    right.rotate_right();\n                }\n            }\n            self.rotate_left();\n        } else {\n            {\n                let left = self\n                    .left\n                    .as_mut()\n                    .expect(\"Invalid tree: leaf is taller than its sibling.\");\n                let left_right_h = left.right.as_ref().map_or(0, |n| n.height);\n                let left_left_h = left.left.as_ref().map_or(0, |n| n.height);\n                if left_right_h \u003e left_left_h {\n                    left.rotate_left();\n                }\n            }\n            self.rotate_right();\n        }\n    }\n\n    fn rotate_left(\u0026mut self) {\n        let mut new_root = self.right.take().unwrap();\n        let t1 = self.left.take();\n        let t2 = new_root.left.take();\n        let t3 = new_root.right.take();\n        swap_interval_data(self, \u0026mut *new_root);\n\n        new_root.left = t1;\n        new_root.right = t2;\n        new_root.update_height();\n        new_root.update_max();\n\n        self.right = t3;\n        self.left = Some(new_root);\n        self.update_height();\n        self.update_max();\n    }\n\n    fn rotate_right(\u0026mut self) {\n        let mut new_root = self.left.take().unwrap();\n        let t1 = new_root.left.take();\n        let t2 = new_root.right.take();\n        let t3 = self.right.take();\n        swap_interval_data(self, \u0026mut *new_root);\n\n        new_root.left = t2;\n        new_root.right = t3;\n        new_root.update_height();\n        new_root.update_max();\n\n        self.left = t1;\n        self.right = Some(new_root);\n        self.update_height();\n        self.update_max();\n    }\n}\n\nfn swap_interval_data\u003cN: Ord + Clone, D\u003e(node_1: \u0026mut Node\u003cN, D\u003e, node_2: \u0026mut Node\u003cN, D\u003e) {\n    mem::swap(\u0026mut node_1.value, \u0026mut node_2.value);\n    mem::swap(\u0026mut node_1.interval, \u0026mut node_2.interval);\n}\n\nfn intersect\u003cN: Ord + Clone\u003e(range_1: \u0026Interval\u003cN\u003e, range_2: \u0026Interval\u003cN\u003e) -\u003e bool {\n    range_1.start \u003c range_1.end\n        \u0026\u0026 range_2.start \u003c range_2.end\n        \u0026\u0026 range_1.end \u003e range_2.start\n        \u0026\u0026 range_1.start \u003c range_2.end\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{Entry, IntervalTree, Node};\n    use crate::utils::Interval;\n    use std::cmp;\n    use std::cmp::{max, min};\n    use std::ops::Range;\n\n    fn validate(node: \u0026Node\u003ci64, String\u003e) {\n        validate_height(node);\n        validate_intervals(node);\n        validate_string_metadata(node);\n        if let Some(n) = node.left.as_ref() {\n            validate(n)\n        }\n        if let Some(n) = node.right.as_ref() {\n            validate(n)\n        }\n    }\n\n    fn validate_height(node: \u0026Node\u003ci64, String\u003e) {\n        let left_height = node.left.as_ref().map_or(0, |n| n.height);\n        let right_height = node.right.as_ref().map_or(0, |n| n.height);\n        assert!((left_height - right_height).abs() \u003c= 1);\n        assert_eq!(node.height, cmp::max(left_height, right_height) + 1)\n    }\n\n    fn validate_intervals(node: \u0026Node\u003ci64, String\u003e) {\n        let mut reached_maximum: bool = false;\n        if node.interval.end == node.max {\n            reached_maximum = true;\n        }\n        if let Some(ref son) = node.left {\n            assert!(\n                son.max \u003c= node.max,\n                \"left max invariant violated:\\n{:?} -\u003e {:?}\",\n                node,\n                son\n            );\n            assert!(\n                son.interval.start \u003c= node.interval.start,\n                \"left ord invariant violated\\n{:?} -\u003e {:?}\",\n                node,\n                son\n            );\n            if node.max == son.max {\n                reached_maximum = true;\n            }\n        }\n        if let Some(ref son) = node.right {\n            assert!(\n                son.max \u003c= node.max,\n                \"right max invariant violated\\n{:?} -\u003e {:?}\",\n                node,\n                son\n            );\n            assert!(\n                son.interval.start \u003e= node.interval.start,\n                \"right ord invariant violated\\n{:?} -\u003e {:?}\",\n                node,\n                son\n            );\n            if node.max == son.max {\n                reached_maximum = true;\n            }\n        }\n        assert!(reached_maximum, \"maximum invariant violated: {:?}\", node);\n    }\n\n    fn validate_string_metadata(node: \u0026Node\u003ci64, String\u003e) {\n        let mut name: String = \"\".to_string();\n        name.push_str(\u0026node.interval.start.to_string());\n        name.push(':');\n        name.push_str(\u0026node.interval.end.to_string());\n        assert_eq!(name, node.value, \"Invalid metadata for node {:?}\", node);\n    }\n\n    fn insert_and_validate(tree: \u0026mut IntervalTree\u003ci64, String\u003e, start: i64, end: i64) {\n        let mut name: String = \"\".to_string();\n        name.push_str(\u0026start.to_string());\n        name.push(':');\n        name.push_str(\u0026end.to_string());\n        tree.insert(start..end, name);\n        if let Some(ref n) = tree.root {\n            validate(n);\n        }\n    }\n\n    fn make_entry_tuples(intervals: Vec\u003cRange\u003ci64\u003e\u003e) -\u003e Vec\u003c(Interval\u003ci64\u003e, String)\u003e {\n        let mut entries = vec![];\n        for interval in intervals {\n            let mut data: String = \"\".to_string();\n            data.push_str(\u0026interval.start.to_string());\n            data.push(':');\n            data.push_str(\u0026interval.end.to_string());\n            entries.push((interval.into(), data));\n        }\n        entries.sort_by(|x1, x2| x1.1.cmp(\u0026x2.1));\n        entries\n    }\n\n    fn assert_intersections(\n        tree: \u0026IntervalTree\u003ci64, String\u003e,\n        target: Range\u003ci64\u003e,\n        expected_results: Vec\u003cRange\u003ci64\u003e\u003e,\n    ) {\n        let mut actual_entries: Vec\u003cEntry\u003c'_, i64, String\u003e\u003e = tree.find(\u0026target).collect();\n        println!(\"{:?}\", actual_entries);\n        actual_entries.sort_by(|x1, x2| x1.data.cmp(\u0026x2.data));\n        let expected_entries = make_entry_tuples(expected_results);\n        assert_eq!(actual_entries.len(), expected_entries.len());\n        for (actual, expected) in actual_entries.iter().zip(expected_entries.iter()) {\n            assert_eq!(*actual.interval, expected.0);\n            assert_eq!(actual.data, \u0026expected.1);\n        }\n    }\n\n    fn assert_not_found(tree: \u0026IntervalTree\u003ci64, String\u003e, target: Range\u003ci64\u003e) {\n        assert_intersections(tree, target, vec![]);\n    }\n\n    #[test]\n    fn test_insertion_and_intersection() {\n        let mut tree: IntervalTree\u003ci64, String\u003e = IntervalTree::new();\n        assert_eq!(tree.find(1..2).count(), 0);\n        assert_eq!(tree.find_mut(1..2).count(), 0);\n        tree.insert(50..51, \"50:51\".to_string());\n        assert_not_found(\u0026tree, 49..50);\n        assert_intersections(\u0026tree, 49..55, vec![50..51]);\n        assert_not_found(\u0026tree, 51..55);\n        assert_not_found(\u0026tree, 52..55);\n        assert_not_found(\u0026tree, 40..45);\n        insert_and_validate(\u0026mut tree, 80, 81);\n        assert_intersections(\u0026tree, 80..83, vec![80..81]);\n        assert_intersections(\u0026tree, 1..100, vec![50..51, 80..81]);\n        assert_not_found(\u0026tree, 82..83);\n        insert_and_validate(\u0026mut tree, 30, 35);\n        assert_intersections(\u0026tree, 25..33, vec![30..35]);\n        assert_intersections(\u0026tree, 1..100, vec![30..35, 50..51, 80..81]);\n        assert_not_found(\u0026tree, 42..43);\n        assert_not_found(\u0026tree, 35..36);\n        assert_not_found(\u0026tree, 22..29);\n        insert_and_validate(\u0026mut tree, 70, 77);\n        assert_intersections(\u0026tree, 75..79, vec![70..77]);\n        assert_intersections(\u0026tree, 1..100, vec![30..35, 50..51, 70..77, 80..81]);\n        assert_not_found(\u0026tree, 62..68);\n        assert_intersections(\u0026tree, 75..77, vec![70..77]);\n        assert_not_found(\u0026tree, 78..79);\n        assert_intersections(\u0026tree, 49..51, vec![50..51]);\n        assert_intersections(\u0026tree, 49..55, vec![50..51]);\n        assert_not_found(\u0026tree, 51..55);\n        assert_not_found(\u0026tree, 52..55);\n        assert_not_found(\u0026tree, 40..45);\n        insert_and_validate(\u0026mut tree, 101, 102);\n        insert_and_validate(\u0026mut tree, 103, 104);\n        insert_and_validate(\u0026mut tree, 105, 106);\n        insert_and_validate(\u0026mut tree, 107, 108);\n        insert_and_validate(\u0026mut tree, 111, 112);\n        insert_and_validate(\u0026mut tree, 113, 114);\n        insert_and_validate(\u0026mut tree, 115, 116);\n        insert_and_validate(\u0026mut tree, 117, 118);\n        insert_and_validate(\u0026mut tree, 119, 129);\n        assert_not_found(\u0026tree, 112..113);\n        assert_not_found(\u0026tree, 108..109);\n        assert_intersections(\u0026tree, 106..108, vec![107..108]);\n        assert_intersections(\u0026tree, 1..100, vec![30..35, 50..51, 70..77, 80..81]);\n        assert_intersections(\u0026tree, 1..101, vec![30..35, 50..51, 70..77, 80..81]);\n        assert_intersections(\n            \u0026tree,\n            1..102,\n            vec![30..35, 50..51, 70..77, 80..81, 101..102],\n        );\n        assert_intersections(\n            \u0026tree,\n            100..200,\n            vec![\n                101..102,\n                103..104,\n                105..106,\n                107..108,\n                111..112,\n                113..114,\n                115..116,\n                117..118,\n                119..129,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_insertion_and_intersection_2() {\n        let mut tree: IntervalTree\u003ci64, String\u003e = IntervalTree::new();\n        // interval size we'll insert into the tree\n        let k = 10;\n        for i in 100..200 {\n            insert_and_validate(\u0026mut tree, i, i + k);\n        }\n        for i in 90..210 {\n            // \"random\" interval length we'll search against.\n            // the exact formula doesn't matter; the point is\n            // it will vary from 0.5 * k to 1.5 * k\n            let l = k / 2 + i % k;\n            let lower_bound = i;\n            let upper_bound = i + l;\n            let smallest_start = max(lower_bound - k + 1, 100);\n            let largest_start = min(upper_bound, 200);\n            let mut expected_intersections = vec![];\n            for j in smallest_start..largest_start {\n                expected_intersections.push(j..j + k);\n            }\n            assert_intersections(\u0026tree, lower_bound..upper_bound, expected_intersections);\n        }\n    }\n\n    #[test]\n    fn zero_width_ranges() {\n        let mut tree: IntervalTree\u003ci64, String\u003e = IntervalTree::new();\n        tree.insert(10..10, \"10:10\".to_string());\n\n        assert_not_found(\u0026tree, 5..15);\n        assert_not_found(\u0026tree, 10..10);\n\n        insert_and_validate(\u0026mut tree, 50, 60);\n        assert_not_found(\u0026tree, 55..55);\n    }\n\n    #[test]\n    fn from_iterator() {\n        let tree: IntervalTree\u003ci64, ()\u003e = vec![(10..100, ()), (10..20, ()), (1..8, ())]\n            .into_iter()\n            .collect();\n        assert_eq!(tree.find(\u0026(0..1000)).count(), 3);\n        let tree2: IntervalTree\u003c_, _\u003e = tree\n            .find(\u0026(11..30))\n            .map(|e| (e.interval().clone(), *e.data()))\n            .collect();\n        assert_eq!(tree2.find(\u0026(0..1000)).count(), 2);\n    }\n\n    #[test]\n    fn iter_mut() {\n        let mut tree: IntervalTree\u003ci64, usize\u003e = vec![(10..100, 0), (10..20, 0), (1..8, 0)]\n            .into_iter()\n            .collect();\n        let q = Interval::new(11..30).unwrap();\n        for mut e in tree.find_mut(q.clone()) {\n            *e.data() += 1;\n        }\n        assert!(tree\n            .find(0..100)\n            .all(|e| if super::intersect(e.interval(), \u0026q) {\n                *e.data() == 1\n            } else {\n                *e.data() == 0\n            }));\n    }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":365,"address":[4914016,4914080,4913952,4914144],"length":1,"stats":{"Line":4},"fn_name":"swap_interval_data\u003ci64,usize\u003e"},{"line":366,"address":[4913976,4914104,4914040,4914168],"length":1,"stats":{"Line":4},"fn_name":null},{"line":367,"address":[4914063,4914183,4914127,4914000],"length":1,"stats":{"Line":4},"fn_name":null},{"line":370,"address":[4914640,4914208],"length":1,"stats":{"Line":2},"fn_name":"intersect\u003ci64\u003e"},{"line":371,"address":[4914599,4914676,4915031,4914401,4914244,4914500,4914932,4914833],"length":1,"stats":{"Line":8},"fn_name":null},{"line":372,"address":[4914336,4914768],"length":1,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[4914435,4914867],"length":1,"stats":{"Line":2},"fn_name":null},{"line":374,"address":[4914966,4914534],"length":1,"stats":{"Line":2},"fn_name":null},{"line":385,"address":[8964832],"length":1,"stats":{"Line":1},"fn_name":"validate"},{"line":386,"address":[8964846],"length":1,"stats":{"Line":1},"fn_name":null},{"line":387,"address":[8964856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":388,"address":[8964866],"length":1,"stats":{"Line":1},"fn_name":null},{"line":389,"address":[8964933,8964876],"length":1,"stats":{"Line":2},"fn_name":null},{"line":390,"address":[8964923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":392,"address":[8964997,8964940],"length":1,"stats":{"Line":2},"fn_name":null},{"line":393,"address":[8964987],"length":1,"stats":{"Line":2},"fn_name":null},{"line":397,"address":[8965008],"length":1,"stats":{"Line":1},"fn_name":"validate_height"},{"line":398,"address":[8965028],"length":1,"stats":{"Line":3},"fn_name":null},{"line":399,"address":[8965074],"length":1,"stats":{"Line":4},"fn_name":null},{"line":400,"address":[8965241,8965125],"length":1,"stats":{"Line":1},"fn_name":null},{"line":401,"address":[8965420,8965220,8965276],"length":1,"stats":{"Line":2},"fn_name":null},{"line":404,"address":[8965472],"length":1,"stats":{"Line":1},"fn_name":"validate_intervals"},{"line":405,"address":[8965487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":406,"address":[8965495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":407,"address":[8965544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":409,"address":[8965640,8965552],"length":1,"stats":{"Line":2},"fn_name":null},{"line":410,"address":[8965710,8965632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":411,"address":[8965602],"length":1,"stats":{"Line":1},"fn_name":null},{"line":416,"address":[8966079,8966035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":417,"address":[8965681,8965981],"length":1,"stats":{"Line":2},"fn_name":null},{"line":422,"address":[8966041,8966349,8966336],"length":1,"stats":{"Line":2},"fn_name":null},{"line":423,"address":[8966341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[8965642,8966354,8966412],"length":1,"stats":{"Line":3},"fn_name":null},{"line":427,"address":[8966404,8966462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[8966374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":433,"address":[8966786,8966742],"length":1,"stats":{"Line":2},"fn_name":null},{"line":434,"address":[8966700,8966436],"length":1,"stats":{"Line":3},"fn_name":null},{"line":439,"address":[8966748,8967019,8967032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":440,"address":[8967024],"length":1,"stats":{"Line":2},"fn_name":null},{"line":443,"address":[8966414,8967045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[8967200,8967908],"length":1,"stats":{"Line":1},"fn_name":"validate_string_metadata"},{"line":447,"address":[8967212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":448,"address":[8967313,8967233],"length":1,"stats":{"Line":2},"fn_name":null},{"line":449,"address":[8967419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[8967426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":451,"address":[8967694,8967583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":454,"address":[8967936,8968463],"length":1,"stats":{"Line":1},"fn_name":"insert_and_validate"},{"line":455,"address":[8967966],"length":1,"stats":{"Line":1},"fn_name":null},{"line":456,"address":[8968104,8968013],"length":1,"stats":{"Line":2},"fn_name":null},{"line":457,"address":[8968172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[8968189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":459,"address":[8968305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":460,"address":[8968443,8968401,8968461],"length":1,"stats":{"Line":2},"fn_name":null},{"line":461,"address":[8968436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":465,"address":[8968496,8969515],"length":1,"stats":{"Line":1},"fn_name":"make_entry_tuples"},{"line":466,"address":[8968521],"length":1,"stats":{"Line":1},"fn_name":null},{"line":467,"address":[8968649,8968557,8968753,8968814,8969433,8968834],"length":1,"stats":{"Line":5},"fn_name":null},{"line":468,"address":[8968898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[8969045,8968948],"length":1,"stats":{"Line":2},"fn_name":null},{"line":470,"address":[8969122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[8969129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[8969268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":474,"address":[8969462],"length":1,"stats":{"Line":3},"fn_name":null},{"line":478,"address":[8969552,8971090],"length":1,"stats":{"Line":1},"fn_name":"assert_intersections"},{"line":483,"address":[8969613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[8969724,8969897],"length":1,"stats":{"Line":2},"fn_name":null},{"line":485,"address":[8969924],"length":1,"stats":{"Line":3},"fn_name":null},{"line":486,"address":[8969984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[8970310,8970046,8970154],"length":1,"stats":{"Line":2},"fn_name":null},{"line":488,"address":[8970265,8970377,8970680,8971006],"length":1,"stats":{"Line":4},"fn_name":null},{"line":489,"address":[8970754,8970949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[8970849,8971000,8971020],"length":1,"stats":{"Line":2},"fn_name":null},{"line":494,"address":[8971120],"length":1,"stats":{"Line":1},"fn_name":"assert_not_found"},{"line":495,"address":[8971153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":499,"address":[8971200,8976242],"length":1,"stats":{"Line":3},"fn_name":"test_insertion_and_intersection"},{"line":500,"address":[8971207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":501,"address":[8971217,8971342,8971506],"length":1,"stats":{"Line":2},"fn_name":null},{"line":502,"address":[8971565,8971436,8971740],"length":1,"stats":{"Line":2},"fn_name":null},{"line":503,"address":[8971679,8971792],"length":1,"stats":{"Line":2},"fn_name":null},{"line":504,"address":[8971828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":505,"address":[8971880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":506,"address":[8972025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":507,"address":[8972077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":508,"address":[8972129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[8972196],"length":1,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[8972203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[8972348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[8972541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[8972608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":514,"address":[8972615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[8972760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":516,"address":[8973001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[8973053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":518,"address":[8973105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":519,"address":[8973172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[8973179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[8973324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[8973618],"length":1,"stats":{"Line":1},"fn_name":null},{"line":523,"address":[8973670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[8973815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":525,"address":[8973867],"length":1,"stats":{"Line":1},"fn_name":null},{"line":526,"address":[8974012],"length":1,"stats":{"Line":1},"fn_name":null},{"line":527,"address":[8974157],"length":1,"stats":{"Line":1},"fn_name":null},{"line":528,"address":[8974209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":529,"address":[8974261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":530,"address":[8974328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":531,"address":[8974350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":532,"address":[8974372],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[8974394],"length":1,"stats":{"Line":1},"fn_name":null},{"line":534,"address":[8974416],"length":1,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[8974438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[8974460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[8974482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[8974504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":539,"address":[8974511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":540,"address":[8974563],"length":1,"stats":{"Line":1},"fn_name":null},{"line":541,"address":[8974615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":542,"address":[8974760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":543,"address":[8975054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":546,"address":[8975348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":547,"address":[8975382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":551,"address":[8975690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[8975724,8975953],"length":1,"stats":{"Line":2},"fn_name":null},{"line":553,"address":[8975737],"length":1,"stats":{"Line":1},"fn_name":null},{"line":554,"address":[8975761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":555,"address":[8975785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":556,"address":[8975809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":557,"address":[8975833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":558,"address":[8975857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":559,"address":[8975881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[8975905],"length":1,"stats":{"Line":1},"fn_name":null},{"line":561,"address":[8975929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":567,"address":[8977826,8976272],"length":1,"stats":{"Line":3},"fn_name":"test_insertion_and_intersection_2"},{"line":568,"address":[8976279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":570,"address":[8976300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":571,"address":[8976463,8976734,8976612,8976312],"length":1,"stats":{"Line":4},"fn_name":null},{"line":572,"address":[8976652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":574,"address":[8976543,8976865,8977803,8976755],"length":1,"stats":{"Line":4},"fn_name":null},{"line":578,"address":[8976902,8977040],"length":1,"stats":{"Line":1},"fn_name":null},{"line":579,"address":[8977015],"length":1,"stats":{"Line":1},"fn_name":null},{"line":580,"address":[8977109,8977023,8977083],"length":1,"stats":{"Line":2},"fn_name":null},{"line":581,"address":[8977091,8977147],"length":1,"stats":{"Line":2},"fn_name":null},{"line":582,"address":[8977278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":583,"address":[8977314],"length":1,"stats":{"Line":1},"fn_name":null},{"line":584,"address":[8977790,8977331,8977647,8977471],"length":1,"stats":{"Line":4},"fn_name":null},{"line":585,"address":[8977684],"length":1,"stats":{"Line":1},"fn_name":null},{"line":587,"address":[8977549],"length":1,"stats":{"Line":1},"fn_name":null},{"line":592,"address":[8977856,8978163],"length":1,"stats":{"Line":3},"fn_name":"zero_width_ranges"},{"line":593,"address":[8977863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":594,"address":[8977873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":596,"address":[8977979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":597,"address":[8978025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":599,"address":[8978092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":600,"address":[8978099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":604,"address":[8979106,8978192],"length":1,"stats":{"Line":3},"fn_name":"from_iterator"},{"line":605,"address":[8978199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":608,"address":[8978507,8978730,8978599],"length":1,"stats":{"Line":2},"fn_name":null},{"line":609,"address":[8978693,8978797],"length":1,"stats":{"Line":2},"fn_name":null},{"line":611,"address":[9362144,9362163],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":613,"address":[8979042,8978827,8978925],"length":1,"stats":{"Line":2},"fn_name":null},{"line":617,"address":[8979136,8980327],"length":1,"stats":{"Line":3},"fn_name":"iter_mut"},{"line":618,"address":[8979143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":621,"address":[8979534,8979674],"length":1,"stats":{"Line":2},"fn_name":null},{"line":622,"address":[8979940,8979920,8980064,8979698],"length":1,"stats":{"Line":3},"fn_name":null},{"line":623,"address":[8980012,8980069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":625,"address":[8980294,8980177,8980125],"length":1,"stats":{"Line":2},"fn_name":null},{"line":626,"address":[8980101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":627,"address":[8980169],"length":1,"stats":{"Line":4},"fn_name":null},{"line":628,"address":[9362376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":630,"address":[9362359,9362426],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":291,"coverable":305},{"path":["/","home","todd","rust-bio","src","data_structures","interval_tree","mod.rs"],"content":"mod array_backed_interval_tree;\nmod avl_interval_tree;\n\npub use array_backed_interval_tree::ArrayBackedIntervalTree;\npub use avl_interval_tree::{\n    Entry, EntryMut, IntervalTree, IntervalTreeIterator, IntervalTreeIteratorMut,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","data_structures","mod.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Various useful data structures.\n\npub mod annot_map;\npub mod bit_tree;\npub mod bitenc;\npub mod bwt;\npub mod fmindex;\npub mod interpolation_table;\npub mod interval_tree;\npub mod qgram_index;\npub mod rank_select;\npub mod smallints;\npub mod suffix_array;\npub mod wavelet_matrix;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","data_structures","qgram_index.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A classical, flexible, q-gram index implementation.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::alphabets;\n//! use bio::data_structures::qgram_index;\n//!\n//! let text = b\"ACGGCTGAGATGAT\";\n//! let alphabet = alphabets::dna::alphabet();\n//! let q = 3;\n//! let qgram_index = qgram_index::QGramIndex::new(q, text, \u0026alphabet);\n//!\n//! let pattern = b\"GCTG\";\n//! let matches = qgram_index.matches(pattern, 1);\n//! assert_eq!(\n//!     matches,\n//!     [qgram_index::Match {\n//!         pattern: qgram_index::Interval { start: 0, stop: 4 },\n//!         text: qgram_index::Interval { start: 3, stop: 7 },\n//!         count: 2\n//!     }]\n//! );\n//! ```\n\nuse std::cmp;\nuse std::collections;\nuse std::collections::hash_map::Entry;\n\nuse crate::alphabets::{Alphabet, RankTransform};\nuse crate::utils;\n\n/// A classical, flexible, q-gram index implementation.\n#[derive(Serialize, Deserialize)]\npub struct QGramIndex {\n    q: u32,\n    address: Vec\u003cusize\u003e,\n    pos: Vec\u003cusize\u003e,\n    ranks: RankTransform,\n}\n\nimpl QGramIndex {\n    /// Create a new q-gram index.\n    /// The q has to be smaller than b / log2(|A|) with |A| being the alphabet size and b the number\n    /// bits with the `usize` data type.\n    pub fn new(q: u32, text: \u0026[u8], alphabet: \u0026Alphabet) -\u003e Self {\n        QGramIndex::with_max_count(q, text, alphabet, std::usize::MAX)\n    }\n\n    /// Create a new q-gram index, only considering q-grams that occur at most `max_count` times.\n    /// The q has to be smaller than b / log2(|A|) with |A| being the alphabet size and b the number\n    /// bits with the `usize` data type.\n    pub fn with_max_count(q: u32, text: \u0026[u8], alphabet: \u0026Alphabet, max_count: usize) -\u003e Self {\n        let ranks = RankTransform::new(alphabet);\n\n        let qgram_count = alphabet.len().pow(q as u32);\n        let mut address = vec![0; qgram_count + 1];\n        let mut pos = vec![0; text.len()];\n\n        for qgram in ranks.qgrams(q, text) {\n            address[qgram] += 1;\n        }\n\n        for a in address.iter_mut().skip(1) {\n            if *a \u003e max_count {\n                // mask qgram\n                *a = 0;\n            }\n        }\n\n        utils::prescan(\u0026mut address, 0, |a, b| a + b);\n\n        {\n            let mut offset = vec![0; qgram_count];\n            for (i, qgram) in ranks.qgrams(q, text).enumerate() {\n                let a = address[qgram as usize];\n                if address[qgram as usize + 1] - a != 0 {\n                    // if not masked, insert positions\n                    pos[a + offset[qgram as usize]] = i;\n                    offset[qgram as usize] += 1;\n                }\n            }\n        }\n\n        QGramIndex {\n            q,\n            address,\n            pos,\n            ranks,\n        }\n    }\n\n    /// The used q.\n    pub fn q(\u0026self) -\u003e u32 {\n        self.q\n    }\n\n    /// Return text positions with matching q-gram. Complexity O(1).\n    pub fn qgram_matches(\u0026self, qgram: usize) -\u003e \u0026[usize] {\n        \u0026self.pos[self.address[qgram]..self.address[qgram + 1]]\n    }\n\n    /// Return matches of the given pattern.\n    /// Complexity O(m + k) for pattern of length m and k being the number of matching q-grams.\n    pub fn matches(\u0026self, pattern: \u0026[u8], min_count: usize) -\u003e Vec\u003cMatch\u003e {\n        let q = self.q as usize;\n        let mut diagonals = collections::HashMap::new();\n        for (i, qgram) in self.ranks.qgrams(self.q, pattern).enumerate() {\n            for \u0026p in self.qgram_matches(qgram) {\n                let diagonal = p - i;\n                match diagonals.entry(diagonal) {\n                    Entry::Vacant(v) =\u003e {\n                        v.insert(Match {\n                            pattern: Interval {\n                                start: i,\n                                stop: i + q,\n                            },\n                            text: Interval {\n                                start: p,\n                                stop: p + q,\n                            },\n                            count: 1,\n                        });\n                    }\n                    Entry::Occupied(mut o) =\u003e {\n                        let m = o.get_mut();\n                        m.pattern.stop = i + q;\n                        m.text.stop = p + q;\n                        m.count += 1;\n                    }\n                }\n            }\n        }\n        diagonals\n            .into_iter()\n            .filter_map(|(_, m)| if m.count \u003e= min_count { Some(m) } else { None })\n            .collect()\n    }\n\n    /// Return exact matches (substrings) of the given pattern.\n    /// Complexity O(m + k) for pattern of length m and k being the number of matching q-grams.\n    pub fn exact_matches(\u0026self, pattern: \u0026[u8]) -\u003e Vec\u003cExactMatch\u003e {\n        let q = self.q as usize;\n        let mut diagonals = collections::HashMap::new();\n        let mut matches = Vec::new();\n\n        for (i, qgram) in self.ranks.qgrams(self.q, pattern).enumerate() {\n            for \u0026p in self.qgram_matches(qgram) {\n                let diagonal = p as i32 - i as i32;\n                match diagonals.entry(diagonal) {\n                    Entry::Vacant(v) =\u003e {\n                        v.insert(ExactMatch {\n                            pattern: Interval {\n                                start: i,\n                                stop: i + q,\n                            },\n                            text: Interval {\n                                start: p,\n                                stop: p + q,\n                            },\n                        });\n                    }\n                    Entry::Occupied(mut o) =\u003e {\n                        let m = o.get_mut();\n                        if m.pattern.stop - q + 1 == i {\n                            m.pattern.stop = i + q;\n                            m.text.stop = p + q;\n                        } else {\n                            // discontinue match\n                            matches.push(*m);\n                            // start new match\n                            m.pattern.start = i;\n                            m.pattern.stop = i + q;\n                            m.text.start = p;\n                            m.text.stop = p + q;\n                        }\n                    }\n                }\n            }\n        }\n        for (_, m) in diagonals {\n            matches.push(m);\n        }\n\n        matches\n    }\n}\n\n/// An interval, consisting of start and stop position (the latter exclusive).\n#[derive(PartialEq, Eq, Debug, Copy, Clone)]\npub struct Interval {\n    pub start: usize,\n    pub stop: usize,\n}\n\nimpl Interval {\n    /// Get the text within the given interval.\n    pub fn get\u003c'a\u003e(\u0026self, text: \u0026'a [u8]) -\u003e \u0026'a [u8] {\n        \u0026text[self.start..self.stop]\n    }\n}\n\n/// A match between the pattern and the text.\n#[derive(PartialEq, Eq, Debug, Copy, Clone)]\npub struct Match {\n    pub pattern: Interval,\n    pub text: Interval,\n    pub count: usize,\n}\n\nimpl cmp::Ord for Match {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e cmp::Ordering {\n        self.count.cmp(\u0026other.count)\n    }\n}\n\nimpl cmp::PartialOrd for Match {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003ccmp::Ordering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\n/// An exact match between the pattern and the text.\n#[derive(PartialEq, Debug, Copy, Clone)]\npub struct ExactMatch {\n    pub pattern: Interval,\n    pub text: Interval,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::alphabets;\n\n    fn setup() -\u003e (\u0026'static [u8], alphabets::Alphabet) {\n        let text = b\"ACGGCTGAGATGAT\";\n        let alphabet = alphabets::dna::alphabet();\n\n        (text, alphabet)\n    }\n\n    #[test]\n    fn test_qgram_matches() {\n        let (text, alphabet) = setup();\n        let q = 3;\n        let qgram_index = QGramIndex::new(q, text, \u0026alphabet);\n\n        let ranks = alphabets::RankTransform::new(\u0026alphabet);\n\n        let qgram = ranks.qgrams(q, b\"TGA\").next().unwrap();\n\n        let matches = qgram_index.qgram_matches(qgram);\n        assert_eq!(matches, [5, 10]);\n    }\n\n    #[test]\n    fn test_matches() {\n        let (text, alphabet) = setup();\n        let q = 3;\n        let qgram_index = QGramIndex::new(q, text, \u0026alphabet);\n\n        let pattern = b\"GCTG\";\n        let matches = qgram_index.matches(pattern, 1);\n        assert_eq!(\n            matches,\n            [Match {\n                pattern: Interval { start: 0, stop: 4 },\n                text: Interval { start: 3, stop: 7 },\n                count: 2,\n            }]\n        );\n    }\n\n    #[test]\n    fn test_exact_matches() {\n        let (text, alphabet) = setup();\n        let q = 3;\n        let qgram_index = QGramIndex::new(q, text, \u0026alphabet);\n\n        let pattern = b\"GCTGA\";\n        let exact_matches = qgram_index.exact_matches(pattern);\n        assert!(exact_matches.len() == 2);\n        for m in exact_matches {\n            assert_eq!(m.pattern.get(pattern), m.text.get(text));\n        }\n    }\n\n    #[test]\n    fn test_exact_matches_self() {\n        let (text, alphabet) = setup();\n        let q = 3;\n        let qgram_index = QGramIndex::new(q, text, \u0026alphabet);\n\n        let exact_matches = qgram_index.exact_matches(text);\n        assert!(!exact_matches.is_empty());\n    }\n\n    #[test]\n    #[cfg(feature = \"nightly\")]\n    fn test_serde() {\n        use serde::{Deserialize, Serialize};\n        fn impls_serde_traits\u003cS: Serialize + Deserialize\u003e() {}\n\n        impls_serde_traits::\u003cQGramIndex\u003e();\n    }\n}\n","traces":[{"line":51,"address":[4865664],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":52,"address":[4865694],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[4868101,4868116,4865728],"length":1,"stats":{"Line":2},"fn_name":"with_max_count"},{"line":59,"address":[4865839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[4865965,4865861],"length":1,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[4865973],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[4866069],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[4866184,4866560,4866442,4866280],"length":1,"stats":{"Line":8},"fn_name":null},{"line":66,"address":[4866565,4866474],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[4866398,4866871,4866614,4866927],"length":1,"stats":{"Line":10},"fn_name":null},{"line":70,"address":[4866908],"length":1,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[4866920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[4866942,4866828],"length":1,"stats":{"Line":14},"fn_name":null},{"line":79,"address":[4866963],"length":1,"stats":{"Line":4},"fn_name":null},{"line":80,"address":[4867103,4867783,4867224,4867007],"length":1,"stats":{"Line":16},"fn_name":null},{"line":81,"address":[4867298],"length":1,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[4867748,4867358],"length":1,"stats":{"Line":8},"fn_name":null},{"line":84,"address":[4867530],"length":1,"stats":{"Line":4},"fn_name":null},{"line":85,"address":[4867750,4867679],"length":1,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[4868128],"length":1,"stats":{"Line":0},"fn_name":"q"},{"line":100,"address":[4868133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[4868144],"length":1,"stats":{"Line":1},"fn_name":"qgram_matches"},{"line":105,"address":[4868168],"length":1,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[4869982,4868384],"length":1,"stats":{"Line":1},"fn_name":"matches"},{"line":111,"address":[4868457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[4868484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[4868524,4868622,4869039,4868815],"length":1,"stats":{"Line":4},"fn_name":null},{"line":114,"address":[4868884,4869049,4869638],"length":1,"stats":{"Line":3},"fn_name":null},{"line":115,"address":[4869089,4869144],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[4869193,4869117,4869842,4869636],"length":1,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[4869176,4869270],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[4869500,4869318],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[4869404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[4869441,4869366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[4869484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[4869603,4869420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[4869195],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[4869661,4869227],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[4869728,4869669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[4869711,4869771,4869796],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[4869847,4869838,4869775],"length":1,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[4869896,4868721],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[4869888],"length":1,"stats":{"Line":3},"fn_name":null},{"line":147,"address":[4870016,4872253],"length":1,"stats":{"Line":1},"fn_name":"exact_matches"},{"line":148,"address":[4870087],"length":1,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[4870114],"length":1,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[4870144],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[4870315,4870179,4870508,4870738,4870250],"length":1,"stats":{"Line":10},"fn_name":null},{"line":153,"address":[4871321,4870577,4870748],"length":1,"stats":{"Line":6},"fn_name":null},{"line":154,"address":[4870788,4870839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[4870888,4870812,4871319],"length":1,"stats":{"Line":4},"fn_name":null},{"line":156,"address":[4870965,4870871],"length":1,"stats":{"Line":4},"fn_name":null},{"line":157,"address":[4871013,4871195],"length":1,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[4871099],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[4871136,4871061],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[4871179],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[4871286,4871115],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[4870890],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[4871339,4870922],"length":1,"stats":{"Line":4},"fn_name":null},{"line":170,"address":[4871347,4871649,4871816],"length":1,"stats":{"Line":4},"fn_name":null},{"line":171,"address":[4871602,4871543],"length":1,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[4871654,4871645,4871585],"length":1,"stats":{"Line":4},"fn_name":null},{"line":175,"address":[4871485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[4871705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[4871708,4871770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[4871750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[4871821,4871754,4871812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[4871997,4871854,4872224,4870414,4871965],"length":1,"stats":{"Line":8},"fn_name":null},{"line":187,"address":[4872173],"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[4872288],"length":1,"stats":{"Line":1},"fn_name":"get"},{"line":204,"address":[4872331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[4872400],"length":1,"stats":{"Line":0},"fn_name":"cmp"},{"line":218,"address":[4872414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[4872448],"length":1,"stats":{"Line":0},"fn_name":"partial_cmp"},{"line":224,"address":[4872462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[9377120],"length":1,"stats":{"Line":1},"fn_name":"setup"},{"line":241,"address":[9377133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[9377145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[9377164],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[9179744,9179749],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":249,"address":[9377271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[9377330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[9377359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[9377379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[9377503,9377573,9377423],"length":1,"stats":{"Line":3},"fn_name":null},{"line":257,"address":[9377620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[9377677,9377788],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[9179781,9179776],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":263,"address":[9377895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[9377951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[9377977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[9377984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[9378023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[9378075,9378194,9378264],"length":1,"stats":{"Line":2},"fn_name":null},{"line":280,"address":[9179808,9179813],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":281,"address":[9378375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[9378455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[9378484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[9378491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[9378571,9378527],"length":1,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[9378587,9378644,9378760],"length":1,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[9378792,9378956,9378697,9379320,9378936],"length":1,"stats":{"Line":4},"fn_name":null},{"line":289,"address":[9379334,9379084],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[9179845,9179840],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":295,"address":[9379479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[9379545],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[9379571],"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[9379601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[9379653,9379704,9379766],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":97,"coverable":115},{"path":["/","home","todd","rust-bio","src","data_structures","rank_select.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Rank/Select data structure based on Gonzalez, Grabowski, Mäkinen, Navarro (2005).\n//! This implementation uses only a single level of blocks, and performs well for large n.\n//!\n//! Example\n//!\n//! ```\n//! extern crate bv;\n//! # extern crate bio;\n//! # fn main() {\n//! use bio::data_structures::rank_select::RankSelect;\n//! use bv::BitVec;\n//! use bv::BitsMut;\n//!\n//! let mut bits: BitVec\u003cu8\u003e = BitVec::new_fill(false, 64);\n//! bits.set_bit(5, true);\n//! bits.set_bit(32, true);\n//! let rs = RankSelect::new(bits, 1);\n//! assert!(rs.rank(6).unwrap() == 1);\n//! # }\n//! ```\n\nuse std::cmp;\nuse std::ops::Deref;\n\nuse bv::BitVec;\nuse bv::Bits;\n\n/// A rank/select data structure.\n#[derive(Serialize, Deserialize)]\npub struct RankSelect {\n    n: usize,\n    bits: BitVec\u003cu8\u003e,\n    superblocks_1: Vec\u003cSuperblockRank\u003e,\n    superblocks_0: Vec\u003cSuperblockRank\u003e,\n    /// superblock size in bits\n    s: usize,\n    /// superblock size in 32 bits\n    k: usize,\n}\n\nimpl RankSelect {\n    /// Create a new instance.\n    ///\n    /// # Arguments\n    ///\n    /// * `bits` - A bit vector.\n    /// * `k` - Determines the size (k * 32 bits) of the superblocks.\n    ///   A small k means faster rank query times at the expense of using more\n    ///   space and slower select query times.\n    ///   The data structure needs O(n + n log n / (k * 32)) bits with n being the bits of the given bitvector.\n    ///   The data structure is succinct if k is chosen as a sublinear function of n\n    ///   (e.g. k = (log n)² / 32).\n    pub fn new(bits: BitVec\u003cu8\u003e, k: usize) -\u003e RankSelect {\n        let n = bits.len() as usize;\n        let s = k * 32;\n\n        RankSelect {\n            n,\n            s,\n            k,\n            superblocks_1: superblocks(true, n, s, \u0026bits),\n            superblocks_0: superblocks(false, n, s, \u0026bits),\n            bits,\n        }\n    }\n\n    /// Return the used k (see `RankSelect::new()`).\n    pub fn k(\u0026self) -\u003e usize {\n        self.k\n    }\n\n    /// Get internal representation of bit vector.\n    pub fn bits(\u0026self) -\u003e \u0026BitVec\u003cu8\u003e {\n        \u0026self.bits\n    }\n\n    /// Return i-th bit.\n    pub fn get(\u0026self, i: u64) -\u003e bool {\n        self.bits.get_bit(i)\n    }\n\n    /// Get the 1-rank of a given bit, i.e. the number of 1-bits in the bitvector up to i (inclusive).\n    /// Complexity: O(k).\n    ///\n    /// # Arguments\n    ///\n    /// * `i` - Position of the bit to determine the rank for.\n    pub fn rank_1(\u0026self, i: u64) -\u003e Option\u003cu64\u003e {\n        if i \u003e= self.n as u64 {\n            None\n        } else {\n            let s = i / self.s as u64; // the superblock\n            let b = i / 8; // the block\n            let j = i % 8; // the bit in the block\n                           // take the superblock rank\n            let mut rank = *self.superblocks_1[s as usize];\n            // add the rank within the block\n            let mask = ((2u16 \u003c\u003c j) - 1) as u8;\n            rank += (self.bits.get_block(b as usize) \u0026 mask).count_ones() as u64;\n            // add the popcounts of blocks from the beginning of the current superblock\n            // up to the current block\n            for block in (s * self.s as u64 / 8)..b {\n                let b = self.bits.get_block(block as usize);\n                rank += b.count_ones() as u64;\n            }\n\n            Some(rank)\n        }\n    }\n\n    /// Get the 0-rank of a given bit, i.e. the number of 0-bits in the bitvector up to i (inclusive).\n    /// Complexity: O(k).\n    ///\n    /// # Arguments\n    ///\n    /// * `i` - Position of the bit to determine the rank for.\n    pub fn rank_0(\u0026self, i: u64) -\u003e Option\u003cu64\u003e {\n        self.rank_1(i).map(|r| (i + 1) - r)\n    }\n\n    /// Alias for `RankSelect::rank_1`.\n    pub fn rank(\u0026self, i: u64) -\u003e Option\u003cu64\u003e {\n        self.rank_1(i)\n    }\n\n    /// Get the smallest bit with a given 1-rank.\n    /// Complexity: O(log (n / k) + k).\n    ///\n    /// # Arguments\n    ///\n    /// * `j` - The rank to find the smallest bit for.\n    pub fn select_1(\u0026self, j: u64) -\u003e Option\u003cu64\u003e {\n        self.select_x(\n            j,\n            \u0026self.superblocks_1,\n            |bit| bit != 0,\n            |block| block.count_ones(),\n        )\n    }\n\n    /// Get the smallest bit with a given 0-rank.\n    /// Complexity: O(log (n / k) + k).\n    ///\n    /// # Arguments\n    ///\n    /// * `j` - The rank to find the smallest bit for.\n    pub fn select_0(\u0026self, j: u64) -\u003e Option\u003cu64\u003e {\n        self.select_x(\n            j,\n            \u0026self.superblocks_0,\n            |bit| bit == 0,\n            |block| block.count_zeros(),\n        )\n    }\n\n    fn select_x\u003cF: Fn(u8) -\u003e bool, C: Fn(u8) -\u003e u32\u003e(\n        \u0026self,\n        j: u64,\n        superblocks: \u0026[SuperblockRank],\n        is_match: F,\n        count_all: C,\n    ) -\u003e Option\u003cu64\u003e {\n        if j == 0 {\n            return None;\n        }\n        let mut superblock = match superblocks.binary_search(\u0026SuperblockRank::First(j)) {\n            Ok(i) | Err(i) =\u003e i, // superblock with same rank exists\n        };\n        if superblock \u003e 0 {\n            superblock -= 1;\n        }\n        let mut rank = *superblocks[superblock];\n\n        let first_block = superblock * self.s / 8;\n        for block in first_block..cmp::min(first_block + self.s / 8, self.bits.block_len()) {\n            let b = self.bits.get_block(block);\n            let p = count_all(b) as u64;\n            if rank + p \u003e= j {\n                let mut bit = 0b1;\n                // do not look at unused bits of the last block\n                let max_bit = cmp::min(8, self.bits.len() - block as u64 * 8);\n                for i in 0..max_bit {\n                    rank += is_match(b \u0026 bit) as u64;\n                    if rank == j {\n                        return Some(block as u64 * 8 + i);\n                    }\n                    bit \u003c\u003c= 1;\n                }\n            }\n            rank += p;\n        }\n\n        None\n    }\n\n    /// Alias for `RankSelect::select_1`.\n    pub fn select(\u0026self, j: u64) -\u003e Option\u003cu64\u003e {\n        self.select_1(j)\n    }\n}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum SuperblockRank {\n    First(u64),\n    Some(u64),\n}\n\nimpl Deref for SuperblockRank {\n    type Target = u64;\n\n    fn deref(\u0026self) -\u003e \u0026u64 {\n        match self {\n            SuperblockRank::First(rank) =\u003e rank,\n            SuperblockRank::Some(rank) =\u003e rank,\n        }\n    }\n}\n\nimpl PartialOrd for SuperblockRank {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003ccmp::Ordering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for SuperblockRank {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e cmp::Ordering {\n        let cmp = (**self).cmp(\u0026**other);\n        if cmp == cmp::Ordering::Equal {\n            match (self, other) {\n                (SuperblockRank::First(_), SuperblockRank::Some(_)) =\u003e cmp::Ordering::Less,\n                (SuperblockRank::Some(_), SuperblockRank::First(_)) =\u003e cmp::Ordering::Greater,\n                _ =\u003e cmp,\n            }\n        } else {\n            cmp\n        }\n    }\n}\n\n/// Create `n` superblocks of size `s` from a given bitvector.\nfn superblocks(t: bool, n: usize, s: usize, bits: \u0026BitVec\u003cu8\u003e) -\u003e Vec\u003cSuperblockRank\u003e {\n    let mut superblocks = Vec::with_capacity(n / s + 1);\n    let mut rank: u64 = 0;\n    let mut last_rank = None;\n    let mut i = 0;\n    let nblocks = (bits.len() as f64 / 8.0).ceil() as usize;\n    for block in 0..nblocks {\n        let b = bits.get_block(block);\n        if i % s == 0 {\n            superblocks.push(if Some(rank) != last_rank {\n                SuperblockRank::First(rank)\n            } else {\n                SuperblockRank::Some(rank)\n            });\n            last_rank = Some(rank);\n        }\n        rank += if t {\n            b.count_ones() as u64\n        } else {\n            b.count_zeros() as u64\n        };\n        i += 8;\n    }\n\n    superblocks\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bv::bit_vec;\n    use bv::BitVec;\n    use bv::BitsMut;\n\n    #[test]\n    fn test_select_start() {\n        let mut bits: BitVec\u003cu8\u003e = BitVec::new_fill(false, 900);\n        bits.set_bit(64, true);\n\n        let rs = RankSelect::new(bits, 1);\n\n        assert_eq!(rs.select_1(1), Some(64));\n    }\n\n    #[test]\n    fn test_select_end() {\n        let mut bits: BitVec\u003cu8\u003e = BitVec::new_fill(false, 900);\n        bits.set_bit(50, true);\n\n        let rs = RankSelect::new(bits, 1);\n        assert_eq!(rs.select_1(1).unwrap(), 50);\n    }\n\n    #[test]\n    fn test_rank_select() {\n        let mut bits: BitVec\u003cu8\u003e = BitVec::new_fill(false, 64);\n        bits.set_bit(5, true);\n        bits.set_bit(32, true);\n        let rs = RankSelect::new(bits, 1);\n        assert_eq!(rs.rank_1(1).unwrap(), 0);\n        assert_eq!(rs.rank_1(5).unwrap(), 1);\n        assert_eq!(rs.rank_1(6).unwrap(), 1);\n        assert_eq!(rs.rank_1(7).unwrap(), 1);\n        assert_eq!(rs.rank_1(32).unwrap(), 2);\n        assert_eq!(rs.rank_1(33).unwrap(), 2);\n        assert_eq!(rs.rank_1(64), None);\n        assert_eq!(rs.select_1(0), None);\n        assert_eq!(rs.select_1(1).unwrap(), 5);\n        assert_eq!(rs.select_1(2).unwrap(), 32);\n        assert_eq!(rs.rank_0(1).unwrap(), 2);\n        assert_eq!(rs.rank_0(4).unwrap(), 5);\n        assert_eq!(rs.rank_0(5).unwrap(), 5);\n        assert_eq!(rs.select_0(0), None);\n        assert_eq!(rs.select_0(1).unwrap(), 0);\n        assert_eq!(rs.get(5), true);\n        assert_eq!(rs.get(1), false);\n        assert_eq!(rs.get(32), true);\n    }\n\n    #[test]\n    fn test_rank_select2() {\n        let mut bits: BitVec\u003cu8\u003e = BitVec::new_fill(false, 64);\n        bits.set_bit(5, true);\n        bits.set_bit(32, true);\n        let rs = RankSelect::new(bits, 1);\n        assert_eq!(rs.select_1(2).unwrap(), 32);\n    }\n\n    #[test]\n    fn test_select() {\n        let bits: BitVec\u003cu8\u003e = bit_vec![true, false];\n        let rs = RankSelect::new(bits, 1);\n\n        assert_eq!(rs.select_0(0), None);\n        assert_eq!(rs.select_1(0), None);\n\n        assert_eq!(rs.select_0(1), Some(1));\n        assert_eq!(rs.select_1(1), Some(0));\n\n        assert_eq!(rs.select_0(2), None);\n        assert_eq!(rs.select_1(2), None);\n    }\n\n    #[test]\n    fn test_single_select() {\n        let bits: BitVec\u003cu8\u003e = bit_vec![true];\n        let rs = RankSelect::new(bits, 1);\n        assert_eq!(rs.select_1(0), None);\n        assert_eq!(rs.select_1(1), Some(0));\n        assert_eq!(rs.select_0(0), None);\n        assert_eq!(rs.select_0(1), None);\n\n        let bits: BitVec\u003cu8\u003e = bit_vec![false];\n        let rs = RankSelect::new(bits, 1);\n        assert_eq!(rs.select_1(1), None);\n        assert_eq!(rs.select_1(0), None);\n        assert_eq!(rs.select_0(0), None);\n        assert_eq!(rs.select_0(1), Some(0));\n        assert_eq!(rs.rank_0(0), Some(1));\n        assert_eq!(rs.rank_1(0), Some(0));\n    }\n\n    #[test]\n    fn test_rank_k() {\n        let mut bits: BitVec\u003cu8\u003e = BitVec::new_fill(false, 72);\n        bits.set_bit(63, true);\n        let rs = RankSelect::new(bits, 2);\n        assert_eq!(rs.rank_1(63), Some(1));\n        assert_eq!(rs.rank_1(64), Some(1));\n        assert_eq!(rs.rank_1(71), Some(1));\n    }\n}\n","traces":[{"line":58,"address":[4421856,4422294,4422309],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":59,"address":[4421902],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[4422014,4422039,4421939],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[4422032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[4422093],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[4422320],"length":1,"stats":{"Line":0},"fn_name":"k"},{"line":74,"address":[4422325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[4422336],"length":1,"stats":{"Line":1},"fn_name":"bits"},{"line":79,"address":[4422344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[4422352],"length":1,"stats":{"Line":1},"fn_name":"get"},{"line":84,"address":[4422366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[4422400],"length":1,"stats":{"Line":2},"fn_name":"rank_1"},{"line":94,"address":[4422433,4423195],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[4422469],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[4422443,4422607,4422520],"length":1,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[4422546],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[4422566],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[4422583,4422642],"length":1,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[4422803,4422674],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[4422965,4422841,4422902,4422787],"length":1,"stats":{"Line":6},"fn_name":null},{"line":107,"address":[4423005,4422947,4423354,4423205],"length":1,"stats":{"Line":8},"fn_name":null},{"line":108,"address":[4423237],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[4423359,4423321,4423389],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[4423167],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[4423392],"length":1,"stats":{"Line":2},"fn_name":"rank_0"},{"line":123,"address":[4423406],"length":1,"stats":{"Line":6},"fn_name":null},{"line":127,"address":[4423488],"length":1,"stats":{"Line":0},"fn_name":"rank"},{"line":128,"address":[4423502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[4423536],"length":1,"stats":{"Line":2},"fn_name":"select_1"},{"line":138,"address":[4423600],"length":1,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[4423560],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[4680656,4680671],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":142,"address":[4680688,4680759,4680754],"length":1,"stats":{"Line":5},"fn_name":"{{closure}}"},{"line":152,"address":[4423632],"length":1,"stats":{"Line":2},"fn_name":"select_0"},{"line":153,"address":[4423696],"length":1,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[4423656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[4680768,4680783],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":157,"address":[4680873,4680878,4680800],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":161,"address":[4682965,4682950,4682976,4685046,4685061,4680880],"length":1,"stats":{"Line":4},"fn_name":"select_x\u003cclosure-0,closure-1\u003e"},{"line":168,"address":[4680951,4683047],"length":1,"stats":{"Line":4},"fn_name":null},{"line":169,"address":[4680957,4683053],"length":1,"stats":{"Line":4},"fn_name":null},{"line":171,"address":[4680998,4683231,4683249,4683094,4681135,4681153],"length":1,"stats":{"Line":8},"fn_name":null},{"line":172,"address":[4683233,4683251,4681155,4683187,4681091,4681137],"length":1,"stats":{"Line":12},"fn_name":null},{"line":174,"address":[4681243,4683339,4681187,4683283],"length":1,"stats":{"Line":8},"fn_name":null},{"line":175,"address":[4681200,4683341,4683296,4681245],"length":1,"stats":{"Line":4},"fn_name":null},{"line":177,"address":[4681285,4683381],"length":1,"stats":{"Line":4},"fn_name":null},{"line":179,"address":[4681419,4681510,4683515,4683606],"length":1,"stats":{"Line":5},"fn_name":null},{"line":180,"address":[4681482,4684978,4681878,4681551,4682882,4683647,4683974,4683578],"length":1,"stats":{"Line":17},"fn_name":null},{"line":181,"address":[4684014,4681918],"length":1,"stats":{"Line":5},"fn_name":null},{"line":182,"address":[4684052,4681956],"length":1,"stats":{"Line":4},"fn_name":null},{"line":183,"address":[4682017,4684113,4684568,4682472],"length":1,"stats":{"Line":7},"fn_name":null},{"line":184,"address":[4684205,4682109],"length":1,"stats":{"Line":5},"fn_name":null},{"line":186,"address":[4684213,4682117],"length":1,"stats":{"Line":5},"fn_name":null},{"line":187,"address":[4682484,4682841,4684580,4684399,4684937,4682303],"length":1,"stats":{"Line":15},"fn_name":null},{"line":188,"address":[4682521,4682628,4684617,4684724],"length":1,"stats":{"Line":5},"fn_name":null},{"line":189,"address":[4682616,4684712],"length":1,"stats":{"Line":6},"fn_name":null},{"line":190,"address":[4682688,4682795,4684784,4684891],"length":1,"stats":{"Line":4},"fn_name":null},{"line":192,"address":[4684757,4682834,4682661,4684930],"length":1,"stats":{"Line":12},"fn_name":null},{"line":195,"address":[4684947,4682851,4684983,4682887],"length":1,"stats":{"Line":4},"fn_name":null},{"line":198,"address":[4681853,4683949],"length":1,"stats":{"Line":4},"fn_name":null},{"line":202,"address":[4423728],"length":1,"stats":{"Line":0},"fn_name":"select"},{"line":203,"address":[4423742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[4423776],"length":1,"stats":{"Line":2},"fn_name":"deref"},{"line":217,"address":[4423801,4423821],"length":1,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[4423789,4423807],"length":1,"stats":{"Line":4},"fn_name":null},{"line":219,"address":[4423827],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[4423856],"length":1,"stats":{"Line":0},"fn_name":"partial_cmp"},{"line":226,"address":[4423870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[4423904],"length":1,"stats":{"Line":2},"fn_name":"cmp"},{"line":232,"address":[4423928],"length":1,"stats":{"Line":2},"fn_name":null},{"line":233,"address":[4424013,4423974],"length":1,"stats":{"Line":4},"fn_name":null},{"line":234,"address":[4424025,4424074,4424121,4424119],"length":1,"stats":{"Line":6},"fn_name":null},{"line":235,"address":[4424076,4424035,4424114],"length":1,"stats":{"Line":5},"fn_name":null},{"line":236,"address":[4424089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[4424066],"length":1,"stats":{"Line":3},"fn_name":null},{"line":240,"address":[4424005],"length":1,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[4424128,4425496,4425511],"length":1,"stats":{"Line":2},"fn_name":"superblocks"},{"line":247,"address":[4424209],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[4424339],"length":1,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[4424351],"length":1,"stats":{"Line":2},"fn_name":null},{"line":250,"address":[4424363],"length":1,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[4424518,4424375],"length":1,"stats":{"Line":4},"fn_name":null},{"line":252,"address":[4424790,4424600,4425458],"length":1,"stats":{"Line":6},"fn_name":null},{"line":253,"address":[4424822],"length":1,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[4424855,4424995,4425180],"length":1,"stats":{"Line":6},"fn_name":null},{"line":255,"address":[4425055,4425021,4424934,4425093],"length":1,"stats":{"Line":7},"fn_name":null},{"line":256,"address":[4425057],"length":1,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[4425027],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[4425120],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[4425004,4425373,4425413,4425329],"length":1,"stats":{"Line":6},"fn_name":null},{"line":263,"address":[4425319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[4425363],"length":1,"stats":{"Line":2},"fn_name":null},{"line":267,"address":[4425463,4425388,4425450],"length":1,"stats":{"Line":4},"fn_name":null},{"line":281,"address":[6267336,6266896],"length":1,"stats":{"Line":3},"fn_name":"test_select_start"},{"line":282,"address":[6266903],"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[6266951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[6266958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[6267274,6267247,6267068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":291,"address":[6267827,6267376],"length":1,"stats":{"Line":3},"fn_name":"test_select_end"},{"line":292,"address":[6267383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[6267431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[6267438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[6267548,6267760,6267646],"length":1,"stats":{"Line":2},"fn_name":null},{"line":300,"address":[6267856,6272526],"length":1,"stats":{"Line":3},"fn_name":"test_rank_select"},{"line":301,"address":[6267863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[6267917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[6267942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[6267990],"length":1,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[6268351,6268071,6268193],"length":1,"stats":{"Line":2},"fn_name":null},{"line":306,"address":[6268306,6268418,6268613],"length":1,"stats":{"Line":2},"fn_name":null},{"line":307,"address":[6268681,6268568,6268876],"length":1,"stats":{"Line":2},"fn_name":null},{"line":308,"address":[6269139,6268944,6268831],"length":1,"stats":{"Line":2},"fn_name":null},{"line":309,"address":[6269094,6269207,6269402],"length":1,"stats":{"Line":2},"fn_name":null},{"line":310,"address":[6269665,6269357,6269470],"length":1,"stats":{"Line":2},"fn_name":null},{"line":311,"address":[6269733,6269620,6269918],"length":1,"stats":{"Line":2},"fn_name":null},{"line":312,"address":[6269873,6270167,6269981],"length":1,"stats":{"Line":2},"fn_name":null},{"line":313,"address":[6270230,6270425,6270122],"length":1,"stats":{"Line":2},"fn_name":null},{"line":314,"address":[6270688,6270380,6270493],"length":1,"stats":{"Line":2},"fn_name":null},{"line":315,"address":[6270643,6270951,6270756],"length":1,"stats":{"Line":2},"fn_name":null},{"line":316,"address":[6271019,6270906,6271214],"length":1,"stats":{"Line":2},"fn_name":null},{"line":317,"address":[6271282,6271476,6271169],"length":1,"stats":{"Line":2},"fn_name":null},{"line":318,"address":[6271431,6271544,6271718],"length":1,"stats":{"Line":2},"fn_name":null},{"line":319,"address":[6271682,6271775,6271936],"length":1,"stats":{"Line":2},"fn_name":null},{"line":320,"address":[6271992,6272118,6271913],"length":1,"stats":{"Line":2},"fn_name":null},{"line":321,"address":[6272297,6272095,6272169],"length":1,"stats":{"Line":2},"fn_name":null},{"line":322,"address":[6272274,6272348,6272463],"length":1,"stats":{"Line":2},"fn_name":null},{"line":326,"address":[6272560,6273036],"length":1,"stats":{"Line":3},"fn_name":"test_rank_select2"},{"line":327,"address":[6272567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[6272615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":329,"address":[6272637],"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[6272685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":331,"address":[6272969,6272754,6272855],"length":1,"stats":{"Line":2},"fn_name":null},{"line":335,"address":[6273072,6273294],"length":1,"stats":{"Line":3},"fn_name":"test_select"},{"line":336,"address":[6273079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[6273218],"length":1,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[6273591,6273528,6273321],"length":1,"stats":{"Line":2},"fn_name":null},{"line":340,"address":[6273839,6273653,6273546],"length":1,"stats":{"Line":2},"fn_name":null},{"line":342,"address":[6273902,6274076,6273794],"length":1,"stats":{"Line":2},"fn_name":null},{"line":343,"address":[6274295,6274040,6274133],"length":1,"stats":{"Line":2},"fn_name":null},{"line":345,"address":[6274352,6274262,6274514],"length":1,"stats":{"Line":2},"fn_name":null},{"line":346,"address":[6274571,6274710,6274481],"length":1,"stats":{"Line":2},"fn_name":null},{"line":350,"address":[6274970,6274768],"length":1,"stats":{"Line":3},"fn_name":"test_single_select"},{"line":351,"address":[6274932,6274775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[6274856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[6275268,6274997,6275204],"length":1,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[6275330,6275223,6275515],"length":1,"stats":{"Line":2},"fn_name":null},{"line":355,"address":[6275764,6275470,6275578],"length":1,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[6275827,6275986,6275719],"length":1,"stats":{"Line":2},"fn_name":null},{"line":358,"address":[6276043,6276142,6275963],"length":1,"stats":{"Line":2},"fn_name":null},{"line":359,"address":[6276082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":360,"address":[6276196,6276403,6276466],"length":1,"stats":{"Line":2},"fn_name":null},{"line":361,"address":[6276529,6276421,6276714],"length":1,"stats":{"Line":2},"fn_name":null},{"line":362,"address":[6276669,6276777,6276957],"length":1,"stats":{"Line":2},"fn_name":null},{"line":363,"address":[6276918,6277175,6277014],"length":1,"stats":{"Line":2},"fn_name":null},{"line":364,"address":[6277142,6277232,6277393],"length":1,"stats":{"Line":2},"fn_name":null},{"line":365,"address":[6277591,6277360,6277450],"length":1,"stats":{"Line":2},"fn_name":null},{"line":369,"address":[6277664,6278557],"length":1,"stats":{"Line":3},"fn_name":"test_rank_k"},{"line":370,"address":[6277671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":371,"address":[6277719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":372,"address":[6277726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[6278080,6277845,6278028],"length":1,"stats":{"Line":2},"fn_name":null},{"line":374,"address":[6278047,6278136,6278298],"length":1,"stats":{"Line":2},"fn_name":null},{"line":375,"address":[6278494,6278265,6278355],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":155,"coverable":165},{"path":["/","home","todd","rust-bio","src","data_structures","smallints.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A data structure for a sequence of small integers with a few big integers.\n//! Small ints are stored in type S (e.g. a byte), big ints are stored separately (in type B) in a BTree.\n//! The implementation provides vector-like operations on the data structure (e.g. retrieve a position,\n//! add an integer, etc.).\n//!\n//! # Example\n//!\n//! ```\n//! use bio::data_structures::smallints::SmallInts;\n//! let mut smallints: SmallInts\u003cu8, usize\u003e = SmallInts::new();\n//! smallints.push(3);\n//! smallints.push(4);\n//! smallints.push(255);\n//! smallints.push(305093);\n//! assert_eq!(smallints.get(0).unwrap(), 3);\n//! smallints.set(0, 50000);\n//! let values: Vec\u003cusize\u003e = smallints.iter().collect();\n//! assert_eq!(values, [50000, 4, 255, 305093]);\n//! ```\n\nuse std::collections::BTreeMap;\nuse std::iter::{repeat, Enumerate};\nuse std::mem::size_of;\nuse std::slice;\n\nuse num_integer::Integer;\nuse num_traits::{cast, Bounded, Num, NumCast};\n\n/// Data structure for storing a sequence of small integers with few big ones space efficiently\n/// while supporting classical vector operations.\n#[derive(Serialize, Deserialize)]\npub struct SmallInts\u003cF: Integer + Bounded + NumCast + Copy, B: Integer + NumCast + Copy\u003e {\n    smallints: Vec\u003cF\u003e,\n    bigints: BTreeMap\u003cusize, B\u003e,\n}\n\nimpl\u003cS: Integer + Bounded + NumCast + Copy, B: Integer + NumCast + Copy\u003e Default\n    for SmallInts\u003cS, B\u003e\n{\n    fn default() -\u003e Self {\n        assert!(\n            size_of::\u003cS\u003e() \u003c size_of::\u003cB\u003e(),\n            \"S has to be smaller than B\"\n        );\n        SmallInts {\n            smallints: Vec::new(),\n            bigints: BTreeMap::new(),\n        }\n    }\n}\n\nimpl\u003cS: Integer + Bounded + NumCast + Copy, B: Integer + NumCast + Copy\u003e SmallInts\u003cS, B\u003e {\n    /// Create a new instance.\n    pub fn new() -\u003e Self {\n        Default::default()\n    }\n\n    /// Create a new instance with a given capacity.\n    pub fn with_capacity(n: usize) -\u003e Self {\n        assert!(\n            size_of::\u003cS\u003e() \u003c size_of::\u003cB\u003e(),\n            \"S has to be smaller than B\"\n        );\n        SmallInts {\n            smallints: Vec::with_capacity(n),\n            bigints: BTreeMap::new(),\n        }\n    }\n\n    /// Create a new instance containing `n` times the integer `v` (and `v` is expected to be small).\n    pub fn from_elem(v: S, n: usize) -\u003e Self {\n        assert!(\n            size_of::\u003cS\u003e() \u003c size_of::\u003cB\u003e(),\n            \"S has to be smaller than B\"\n        );\n        if v \u003e cast(0).unwrap() {\n            assert!(v \u003c S::max_value(), \"v has to be smaller than maximum value\");\n        }\n\n        SmallInts {\n            smallints: repeat(v).take(n).collect(),\n            bigints: BTreeMap::new(),\n        }\n    }\n\n    /// Return the integer at position `i`.\n    pub fn get(\u0026self, i: usize) -\u003e Option\u003cB\u003e {\n        if i \u003c self.smallints.len() {\n            self.real_value(i, self.smallints[i])\n        } else {\n            None\n        }\n    }\n\n    /// Append `v` to the sequence. This will determine whether `v` is big or small and store it accordingly.\n    pub fn push(\u0026mut self, v: B) {\n        let maxv: S = S::max_value();\n        match cast(v) {\n            Some(v) if v \u003c maxv =\u003e self.smallints.push(v),\n            _ =\u003e {\n                let i = self.smallints.len();\n                self.smallints.push(maxv);\n                self.bigints.insert(i, v);\n            }\n        }\n    }\n\n    /// Set value of position `i` to `v`. This will determine whether `v` is big or small and store it accordingly.\n    pub fn set(\u0026mut self, i: usize, v: B) {\n        let maxv: S = S::max_value();\n        match cast(v) {\n            Some(v) if v \u003c maxv =\u003e self.smallints[i] = v,\n            _ =\u003e {\n                self.smallints[i] = maxv;\n                self.bigints.insert(i, v);\n            }\n        }\n    }\n\n    /// Iterate over sequence. Values will be returned in the big integer type (`B`).\n    pub fn iter(\u0026self) -\u003e Iter\u003c'_, S, B\u003e {\n        Iter {\n            smallints: self,\n            items: self.smallints.iter().enumerate(),\n        }\n    }\n\n    /// Decompress into a normal vector of big integers (type `B`).\n    pub fn decompress(\u0026self) -\u003e Vec\u003cB\u003e {\n        self.iter().collect()\n    }\n\n    /// Length of the sequence.\n    pub fn len(\u0026self) -\u003e usize {\n        self.smallints.len()\n    }\n\n    /// is the sequence empty?\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.smallints.is_empty()\n    }\n\n    fn real_value(\u0026self, i: usize, v: S) -\u003e Option\u003cB\u003e {\n        if v \u003c S::max_value() {\n            cast(v)\n        } else {\n            self.bigints.get(\u0026i).cloned()\n        }\n    }\n}\n\n/// Iterator over the elements of a `SmallInts` sequence.\npub struct Iter\u003c'a, S, B\u003e\nwhere\n    S: Integer + Bounded + NumCast + Copy,\n    B: Integer + NumCast + Copy,\n    \u003cS as Num\u003e::FromStrRadixErr: 'a,\n    \u003cB as Num\u003e::FromStrRadixErr: 'a,\n{\n    smallints: \u0026'a SmallInts\u003cS, B\u003e,\n    items: Enumerate\u003cslice::Iter\u003c'a, S\u003e\u003e,\n}\n\nimpl\u003c'a, S, B\u003e Iterator for Iter\u003c'a, S, B\u003e\nwhere\n    S: 'a + Integer + Bounded + NumCast + Copy,\n    B: 'a + Integer + NumCast + Copy,\n    \u003cS as Num\u003e::FromStrRadixErr: 'a,\n    \u003cB as Num\u003e::FromStrRadixErr: 'a,\n{\n    type Item = B;\n\n    fn next(\u0026mut self) -\u003e Option\u003cB\u003e {\n        match self.items.next() {\n            Some((i, \u0026v)) =\u003e self.smallints.real_value(i, v),\n            None =\u003e None,\n        }\n    }\n}\n\n#[cfg(tests)]\nmod tests {\n    #[test]\n    fn test_serde() {\n        use serde::{Deserialize, Serialize};\n        fn impls_serde_traits\u003cS: Serialize + Deserialize\u003e() {}\n\n        impls_serde_traits::\u003cSmallInts\u003ci8, isize\u003e\u003e();\n    }\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":54},{"path":["/","home","todd","rust-bio","src","data_structures","suffix_array.rs"],"content":"// Copyright 2014-2016 Johannes Köster, Taylor Cramer.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Suffix arrays and related algorithms.\n//! The implementation is based on the lecture notes\n//! \"Algorithmen auf Sequenzen\", Kopczynski, Marschall, Martin and Rahmann, 2008 - 2015.\n//! The original algorithm desciption can be found in:\n//! [Ge Nong, Sen Zhang, Wai Hong Chan: Two Efficient Algorithms for Linear Time Suffix Array Construction. IEEE Trans. Computers 60(10): 1471–1484 (2011)](https://doi.org/10.1109/TC.2010.188)\n//!\n//! # Examples\n//!\n//! ```\n//! use bio::data_structures::suffix_array::suffix_array;\n//! let text = b\"GCCTTAACATTATTACGCCTA$\";\n//! let pos = suffix_array(text);\n//! assert_eq!(\n//!     pos,\n//!     vec![21, 20, 5, 6, 14, 11, 8, 7, 17, 1, 15, 18, 2, 16, 0, 19, 4, 13, 10, 3, 12, 9]\n//! );\n//! ```\n\nuse std::cmp;\nuse std::fmt::Debug;\nuse std::iter;\nuse std::ops::Deref;\n\nuse num_integer::Integer;\nuse num_traits::{cast, NumCast, Unsigned};\n\nuse bv::{BitVec, Bits, BitsMut};\nuse vec_map::VecMap;\n\nuse crate::alphabets::{Alphabet, RankTransform};\nuse crate::data_structures::smallints::SmallInts;\n\npub type LCPArray = SmallInts\u003ci8, isize\u003e;\npub type RawSuffixArray = Vec\u003cusize\u003e;\npub type RawSuffixArraySlice\u003c'a\u003e = \u0026'a [usize];\n\n/// A trait exposing general functionality of suffix arrays.\npub trait SuffixArray {\n    fn get(\u0026self, index: usize) -\u003e Option\u003cusize\u003e;\n    fn len(\u0026self) -\u003e usize;\n    fn is_empty(\u0026self) -\u003e bool;\n\n    // /// Sample the suffix array with the given sample rate.\n    // ///\n    // /// # Arguments\n    // ///\n    // /// * `bwt` - the corresponding BWT\n    // /// * `less` - the corresponding less array\n    // /// * `occ` - the corresponding occ table\n    // /// * `sampling_rate` - if sampling rate is k, every k-th entry will be kept\n    // ///\n    // /// # Example\n    // ///\n    // /// ```\n    // /// use bio::data_structures::suffix_array::{suffix_array, SuffixArray};\n    // /// use bio::data_structures::bwt::{bwt, less, Occ};\n    // /// use bio::alphabets::dna;\n    // ///\n    // /// let text = b\"ACGCGAT$\";\n    // /// let alphabet = dna::n_alphabet();\n    // /// let sa = suffix_array(text);\n    // /// let bwt = bwt(text, \u0026sa);\n    // /// let less = less(\u0026bwt, \u0026alphabet);\n    // /// let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n    // /// let sampled = sa.sample(\u0026bwt, \u0026less, \u0026occ, 1);\n    // ///\n    // /// for i in 0..sa.len() {\n    // ///    assert_eq!(sa.get(i), sampled.get(i));\n    // /// }\n    // /// ```\n    // fn sample\u003cDBWT: DerefBWT, DLess: DerefLess, DOcc: DerefOcc\u003e\n    //     (\u0026self, bwt: DBWT, less: DLess, occ: DOcc, sampling_rate: usize) -\u003e\n    //     SampledSuffixArray\u003cDBWT, DLess, DOcc\u003e {\n    //\n    //     let mut sample = Vec::with_capacity((self.len() as f32 / sampling_rate as f32).ceil() as usize);\n    //     for i in 0..self.len() {\n    //         if (i % sampling_rate) == 0 {\n    //             sample.push(self.get(i).unwrap());\n    //         }\n    //     }\n    //\n    //     SampledSuffixArray {\n    //         bwt: bwt,\n    //         less: less,\n    //         occ: occ,\n    //         sample: sample,\n    //         s: sampling_rate,\n    //     }\n    // }\n}\n\n// /// A sampled suffix array.\n// pub struct SampledSuffixArray\u003cDBWT: DerefBWT, DLess: DerefLess, DOcc: DerefOcc\u003e {\n//     bwt: DBWT,\n//     less: DLess,\n//     occ: DOcc,\n//     sample: Vec\u003cusize\u003e,\n//     s: usize, // Rate of sampling\n// }\n\nimpl SuffixArray for RawSuffixArray {\n    fn get(\u0026self, index: usize) -\u003e Option\u003cusize\u003e {\n        // Explicitly written out because Vec::get(index) generates a recursion warning\n        if index \u003c self.len() {\n            Some(self[index])\n        } else {\n            None\n        }\n    }\n\n    fn len(\u0026self) -\u003e usize {\n        Vec::len(self)\n    }\n\n    fn is_empty(\u0026self) -\u003e bool {\n        Vec::is_empty(self)\n    }\n\n    // fn sample\u003cDBWT: DerefBWT, DLess: DerefLess, DOcc: DerefOcc\u003e\n    //     (\u0026self, bwt: DBWT, less: DLess, occ: DOcc, sampling_rate: usize) -\u003e\n    //     SampledSuffixArray\u003cDBWT, DLess, DOcc\u003e {\n    //     // Provide a specialized, faster implementation using iterators.\n    //\n    //     let sample = self.iter().cloned().step(sampling_rate).collect();\n    //\n    //     SampledSuffixArray {\n    //         bwt: bwt,\n    //         less: less,\n    //         occ: occ,\n    //         sample: sample,\n    //         s: sampling_rate,\n    //     }\n    // }\n}\n\n// impl\u003cDBWT: DerefBWT, DLess: DerefLess, DOcc: DerefOcc\u003e SuffixArray for SampledSuffixArray\u003cDBWT, DLess, DOcc\u003e {\n//     fn get(\u0026self, index: usize) -\u003e Option\u003cusize\u003e {\n//         if index \u003c self.len() {\n//             let mut pos = index;\n//             let mut offset = 0;\n//             loop {\n//                 if pos % self.s == 0 {\n//                     return Some(self.sample[pos / self.s] + offset);\n//                 }\n//\n//                 let c = self.bwt[pos];\n//                 pos = self.less[c as usize] + self.occ.get(\u0026self.bwt, pos - 1, c);\n//                 offset += 1;\n//             }\n//         } else {\n//             None\n//         }\n//     }\n//\n//     fn len(\u0026self) -\u003e usize {\n//         self.bwt.len()\n//     }\n\n//     fn is_empty(\u0026self) -\u003e bool {\n//         self.bwt.is_empty()\n//     }\n// }\n//\n//\n// impl\u003cDBWT: DerefBWT, DLess: DerefLess, DOcc: DerefOcc\u003e SampledSuffixArray\u003cDBWT, DLess, DOcc\u003e {\n//     pub fn sampling_rate(\u0026self) -\u003e usize {\n//         self.s\n//     }\n// }\n\n/// Construct suffix array for given text of length n.\n/// Complexity: O(n).\n/// This is an implementation of the induced sorting as presented by\n/// Ge Nong, Sen Zhang und Wai Hong Chan (2009), also known as SAIS.\n/// The implementation is based on the following lecture notes:\n/// http://ls11-www.cs.tu-dortmund.de/people/rahmann/algoseq.pdf\n///\n/// The idea is to first mark positions as L or S, with L being a position\n/// the suffix of which is lexicographically larger than that of the next position.\n/// Then, LMS-positions (leftmost S) are S-positions right to an L-position.\n/// An LMS substring is the substring from one LMS position to the next (inclusive).\n/// The algorithm works as follows:\n///\n/// 1. Sort LMS positions: first step 2 is applied to the unsorted sequence\n///    of positions. Surprisingly, this sorts the LMS substrings. If all substrings\n///    are different, LMS positions (and their suffixes) are sorted. Else, a reduced\n///    text is build (at most half the size of the original text) and we recurse into\n///    suffix array construction on the reduced text, yielding the sorted LMS positions.\n/// 2. Derive the order of the other positions/suffixes from the (sorted) LMS positions.\n///    For this, the (still empty) suffix array is partitioned into buckets.\n///    Each bucket denotes an interval of suffixes with the same first symbol.\n///    We know that the L-suffixes have to occur first in the buckets, because they\n///    have to be lexicographically smaller than the S-suffixes with the same first letter.\n///    The LMS-positions can now be used to insert the L-positions in the correct order\n///    into the buckets.\n///    Then, the S-positions can be inserted, again using the already existing entries\n///    in the array.\n///\n/// # Arguments\n///\n/// * `text` - the text, ended by sentinel symbol (being lexicographically smallest). The text may\n///   also contain multiple sentinel symbols, used to concatenate multiple sequences without mixing\n///   their suffixes together.\n///\n/// # Example\n///\n/// ```\n/// use bio::data_structures::suffix_array::suffix_array;\n/// let text = b\"GCCTTAACATTATTACGCCTA$\";\n/// let pos = suffix_array(text);\n/// assert_eq!(\n///     pos,\n///     vec![21, 20, 5, 6, 14, 11, 8, 7, 17, 1, 15, 18, 2, 16, 0, 19, 4, 13, 10, 3, 12, 9]\n/// );\n/// ```\npub fn suffix_array(text: \u0026[u8]) -\u003e RawSuffixArray {\n    let n = text.len();\n    let alphabet = Alphabet::new(text);\n    let sentinel_count = sentinel_count(text);\n    let mut sais = SAIS::new(n);\n\n    match alphabet.len() + sentinel_count {\n        a if a \u003c= std::u8::MAX as usize =\u003e {\n            sais.construct(\u0026transform_text::\u003cu8\u003e(text, \u0026alphabet, sentinel_count))\n        }\n        a if a \u003c= std::u16::MAX as usize =\u003e {\n            sais.construct(\u0026transform_text::\u003cu16\u003e(text, \u0026alphabet, sentinel_count))\n        }\n        a if a \u003c= std::u32::MAX as usize =\u003e {\n            sais.construct(\u0026transform_text::\u003cu32\u003e(text, \u0026alphabet, sentinel_count))\n        }\n        _ =\u003e sais.construct(\u0026transform_text::\u003cu64\u003e(text, \u0026alphabet, sentinel_count)),\n    }\n\n    sais.pos\n}\n\n/// Construct lcp array for given text and suffix array of length n.\n/// Complexity: O(n).\n///\n/// # Arguments\n///\n/// * `text` - the text ended by sentinel symbol (being lexicographically smallest)\n/// * `pos` - the suffix array for the text\n///\n/// # Example\n///\n/// ```\n/// use bio::data_structures::suffix_array::{lcp, suffix_array};\n/// let text = b\"GCCTTAACATTATTACGCCTA$\";\n/// let pos = suffix_array(text);\n///\n/// // obtain compressed LCP array\n/// let lcp = lcp(text, \u0026pos);\n///\n/// // get most values in O(1).\n/// assert_eq!(lcp.get(6).unwrap(), 4);\n///\n/// // obtain uncompressed LCP array.\n/// let uncompressed = lcp.decompress();\n/// assert_eq!(\n///     uncompressed,\n///     [-1, 0, 1, 1, 2, 1, 4, 0, 1, 3, 1, 1, 2, 0, 4, 0, 2, 2, 2, 1, 3, 3, -1]\n/// )\n/// ```\npub fn lcp\u003cSA: Deref\u003cTarget = RawSuffixArray\u003e\u003e(text: \u0026[u8], pos: SA) -\u003e LCPArray {\n    assert_eq!(text.len(), pos.len());\n    let n = text.len();\n\n    // provide the lexicographical rank for each suffix\n    let mut rank: Vec\u003cusize\u003e = iter::repeat(0).take(n).collect();\n    for (r, p) in pos.iter().enumerate() {\n        rank[*p] = r;\n    }\n\n    let mut lcp = SmallInts::from_elem(-1, n + 1);\n    let mut l = 0usize;\n    for (p, \u0026r) in rank.iter().enumerate().take(n - 1) {\n        // since the sentinel has rank 0 and is excluded above,\n        // we will never have a negative index below\n        let pred = pos[r - 1];\n        while pred + l \u003c n \u0026\u0026 p + l \u003c n \u0026\u0026 text[p + l] == text[pred + l] {\n            l += 1;\n        }\n        lcp.set(r, l as isize);\n        l = if l \u003e 0 { l - 1 } else { 0 };\n    }\n\n    lcp\n}\n\n/// Calculate all locally shortest unique substrings from a given suffix and lcp array\n/// (Ohlebusch (2013). \"Bioinformatics Algorithms\". ISBN 978-3-00-041316-2).\n/// Complexity: O(n)\n///\n/// # Arguments\n///\n/// * `pos` - the suffix array\n/// * `lcp` - the lcp array\n///\n/// # Returns\n///\n/// An vector of the length of the shortest unique substring for each position of the text.\n/// Suffixes are excluded. If no unique substring starts at a given position, the entry is `None`.\n///\n/// # Example\n///\n/// ```\n/// use bio::data_structures::suffix_array::{lcp, shortest_unique_substrings, suffix_array};\n/// let text = b\"GCTGCTA$\";\n/// let pos = suffix_array(text);\n///\n/// // obtain compressed LCP array\n/// let lcp = lcp(text, \u0026pos);\n///\n/// // calculate shortest unique substrings\n/// let sus = shortest_unique_substrings(\u0026pos, \u0026lcp);\n/// assert_eq!(\n///     sus,\n///     [\n///         Some(4),\n///         Some(3),\n///         Some(2),\n///         Some(4),\n///         Some(3),\n///         Some(2),\n///         Some(1),\n///         Some(1)\n///     ]\n/// );\n/// ```\npub fn shortest_unique_substrings\u003cSA: SuffixArray\u003e(pos: \u0026SA, lcp: \u0026LCPArray) -\u003e Vec\u003cOption\u003cusize\u003e\u003e {\n    let n = pos.len();\n    // Initialize array representing the length of the shortest unique substring starting at position i\n    let mut sus = vec![None; n];\n    for i in 0..n {\n        // The longest common prefixes (LCP) of suffix pos[i] with its predecessor and successor are not unique.\n        // In turn the their maximum + 1 is the length of the shortest unique substring starting at pos[i].\n        let len = 1 + cmp::max(lcp.get(i).unwrap(), lcp.get(i + 1).unwrap_or(0)) as usize;\n        let p = pos.get(i).unwrap();\n        // Check if the suffix pos[i] is a prefix of pos[i+1]. In that case, there is no unique substring\n        // at this position.\n        if n - p \u003e= len {\n            sus[p] = Some(len);\n        }\n    }\n    sus\n}\n\n/// Return last character of the text (expected to be the sentinel).\nfn sentinel(text: \u0026[u8]) -\u003e u8 {\n    text[text.len() - 1]\n}\n\n/// Count the sentinels occurring in the text given that the last character is the sentinel.\nfn sentinel_count(text: \u0026[u8]) -\u003e usize {\n    let sentinel = sentinel(text);\n    assert!(\n        text.iter().all(|\u0026a| a \u003e= sentinel),\n        \"Expecting extra sentinel symbol being lexicographically smallest at the end of the \\\n         text.\"\n    );\n\n    text.iter()\n        .fold(0, |count, \u0026a| count + (a == sentinel) as usize)\n}\n\n/// Transform the given text into integers for usage in `SAIS`.\nfn transform_text\u003cT: Integer + Unsigned + NumCast + Copy + Debug\u003e(\n    text: \u0026[u8],\n    alphabet: \u0026Alphabet,\n    sentinel_count: usize,\n) -\u003e Vec\u003cT\u003e {\n    let sentinel = sentinel(text);\n    let transform = RankTransform::new(alphabet);\n    let offset = sentinel_count - 1;\n\n    let mut transformed: Vec\u003cT\u003e = Vec::with_capacity(text.len());\n    let mut s = sentinel_count;\n    for \u0026a in text.iter() {\n        if a == sentinel {\n            s -= 1;\n            transformed.push(cast(s).unwrap());\n        } else {\n            transformed\n                .push(cast(*(transform.ranks.get(a as usize)).unwrap() as usize + offset).unwrap());\n        }\n    }\n\n    transformed\n}\n\n/// SAIS implementation (see function `suffix_array` for description).\nstruct SAIS {\n    pos: Vec\u003cusize\u003e,\n    lms_pos: Vec\u003cusize\u003e,\n    reduced_text_pos: Vec\u003cusize\u003e,\n    bucket_sizes: VecMap\u003cusize\u003e,\n    bucket_start: Vec\u003cusize\u003e,\n    bucket_end: Vec\u003cusize\u003e,\n}\n\nimpl SAIS {\n    /// Create a new instance.\n    fn new(n: usize) -\u003e Self {\n        SAIS {\n            pos: Vec::with_capacity(n),\n            lms_pos: Vec::with_capacity(n),\n            reduced_text_pos: vec![0; n],\n            bucket_sizes: VecMap::new(),\n            bucket_start: Vec::with_capacity(n),\n            bucket_end: Vec::with_capacity(n),\n        }\n    }\n\n    /// Init buckets.\n    fn init_bucket_start\u003cT: Integer + Unsigned + NumCast + Copy\u003e(\u0026mut self, text: \u0026[T]) {\n        self.bucket_sizes.clear();\n        self.bucket_start.clear();\n\n        for \u0026c in text.iter() {\n            if !self.bucket_sizes.contains_key(cast(c).unwrap()) {\n                self.bucket_sizes.insert(cast(c).unwrap(), 0);\n            }\n            *(self.bucket_sizes.get_mut(cast(c).unwrap()).unwrap()) += 1;\n        }\n\n        let mut sum = 0;\n        for \u0026size in self.bucket_sizes.values() {\n            self.bucket_start.push(sum);\n            sum += size;\n        }\n    }\n\n    /// Initialize pointers to the last element of the buckets.\n    fn init_bucket_end\u003cT: Integer + Unsigned + NumCast + Copy\u003e(\u0026mut self, text: \u0026[T]) {\n        self.bucket_end.clear();\n        for \u0026r in self.bucket_start[1..].iter() {\n            self.bucket_end.push(r - 1);\n        }\n        self.bucket_end.push(text.len() - 1);\n    }\n\n    /// Check if two LMS substrings are equal.\n    fn lms_substring_eq\u003cT: Integer + Unsigned + NumCast + Copy\u003e(\n        \u0026self,\n        text: \u0026[T],\n        pos_types: \u0026PosTypes,\n        i: usize,\n        j: usize,\n    ) -\u003e bool {\n        for k in 0.. {\n            let lmsi = pos_types.is_lms_pos(i + k);\n            let lmsj = pos_types.is_lms_pos(j + k);\n            if text[i + k] != text[j + k] {\n                // different symbols\n                return false;\n            }\n            if lmsi != lmsj {\n                // different length\n                return false;\n            }\n            if k \u003e 0 \u0026\u0026 lmsi \u0026\u0026 lmsj {\n                // same symbols and same length\n                return true;\n            }\n        }\n        false\n    }\n\n    /// Sort LMS suffixes.\n    fn sort_lms_suffixes\u003c\n        T: Integer + Unsigned + NumCast + Copy + Debug,\n        S: Integer + Unsigned + NumCast + Copy + Debug,\n    \u003e(\n        \u0026mut self,\n        text: \u0026[T],\n        pos_types: \u0026PosTypes,\n        lms_substring_count: usize,\n    ) {\n        // if less than 2 LMS substrings are present, no further sorting is needed\n        if lms_substring_count \u003e 1 {\n            // sort LMS suffixes by recursively building SA on reduced text\n            let mut reduced_text: Vec\u003cS\u003e = vec![cast(0).unwrap(); lms_substring_count];\n            let mut label = 0;\n            reduced_text[self.reduced_text_pos[self.pos[0]]] = cast(label).unwrap();\n            let mut prev = None;\n            for \u0026p in \u0026self.pos {\n                if pos_types.is_lms_pos(p) {\n                    // choose same label if substrings are equal\n                    if prev.is_some() \u0026\u0026 !self.lms_substring_eq(text, pos_types, prev.unwrap(), p) {\n                        label += 1;\n                    }\n                    reduced_text[self.reduced_text_pos[p]] = cast(label).unwrap();\n                    prev = Some(p);\n                }\n            }\n\n            // if we have less labels than substrings, we have to sort by recursion\n            // because two or more substrings are equal\n            if label + 1 \u003c lms_substring_count {\n                // backup lms_pos\n                let lms_pos = self.lms_pos.clone();\n                // recurse SA construction for reduced text\n                self.construct(\u0026reduced_text);\n                // obtain sorted lms suffixes\n                self.lms_pos.clear();\n                for \u0026p in \u0026self.pos {\n                    self.lms_pos.push(lms_pos[p]);\n                }\n            } else {\n                // otherwise, lms_pos is updated with the sorted suffixes from pos\n                // obtain sorted lms suffixes\n                self.lms_pos.clear();\n                for \u0026p in \u0026self.pos {\n                    if pos_types.is_lms_pos(p) {\n                        self.lms_pos.push(p);\n                    }\n                }\n            }\n        }\n    }\n\n    /// Construct the suffix array.\n    fn construct\u003cT: Integer + Unsigned + NumCast + Copy + Debug\u003e(\u0026mut self, text: \u0026[T]) {\n        let pos_types = PosTypes::new(text);\n        self.calc_lms_pos(text, \u0026pos_types);\n        self.calc_pos(text, \u0026pos_types);\n    }\n\n    /// Step 1 of the SAIS algorithm.\n    fn calc_lms_pos\u003cT: Integer + Unsigned + NumCast + Copy + Debug\u003e(\n        \u0026mut self,\n        text: \u0026[T],\n        pos_types: \u0026PosTypes,\n    ) {\n        let n = text.len();\n\n        // collect LMS positions\n        self.lms_pos.clear();\n        let mut i = 0;\n        for r in 0..n {\n            if pos_types.is_lms_pos(r) {\n                self.lms_pos.push(r);\n                self.reduced_text_pos[r] = i;\n                i += 1;\n            }\n        }\n\n        // sort LMS substrings by applying step 2 with unsorted LMS positions\n        self.calc_pos(text, pos_types);\n\n        let lms_substring_count = self.lms_pos.len();\n\n        if lms_substring_count \u003c= std::u8::MAX as usize {\n            self.sort_lms_suffixes::\u003cT, u8\u003e(text, pos_types, lms_substring_count);\n        } else if lms_substring_count \u003c= std::u16::MAX as usize {\n            self.sort_lms_suffixes::\u003cT, u16\u003e(text, pos_types, lms_substring_count);\n        } else if lms_substring_count \u003c= std::u32::MAX as usize {\n            self.sort_lms_suffixes::\u003cT, u32\u003e(text, pos_types, lms_substring_count);\n        } else {\n            self.sort_lms_suffixes::\u003cT, u64\u003e(text, pos_types, lms_substring_count);\n        }\n    }\n\n    /// Step 2 of the SAIS algorithm.\n    fn calc_pos\u003cT: Integer + Unsigned + NumCast + Copy\u003e(\n        \u0026mut self,\n        text: \u0026[T],\n        pos_types: \u0026PosTypes,\n    ) {\n        let n = text.len();\n        self.pos.clear();\n\n        self.init_bucket_start(text);\n        self.init_bucket_end(text);\n\n        // init all positions as unknown (n-1 is max position)\n        self.pos.resize(n, n);\n\n        // insert LMS positions to the end of their buckets\n        for \u0026p in self.lms_pos.iter().rev() {\n            let c: usize = cast(text[p]).unwrap();\n            self.pos[self.bucket_end[c]] = p;\n            // subtract without overflow: last -1 will cause overflow, but it does not matter\n            self.bucket_end[c] = self.bucket_end[c].wrapping_sub(1);\n        }\n\n        // reset bucket ends\n        self.init_bucket_end(text);\n\n        // insert L-positions into buckets\n        for r in 0..n {\n            let p = self.pos[r];\n            // ignore undefined positions and the zero since it has no predecessor\n            if p == n || p == 0 {\n                continue;\n            }\n            let pred = p - 1;\n            if pos_types.is_l_pos(pred) {\n                let c: usize = cast(text[pred]).unwrap();\n                self.pos[self.bucket_start[c]] = pred;\n                self.bucket_start[c] += 1;\n            }\n        }\n\n        // insert S-positions into buckets\n        for r in (0..n).rev() {\n            let p = self.pos[r];\n            if p == 0 {\n                continue;\n            }\n            let pred = p - 1;\n            if pos_types.is_s_pos(pred) {\n                let c: usize = cast(text[pred]).unwrap();\n                self.pos[self.bucket_end[c]] = pred;\n                // subtract without overflow: last -1 will cause overflow, but it won't be used\n                self.bucket_end[c] = self.bucket_end[c].wrapping_sub(1);\n            }\n        }\n    }\n}\n\n/// Position types (L or S).\n#[derive(Debug)]\nstruct PosTypes {\n    pos_types: BitVec,\n}\n\nimpl PosTypes {\n    /// Calculate the text position type.\n    /// L-type marks suffixes being lexicographically larger than their successor,\n    /// S-type marks the others.\n    /// This function fills a BitVec, with 1-bits denoting S-type\n    /// and 0-bits denoting L-type.\n    ///\n    /// # Arguments\n    ///\n    /// * `text` - the text, ending with a sentinel.\n    fn new\u003cT: Integer + Unsigned + NumCast + Copy\u003e(text: \u0026[T]) -\u003e Self {\n        let n = text.len();\n        let mut pos_types = BitVec::new_fill(false, n as u64);\n        pos_types.set_bit(n as u64 - 1, true);\n\n        for p in (0..n - 1).rev() {\n            if text[p] == text[p + 1] {\n                // if the characters are equal, the next position determines\n                // the lexicographical order\n                let v = pos_types.get_bit(p as u64 + 1);\n                pos_types.set_bit(p as u64, v);\n            } else {\n                pos_types.set_bit(p as u64, text[p] \u003c text[p + 1]);\n            }\n        }\n\n        PosTypes { pos_types }\n    }\n\n    /// Check if p is S-position.\n    fn is_s_pos(\u0026self, p: usize) -\u003e bool {\n        self.pos_types.get_bit(p as u64)\n    }\n\n    /// Check if p is L-position.\n    fn is_l_pos(\u0026self, p: usize) -\u003e bool {\n        !self.pos_types.get_bit(p as u64)\n    }\n\n    /// Check if p is LMS-position.\n    fn is_lms_pos(\u0026self, p: usize) -\u003e bool {\n        p != 0 \u0026\u0026 self.is_s_pos(p) \u0026\u0026 self.is_l_pos(p - 1)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    // Commented-out imports waiting on re-enabling of sampled suffix array\n    // See issue #70\n    use super::*;\n    use super::{transform_text, PosTypes, SAIS};\n    use crate::alphabets::Alphabet;\n    use bv::{BitVec, BitsPush};\n    //use data_structures::bwt::{bwt, less, Occ};\n    use std::str;\n\n    #[test]\n    fn test_pos_types() {\n        let orig_text = b\"GCCTTAACATTATTACGCCTA$\";\n        let alphabet = Alphabet::new(orig_text);\n        let text: Vec\u003cu8\u003e = transform_text(orig_text, \u0026alphabet, 1);\n        let n = text.len();\n\n        let pos_types = PosTypes::new(\u0026text);\n        //let mut test = BitSlice::from_slice(\u0026[0b01100110, 0b10010011, 0b01100100]).to_owned();\n        let mut test = BitVec::new();\n        test.push_block(0b001001101100100101100110);\n        test.truncate(n as u64);\n        assert_eq!(pos_types.pos_types, test);\n        let lms_pos: Vec\u003cusize\u003e = (0..n).filter(|\u0026p| pos_types.is_lms_pos(p)).collect();\n        assert_eq!(lms_pos, vec![1, 5, 8, 11, 14, 17, 21]);\n    }\n\n    #[test]\n    fn test_buckets() {\n        let orig_text = b\"GCCTTAACATTATTACGCCTA$\";\n        let alphabet = Alphabet::new(orig_text);\n        let text: Vec\u003cu8\u003e = transform_text(orig_text, \u0026alphabet, 1);\n        let n = text.len();\n\n        let mut sais = SAIS::new(n);\n        sais.init_bucket_start(\u0026text);\n        assert_eq!(sais.bucket_start, vec![0, 1, 7, 13, 15]);\n        sais.init_bucket_end(\u0026text);\n        assert_eq!(sais.bucket_end, vec![0, 6, 12, 14, 21]);\n    }\n\n    #[test]\n    fn test_pos() {\n        let orig_text = b\"GCCTTAACATTATTACGCCTA$\";\n        let alphabet = Alphabet::new(orig_text);\n        let text: Vec\u003cu8\u003e = transform_text(orig_text, \u0026alphabet, 1);\n        let n = text.len();\n\n        let mut sais = SAIS::new(n);\n        let pos_types = PosTypes::new(\u0026text);\n        sais.lms_pos = vec![21, 5, 14, 8, 11, 17, 1];\n        sais.calc_pos(\u0026text, \u0026pos_types);\n        assert_eq!(\n            sais.pos,\n            vec![21, 20, 5, 6, 14, 11, 8, 7, 17, 1, 15, 18, 2, 16, 0, 19, 4, 13, 10, 3, 12, 9,]\n        );\n    }\n\n    #[test]\n    fn test_lms_pos() {\n        let orig_text = b\"GCCTTAACATTATTACGCCTA$\";\n        let alphabet = Alphabet::new(orig_text);\n        let text: Vec\u003cu8\u003e = transform_text(orig_text, \u0026alphabet, 1);\n        let n = text.len();\n\n        let mut sais = SAIS::new(n);\n        let pos_types = PosTypes::new(\u0026text);\n        sais.calc_lms_pos(\u0026text, \u0026pos_types);\n    }\n\n    #[test]\n    fn test_issue10_1() {\n        let text = b\"TGTGTGTGTG$\";\n        let pos = suffix_array(text);\n        assert_eq!(pos, [10, 9, 7, 5, 3, 1, 8, 6, 4, 2, 0]);\n    }\n\n    #[test]\n    fn test_issue10_2() {\n        let text = b\"TGTGTGTG$\";\n        let pos = suffix_array(text);\n        assert_eq!(pos, [8, 7, 5, 3, 1, 6, 4, 2, 0]);\n    }\n\n    #[test]\n    fn test_handles_sentinels_properly() {\n        let reads = b\"TACTCCGCTAGGGACACCTAAATAGATACTCGCAAAGGCGACTGATATATCCTTAGGTCGAAGAGATACCAGAGAAATAGTAGGTCTTAGGCTAGTCCTT$AAGGACTAGCCTAAGACCTACTATTTCTCTGGTATCTCTTCGACCTAAGGATATATCAGTCGCCTTTGCGAGTATCTATTTAGGTGTCCCTAGCGGAGTA$TAGGGACACCTAAATAGATACTCGCAAAGGCGACTGATATATCCTTAGGTCGAAGAGATACCAGAGAAATAGTAGGTCTTAGGCTAGTCCTTGTCCAGTA$TACTGGACAAGGACTAGCCTAAGACCTACTATTTCTCTGGTATCTCTTCGACCTAAGGATATATCAGTCGCCTTTGCGAGTATCTATTTAGGTGTCCCTA$ACGCACCCCGGCATTCGTCGACTCTACACTTAGTGGAACATACAAATTCGCTCGCAGGAGCGCCTCATACATTCTAACGCAGTGATCTTCGGCTGAGACT$AGTCTCAGCCGAAGATCACTGCGTTAGAATGTATGAGGCGCTCCTGCGAGCGAATTTGTATGTTCCACTAAGTGTAGAGTCGACGAATGCCGGGGTGCGT$\";\n        suffix_array(reads);\n    }\n\n    fn str_from_pos(sa: \u0026[usize], text: \u0026[u8], index: usize) -\u003e String {\n        String::from(\n            str::from_utf8(\u0026text[sa[index]..])\n                .unwrap()\n                .split('$')\n                .next()\n                .unwrap_or(\"\"),\n        ) + \"$\"\n    }\n\n    #[test]\n    fn test_sorts_lexically() {\n        let test_cases =             [(\u0026b\"A$C$G$T$\"[..], \"simple\"),\n             (\u0026b\"A$A$T$T$\"[..], \"duplicates\"),\n             (\u0026b\"AA$GA$CA$TA$TC$TG$GT$GC$\"[..], \"two letter\"),\n             (\u0026b\"AGCCAT$\\\n                CAGCC$\"[..],\n                \"substring\"),\n             (\u0026b\"GTAGGCCTAATTATAATCAGCGGACATTTCGTATTGCTCGGGCTGCCAGGATTTTAGCATCAGTAGCCGGGTAATGGAACCTCAAGAGGTCAGCGTCGAA$\\\n                AATCAGCGGACATTTCGTATTGCTCGGGCTGCCAGGATTTTAGCATCAGTAGCCGGGTAATGGAACCTCAAGAGGTCAGCGTCGAATGGCTATTCCAATA$\"[..],\n                \"complex\"),\n             (\u0026b\"GTAGGCCTAATTATAATCAGCGGACATTTCGTATTGCTCGGGCTGCCAGGATTTTAGCATCAGTAGCCGGGTAATGGAACCTCAAGAGGTCAGCGTCGAA$\\\n                TTCGACGCTGACCTCTTGAGGTTCCATTACCCGGCTACTGATGCTAAAATCCTGGCAGCCCGAGCAATACGAAATGTCCGCTGATTATAATTAGGCCTAC$\\\n                AATCAGCGGACATTTCGTATTGCTCGGGCTGCCAGGATTTTAGCATCAGTAGCCGGGTAATGGAACCTCAAGAGGTCAGCGTCGAATGGCTATTCCAATA$\\\n                TATTGGAATAGCCATTCGACGCTGACCTCTTGAGGTTCCATTACCCGGCTACTGATGCTAAAATCCTGGCAGCCCGAGCAATACGAAATGTCCGCTGATT$\"[..],\n                \"complex with revcomps\"),\n             ];\n\n        for \u0026(text, test_name) in test_cases.iter() {\n            let pos = suffix_array(text);\n            for i in 0..(pos.len() - 2) {\n                // Check that every element in the suffix array is lexically \u003c= the next elem\n                let cur = str_from_pos(\u0026pos, \u0026text, i);\n                let next = str_from_pos(\u0026pos, \u0026text, i + 1);\n\n                assert!(\n                    cur \u003c= next,\n                    format!(\n                        \"Failed:\\n{}\\n{}\\nat positions {} and {} are out of order in \\\n                         test: {}\",\n                        cur,\n                        next,\n                        pos[i],\n                        pos[i + 1],\n                        test_name\n                    )\n                );\n            }\n        }\n    }\n\n    // #[test]\n    // fn test_sampled_matches() {\n    //     let test_cases =             [(\u0026b\"A$C$G$T$\"[..], \"simple\"),\n    //          (\u0026b\"A$A$T$T$\"[..], \"duplicates\"),\n    //          (\u0026b\"AA$GA$CA$TA$TC$TG$GT$GC$\"[..], \"two letter\"),\n    //          (\u0026b\"AGCCAT$\\\n    //             CAGCC$\"[..],\n    //             \"substring\"),\n    //          (\u0026b\"GTAGGCCTAATTATAATCAGCGGACATTTCGTATTGCTCGGGCTGCCAGGATTTTAGCATCAGTAGCCGGGTAATGGAACCTCAAGAGGTCAGCGTCGAA$\\\n    //             AATCAGCGGACATTTCGTATTGCTCGGGCTGCCAGGATTTTAGCATCAGTAGCCGGGTAATGGAACCTCAAGAGGTCAGCGTCGAATGGCTATTCCAATA$\"[..],\n    //             \"complex\"),\n    //          (\u0026b\"GTAGGCCTAATTATAATCAGCGGACATTTCGTATTGCTCGGGCTGCCAGGATTTTAGCATCAGTAGCCGGGTAATGGAACCTCAAGAGGTCAGCGTCGAA$\\\n    //             TTCGACGCTGACCTCTTGAGGTTCCATTACCCGGCTACTGATGCTAAAATCCTGGCAGCCCGAGCAATACGAAATGTCCGCTGATTATAATTAGGCCTAC$\\\n    //             AATCAGCGGACATTTCGTATTGCTCGGGCTGCCAGGATTTTAGCATCAGTAGCCGGGTAATGGAACCTCAAGAGGTCAGCGTCGAATGGCTATTCCAATA$\\\n    //             TATTGGAATAGCCATTCGACGCTGACCTCTTGAGGTTCCATTACCCGGCTACTGATGCTAAAATCCTGGCAGCCCGAGCAATACGAAATGTCCGCTGATT$\"[..],\n    //             \"complex with revcomps\"),\n    //          ];\n    //\n    //     for \u0026(text, _) in test_cases.into_iter() {\n    //         let alphabet = dna::n_alphabet();\n    //         let sa = suffix_array(text);\n    //         let bwt = bwt(text, \u0026sa);\n    //         let less = less(\u0026bwt, \u0026alphabet);\n    //         let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n    //         let sampled = sa.sample(\u0026bwt, \u0026less, \u0026occ, 2);\n    //\n    //         for i in 0..sa.len() {\n    //             assert_eq!(sa.get(i), sampled.get(i));\n    //         }\n    //     }\n    // }\n}\n","traces":[{"line":107,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[5280560,5282015],"length":1,"stats":{"Line":1},"fn_name":"suffix_array"},{"line":222,"address":[5280619],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[5280648],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[5280672],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[5280713],"length":1,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[5280898,5280761,5280858],"length":1,"stats":{"Line":4},"fn_name":null},{"line":228,"address":[5280866,5280984],"length":1,"stats":{"Line":4},"fn_name":null},{"line":229,"address":[5281016],"length":1,"stats":{"Line":3},"fn_name":null},{"line":231,"address":[5280930,5281248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[5281280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[5281466,5281193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[5281498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[5281628,5281441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[5281148],"length":1,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[5282048],"length":1,"stats":{"Line":2},"fn_name":"sentinel"},{"line":357,"address":[5282184,5282072,5282202],"length":1,"stats":{"Line":2},"fn_name":null},{"line":361,"address":[5282208],"length":1,"stats":{"Line":2},"fn_name":"sentinel_count"},{"line":362,"address":[5282232],"length":1,"stats":{"Line":2},"fn_name":null},{"line":363,"address":[5282338,5282304],"length":1,"stats":{"Line":2},"fn_name":null},{"line":364,"address":[5023981,5023968],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":369,"address":[5282388,5282320],"length":1,"stats":{"Line":4},"fn_name":null},{"line":370,"address":[5024016,5024035],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":374,"address":[5026175,5026208,5027280,5024112,5027243,5025152,5025117,5028295],"length":1,"stats":{"Line":1},"fn_name":"transform_text\u003cu32\u003e"},{"line":379,"address":[5026317,5024221,5025258,5027386],"length":1,"stats":{"Line":3},"fn_name":null},{"line":380,"address":[5026344,5024248,5025285,5027413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":381,"address":[5024340,5027432,5026439,5024270,5025304,5025368,5027496,5026366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[5027477,5026417,5025349,5024426,5026528,5024321,5025454,5027582],"length":1,"stats":{"Line":4},"fn_name":null},{"line":384,"address":[5027614,5024461,5025486,5026563],"length":1,"stats":{"Line":3},"fn_name":null},{"line":385,"address":[5026692,5027622,5024929,5025716,5026571,5024469,5024584,5027737,5025609,5025972,5024691,5027046,5028096,5027844,5025494,5026799],"length":1,"stats":{"Line":6},"fn_name":null},{"line":386,"address":[5026836,5027881,5024927,5024728,5026170,5025753,5027238,5025970,5028094,5028290,5025112,5027044],"length":1,"stats":{"Line":7},"fn_name":null},{"line":387,"address":[5024839,5025796,5026951,5026879,5025868,5024771,5027924,5027994],"length":1,"stats":{"Line":3},"fn_name":null},{"line":388,"address":[5025911,5026994,5024808,5028035,5024880,5025833,5027961,5026916],"length":1,"stats":{"Line":4},"fn_name":null},{"line":390,"address":[5027227,5025101,5026156,5028276],"length":1,"stats":{"Line":1},"fn_name":null},{"line":391,"address":[5024736,5024939,5027056,5025982,5025761,5027889,5026844,5028106],"length":1,"stats":{"Line":4},"fn_name":null},{"line":410,"address":[5282416,5282959,5282974],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":412,"address":[5282445],"length":1,"stats":{"Line":2},"fn_name":null},{"line":413,"address":[5282460],"length":1,"stats":{"Line":2},"fn_name":null},{"line":414,"address":[5282480],"length":1,"stats":{"Line":2},"fn_name":null},{"line":415,"address":[5282536],"length":1,"stats":{"Line":2},"fn_name":null},{"line":416,"address":[5282591],"length":1,"stats":{"Line":3},"fn_name":null},{"line":417,"address":[5282649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[5028336,5031232,5029296,5030272],"length":1,"stats":{"Line":3},"fn_name":"init_bucket_start\u003cu8\u003e"},{"line":423,"address":[5028391,5029351,5031287,5030327],"length":1,"stats":{"Line":5},"fn_name":null},{"line":424,"address":[5030345,5031305,5028409,5029369],"length":1,"stats":{"Line":3},"fn_name":null},{"line":426,"address":[5031521,5029016,5029585,5029395,5030371,5029981,5030561,5028625,5030948,5028435,5031331,5031903],"length":1,"stats":{"Line":13},"fn_name":null},{"line":427,"address":[5028862,5030604,5030796,5031561,5028665,5029628,5031752,5029826],"length":1,"stats":{"Line":10},"fn_name":null},{"line":428,"address":[5029750,5030723,5028786,5031679],"length":1,"stats":{"Line":3},"fn_name":null},{"line":430,"address":[5029844,5031769,5030814,5030953,5028879,5031908,5029986,5029021],"length":1,"stats":{"Line":3},"fn_name":null},{"line":433,"address":[5029542,5030518,5028582,5031478],"length":1,"stats":{"Line":3},"fn_name":null},{"line":434,"address":[5031938,5029051,5032049,5030127,5032145,5029554,5031094,5031190,5029162,5028594,5029258,5030016,5030530,5031490,5030983,5030223],"length":1,"stats":{"Line":16},"fn_name":null},{"line":435,"address":[5029202,5032089,5030167,5031134],"length":1,"stats":{"Line":3},"fn_name":null},{"line":436,"address":[5030190,5030258,5030228,5029293,5031195,5032150,5029263,5032180,5029225,5031225,5032112,5031157],"length":1,"stats":{"Line":6},"fn_name":null},{"line":441,"address":[5033632,5033152,5032192,5032672],"length":1,"stats":{"Line":3},"fn_name":"init_bucket_end\u003cu64\u003e"},{"line":442,"address":[5032238,5033198,5032718,5033678],"length":1,"stats":{"Line":5},"fn_name":null},{"line":443,"address":[5033426,5033537,5033696,5033057,5032946,5032577,5033906,5032466,5033216,5032736,5034017,5032256],"length":1,"stats":{"Line":13},"fn_name":null},{"line":444,"address":[5032501,5032981,5033461,5033941],"length":1,"stats":{"Line":3},"fn_name":null},{"line":446,"address":[5033877,5032437,5033547,5033067,5033397,5032587,5034027,5032917],"length":1,"stats":{"Line":8},"fn_name":null},{"line":450,"address":[5034928,5036544,5034112,5035744],"length":1,"stats":{"Line":5},"fn_name":"lms_substring_eq\u003cu16\u003e"},{"line":457,"address":[5036735,5035119,5035720,5034904,5035008,5035935,5034303,5036528,5036624,5037336,5035824,5034192],"length":1,"stats":{"Line":12},"fn_name":null},{"line":458,"address":[5036772,5035972,5035156,5034340],"length":1,"stats":{"Line":4},"fn_name":null},{"line":459,"address":[5034425,5035241,5036057,5036857],"length":1,"stats":{"Line":5},"fn_name":null},{"line":460,"address":[5034510,5036942,5036142,5035326],"length":1,"stats":{"Line":4},"fn_name":null},{"line":462,"address":[5037228,5036420,5034796,5035612],"length":1,"stats":{"Line":5},"fn_name":null},{"line":464,"address":[5034785,5036409,5037217,5035601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":466,"address":[5034831,5035647,5036455,5037263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":468,"address":[5035639,5034838,5035654,5036447,5034823,5036462,5037255,5037270],"length":1,"stats":{"Line":5},"fn_name":null},{"line":470,"address":[5036533,5035725,5034909,5037341],"length":1,"stats":{"Line":2},"fn_name":null},{"line":473,"address":[5036720,5035104,5034288,5035920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[5066288,5049744,5043552,5039424,5051824,5055942,5037360,5068335,5068368,5070406,5043516,5053871,5062160,5053904,5060096,5041462,5051791,5058032,5047664,5057996,5047628,5062125,5045616,5049702,5064208,5041504,5039389,5060061,5045581,5064172,5066255,5055984],"length":1,"stats":{"Line":7},"fn_name":"sort_lms_suffixes\u003cu64,u8\u003e"},{"line":487,"address":[5068455,5058119,5037447,5064295,5053991,5043639,5039511,5047751,5056071,5041591,5066375,5051911,5049831,5060183,5045703,5062247],"length":1,"stats":{"Line":6},"fn_name":null},{"line":489,"address":[5037458,5066386,5058130,5051922,5062258,5039522,5064306,5049842,5043650,5054002,5068466,5045714,5060194,5047762,5056082,5041602],"length":1,"stats":{"Line":7},"fn_name":null},{"line":490,"address":[5068557,5045799,5056167,5043750,5064406,5058230,5047853,5049942,5066486,5062343,5039613,5037558,5052022,5060294,5041687,5054093],"length":1,"stats":{"Line":6},"fn_name":null},{"line":491,"address":[5068569,5056302,5045934,5056179,5058242,5043762,5064418,5062478,5049954,5052171,5062355,5052034,5039625,5054236,5068700,5064555,5045811,5047865,5066498,5060306,5050091,5043896,5066635,5054105,5039756,5047996,5037704,5060440,5058376,5041699,5037570,5041822],"length":1,"stats":{"Line":13},"fn_name":null},{"line":492,"address":[5041991,5062647,5039927,5044065,5052342,5068871,5064726,5050262,5066806,5060609,5048167,5058545,5054407,5037873,5046103,5056471],"length":1,"stats":{"Line":7},"fn_name":null},{"line":493,"address":[5050274,5042183,5046873,5050454,5042761,5069651,5054599,5052534,5051036,5063417,5040707,5052354,5042003,5060801,5067580,5046115,5057241,5062839,5044828,5048947,5053116,5048359,5058737,5046295,5060621,5038065,5058557,5065500,5044077,5056483,5064738,5040119,5048179,5039939,5037885,5066818,5066998,5068883,5069063,5061372,5064918,5038636,5056663,5059308,5044257,5062659,5055187,5054419],"length":1,"stats":{"Line":19},"fn_name":null},{"line":494,"address":[5058780,5069106,5062882,5044300,5060844,5056706,5050497,5048402,5064961,5067041,5038108,5052577,5054642,5042226,5040162,5046338],"length":1,"stats":{"Line":6},"fn_name":null},{"line":496,"address":[5058814,5063149,5044561,5050531,5065228,5044334,5046372,5042260,5048436,5048669,5046605,5054676,5054909,5056740,5042493,5040429,5052844,5056973,5069373,5067308,5060878,5067075,5064995,5062916,5040196,5050764,5059041,5069140,5038142,5061105,5052611,5038369],"length":1,"stats":{"Line":14},"fn_name":null},{"line":497,"address":[5069330,5044524,5042450,5054866,5056930,5065185,5069375,5065230,5040386,5063106,5054911,5044563,5059043,5038371,5050766,5038332,5056975,5063151,5042495,5040431,5050721,5046562,5048626,5067310,5059004,5061068,5046607,5052801,5061107,5048671,5067265,5052846],"length":1,"stats":{"Line":6},"fn_name":null},{"line":499,"address":[5065262,5054943,5069407,5059075,5063183,5038403,5046639,5050798,5057007,5067342,5042527,5040463,5061139,5048703,5052878,5044595],"length":1,"stats":{"Line":6},"fn_name":null},{"line":500,"address":[5050984,5038584,5057189,5055135,5059256,5065448,5063365,5053064,5042709,5061320,5067528,5048895,5044776,5046821,5069599,5040655],"length":1,"stats":{"Line":7},"fn_name":null},{"line":506,"address":[5051057,5057888,5046251,5069019,5060757,5058693,5063438,5062795,5040728,5044213,5050410,5039283,5054555,5066147,5055834,5041354,5049594,5064874,5059955,5040075,5038657,5056619,5052490,5047520,5044849,5042782,5038021,5064064,5067601,5062019,5068227,5061393,5069672,5043408,5051683,5045475,5066954,5053763,5059329,5070298,5065521,5042139,5053137,5057262,5048968,5048315,5055208,5046894],"length":1,"stats":{"Line":14},"fn_name":null},{"line":508,"address":[5065595,5055282,5044923,5057336,5053211,5042856,5049042,5061467,5067675,5038731,5051131,5063512,5046968,5040802,5059403,5069746],"length":1,"stats":{"Line":5},"fn_name":null},{"line":510,"address":[5044946,5038754,5046991,5061490,5053234,5059426,5042879,5055305,5040825,5057359,5049065,5063535,5065618,5067698,5069769,5051154],"length":1,"stats":{"Line":4},"fn_name":null},{"line":512,"address":[5038863,5057468,5061599,5047100,5067807,5051263,5063644,5042988,5053343,5055414,5069878,5065727,5045055,5059535,5040934,5049174],"length":1,"stats":{"Line":4},"fn_name":null},{"line":513,"address":[5059703,5053613,5063812,5070148,5047370,5038886,5040957,5045325,5043156,5053366,5039031,5045078,5055582,5041102,5051431,5045223,5049342,5055684,5057491,5061869,5053511,5063667,5068077,5070046,5039133,5041204,5043011,5051533,5061622,5049197,5057738,5067830,5047123,5059805,5063914,5065750,5047268,5049444,5051286,5061767,5065895,5059558,5057636,5067975,5065997,5069901,5055437,5043258],"length":1,"stats":{"Line":13},"fn_name":null},{"line":514,"address":[5047303,5065930,5063847,5070081,5055617,5057671,5039066,5041137,5049377,5051466,5053546,5043191,5059738,5061802,5045258,5068010],"length":1,"stats":{"Line":5},"fn_name":null},{"line":519,"address":[5049016,5059377,5040776,5057310,5038705,5065569,5044897,5069720,5063486,5051105,5053185,5061441,5046942,5042830,5055256,5067649],"length":1,"stats":{"Line":2},"fn_name":null},{"line":520,"address":[5045488,5043290,5043531,5053886,5059837,5049607,5039165,5045357,5058011,5068240,5059968,5041367,5053645,5047643,5051565,5049717,5055716,5041236,5055847,5060076,5047533,5047402,5062140,5039296,5043421,5063946,5064077,5066160,5049476,5064187,5057901,5068109,5066029,5055957,5070180,5051806,5070421,5051696,5045596,5053776,5061901,5062032,5066270,5039404,5057770,5068350,5070311,5041477],"length":1,"stats":{"Line":7},"fn_name":null},{"line":521,"address":[5070351,5053816,5051789,5062071,5047626,5070404,5057941,5064117,5041407,5066253,5057994,5049647,5062123,5068333,5041460,5043514,5045527,5043461,5039387,5053869,5055940,5060007,5049700,5068280,5039335,5060059,5064170,5047573,5045579,5051736,5055887,5066200],"length":1,"stats":{"Line":6},"fn_name":null},{"line":522,"address":[5068318,5055925,5043499,5039372,5062108,5060044,5049685,5066238,5045564,5051774,5047611,5053854,5041445,5064155,5070389,5057979],"length":1,"stats":{"Line":2},"fn_name":null},{"line":530,"address":[5071065,5070448,5070905,5070608,5070928,5070745,5070585,5070768],"length":1,"stats":{"Line":4},"fn_name":"construct\u003cu16\u003e"},{"line":531,"address":[5070801,5070961,5070481,5070641],"length":1,"stats":{"Line":3},"fn_name":null},{"line":532,"address":[5070990,5070830,5070510,5070670],"length":1,"stats":{"Line":3},"fn_name":null},{"line":533,"address":[5070696,5071016,5070536,5070856],"length":1,"stats":{"Line":5},"fn_name":null},{"line":537,"address":[5071088,5071824,5072560,5073296],"length":1,"stats":{"Line":4},"fn_name":"calc_lms_pos\u003cu64\u003e"},{"line":542,"address":[5071173,5071909,5073381,5072645],"length":1,"stats":{"Line":3},"fn_name":null},{"line":545,"address":[5072669,5073405,5071933,5071197],"length":1,"stats":{"Line":4},"fn_name":null},{"line":546,"address":[5072684,5073420,5071948,5071212],"length":1,"stats":{"Line":3},"fn_name":null},{"line":547,"address":[5071960,5071389,5071224,5072861,5072696,5072125,5073597,5073805,5073432,5073069,5072333,5071597],"length":1,"stats":{"Line":10},"fn_name":null},{"line":548,"address":[5073634,5071565,5072301,5073773,5073037,5072162,5071426,5072898],"length":1,"stats":{"Line":7},"fn_name":null},{"line":549,"address":[5072932,5072196,5071460,5073668],"length":1,"stats":{"Line":5},"fn_name":null},{"line":550,"address":[5071480,5073688,5072952,5072216],"length":1,"stats":{"Line":3},"fn_name":null},{"line":551,"address":[5072303,5073736,5071567,5073000,5072264,5071528,5073039,5073775],"length":1,"stats":{"Line":5},"fn_name":null},{"line":556,"address":[5072846,5071374,5073582,5072110],"length":1,"stats":{"Line":5},"fn_name":null},{"line":558,"address":[5073079,5071607,5072343,5073815],"length":1,"stats":{"Line":4},"fn_name":null},{"line":560,"address":[5071688,5072424,5073160,5071635,5072371,5073107,5073896,5073843],"length":1,"stats":{"Line":9},"fn_name":null},{"line":561,"address":[5073891,5073155,5071683,5072419],"length":1,"stats":{"Line":4},"fn_name":null},{"line":562,"address":[5073217,5073953,5073856,5072384,5071648,5073120,5071745,5072481],"length":1,"stats":{"Line":4},"fn_name":null},{"line":563,"address":[5072476,5071740,5073948,5073212],"length":1,"stats":{"Line":2},"fn_name":null},{"line":564,"address":[5072545,5071813,5072439,5073911,5073175,5073281,5074021,5072549,5071703,5073285,5074017,5071809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[5071804,5072540,5073276,5074012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[5071772,5073244,5073980,5072508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[5074032,5078960,5081424,5076496],"length":1,"stats":{"Line":3},"fn_name":"calc_pos\u003cu16\u003e"},{"line":577,"address":[5074141,5076605,5079069,5081533],"length":1,"stats":{"Line":5},"fn_name":null},{"line":578,"address":[5074171,5081563,5079099,5076635],"length":1,"stats":{"Line":3},"fn_name":null},{"line":580,"address":[5081593,5074201,5079129,5076665],"length":1,"stats":{"Line":5},"fn_name":null},{"line":581,"address":[5076694,5079158,5074230,5081622],"length":1,"stats":{"Line":5},"fn_name":null},{"line":584,"address":[5074251,5079179,5081643,5076715],"length":1,"stats":{"Line":3},"fn_name":null},{"line":587,"address":[5079457,5074268,5076993,5079898,5079196,5076732,5081660,5082363,5074529,5077435,5081921,5074971],"length":1,"stats":{"Line":13},"fn_name":null},{"line":588,"address":[5079500,5077036,5081964,5074572],"length":1,"stats":{"Line":5},"fn_name":null},{"line":589,"address":[5074723,5079650,5082115,5077187],"length":1,"stats":{"Line":3},"fn_name":null},{"line":591,"address":[5077301,5079851,5074837,5077388,5082229,5082316,5074924,5079764],"length":1,"stats":{"Line":8},"fn_name":null},{"line":595,"address":[5076975,5074511,5079439,5081903],"length":1,"stats":{"Line":3},"fn_name":null},{"line":598,"address":[5075205,5074984,5082597,5077448,5083229,5082376,5075837,5077669,5080763,5079911,5080132,5078301],"length":1,"stats":{"Line":12},"fn_name":null},{"line":599,"address":[5075237,5080164,5082629,5077701],"length":1,"stats":{"Line":5},"fn_name":null},{"line":601,"address":[5082685,5077757,5075293,5080220],"length":1,"stats":{"Line":3},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[5075354,5082746,5077875,5077818,5082803,5080281,5080338,5075411],"length":1,"stats":{"Line":5},"fn_name":null},{"line":605,"address":[5075448,5075805,5077912,5077861,5080731,5080375,5075397,5082840,5083197,5078269,5080324,5082789],"length":1,"stats":{"Line":14},"fn_name":null},{"line":606,"address":[5075475,5077939,5080402,5082867],"length":1,"stats":{"Line":4},"fn_name":null},{"line":607,"address":[5080552,5083018,5075626,5078090],"length":1,"stats":{"Line":5},"fn_name":null},{"line":608,"address":[5078201,5075737,5083199,5080733,5083129,5075807,5080663,5078271],"length":1,"stats":{"Line":4},"fn_name":null},{"line":613,"address":[5075858,5083885,5080061,5076493,5080784,5076488,5081413,5078957,5078952,5078432,5083360,5083250,5081418,5077598,5078322,5075134,5080894,5083880,5082526,5075968],"length":1,"stats":{"Line":19},"fn_name":null},{"line":614,"address":[5078464,5076000,5080926,5083392],"length":1,"stats":{"Line":4},"fn_name":null},{"line":615,"address":[5078503,5080965,5076039,5083431],"length":1,"stats":{"Line":5},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[5083446,5080980,5076102,5083494,5078518,5076054,5078566,5081028],"length":1,"stats":{"Line":4},"fn_name":null},{"line":619,"address":[5083483,5081062,5078555,5076136,5081017,5078600,5076091,5083528],"length":1,"stats":{"Line":9},"fn_name":null},{"line":620,"address":[5083552,5076160,5078624,5081086],"length":1,"stats":{"Line":5},"fn_name":null},{"line":621,"address":[5083679,5081212,5078751,5076287],"length":1,"stats":{"Line":4},"fn_name":null},{"line":623,"address":[5081302,5081377,5078841,5083769,5076377,5076452,5078916,5083844],"length":1,"stats":{"Line":9},"fn_name":null},{"line":645,"address":[5087904,5089223,5089238,5085207,5085222,5086550,5083888,5086535,5086560,5087894,5087879,5085232],"length":1,"stats":{"Line":4},"fn_name":"new\u003cu16\u003e"},{"line":646,"address":[5083965,5087981,5085309,5086637],"length":1,"stats":{"Line":3},"fn_name":null},{"line":647,"address":[5086667,5088011,5083995,5085339],"length":1,"stats":{"Line":4},"fn_name":null},{"line":648,"address":[5084019,5085363,5088035,5086691],"length":1,"stats":{"Line":3},"fn_name":null},{"line":650,"address":[5085870,5086823,5085495,5086292,5087628,5088542,5084956,5088167,5088972,5087198,5084526,5084151],"length":1,"stats":{"Line":9},"fn_name":null},{"line":651,"address":[5085907,5087626,5085202,5089218,5088970,5084563,5088579,5084954,5086290,5086530,5087874,5087235],"length":1,"stats":{"Line":10},"fn_name":null},{"line":654,"address":[5088845,5084829,5087501,5086165],"length":1,"stats":{"Line":3},"fn_name":null},{"line":655,"address":[5086265,5084929,5088945,5087601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":657,"address":[5086141,5088821,5087646,5086310,5084805,5084974,5087477,5088990],"length":1,"stats":{"Line":7},"fn_name":null},{"line":665,"address":[5282976],"length":1,"stats":{"Line":3},"fn_name":"is_s_pos"},{"line":666,"address":[5282990],"length":1,"stats":{"Line":2},"fn_name":null},{"line":670,"address":[5283024],"length":1,"stats":{"Line":4},"fn_name":"is_l_pos"},{"line":671,"address":[5283038],"length":1,"stats":{"Line":2},"fn_name":null},{"line":675,"address":[5283072],"length":1,"stats":{"Line":2},"fn_name":"is_lms_pos"},{"line":676,"address":[5283096],"length":1,"stats":{"Line":3},"fn_name":null},{"line":692,"address":[8980752,8981821],"length":1,"stats":{"Line":3},"fn_name":"test_pos_types"},{"line":693,"address":[8980759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":694,"address":[8980774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":695,"address":[8980791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":696,"address":[8980892,8980826],"length":1,"stats":{"Line":2},"fn_name":null},{"line":698,"address":[8980900,8980985],"length":1,"stats":{"Line":2},"fn_name":null},{"line":700,"address":[8981000],"length":1,"stats":{"Line":1},"fn_name":null},{"line":701,"address":[8981007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":702,"address":[8981081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":703,"address":[8981313,8981134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":704,"address":[8981375,8981228],"length":1,"stats":{"Line":4},"fn_name":null},{"line":705,"address":[8981619,8981392],"length":1,"stats":{"Line":2},"fn_name":null},{"line":709,"address":[8981856,8982885],"length":1,"stats":{"Line":3},"fn_name":"test_buckets"},{"line":710,"address":[8981863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":711,"address":[8981878],"length":1,"stats":{"Line":1},"fn_name":null},{"line":712,"address":[8981895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":713,"address":[8982002,8981933],"length":1,"stats":{"Line":2},"fn_name":null},{"line":715,"address":[8982018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":716,"address":[8982063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":717,"address":[8982160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":718,"address":[8982470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":719,"address":[8982530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":723,"address":[8982912,8984130],"length":1,"stats":{"Line":3},"fn_name":"test_pos"},{"line":724,"address":[8982919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":725,"address":[8982934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":726,"address":[8982951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":727,"address":[8983058,8982989],"length":1,"stats":{"Line":2},"fn_name":null},{"line":729,"address":[8983074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":730,"address":[8983119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":731,"address":[8983377,8983460,8983226],"length":1,"stats":{"Line":2},"fn_name":null},{"line":732,"address":[8983417,8983545],"length":1,"stats":{"Line":2},"fn_name":null},{"line":733,"address":[8983858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":735,"address":[8983623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":740,"address":[8984160,8984600],"length":1,"stats":{"Line":3},"fn_name":"test_lms_pos"},{"line":741,"address":[8984167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":742,"address":[8984182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":743,"address":[8984199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":744,"address":[8984234,8984300],"length":1,"stats":{"Line":2},"fn_name":null},{"line":746,"address":[8984313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":747,"address":[8984355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":748,"address":[8984446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":752,"address":[8984846,8984624],"length":1,"stats":{"Line":3},"fn_name":"test_issue10_1"},{"line":753,"address":[8984631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":754,"address":[8984646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":755,"address":[8984809,8984673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":759,"address":[8984880,8985102],"length":1,"stats":{"Line":3},"fn_name":"test_issue10_2"},{"line":760,"address":[8984887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":761,"address":[8984902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":762,"address":[8985065,8984929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":766,"address":[8985136],"length":1,"stats":{"Line":3},"fn_name":"test_handles_sentinels_properly"},{"line":767,"address":[8985140],"length":1,"stats":{"Line":1},"fn_name":null},{"line":768,"address":[8985152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":771,"address":[8980352],"length":1,"stats":{"Line":1},"fn_name":"str_from_pos"},{"line":772,"address":[8980694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":773,"address":[8980434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":782,"address":[8988162,8985200],"length":1,"stats":{"Line":3},"fn_name":"test_sorts_lexically"},{"line":783,"address":[8985774,8985210],"length":1,"stats":{"Line":2},"fn_name":null},{"line":784,"address":[8985304],"length":1,"stats":{"Line":1},"fn_name":null},{"line":785,"address":[8985398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":786,"address":[8985492],"length":1,"stats":{"Line":1},"fn_name":null},{"line":789,"address":[8985586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":792,"address":[8985680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":799,"address":[8986318,8988177,8986158,8988182],"length":1,"stats":{"Line":3},"fn_name":null},{"line":800,"address":[8986389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":801,"address":[8986526,8986770,8986418,8988157],"length":1,"stats":{"Line":4},"fn_name":null},{"line":803,"address":[8986810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":804,"address":[8986906,8987097],"length":1,"stats":{"Line":2},"fn_name":null},{"line":806,"address":[8988109,8987176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":807,"address":[8987153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":808,"address":[8987421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":813,"address":[8987255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":814,"address":[8987300],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":217,"coverable":236},{"path":["/","home","todd","rust-bio","src","data_structures","wavelet_matrix.rs"],"content":"//! Wavelet Matrix data structure for DNA alphabet.\n//! The implementation is based on the paper\n//! [Claude Francisco and Gonzalo Navarro. The wavelet matrix. SPIRE (2012)](https://doi.org/10.1007/978-3-642-34109-0_18)\n//!\n//! # Example\n//!\n//! ```\n//! use bio::data_structures::wavelet_matrix::WaveletMatrix;\n//! let text = b\"AANGGT$ACCNTT$\";\n//! let wm = WaveletMatrix::new(text);\n//! assert_eq!(wm.rank(b'A', 0), 1);\n//! assert_eq!(wm.rank(b'G', 9), 2);\n//! assert_eq!(wm.rank(b'T', 13), 3);\n//! ```\n\nuse crate::data_structures::rank_select::RankSelect;\nuse bv::BitVec;\nuse bv::BitsMut;\n\nconst DNA2INT: [u8; 128] = [\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //  0\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 10\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 20\n    0, 0, 0, 0, 0, 0, 5, 0, 0, 0, // 30\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, // 40\n    2, 3, 4, 5, 6, 7, 0, 0, 0, 0, // 50\n    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, // 60\n    0, 2, 0, 0, 0, 0, 0, 0, 4, 0, // 70\n    0, 0, 0, 0, 3, 0, 0, 0, 0, 0, // 80\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, // 90\n    0, 0, 0, 2, 0, 0, 0, 0, 0, 0, // 100\n    4, 0, 0, 0, 0, 0, 3, 0, 0, 0, // 110\n    0, 0, 0, 0, 0, 0, 0, 0,\n]; // 120\n\n#[derive(Serialize, Deserialize)]\npub struct WaveletMatrix {\n    width: usize,  // levels[0].len()\n    height: usize, // zeros.len() == levels.len()\n    zeros: Vec\u003cu64\u003e,\n    levels: Vec\u003cRankSelect\u003e,\n}\n\nfn build_partlevel(\n    vals: \u0026Vec\u003cu8\u003e,\n    shift: u8,\n    next_zeros: \u0026mut Vec\u003cu8\u003e,\n    next_ones: \u0026mut Vec\u003cu8\u003e,\n    bits: \u0026mut BitVec\u003cu8\u003e,\n    prev_bits: u64,\n) {\n    let mut p = prev_bits;\n    for val in vals {\n        let bit = ((DNA2INT[usize::from(*val)] \u003e\u003e shift) \u0026 1) == 1; // get shifted lsb\n        bits.set_bit(p, bit);\n        p += 1;\n        if bit {\n            next_ones.push(*val);\n        } else {\n            next_zeros.push(*val);\n        }\n    }\n}\n\nimpl WaveletMatrix {\n    /// Construct a new instance of the wavelet matrix of given text of length n (DNA alphabet plus sentinel symbol).\n    /// Complexity: O(n).\n    pub fn new(text: \u0026[u8]) -\u003e Self {\n        let width = text.len();\n        let height: usize = 3; // hardcoded for alphabet size \u003c= 8 (ACGTN$)\n\n        let mut curr_zeros: Vec\u003cu8\u003e = text.to_vec().clone();\n        let mut curr_ones: Vec\u003cu8\u003e = Vec::new();\n\n        let mut zeros: Vec\u003cu64\u003e = Vec::new();\n        let mut levels: Vec\u003cRankSelect\u003e = Vec::new();\n\n        for level in 0..height {\n            let mut next_zeros: Vec\u003cu8\u003e = Vec::with_capacity(width);\n            let mut next_ones: Vec\u003cu8\u003e = Vec::with_capacity(width);\n            let mut curr_bits: BitVec\u003cu8\u003e = BitVec::new_fill(false, width as u64);\n            let shift = (height - level - 1) as u8;\n            build_partlevel(\n                \u0026curr_zeros,\n                shift,\n                \u0026mut next_zeros,\n                \u0026mut next_ones,\n                \u0026mut curr_bits,\n                0,\n            );\n            build_partlevel(\n                \u0026curr_ones,\n                shift,\n                \u0026mut next_zeros,\n                \u0026mut next_ones,\n                \u0026mut curr_bits,\n                curr_zeros.len() as u64,\n            );\n\n            curr_zeros = next_zeros;\n            curr_ones = next_ones;\n\n            let level = RankSelect::new(curr_bits, 1);\n            levels.push(level);\n            zeros.push(curr_zeros.len() as u64);\n        }\n\n        WaveletMatrix {\n            width,\n            height,\n            zeros,\n            levels,\n        }\n    }\n\n    fn check_overflow(\u0026self, p: u64) -\u003e bool {\n        p \u003e= self.width as u64\n    }\n\n    fn prank(\u0026self, level: usize, p: u64, val: u8) -\u003e u64 {\n        if p == 0 {\n            0\n        } else {\n            if val == 0 {\n                self.levels[level].rank_0(p - 1).unwrap()\n            } else {\n                self.levels[level].rank_1(p - 1).unwrap()\n            }\n        }\n    }\n\n    /// Compute the number of occurrences of symbol val in the original text up to position p (inclusive).\n    /// Complexity O(1).\n    pub fn rank(\u0026self, val: u8, p: u64) -\u003e u64 {\n        if self.check_overflow(p) {\n            panic!(\"Invalid p (it must be in range 0..wm_size-1\");\n        }\n        let height = self.height as usize;\n        let mut spos = 0;\n        let mut epos = p + 1;\n        for level in 0..height {\n            let shift = height - level - 1;\n            let bit = ((DNA2INT[val as usize] \u003e\u003e shift) \u0026 1) == 1; // get shifted lsb\n            if bit {\n                spos = self.prank(level, spos, 1) + self.zeros[level];\n                epos = self.prank(level, epos, 1) + self.zeros[level];\n            } else {\n                spos = self.prank(level, spos, 0);\n                epos = self.prank(level, epos, 0);\n            }\n        }\n        epos - spos\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_wm_buildpaper() {\n        let text = b\"476532101417\";\n        let wm = WaveletMatrix::new(text);\n        let levels = vec![\n            vec![\n                true, true, true, true, false, false, false, false, false, true, false, true,\n            ],\n            vec![\n                true, true, false, false, false, false, false, true, true, false, false, true,\n            ],\n            vec![\n                true, false, true, true, false, true, false, true, false, true, false, true,\n            ],\n        ];\n        let zeros = vec![6, 7, 5];\n\n        assert_eq!(wm.height, zeros.len());\n        assert_eq!(wm.width, levels[0].len());\n        for level in 0..wm.height {\n            assert_eq!(wm.zeros[level], zeros[level]);\n            for i in 0..wm.width {\n                assert_eq!(wm.levels[level].bits().get(i as u64), levels[level][i]);\n            }\n        }\n    }\n\n    #[test]\n    fn test_wm_builddna() {\n        let text = b\"ACGTN$NAGCT$\";\n        let wm = WaveletMatrix::new(text);\n        let levels = vec![\n            vec![\n                false, false, false, false, true, true, true, false, false, false, false, true,\n            ],\n            vec![\n                false, false, true, true, false, true, false, true, false, false, false, false,\n            ],\n            vec![\n                false, true, false, true, false, true, false, true, false, true, false, true,\n            ],\n        ];\n        let zeros = vec![8, 8, 6];\n\n        assert_eq!(wm.height, zeros.len());\n        assert_eq!(wm.width, levels[0].len());\n        for level in 0..wm.height {\n            assert_eq!(wm.zeros[level], zeros[level]);\n            for i in 0..wm.width {\n                assert_eq!(wm.levels[level].bits().get(i as u64), levels[level][i]);\n            }\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_wm_rank_overflowpanic() {\n        let text = b\"476532101417\";\n        let wm = WaveletMatrix::new(text);\n        wm.rank(b'4', text.len() as u64);\n    }\n\n    #[test]\n    fn test_wm_rank_firstpos() {\n        let text = b\"476532101417\";\n        let wm = WaveletMatrix::new(text);\n        assert_eq!(wm.rank(b'4', 0), 1);\n    }\n\n    #[test]\n    fn test_wm_rank_lastpos() {\n        let text = b\"476532101417\";\n        let wm = WaveletMatrix::new(text);\n        assert_eq!(wm.rank(b'7', text.len() as u64 - 1), 2);\n    }\n\n    #[test]\n    fn test_wm_rank_1() {\n        let text = b\"476532101417\";\n        let wm = WaveletMatrix::new(text);\n        assert_eq!(wm.rank(b'0', 6), 0);\n        assert_eq!(wm.rank(b'0', 7), 1);\n        assert_eq!(wm.rank(b'0', 8), 1);\n    }\n\n    #[test]\n    fn test_wm_rank_2() {\n        let text = b\"476532101417\";\n        let wm = WaveletMatrix::new(text);\n        assert_eq!(wm.rank(b'4', 8), 1);\n        assert_eq!(wm.rank(b'4', 9), 2);\n        assert_eq!(wm.rank(b'4', 10), 2);\n    }\n\n    #[test]\n    fn test_wm_rank_all() {\n        let text = b\"476532101417\";\n        let wm = WaveletMatrix::new(text);\n\n        let ranks = vec![\n            vec![0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],\n            vec![0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 3, 3],\n            vec![0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1],\n            vec![0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2],\n            vec![0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],\n        ];\n\n        let alphabet = vec![b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7'];\n        for (i, c) in alphabet.iter().enumerate() {\n            for p in 0..text.len() {\n                assert_eq!(wm.rank(*c, p as u64), ranks[i][p]);\n            }\n        }\n    }\n\n    #[test]\n    fn test_wm_rank_alldna() {\n        let text = b\"AAGCTC$$CATTNGA\";\n        let wm = WaveletMatrix::new(text);\n\n        let ranks = vec![\n            vec![1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4],\n            vec![0, 0, 0, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3],\n            vec![0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],\n            vec![0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 3, 3, 3, 3],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1],\n            vec![0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2],\n        ];\n\n        let alphabet = vec![b'A', b'C', b'G', b'T', b'N', b'$'];\n        for (i, c) in alphabet.iter().enumerate() {\n            for p in 0..text.len() {\n                assert_eq!(wm.rank(*c, p as u64), ranks[i][p]);\n            }\n        }\n    }\n}\n","traces":[{"line":44,"address":[9129072],"length":1,"stats":{"Line":1},"fn_name":"build_partlevel"},{"line":52,"address":[9129148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[9129235,9129153,9129587],"length":1,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[9129269,9129444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[9129426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[9129515,9129474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[9129509,9129592,9129594,9129585],"length":1,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[9129576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[9129555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[9129712],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[9132714,9132621,9132526],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[9180096,9180101],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":162,"address":[9390231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[9390246],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[9390510,9390646,9390281],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[9390312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[9390416],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[9390560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[9390855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[9391237,9391030,9390928],"length":1,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[9391296,9391184,9391522],"length":1,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[9391720,9391590,9391429,9392150],"length":1,"stats":{"Line":4},"fn_name":null},{"line":180,"address":[9391757,9391992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[9392160,9392438,9392054,9391911],"length":1,"stats":{"Line":4},"fn_name":null},{"line":182,"address":[9392197,9392452],"length":1,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[9180133,9180128],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":189,"address":[9392567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[9392582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[9392982,9392617,9392846],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[9392648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[9392752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[9392896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[9393191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[9393264,9393366,9393573],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[9393632,9393858,9393520],"length":1,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[9394056,9393765,9394486,9393926],"length":1,"stats":{"Line":4},"fn_name":null},{"line":207,"address":[9394328,9394093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[9394774,9394390,9394247,9394496],"length":1,"stats":{"Line":4},"fn_name":null},{"line":209,"address":[9394788,9394533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[9180160,9180165],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":217,"address":[9394900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[9394912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[9394934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[9180192,9180197],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":224,"address":[9395063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[9395078],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[9395114,9395268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[9180229,9180224],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":231,"address":[9395351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[9395366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[9395650,9395388,9395494],"length":1,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[9180261,9180256],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":238,"address":[9395735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[9395750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[9395980,9395787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[9396036,9396170,9395955],"length":1,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[9396343,9396145,9396227],"length":1,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[9180293,9180288],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":247,"address":[9396439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[9396454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[9396684,9396491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[9396874,9396659,9396740],"length":1,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[9397047,9396849,9396931],"length":1,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[9180325,9180320],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":256,"address":[9397143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[9397158],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[9397507,9398590,9397862,9397201,9397680,9398044,9398226,9398408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[9397227],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[9397368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[9397549],"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[9397731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[9397913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[9398095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[9398277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[9398459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[9398942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[9399420,9399699,9399131,9399218,9399034],"length":1,"stats":{"Line":5},"fn_name":null},{"line":272,"address":[9399709,9399494,9399938],"length":1,"stats":{"Line":3},"fn_name":null},{"line":273,"address":[9399746,9399953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[9180357,9180352],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":280,"address":[9400071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[9400086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[9401092,9400483,9401298,9400129,9400680,9400886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[9400155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[9400320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[9400525],"length":1,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[9400731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":288,"address":[9400937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[9401143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[9401590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[9401844,9401666,9402325,9402046,9401763],"length":1,"stats":{"Line":5},"fn_name":null},{"line":294,"address":[9402120,9402335,9402563],"length":1,"stats":{"Line":3},"fn_name":null},{"line":295,"address":[9402372,9402577],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":132,"coverable":142},{"path":["/","home","todd","rust-bio","src","io","bed.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! BED format reading and writing.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::io::bed;\n//! let example = b\"1\\t5\\t5000\\tname1\\t0.5\";\n//! let mut reader = bed::Reader::new(\u0026example[..]);\n//! let mut writer = bed::Writer::new(vec![]);\n//! for record in reader.records() {\n//!     let rec = record.expect(\"Error reading record.\");\n//!     println!(\"{}\", rec.chrom());\n//!     writer.write(\u0026rec).expect(\"Error writing record.\");\n//! }\n//! ```\n\nuse std::convert::AsRef;\nuse std::fmt::Write;\nuse std::fs;\nuse std::io;\nuse std::marker::Copy;\nuse std::ops::Deref;\nuse std::path::Path;\n\nuse anyhow::Context;\nuse bio_types::annot;\nuse bio_types::annot::loc::Loc;\nuse bio_types::strand;\n\n/// A BED reader.\n#[derive(Debug)]\npub struct Reader\u003cR: io::Read\u003e {\n    inner: csv::Reader\u003cR\u003e,\n}\n\nimpl Reader\u003cfs::File\u003e {\n    /// Read from a given file path.\n    pub fn from_file\u003cP: AsRef\u003cPath\u003e + std::fmt::Debug\u003e(path: P) -\u003e anyhow::Result\u003cSelf\u003e {\n        fs::File::open(\u0026path)\n            .map(Reader::new)\n            .with_context(|| format!(\"Failed to read bed from {:#?}\", path))\n    }\n}\n\nimpl\u003cR: io::Read\u003e Reader\u003cR\u003e {\n    /// Read from a given reader.\n    pub fn new(reader: R) -\u003e Self {\n        Reader {\n            inner: csv::ReaderBuilder::new()\n                .delimiter(b'\\t')\n                .has_headers(false)\n                .from_reader(reader),\n        }\n    }\n\n    /// Iterate over all records.\n    pub fn records(\u0026mut self) -\u003e Records\u003c'_, R\u003e {\n        Records {\n            inner: self.inner.deserialize(),\n        }\n    }\n}\n\n/// An iterator over the records of a BED file.\npub struct Records\u003c'a, R: io::Read\u003e {\n    inner: csv::DeserializeRecordsIter\u003c'a, R, Record\u003e,\n}\n\nimpl\u003c'a, R: io::Read\u003e Iterator for Records\u003c'a, R\u003e {\n    type Item = csv::Result\u003cRecord\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003ccsv::Result\u003cRecord\u003e\u003e {\n        self.inner.next()\n    }\n}\n\n/// A BED writer.\n#[derive(Debug)]\npub struct Writer\u003cW: io::Write\u003e {\n    inner: csv::Writer\u003cW\u003e,\n}\n\nimpl Writer\u003cfs::File\u003e {\n    /// Write to a given file path.\n    #[allow(clippy::wrong_self_convention)]\n    pub fn to_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e io::Result\u003cSelf\u003e {\n        fs::File::create(path).map(Writer::new)\n    }\n}\n\nimpl\u003cW: io::Write\u003e Writer\u003cW\u003e {\n    /// Write to a given writer.\n    pub fn new(writer: W) -\u003e Self {\n        Writer {\n            inner: csv::WriterBuilder::new()\n                .delimiter(b'\\t')\n                .flexible(true)\n                .from_writer(writer),\n        }\n    }\n\n    /// Write a given BED record.\n    pub fn write(\u0026mut self, record: \u0026Record) -\u003e csv::Result\u003c()\u003e {\n        if record.aux.is_empty() {\n            self.inner\n                .serialize(\u0026(\u0026record.chrom, record.start, record.end))\n        } else {\n            self.inner\n                .serialize(\u0026(\u0026record.chrom, record.start, record.end, \u0026record.aux))\n        }\n    }\n}\n\n/// A BED record as defined by BEDtools\n/// (http://bedtools.readthedocs.org/en/latest/content/general-usage.html)\n#[derive(Debug, Serialize, Default, Deserialize, Clone)]\npub struct Record {\n    chrom: String,\n    start: u64,\n    end: u64,\n    #[serde(default)]\n    aux: Vec\u003cString\u003e,\n}\n\nimpl Record {\n    /// Create a new BED record.\n    pub fn new() -\u003e Self {\n        Record {\n            chrom: \"\".to_owned(),\n            start: 0,\n            end: 0,\n            aux: vec![],\n        }\n    }\n\n    /// Chromosome of the feature.\n    pub fn chrom(\u0026self) -\u003e \u0026str {\n        \u0026self.chrom\n    }\n\n    /// Start position of feature (0-based).\n    pub fn start(\u0026self) -\u003e u64 {\n        self.start\n    }\n\n    /// End position of feature (0-based, not included).\n    pub fn end(\u0026self) -\u003e u64 {\n        self.end\n    }\n\n    /// Name of the feature.\n    pub fn name(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.aux(3)\n    }\n\n    /// Score of the feature.\n    pub fn score(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.aux(4)\n    }\n\n    /// Strand of the feature.\n    pub fn strand(\u0026self) -\u003e Option\u003cstrand::Strand\u003e {\n        match self.aux(5) {\n            Some(\"+\") =\u003e Some(strand::Strand::Forward),\n            Some(\"-\") =\u003e Some(strand::Strand::Reverse),\n            _ =\u003e None,\n        }\n    }\n\n    /// Access auxilliary fields after the strand field by index\n    /// (counting first field (chromosome) as 0).\n    pub fn aux(\u0026self, i: usize) -\u003e Option\u003c\u0026str\u003e {\n        let j = i - 3;\n        if j \u003c self.aux.len() {\n            Some(\u0026self.aux[j])\n        } else {\n            None\n        }\n    }\n\n    /// Set chromosome.\n    pub fn set_chrom(\u0026mut self, chrom: \u0026str) {\n        self.chrom = chrom.to_owned();\n    }\n\n    /// Set start of feature.\n    pub fn set_start(\u0026mut self, start: u64) {\n        self.start = start;\n    }\n\n    /// Set end of feature.\n    pub fn set_end(\u0026mut self, end: u64) {\n        self.end = end;\n    }\n\n    /// Set name.\n    pub fn set_name(\u0026mut self, name: \u0026str) {\n        if self.aux.is_empty() {\n            self.aux.push(name.to_owned());\n        } else {\n            self.aux[0] = name.to_owned();\n        }\n    }\n\n    /// Set score.\n    pub fn set_score(\u0026mut self, score: \u0026str) {\n        if self.aux.is_empty() {\n            self.aux.push(\"\".to_owned());\n        }\n        if self.aux.len() \u003c 2 {\n            self.aux.push(score.to_owned());\n        } else {\n            self.aux[1] = score.to_owned();\n        }\n    }\n\n    /// Add auxilliary field. This has to happen after name and score have been set.\n    pub fn push_aux(\u0026mut self, field: \u0026str) {\n        self.aux.push(field.to_owned());\n    }\n}\n\nimpl\u003c'a\u003e From\u003c\u0026'a Record\u003e for annot::contig::Contig\u003cString, strand::Strand\u003e {\n    /// Returns a `Contig` annotation for the BED record.\n    ///\n    /// ```\n    /// use bio::io::bed;\n    /// use bio_types::annot::contig::Contig;\n    /// use bio_types::strand::Strand;\n    /// let example = b\"chr1\\t5\\t5000\\tname1\\t0.5\";\n    /// let mut reader = bed::Reader::new(\u0026example[..]);\n    /// let rec = reader\n    ///     .records()\n    ///     .next()\n    ///     .expect(\"Found no bed record.\")\n    ///     .expect(\"Got a csv::Error\");\n    /// let loc = Contig::from(\u0026rec);\n    /// assert_eq!(loc.to_string(), \"chr1:5-5000\");\n    /// ```\n    fn from(rec: \u0026Record) -\u003e Self {\n        annot::contig::Contig::new(\n            rec.chrom.to_string(),\n            rec.start as isize,\n            (rec.end - rec.start) as usize,\n            rec.strand().unwrap_or(strand::Strand::Unknown),\n        )\n    }\n}\n\n/// Generate a BED format `Record` for an annotation position.\n///\n/// This record will have length 1, and when created it will have an\n/// empty name.\nimpl\u003cR, S\u003e From\u003cannot::pos::Pos\u003cR, S\u003e\u003e for Record\nwhere\n    R: Deref\u003cTarget = str\u003e,\n    S: Into\u003cstrand::Strand\u003e + Copy,\n{\n    fn from(pos: annot::pos::Pos\u003cR, S\u003e) -\u003e Self {\n        let mut bed = Record::new();\n        bed.set_chrom(pos.refid());\n        bed.set_start(pos.pos() as u64);\n        bed.set_end((pos.pos() + 1) as u64);\n        bed.set_name(\"\");\n        bed.set_score(\"0\");\n        bed.push_aux(pos.strand().into().strand_symbol());\n        bed\n    }\n}\n\n/// Generate a BED format `Record` for the location.\n///\n/// As created, it will have an empty name.\nimpl\u003cR, S\u003e From\u003cannot::contig::Contig\u003cR, S\u003e\u003e for Record\nwhere\n    R: Deref\u003cTarget = str\u003e,\n    S: Into\u003cstrand::Strand\u003e + Copy,\n{\n    fn from(contig: annot::contig::Contig\u003cR, S\u003e) -\u003e Self {\n        let mut bed = Record::new();\n        bed.set_chrom(contig.refid());\n        bed.set_start(contig.start() as u64);\n        bed.set_end((contig.start() + contig.length() as isize) as u64);\n        bed.set_name(\"\");\n        bed.set_score(\"0\");\n        bed.push_aux(contig.strand().into().strand_symbol());\n        bed\n    }\n}\n\n/// Generate a BED format `Record` for the position.\n///\n/// Splicing information will be represented with the 12-column\n/// BED format, using columns 10 through 12 (blockCount,\n/// blockSizes, and blockStarts) for exons.\n///\n/// As created, it will have an empty name and default to using\n/// the overall start \u0026 end (columns 1 and 2) for the start and\n/// end of the \"thick\" region (columns 7 and 8).\n/// ```\n/// # extern crate bio;\n/// # extern crate bio_types;\n/// use bio::io::bed;\n/// use bio_types::annot::spliced::{Spliced, SplicingError};\n/// use bio_types::annot::AnnotError;\n/// use bio_types::strand::ReqStrand;\n/// # fn try_main() -\u003e Result\u003c(), Box\u003cSplicingError\u003e\u003e {\n/// let tad3 = Spliced::with_lengths_starts(\n///     \"chrXII\".to_owned(),\n///     765265,\n///     \u0026vec![808, 52, 109],\n///     \u0026vec![0, 864, 984],\n///     ReqStrand::Reverse,\n/// )\n/// .expect(\"Encountered a bio_types::annot::spliced::SplicingError.\");\n/// assert_eq!(\n///     tad3.to_string(),\n///     \"chrXII:765265-766073;766129-766181;766249-766358(-)\"\n/// );\n/// let tad3_exons = tad3.exon_contigs();\n/// assert_eq!(tad3_exons.len(), 3);\n/// assert_eq!(tad3_exons[0].to_string(), \"chrXII:766249-766358(-)\");\n/// assert_eq!(tad3_exons[1].to_string(), \"chrXII:766129-766181(-)\");\n/// assert_eq!(tad3_exons[2].to_string(), \"chrXII:765265-766073(-)\");\n/// let mut buf = Vec::new();\n/// {\n///     let mut writer = bed::Writer::new(\u0026mut buf);\n///     let mut tad3_bed = bed::Record::from(tad3);\n///     tad3_bed.set_name(\"YLR316C\");\n///     writer.write(\u0026tad3_bed).unwrap();\n/// }\n/// assert_eq!(\n///     \"chrXII\\t765265\\t766358\\tYLR316C\\t0\\t-\\t765265\\t766358\\t0\\t3\\t808,52,109,\\t0,864,984,\\n\",\n///     String::from_utf8(buf)\n///         .unwrap_or_else(|_| \"???\".to_owned())\n///         .as_str()\n/// );\n/// # Ok(())\n/// # }\n/// # fn main() { try_main().unwrap(); }\n/// ```\nimpl\u003cR, S\u003e From\u003cannot::spliced::Spliced\u003cR, S\u003e\u003e for Record\nwhere\n    R: Deref\u003cTarget = str\u003e,\n    S: Into\u003cstrand::Strand\u003e + Copy,\n{\n    fn from(spliced: annot::spliced::Spliced\u003cR, S\u003e) -\u003e Self {\n        let mut bed = Record::new();\n        bed.set_chrom(spliced.refid());\n        bed.set_start(spliced.start() as u64);\n        bed.set_end((spliced.start() + spliced.length() as isize) as u64);\n        bed.set_name(\"\");\n        bed.set_score(\"0\");\n        bed.push_aux(spliced.strand().into().strand_symbol());\n        bed.push_aux(spliced.start().to_string().as_str()); // thickStart = chromStart\n        bed.push_aux(\n            (spliced.start() + spliced.length() as isize)\n                .to_string()\n                .as_str(),\n        ); // thickEnd = chromEnd\n        bed.push_aux(\"0\"); // RGB color = black\n\n        bed.push_aux(spliced.exon_count().to_string().as_str());\n\n        let mut block_sizes = String::new();\n        for block_size in spliced.exon_lengths() {\n            write!(block_sizes, \"{},\", block_size).unwrap();\n        }\n        bed.push_aux(\u0026block_sizes);\n\n        let mut block_starts = String::new();\n        for block_start in spliced.exon_starts() {\n            write!(block_starts, \"{},\", block_start).unwrap();\n        }\n        bed.push_aux(\u0026block_starts);\n        bed\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use bio_types::annot::{contig::Contig, pos::Pos, spliced::Spliced};\n    use bio_types::strand::{ReqStrand, Strand};\n\n    const BED_FILE: \u0026[u8] = b\"1\\t5\\t5000\\tname1\\tup\n2\\t3\\t5005\\tname2\\tup\n\";\n    const BED_FILE_COMPACT: \u0026[u8] = b\"1\\t5\\t5000\\n2\\t3\\t5005\\n\";\n\n    #[test]\n    fn test_reader() {\n        let chroms = [\"1\", \"2\"];\n        let starts = [5, 3];\n        let ends = [5000, 5005];\n        let names = [\"name1\", \"name2\"];\n        let scores = [\"up\", \"up\"];\n\n        let mut reader = Reader::new(BED_FILE);\n        for (i, r) in reader.records().enumerate() {\n            let record = r.expect(\"Error reading record\");\n            assert_eq!(record.chrom(), chroms[i]);\n            assert_eq!(record.start(), starts[i]);\n            assert_eq!(record.end(), ends[i]);\n            assert_eq!(record.name().expect(\"Error reading name\"), names[i]);\n            assert_eq!(record.score().expect(\"Error reading score\"), scores[i]);\n        }\n    }\n\n    #[test]\n    fn test_reader_compact() {\n        let chroms = [\"1\", \"2\"];\n        let starts = [5, 3];\n        let ends = [5000, 5005];\n\n        let mut reader = Reader::new(BED_FILE_COMPACT);\n        for (i, r) in reader.records().enumerate() {\n            let record = r.unwrap();\n            assert_eq!(record.chrom(), chroms[i]);\n            assert_eq!(record.start(), starts[i]);\n            assert_eq!(record.end(), ends[i]);\n        }\n    }\n\n    #[test]\n    fn test_reader_from_file_path_doesnt_exist_returns_err() {\n        let path = Path::new(\"/I/dont/exist.bed\");\n        let error = Reader::from_file(path)\n            .unwrap_err()\n            .downcast::\u003cString\u003e()\n            .unwrap();\n\n        assert_eq!(\u0026error, \"Failed to read bed from \\\"/I/dont/exist.bed\\\"\")\n    }\n\n    #[test]\n    fn test_writer() {\n        let mut reader = Reader::new(BED_FILE);\n        let mut writer = Writer::new(vec![]);\n        for r in reader.records() {\n            writer\n                .write(\u0026r.expect(\"Error reading record\"))\n                .expect(\"Error writing record\");\n        }\n        assert_eq!(writer.inner.into_inner().unwrap(), BED_FILE);\n    }\n\n    #[test]\n    fn spliced_to_bed() {\n        //chrV    166236  166885  YER007C-A       0       -       166236  166885  0       2       535,11, 0,638,\n        let tma20 = Spliced::with_lengths_starts(\n            \"chrV\".to_owned(),\n            166236,\n            \u0026[535, 11],\n            \u0026[0, 638],\n            ReqStrand::Reverse,\n        )\n        .unwrap();\n        let mut buf = Vec::new();\n        {\n            let mut writer = Writer::new(\u0026mut buf);\n            let mut tma20_bed = Record::from(tma20);\n            tma20_bed.set_name(\"YER007C-A\");\n            writer.write(\u0026tma20_bed).unwrap();\n        }\n        assert_eq!(\n            \"chrV\\t166236\\t166885\\tYER007C-A\\t0\\t-\\t166236\\t166885\\t0\\t2\\t535,11,\\t0,638,\\n\",\n            String::from_utf8(buf).unwrap().as_str()\n        );\n\n        //chrXVI  173151  174702  YPL198W 0       +       173151  174702  0       3       11,94,630,      0,420,921,\n        let rpl7b = Spliced::with_lengths_starts(\n            \"chrXVI\".to_owned(),\n            173151,\n            \u0026[11, 94, 630],\n            \u0026[0, 420, 921],\n            ReqStrand::Forward,\n        )\n        .unwrap();\n        let mut buf = Vec::new();\n        {\n            let mut writer = Writer::new(\u0026mut buf);\n            let mut rpl7b_bed = Record::from(rpl7b);\n            rpl7b_bed.set_name(\"YPL198W\");\n            writer.write(\u0026rpl7b_bed).unwrap();\n        }\n        assert_eq!(\n            \"chrXVI\\t173151\\t174702\\tYPL198W\\t0\\t+\\t173151\\t174702\\t0\\t3\\t11,94,630,\\t0,420,921,\\n\",\n            String::from_utf8(buf).unwrap().as_str()\n        );\n\n        //chrXII  765265  766358  YLR316C 0       -       765265  766358  0       3       808,52,109,     0,864,984,\n        let tad3 = Spliced::with_lengths_starts(\n            \"chrXII\".to_owned(),\n            765265,\n            \u0026[808, 52, 109],\n            \u0026[0, 864, 984],\n            ReqStrand::Reverse,\n        )\n        .unwrap();\n        let mut buf = Vec::new();\n        {\n            let mut writer = Writer::new(\u0026mut buf);\n            let mut tad3_bed = Record::from(tad3);\n            tad3_bed.set_name(\"YLR316C\");\n            writer.write(\u0026tad3_bed).unwrap();\n        }\n        assert_eq!(\"chrXII\\t765265\\t766358\\tYLR316C\\t0\\t-\\t765265\\t766358\\t0\\t3\\t808,52,109,\\t0,864,984,\\n\",\n                   String::from_utf8(buf).unwrap().as_str());\n    }\n\n    #[test]\n    fn test_bed_from_contig() {\n        let contig = Contig::new(\n            \"chrXI\".to_owned(),\n            334412,\n            334916 - 334412,\n            ReqStrand::Reverse,\n        );\n\n        let record = Record::from(contig);\n\n        assert_eq!(record.chrom(), String::from(\"chrXI\"));\n        assert_eq!(record.start(), 334412);\n        assert_eq!(record.end(), 334412 + (334916 - 334412));\n        assert_eq!(record.name(), Some(\"\"));\n        assert_eq!(record.score(), Some(\"0\"));\n        assert_eq!(record.strand(), Some(Strand::Reverse));\n    }\n\n    #[test]\n    fn test_bed_from_pos() {\n        let pos = Pos::new(\"chrXI\".to_owned(), 334412, ReqStrand::Reverse);\n\n        let record = Record::from(pos);\n\n        assert_eq!(record.chrom(), String::from(\"chrXI\"));\n        assert_eq!(record.start(), 334412);\n        assert_eq!(record.end(), 334412 + 1);\n        assert_eq!(record.name(), Some(\"\"));\n        assert_eq!(record.score(), Some(\"0\"));\n        assert_eq!(record.strand(), Some(Strand::Reverse));\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":360,"address":[5467035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[5467514],"length":1,"stats":{"Line":1},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[4340980,4338320],"length":1,"stats":{"Line":3},"fn_name":"test_reader"},{"line":399,"address":[4338327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":400,"address":[4338389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":401,"address":[4338413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":402,"address":[4338437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":403,"address":[4338491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":405,"address":[4338545],"length":1,"stats":{"Line":1},"fn_name":null},{"line":406,"address":[4338831,4338672,4338586,4338859,4340923],"length":1,"stats":{"Line":4},"fn_name":null},{"line":407,"address":[4339219],"length":1,"stats":{"Line":1},"fn_name":null},{"line":408,"address":[4339674,4339349,4339482],"length":1,"stats":{"Line":2},"fn_name":null},{"line":409,"address":[4339640,4339943,4339734],"length":1,"stats":{"Line":2},"fn_name":null},{"line":410,"address":[4340011,4339909,4340213],"length":1,"stats":{"Line":2},"fn_name":null},{"line":411,"address":[4340552,4340180,4340275],"length":1,"stats":{"Line":2},"fn_name":null},{"line":412,"address":[4340868,4340519,4340609],"length":1,"stats":{"Line":2},"fn_name":null},{"line":417,"address":[4342781,4341008],"length":1,"stats":{"Line":3},"fn_name":"test_reader_compact"},{"line":418,"address":[4341015],"length":1,"stats":{"Line":1},"fn_name":null},{"line":419,"address":[4341065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[4341089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[4341113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":423,"address":[4341240,4342724,4341427,4341154,4341399],"length":1,"stats":{"Line":4},"fn_name":null},{"line":424,"address":[4341784],"length":1,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[4341902,4342017,4342182],"length":1,"stats":{"Line":2},"fn_name":null},{"line":426,"address":[4342157,4342236,4342424],"length":1,"stats":{"Line":2},"fn_name":null},{"line":427,"address":[4342664,4342399,4342486],"length":1,"stats":{"Line":2},"fn_name":null},{"line":432,"address":[4342816,4343160],"length":1,"stats":{"Line":3},"fn_name":"test_reader_from_file_path_doesnt_exist_returns_err"},{"line":433,"address":[4342823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":434,"address":[4342876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[4342950,4343114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":443,"address":[4343184,4344525],"length":1,"stats":{"Line":3},"fn_name":"test_writer"},{"line":444,"address":[4343191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":445,"address":[4343308,4343229],"length":1,"stats":{"Line":2},"fn_name":null},{"line":446,"address":[4343561,4344144,4343329,4343397,4343533],"length":1,"stats":{"Line":4},"fn_name":null},{"line":447,"address":[4344035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":448,"address":[4343897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":451,"address":[4344182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":455,"address":[4347595,4344560],"length":1,"stats":{"Line":3},"fn_name":"spliced_to_bed"},{"line":458,"address":[4344615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":462,"address":[4344640],"length":1,"stats":{"Line":1},"fn_name":null},{"line":465,"address":[4344754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":467,"address":[4344797],"length":1,"stats":{"Line":1},"fn_name":null},{"line":468,"address":[4344845],"length":1,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[4344997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[4345140,4345077],"length":1,"stats":{"Line":2},"fn_name":null},{"line":472,"address":[4345350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":474,"address":[4345184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":479,"address":[4345572],"length":1,"stats":{"Line":1},"fn_name":null},{"line":483,"address":[4345599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[4345714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[4345757],"length":1,"stats":{"Line":1},"fn_name":null},{"line":489,"address":[4345805],"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[4345957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":491,"address":[4346037,4346094],"length":1,"stats":{"Line":2},"fn_name":null},{"line":493,"address":[4346292],"length":1,"stats":{"Line":1},"fn_name":null},{"line":495,"address":[4346138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[4346509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":504,"address":[4346536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":507,"address":[4346651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[4346694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[4346742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[4346894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[4346974,4347031],"length":1,"stats":{"Line":2},"fn_name":null},{"line":514,"address":[4347229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[4347075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":519,"address":[4347632,4347829],"length":1,"stats":{"Line":3},"fn_name":"test_bed_from_contig"},{"line":521,"address":[4347647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[4347680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":527,"address":[4347746],"length":1,"stats":{"Line":1},"fn_name":null},{"line":529,"address":[4347868,4348004],"length":1,"stats":{"Line":2},"fn_name":null},{"line":530,"address":[4348237,4348408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":531,"address":[4348468,4348606,4348374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":532,"address":[4348573,4348668,4348821],"length":1,"stats":{"Line":2},"fn_name":null},{"line":533,"address":[4348788,4348878,4349021],"length":1,"stats":{"Line":2},"fn_name":null},{"line":534,"address":[4348998,4349072,4349200],"length":1,"stats":{"Line":2},"fn_name":null},{"line":538,"address":[4349264,4350768],"length":1,"stats":{"Line":3},"fn_name":"test_bed_from_pos"},{"line":539,"address":[4349271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":541,"address":[4349342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":543,"address":[4349533,4349397],"length":1,"stats":{"Line":2},"fn_name":null},{"line":544,"address":[4349934,4349766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":545,"address":[4349991,4350129,4349903],"length":1,"stats":{"Line":2},"fn_name":null},{"line":546,"address":[4350096,4350344,4350191],"length":1,"stats":{"Line":2},"fn_name":null},{"line":547,"address":[4350311,4350544,4350401],"length":1,"stats":{"Line":2},"fn_name":null},{"line":548,"address":[4350595,4350521,4350721],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":172,"coverable":190},{"path":["/","home","todd","rust-bio","src","io","fasta.rs"],"content":"// Copyright 2014-2018 Johannes Köster, Christopher Schröder, Henning Timm.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Structs and trait to read and write files in FASTA format.\n//!\n//! # Example\n//!\n//! ## Read\n//!\n//! In this example, we parse a fasta file from stdin and compute some statistics\n//!\n//! ```\n//! use bio::io::fasta;\n//! use std::io;\n//!\n//! let mut reader = fasta::Reader::new(io::stdin());\n//!\n//! let mut nb_reads = 0;\n//! let mut nb_bases = 0;\n//!\n//! for result in reader.records() {\n//!     let record = result.expect(\"Error during fasta record parsing\");\n//!     println!(\"{}\", record.id());\n//!\n//!     nb_reads += 1;\n//!     nb_bases += record.seq().len();\n//! }\n//!\n//! println!(\"Number of reads: {}\", nb_reads);\n//! println!(\"Number of bases: {}\", nb_bases);\n//! ```\n//!\n//! We can also use a `while` loop to iterate over records.\n//! This is slightly faster than the `for` loop.\n//! ```\n//! use bio::io::fasta;\n//! use std::io;\n//! let mut records = fasta::Reader::new(io::stdin()).records();\n//!\n//! let mut nb_reads = 0;\n//! let mut nb_bases = 0;\n//!\n//! while let Some(Ok(record)) = records.next() {\n//!     nb_reads += 1;\n//!     nb_bases += record.seq().len();\n//! }\n//!\n//! println!(\"Number of reads: {}\", nb_reads);\n//! println!(\"Number of bases: {}\", nb_bases);\n//! ```\n//!\n//! ## Write\n//!\n//! In this example we generate 10 random sequences with length 100 and write them to stdout.\n//!\n//! ```\n//! use std::io;\n//! use bio::io::fasta;\n//!\n//! let mut seed = 42;\n//!\n//! let nucleotides = [b'A', b'C', b'G', b'T'];\n//!\n//! let mut writer = fasta::Writer::new(io::stdout());\n//!\n//! for _ in 0..10 {\n//!     let seq = (0..100).map(|_| {\n//!         seed = ((seed ^ seed \u003c\u003c 13) ^ seed \u003e\u003e 7) ^ seed \u003c\u003c 17; // don't use this random generator\n//!         nucleotides[seed % 4]\n//!     }).collect::\u003cVec\u003cu8\u003e\u003e();\n//!\n//!    writer.write(\"random\", None, seq.as_slice()).expect(\"Error writing record.\");\n//! }\n//! ```\n//!\n//! ## Read and Write\n//!\n//! In this example we filter reads from stdin on sequence length and write them to stdout\n//!\n//! ```\n//! use bio::io::fasta;\n//! use bio::io::fasta::FastaRead;\n//! use std::io;\n//!\n//! let mut reader = fasta::Reader::new(io::stdin());\n//! let mut writer = fasta::Writer::new(io::stdout());\n//! let mut record = fasta::Record::new();\n//!\n//! while let Ok(()) = reader.read(\u0026mut record) {\n//!     if record.is_empty() {\n//!         break;\n//!     }\n//!\n//!     if record.seq().len() \u003e 100 {\n//!         writer\n//!             .write_record(\u0026record)\n//!             .ok()\n//!             .expect(\"Error writing record.\");\n//!     }\n//! }\n//! ```\n//!\n//! ## Index\n//!\n//! Random access to FASTA files is facilitated by [`Index`] and [`IndexedReader`]. The FASTA files\n//! must already be indexed with [`samtools faidx`](https://www.htslib.org/doc/faidx.html).\n//!\n//! In this example, we read in the first 10 bases of the sequence named \"chr1\".\n//!\n//! ```rust\n//! use bio::io::fasta::IndexedReader;\n//! // create dummy files\n//! const FASTA_FILE: \u0026[u8] = b\"\u003echr1\\nGTAGGCTGAAAA\\nCCCC\";\n//! const FAI_FILE: \u0026[u8] = b\"chr1\\t16\\t6\\t12\\t13\";\n//!\n//! let seq_name = \"chr1\";\n//! let start: u64 = 0;  // start is 0-based, inclusive\n//! let stop: u64 = 10;  // stop is 0-based, exclusive\n//! // load the index\n//! let mut faidx = IndexedReader::new(std::io::Cursor::new(FASTA_FILE), FAI_FILE).unwrap();\n//! // move the pointer in the index to the desired sequence and interval\n//! faidx.fetch(seq_name, start, stop).expect(\"Couldn't fetch interval\");\n//! // read the subsequence defined by the interval into a vector\n//! let mut seq = Vec::new();\n//! faidx.read(\u0026mut seq).expect(\"Couldn't read the interval\");\n//! assert_eq!(seq, b\"GTAGGCTGAA\");\n//! ```\n//!\n\nuse std::cmp::min;\nuse std::collections;\nuse std::convert::AsRef;\nuse std::fs;\nuse std::io;\nuse std::io::prelude::*;\nuse std::path::Path;\n\nuse crate::utils::{Text, TextSlice};\nuse anyhow::Context;\nuse std::fmt;\n\n/// Maximum size of temporary buffer used for reading indexed FASTA files.\nconst MAX_FASTA_BUFFER_SIZE: usize = 512;\n\n/// Trait for FASTA readers.\npub trait FastaRead {\n    fn read(\u0026mut self, record: \u0026mut Record) -\u003e io::Result\u003c()\u003e;\n}\n\n/// A FASTA reader.\n#[derive(Debug)]\npub struct Reader\u003cR: io::Read\u003e {\n    reader: io::BufReader\u003cR\u003e,\n    line: String,\n}\n\nimpl Reader\u003cfs::File\u003e {\n    /// Read FASTA from given file path.\n    pub fn from_file\u003cP: AsRef\u003cPath\u003e + std::fmt::Debug\u003e(path: P) -\u003e anyhow::Result\u003cSelf\u003e {\n        fs::File::open(\u0026path)\n            .map(Reader::new)\n            .with_context(|| format!(\"Failed to read fasta from {:#?}\", path))\n    }\n}\n\nimpl\u003cR: io::Read\u003e Reader\u003cR\u003e {\n    /// Create a new Fasta reader given an instance of `io::Read`.\n    ///\n    /// # Example\n    /// ```rust\n    /// # use std::io;\n    /// # use bio::io::fasta::Reader;\n    /// # fn main() {\n    /// # const fasta_file: \u0026'static [u8] = b\"\u003eid desc\n    /// # AAAA\n    /// # \";\n    /// let reader = Reader::new(fasta_file);\n    /// # }\n    /// ```\n    pub fn new(reader: R) -\u003e Self {\n        Reader {\n            reader: io::BufReader::new(reader),\n            line: String::new(),\n        }\n    }\n\n    /// Return an iterator over the records of this Fasta file.\n    ///\n    /// # Example\n    /// ```rust\n    /// # use std::io;\n    /// # use bio::io::fasta::Reader;\n    /// # use bio::io::fasta::Record;\n    /// # fn main() {\n    /// # const fasta_file: \u0026'static [u8] = b\"\u003eid desc\n    /// # AAAA\n    /// # \";\n    /// # let reader = Reader::new(fasta_file);\n    /// for record in reader.records() {\n    ///     let record = record.unwrap();\n    ///     assert_eq!(record.id(), \"id\");\n    ///     assert_eq!(record.desc().unwrap(), \"desc\");\n    ///     assert_eq!(record.seq().to_vec(), b\"AAAA\");\n    /// }\n    /// # }\n    /// ```\n    pub fn records(self) -\u003e Records\u003cR\u003e {\n        Records {\n            reader: self,\n            error_has_occured: false,\n        }\n    }\n\n    pub(crate) fn new_with_line(reader: io::BufReader\u003cR\u003e, line: String) -\u003e Self {\n        Reader { reader, line }\n    }\n}\n\nimpl\u003cR\u003e FastaRead for Reader\u003cR\u003e\nwhere\n    R: io::Read,\n{\n    /// Read the next FASTA record into the given `Record`.\n    /// An empty record indicates that no more records can be read.\n    ///\n    /// Use this method when you want to read records as fast as\n    /// possible because it allows the reuse of a `Record` allocation.\n    ///\n    /// The [records](Reader::records) iterator provides a more ergonomic\n    /// approach to accessing FASTA records.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the record is incomplete,\n    /// syntax is violated or any form of I/O error is encountered.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use bio::io::fasta::Record;\n    /// use bio::io::fasta::{FastaRead, Reader};\n    ///\n    /// const fasta_file: \u0026'static [u8] = b\"\u003eid desc\n    /// AAAA\n    /// \";\n    /// let mut reader = Reader::new(fasta_file);\n    /// let mut record = Record::new();\n    ///\n    /// // Check for errors parsing the record\n    /// reader\n    ///     .read(\u0026mut record)\n    ///     .expect(\"fasta reader: got an io::Error or could not read_line()\");\n    ///\n    /// assert_eq!(record.id(), \"id\");\n    /// assert_eq!(record.desc().unwrap(), \"desc\");\n    /// assert_eq!(record.seq().to_vec(), b\"AAAA\");\n    /// ```\n    fn read(\u0026mut self, record: \u0026mut Record) -\u003e io::Result\u003c()\u003e {\n        record.clear();\n        if self.line.is_empty() {\n            self.reader.read_line(\u0026mut self.line)?;\n            if self.line.is_empty() {\n                return Ok(());\n            }\n        }\n\n        if !self.line.starts_with('\u003e') {\n            return Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"Expected \u003e at record start.\",\n            ));\n        }\n        let mut header_fields = self.line[1..].trim_end().splitn(2, char::is_whitespace);\n        record.id = header_fields.next().map(|s| s.to_owned()).unwrap();\n        record.desc = header_fields.next().map(|s| s.to_owned());\n        loop {\n            self.line.clear();\n            self.reader.read_line(\u0026mut self.line)?;\n            if self.line.is_empty() || self.line.starts_with('\u003e') {\n                break;\n            }\n            record.seq.push_str(self.line.trim_end());\n        }\n\n        Ok(())\n    }\n}\n\n/// A FASTA index as created by SAMtools (.fai).\n#[derive(Debug, Clone)]\npub struct Index {\n    inner: Vec\u003cIndexRecord\u003e,\n    name_to_rid: collections::HashMap\u003cString, usize\u003e,\n}\n\nimpl Index {\n    /// Open a FASTA index from a given `io::Read` instance.\n    pub fn new\u003cR: io::Read\u003e(fai: R) -\u003e csv::Result\u003cSelf\u003e {\n        let mut inner = vec![];\n        let mut name_to_rid = collections::HashMap::new();\n\n        let mut fai_reader = csv::ReaderBuilder::new()\n            .delimiter(b'\\t')\n            .has_headers(false)\n            .from_reader(fai);\n        for (rid, row) in fai_reader.deserialize().enumerate() {\n            let record: IndexRecord = row?;\n            name_to_rid.insert(record.name.clone(), rid);\n            inner.push(record);\n        }\n        Ok(Index { inner, name_to_rid })\n    }\n\n    /// Open a FASTA index from a given file path.\n    pub fn from_file\u003cP: AsRef\u003cPath\u003e + std::fmt::Debug\u003e(path: \u0026P) -\u003e anyhow::Result\u003cSelf\u003e {\n        fs::File::open(\u0026path)\n            .map_err(csv::Error::from)\n            .and_then(Self::new)\n            .with_context(|| format!(\"Failed to read fasta index from {:#?}\", path))\n    }\n\n    /// Open a FASTA index given the corresponding FASTA file path.\n    /// That is, for ref.fasta we expect ref.fasta.fai.\n    pub fn with_fasta_file\u003cP: AsRef\u003cPath\u003e\u003e(fasta_path: \u0026P) -\u003e anyhow::Result\u003cSelf\u003e {\n        let mut fai_path = fasta_path.as_ref().as_os_str().to_owned();\n        fai_path.push(\".fai\");\n\n        Self::from_file(\u0026fai_path)\n    }\n\n    /// Return a vector of sequences described in the index.\n    pub fn sequences(\u0026self) -\u003e Vec\u003cSequence\u003e {\n        // sort kv pairs by rid to preserve order\n        self.inner\n            .iter()\n            .map(|record| Sequence {\n                name: record.name.clone(),\n                len: record.len,\n            })\n            .collect()\n    }\n}\n\n/// A FASTA reader with an index as created by SAMtools (.fai).\n#[derive(Debug)]\npub struct IndexedReader\u003cR: io::Read + io::Seek\u003e {\n    reader: io::BufReader\u003cR\u003e,\n    pub index: Index,\n    fetched_idx: Option\u003cIndexRecord\u003e,\n    start: Option\u003cu64\u003e,\n    stop: Option\u003cu64\u003e,\n}\n\nimpl IndexedReader\u003cfs::File\u003e {\n    /// Read from a given file path. This assumes the index ref.fasta.fai to be\n    /// present for FASTA ref.fasta.\n    pub fn from_file\u003cP: AsRef\u003cPath\u003e + std::fmt::Debug\u003e(path: \u0026P) -\u003e anyhow::Result\u003cSelf\u003e {\n        let index = Index::with_fasta_file(path)?;\n        fs::File::open(\u0026path)\n            .map(|f| Self::with_index(f, index))\n            .map_err(csv::Error::from)\n            .with_context(|| format!(\"Failed to read fasta from {:#?}\", path))\n    }\n}\n\nimpl\u003cR: io::Read + io::Seek\u003e IndexedReader\u003cR\u003e {\n    /// Read from a FASTA and its index, both given as `io::Read`. FASTA has to\n    /// be `io::Seek` in addition.\n    pub fn new\u003cI: io::Read\u003e(fasta: R, fai: I) -\u003e csv::Result\u003cSelf\u003e {\n        let index = Index::new(fai)?;\n        Ok(IndexedReader {\n            reader: io::BufReader::new(fasta),\n            index,\n            fetched_idx: None,\n            start: None,\n            stop: None,\n        })\n    }\n\n    /// Read from a FASTA and its index, the first given as `io::Read`, the\n    /// second given as index object.\n    pub fn with_index(fasta: R, index: Index) -\u003e Self {\n        IndexedReader {\n            reader: io::BufReader::new(fasta),\n            index,\n            fetched_idx: None,\n            start: None,\n            stop: None,\n        }\n    }\n\n    /// Fetch an interval from the sequence with the given name for reading.\n    ///\n    /// `start` and `stop` are 0-based and `stop` is exclusive - i.e. `[start, stop)`\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use bio::io::fasta::IndexedReader;\n    /// // create dummy files\n    /// const FASTA_FILE: \u0026[u8] = b\"\u003echr1\\nGTAGGCTGAAAA\\nCCCC\";\n    /// const FAI_FILE: \u0026[u8] = b\"chr1\\t16\\t6\\t12\\t13\";\n    ///\n    /// let seq_name = \"chr1\";\n    /// let start: u64 = 0;  // start is 0-based, inclusive\n    /// let stop: u64 = 10;  // stop is 0-based, exclusive\n    /// // load the index\n    /// let mut faidx = IndexedReader::new(std::io::Cursor::new(FASTA_FILE), FAI_FILE).unwrap();\n    /// // move the pointer in the index to the desired sequence and interval\n    /// faidx.fetch(seq_name, start, stop).expect(\"Couldn't fetch interval\");\n    /// // read the subsequence defined by the interval into a vector\n    /// let mut seq = Vec::new();\n    /// faidx.read(\u0026mut seq).expect(\"Couldn't read the interval\");\n    /// assert_eq!(seq, b\"GTAGGCTGAA\");\n    /// ```\n    ///\n    /// # Errors\n    /// If the `seq_name` does not exist within the index.\n    ///\n    pub fn fetch(\u0026mut self, seq_name: \u0026str, start: u64, stop: u64) -\u003e io::Result\u003c()\u003e {\n        let idx = self.idx(seq_name)?;\n        self.start = Some(start);\n        self.stop = Some(stop);\n        self.fetched_idx = Some(idx);\n        Ok(())\n    }\n\n    /// Fetch an interval from the sequence with the given record index for reading.\n    ///\n    /// `start` and `stop` are 0-based and `stop` is exclusive - i.e. `[start, stop)`\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use bio::io::fasta::IndexedReader;\n    /// // create dummy files\n    /// const FASTA_FILE: \u0026[u8] = b\"\u003echr1\\nGTAGGCTGAAAA\\nCCCC\";\n    /// const FAI_FILE: \u0026[u8] = b\"chr1\\t16\\t6\\t12\\t13\";\n    ///\n    /// let rid: usize = 0;\n    /// let start: u64 = 0;  // start is 0-based, inclusive\n    /// let stop: u64 = 10;  // stop is 0-based, exclusive\n    /// // load the index\n    /// let mut faidx = IndexedReader::new(std::io::Cursor::new(FASTA_FILE), FAI_FILE).unwrap();\n    /// // move the pointer in the index to the desired sequence and interval\n    /// faidx.fetch_by_rid(rid, start, stop).expect(\"Couldn't fetch interval\");\n    /// // read the subsequence defined by the interval into a vector\n    /// let mut seq = Vec::new();\n    /// faidx.read(\u0026mut seq).expect(\"Couldn't read the interval\");\n    /// assert_eq!(seq, b\"GTAGGCTGAA\");\n    /// ```\n    ///\n    /// # Errors\n    /// If `rid` does not exist within the index.\n    ///\n    pub fn fetch_by_rid(\u0026mut self, rid: usize, start: u64, stop: u64) -\u003e io::Result\u003c()\u003e {\n        let idx = self.idx_by_rid(rid)?;\n        self.start = Some(start);\n        self.stop = Some(stop);\n        self.fetched_idx = Some(idx);\n        Ok(())\n    }\n\n    /// Fetch the whole sequence with the given name for reading.\n    pub fn fetch_all(\u0026mut self, seq_name: \u0026str) -\u003e io::Result\u003c()\u003e {\n        let idx = self.idx(seq_name)?;\n        self.start = Some(0);\n        self.stop = Some(idx.len);\n        self.fetched_idx = Some(idx);\n        Ok(())\n    }\n\n    /// Fetch the whole sequence with the given record index for reading.\n    pub fn fetch_all_by_rid(\u0026mut self, rid: usize) -\u003e io::Result\u003c()\u003e {\n        let idx = self.idx_by_rid(rid)?;\n        self.start = Some(0);\n        self.stop = Some(idx.len);\n        self.fetched_idx = Some(idx);\n        Ok(())\n    }\n\n    /// Read the fetched sequence into the given vector.\n    pub fn read(\u0026mut self, seq: \u0026mut Text) -\u003e io::Result\u003c()\u003e {\n        let idx = self.fetched_idx.clone();\n        match (idx, self.start, self.stop) {\n            (Some(idx), Some(start), Some(stop)) =\u003e self.read_into_buffer(idx, start, stop, seq),\n            _ =\u003e Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"No sequence fetched for reading.\",\n            )),\n        }\n    }\n\n    /// Return an iterator yielding the fetched sequence.\n    pub fn read_iter(\u0026mut self) -\u003e io::Result\u003cIndexedReaderIterator\u003c'_, R\u003e\u003e {\n        let idx = self.fetched_idx.clone();\n        match (idx, self.start, self.stop) {\n            (Some(idx), Some(start), Some(stop)) =\u003e self.read_into_iter(idx, start, stop),\n            _ =\u003e Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"No sequence fetched for reading.\",\n            )),\n        }\n    }\n\n    fn read_into_buffer(\n        \u0026mut self,\n        idx: IndexRecord,\n        start: u64,\n        stop: u64,\n        seq: \u0026mut Text,\n    ) -\u003e io::Result\u003c()\u003e {\n        if stop \u003e idx.len {\n            return Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"FASTA read interval was out of bounds\",\n            ));\n        } else if start \u003e stop {\n            return Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"Invalid query interval\",\n            ));\n        }\n\n        let mut bases_left = stop - start;\n        let mut line_offset = self.seek_to(\u0026idx, start)?;\n\n        seq.clear();\n        while bases_left \u003e 0 {\n            bases_left -= self.read_line(\u0026idx, \u0026mut line_offset, bases_left, seq)?;\n        }\n\n        Ok(())\n    }\n\n    fn read_into_iter(\n        \u0026mut self,\n        idx: IndexRecord,\n        start: u64,\n        stop: u64,\n    ) -\u003e io::Result\u003cIndexedReaderIterator\u003c'_, R\u003e\u003e {\n        if stop \u003e idx.len {\n            return Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"FASTA read interval was out of bounds\",\n            ));\n        } else if start \u003e stop {\n            return Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"Invalid query interval\",\n            ));\n        }\n\n        let bases_left = stop - start;\n        let line_offset = self.seek_to(\u0026idx, start)?;\n        let capacity = min(\n            MAX_FASTA_BUFFER_SIZE,\n            min(bases_left, idx.line_bases) as usize,\n        );\n\n        Ok(IndexedReaderIterator {\n            reader: self,\n            record: idx,\n            bases_left,\n            line_offset,\n            buf: Vec::with_capacity(capacity),\n            buf_idx: 0,\n        })\n    }\n\n    /// Return the IndexRecord for the given sequence name or io::Result::Err\n    fn idx(\u0026self, seqname: \u0026str) -\u003e io::Result\u003cIndexRecord\u003e {\n        match self.index.name_to_rid.get(seqname) {\n            Some(rid) =\u003e self.idx_by_rid(*rid),\n            None =\u003e Err(io::Error::new(\n                io::ErrorKind::Other,\n                format!(\"Unknown sequence name: {}.\", seqname),\n            )),\n        }\n    }\n\n    /// Return the IndexRecord for the given record index or io::Result::Err\n    fn idx_by_rid(\u0026self, rid: usize) -\u003e io::Result\u003cIndexRecord\u003e {\n        match self.index.inner.get(rid) {\n            Some(record) =\u003e Ok(record.clone()),\n            None =\u003e Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"Invalid record index in fasta file.\",\n            )),\n        }\n    }\n\n    /// Seek to the given position in the specified FASTA record. The position\n    /// of the cursor on the line that the seek ended on is returned.\n    fn seek_to(\u0026mut self, idx: \u0026IndexRecord, start: u64) -\u003e io::Result\u003cu64\u003e {\n        assert!(start \u003c= idx.len);\n\n        let line_offset = start % idx.line_bases;\n        let line_start = start / idx.line_bases * idx.line_bytes;\n        let offset = idx.offset + line_start + line_offset;\n        self.reader.seek(io::SeekFrom::Start(offset))?;\n\n        Ok(line_offset)\n    }\n\n    /// Tries to read up to `bases_left` bases from the current line into `buf`,\n    /// returning the actual number of bases read. Depending on the amount of\n    /// whitespace per line, the current `line_offset`, and the amount of bytes\n    /// returned from `BufReader::fill_buf`, this function may return Ok(0)\n    /// multiple times in a row.\n    fn read_line(\n        \u0026mut self,\n        idx: \u0026IndexRecord,\n        line_offset: \u0026mut u64,\n        bases_left: u64,\n        buf: \u0026mut Vec\u003cu8\u003e,\n    ) -\u003e io::Result\u003cu64\u003e {\n        let (bytes_to_read, bytes_to_keep) = {\n            let src = self.reader.fill_buf()?;\n            if src.is_empty() {\n                return Err(io::Error::new(\n                    io::ErrorKind::UnexpectedEof,\n                    \"FASTA file is truncated.\",\n                ));\n            }\n\n            let bases_on_line = idx.line_bases - min(idx.line_bases, *line_offset);\n            let bases_in_buffer = min(src.len() as u64, bases_on_line);\n\n            let (bytes_to_read, bytes_to_keep) = if bases_in_buffer \u003c= bases_left {\n                let bytes_to_read = min(src.len() as u64, idx.line_bytes - *line_offset);\n\n                (bytes_to_read, bases_in_buffer)\n            } else {\n                (bases_left, bases_left)\n            };\n\n            buf.extend_from_slice(\u0026src[..bytes_to_keep as usize]);\n            (bytes_to_read, bytes_to_keep)\n        };\n\n        self.reader.consume(bytes_to_read as usize);\n\n        assert!(bytes_to_read \u003e 0);\n        *line_offset += bytes_to_read;\n        if *line_offset \u003e= idx.line_bytes {\n            *line_offset = 0;\n        }\n\n        Ok(bytes_to_keep)\n    }\n}\n\n/// Record of a FASTA index.\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\nstruct IndexRecord {\n    name: String,\n    len: u64,\n    offset: u64,\n    line_bases: u64,\n    line_bytes: u64,\n}\n\n/// A sequence record returned by the FASTA index.\n#[derive(Debug, PartialEq)]\npub struct Sequence {\n    pub name: String,\n    pub len: u64,\n}\n\npub struct IndexedReaderIterator\u003c'a, R: io::Read + io::Seek\u003e {\n    reader: \u0026'a mut IndexedReader\u003cR\u003e,\n    record: IndexRecord,\n    bases_left: u64,\n    line_offset: u64,\n    buf: Vec\u003cu8\u003e,\n    buf_idx: usize,\n}\n\nimpl\u003c'a, R: io::Read + io::Seek + 'a\u003e IndexedReaderIterator\u003c'a, R\u003e {\n    fn fill_buffer(\u0026mut self) -\u003e io::Result\u003c()\u003e {\n        assert!(self.bases_left \u003e 0);\n\n        self.buf.clear();\n        let bases_to_read = min(self.buf.capacity() as u64, self.bases_left);\n\n        // May loop one or more times; see IndexedReader::read_line.\n        while self.buf.is_empty() {\n            self.bases_left -= self.reader.read_line(\n                \u0026self.record,\n                \u0026mut self.line_offset,\n                bases_to_read,\n                \u0026mut self.buf,\n            )?;\n        }\n\n        self.buf_idx = 0;\n        Ok(())\n    }\n}\n\nimpl\u003c'a, R: io::Read + io::Seek + 'a\u003e Iterator for IndexedReaderIterator\u003c'a, R\u003e {\n    type Item = io::Result\u003cu8\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        if self.buf_idx \u003c self.buf.len() {\n            let item = Some(Ok(self.buf[self.buf_idx]));\n            self.buf_idx += 1;\n            item\n        } else if self.bases_left \u003e 0 {\n            if let Err(e) = self.fill_buffer() {\n                self.bases_left = 0;\n                self.buf_idx = self.buf.len();\n\n                return Some(Err(e));\n            }\n\n            self.buf_idx = 1;\n            Some(Ok(self.buf[0]))\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(\u0026self) -\u003e (usize, Option\u003cusize\u003e) {\n        let hint = self.bases_left as usize + (self.buf.len() - self.buf_idx);\n\n        (hint, Some(hint))\n    }\n}\n\n/// A Fasta writer.\n#[derive(Debug)]\npub struct Writer\u003cW: io::Write\u003e {\n    writer: io::BufWriter\u003cW\u003e,\n}\n\nimpl Writer\u003cfs::File\u003e {\n    /// Write to the given file path.\n    #[allow(clippy::wrong_self_convention)]\n    pub fn to_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e io::Result\u003cSelf\u003e {\n        fs::File::create(path).map(Writer::new)\n    }\n}\n\nimpl\u003cW: io::Write\u003e Writer\u003cW\u003e {\n    /// Create a new Fasta writer.\n    pub fn new(writer: W) -\u003e Self {\n        Writer {\n            writer: io::BufWriter::new(writer),\n        }\n    }\n\n    /// Directly write a [`fasta::Record`](struct.Record.html).\n    ///\n    /// # Errors\n    /// If there is an issue writing to the `Writer`.\n    ///\n    /// # Examples\n    /// ```rust\n    /// use bio::io::fasta::{Record, Writer};\n    /// use std::fs;\n    /// use std::io;\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"test.fa\");\n    /// let file = fs::File::create(path).unwrap();\n    /// {\n    ///     let handle = io::BufWriter::new(file);\n    ///     let mut writer = Writer::new(handle);\n    ///     let record = Record::with_attrs(\"id\", Some(\"desc\"), b\"ACGT\");\n    ///\n    ///     let write_result = writer.write_record(\u0026record);\n    ///     assert!(write_result.is_ok());\n    /// }\n    ///\n    /// let actual = fs::read_to_string(path).unwrap();\n    /// let expected = \"\u003eid desc\\nACGT\\n\";\n    ///\n    /// assert!(fs::remove_file(path).is_ok());\n    /// assert_eq!(actual, expected)\n    /// ```\n    pub fn write_record(\u0026mut self, record: \u0026Record) -\u003e io::Result\u003c()\u003e {\n        self.write(record.id(), record.desc(), record.seq())\n    }\n\n    /// Write a Fasta record with given id, optional description and sequence.\n    pub fn write(\u0026mut self, id: \u0026str, desc: Option\u003c\u0026str\u003e, seq: TextSlice\u003c'_\u003e) -\u003e io::Result\u003c()\u003e {\n        self.writer.write_all(b\"\u003e\")?;\n        self.writer.write_all(id.as_bytes())?;\n        if let Some(desc) = desc {\n            self.writer.write_all(b\" \")?;\n            self.writer.write_all(desc.as_bytes())?;\n        }\n        self.writer.write_all(b\"\\n\")?;\n        self.writer.write_all(seq)?;\n        self.writer.write_all(b\"\\n\")?;\n\n        Ok(())\n    }\n\n    /// Flush the writer, ensuring that everything is written.\n    pub fn flush(\u0026mut self) -\u003e io::Result\u003c()\u003e {\n        self.writer.flush()\n    }\n}\n\n/// A FASTA record.\n#[derive(Default, Clone, Debug, Serialize, Deserialize)]\npub struct Record {\n    id: String,\n    desc: Option\u003cString\u003e,\n    seq: String,\n}\n\nimpl Record {\n    /// Create a new instance.\n    pub fn new() -\u003e Self {\n        Record {\n            id: String::new(),\n            desc: None,\n            seq: String::new(),\n        }\n    }\n\n    /// Create a new `Record` from given attributes.\n    ///\n    /// # Examples\n    /// ```rust\n    /// use bio::io::fasta::Record;\n    ///\n    /// let read_id = \"read1\";\n    /// let description = Some(\"sampleid=foobar\");\n    /// let sequence = b\"ACGT\";\n    /// let record = Record::with_attrs(read_id, description, sequence);\n    ///\n    /// assert_eq!(\"\u003eread1 sampleid=foobar\\nACGT\\n\", record.to_string())\n    /// ```\n    pub fn with_attrs(id: \u0026str, desc: Option\u003c\u0026str\u003e, seq: TextSlice\u003c'_\u003e) -\u003e Self {\n        let desc = match desc {\n            Some(desc) =\u003e Some(desc.to_owned()),\n            _ =\u003e None,\n        };\n        Record {\n            id: id.to_owned(),\n            desc,\n            seq: String::from_utf8(seq.to_vec()).unwrap(),\n        }\n    }\n\n    /// Check if record is empty.\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.id.is_empty() \u0026\u0026 self.desc.is_none() \u0026\u0026 self.seq.is_empty()\n    }\n\n    /// Check validity of Fasta record.\n    pub fn check(\u0026self) -\u003e Result\u003c(), \u0026str\u003e {\n        if self.id().is_empty() {\n            return Err(\"Expecting id for Fasta record.\");\n        }\n        if !self.seq.is_ascii() {\n            return Err(\"Non-ascii character found in sequence.\");\n        }\n\n        Ok(())\n    }\n\n    /// Return the id of the record.\n    pub fn id(\u0026self) -\u003e \u0026str {\n        self.id.as_ref()\n    }\n\n    /// Return descriptions if present.\n    pub fn desc(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        match self.desc.as_ref() {\n            Some(desc) =\u003e Some(\u0026desc),\n            None =\u003e None,\n        }\n    }\n\n    /// Return the sequence of the record.\n    pub fn seq(\u0026self) -\u003e TextSlice\u003c'_\u003e {\n        self.seq.as_bytes()\n    }\n\n    /// Clear the record.\n    fn clear(\u0026mut self) {\n        self.id.clear();\n        self.desc = None;\n        self.seq.clear();\n    }\n}\n\nimpl fmt::Display for Record {\n    /// Allows for using `Record` in a given formatter `f`. In general this is for\n    /// creating a `String` representation of a `Record` and, optionally, writing it to\n    /// a file.\n    ///\n    /// # Errors\n    /// Returns [`std::fmt::Error`](https://doc.rust-lang.org/std/fmt/struct.Error.html)\n    /// if there is an issue formatting to the stream.\n    ///\n    /// # Examples\n    ///\n    /// Read in a Fasta `Record` and create a `String` representation of it.\n    ///\n    /// ```rust\n    /// use bio::io::fasta::Reader;\n    /// use std::fmt::Write;\n    /// // create a \"fake\" fasta file\n    /// let fasta: \u0026'static [u8] = b\"\u003eid comment1 comment2\\nACGT\\n\";\n    /// let mut records = Reader::new(fasta).records().map(|r| r.unwrap());\n    /// let record = records.next().unwrap();\n    ///\n    /// let mut actual = String::new();\n    /// // populate `actual` with a string representation of our record\n    /// write!(actual, \"{}\", record).unwrap();\n    ///\n    /// let expected = std::str::from_utf8(fasta).unwrap();\n    ///\n    /// assert_eq!(actual, expected)\n    /// ```\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e Result\u003c(), fmt::Error\u003e {\n        let header = match self.desc() {\n            Some(d) =\u003e format!(\"{} {}\", self.id().to_owned(), d),\n            None =\u003e self.id().to_owned(),\n        };\n        write!(\n            f,\n            \"\u003e{}\\n{}\\n\",\n            header,\n            std::str::from_utf8(self.seq()).unwrap(),\n        )\n    }\n}\n\n/// An iterator over the records of a Fasta file.\n#[derive(Debug)]\npub struct Records\u003cR: io::Read\u003e {\n    reader: Reader\u003cR\u003e,\n    error_has_occured: bool,\n}\n\nimpl\u003cR: io::Read\u003e Iterator for Records\u003cR\u003e {\n    type Item = io::Result\u003cRecord\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cio::Result\u003cRecord\u003e\u003e {\n        if self.error_has_occured {\n            None\n        } else {\n            let mut record = Record::new();\n            match self.reader.read(\u0026mut record) {\n                Ok(()) if record.is_empty() =\u003e None,\n                Ok(()) =\u003e Some(Ok(record)),\n                Err(err) =\u003e {\n                    self.error_has_occured = true;\n                    Some(Err(err))\n                }\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fmt::Write as FmtWrite;\n    use std::io;\n\n    const FASTA_FILE: \u0026[u8] = b\"\u003eid desc\nACCGTAGGCTGA\nCCGTAGGCTGAA\nCGTAGGCTGAAA\nGTAGGCTGAAAA\nCCCC\n\u003eid2\nATTGTTGTTTTA\nATTGTTGTTTTA\nATTGTTGTTTTA\nGGGG\n\";\n    const FAI_FILE: \u0026[u8] = b\"id\\t52\\t9\\t12\\t13\nid2\\t40\\t71\\t12\\t13\n\";\n\n    const TRUNCATED_FASTA: \u0026[u8] = b\"\u003eid desc\\nACCGTAGGCTGA\";\n\n    const FASTA_FILE_CRLF: \u0026[u8] = b\"\u003eid desc\\r\nACCGTAGGCTGA\\r\nCCGTAGGCTGAA\\r\nCGTAGGCTGAAA\\r\nGTAGGCTGAAAA\\r\nCCCC\\r\n\u003eid2\\r\nATTGTTGTTTTA\\r\nATTGTTGTTTTA\\r\nATTGTTGTTTTA\\r\nGGGG\\r\n\";\n    const FAI_FILE_CRLF: \u0026[u8] = b\"id\\t52\\t10\\t12\\t14\\r\nid2\\t40\\t78\\t12\\t14\\r\n\";\n\n    const FASTA_FILE_NO_TRAILING_LF: \u0026[u8] = b\"\u003eid desc\nGTAGGCTGAAAA\nCCCC\";\n    const FAI_FILE_NO_TRAILING_LF: \u0026[u8] = b\"id\\t16\\t9\\t12\\t13\";\n\n    const WRITE_FASTA_FILE: \u0026[u8] = b\"\u003eid desc\nACCGTAGGCTGA\n\u003eid2\nATTGTTGTTTTA\n\";\n\n    struct ReaderMock {\n        seek_fails: bool,\n        read_fails: bool,\n    }\n\n    impl Read for ReaderMock {\n        fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e io::Result\u003cusize\u003e {\n            if self.read_fails {\n                Err(io::Error::new(io::ErrorKind::Other, \"Read set to fail\"))\n            } else {\n                Ok(buf.len())\n            }\n        }\n    }\n\n    impl Seek for ReaderMock {\n        fn seek(\u0026mut self, pos: io::SeekFrom) -\u003e io::Result\u003cu64\u003e {\n            if let io::SeekFrom::Start(pos) = pos {\n                if self.seek_fails {\n                    Err(io::Error::new(io::ErrorKind::Other, \"Seek set to fail\"))\n                } else {\n                    Ok(pos)\n                }\n            } else {\n                unimplemented!();\n            }\n        }\n    }\n\n    #[test]\n    fn test_reader() {\n        let reader = Reader::new(FASTA_FILE);\n        let ids = [\"id\", \"id2\"];\n        let descs = [Some(\"desc\"), None];\n        let seqs: [\u0026[u8]; 2] = [\n            b\"ACCGTAGGCTGACCGTAGGCTGAACGTAGGCTGAAAGTAGGCTGAAAACCCC\",\n            b\"ATTGTTGTTTTAATTGTTGTTTTAATTGTTGTTTTAGGGG\",\n        ];\n\n        for (i, r) in reader.records().enumerate() {\n            let record = r.expect(\"Error reading record\");\n            assert_eq!(record.check(), Ok(()));\n            assert_eq!(record.id(), ids[i]);\n            assert_eq!(record.desc(), descs[i]);\n            assert_eq!(record.seq(), seqs[i]);\n        }\n    }\n\n    #[test]\n    fn test_faread_trait() {\n        let path = \"genome.fa.gz\";\n        let mut fa_reader: Box\u003cdyn FastaRead\u003e = match path.ends_with(\".gz\") {\n            true =\u003e Box::new(Reader::new(io::BufReader::new(FASTA_FILE))),\n            false =\u003e Box::new(Reader::new(FASTA_FILE)),\n        };\n        // The read method can be called, since it is implemented by\n        // FQRead. Right now, the records method would not work.\n        let mut record = Record::new();\n        fa_reader.read(\u0026mut record).unwrap();\n        // Check if the returned result is correct.\n        assert_eq!(record.check(), Ok(()));\n        assert_eq!(record.id(), \"id\");\n        assert_eq!(record.desc(), Some(\"desc\"));\n        assert_eq!(\n            record.seq().to_vec(),\n            b\"ACCGTAGGCTGACCGTAGGCTGAACGTAGGCTGAAAGTAGGCTGAAAACCCC\".to_vec()\n        );\n    }\n\n    #[test]\n    fn test_reader_wrong_header() {\n        let mut reader = Reader::new(\u0026b\"!test\\nACGTA\\n\"[..]);\n        let mut record = Record::new();\n        assert!(\n            reader.read(\u0026mut record).is_err(),\n            \"read() should return Err if FASTA header is malformed\"\n        );\n    }\n\n    #[test]\n    fn test_reader_no_id() {\n        let mut reader = Reader::new(\u0026b\"\u003e\\nACGTA\\n\"[..]);\n        let mut record = Record::new();\n        reader.read(\u0026mut record).unwrap();\n        assert!(\n            record.check().is_err(),\n            \"check() should return Err if FASTA header is empty\"\n        );\n    }\n\n    #[test]\n    fn test_reader_non_ascii_sequence() {\n        let mut reader = Reader::new(\u0026b\"\u003eid\\nACGTA\\xE2\\x98\\xB9AT\\n\"[..]);\n        let mut record = Record::new();\n        reader.read(\u0026mut record).unwrap();\n        assert!(\n            record.check().is_err(),\n            \"check() should return Err if FASTA sequence is not ASCII\"\n        );\n    }\n\n    #[test]\n    fn test_reader_read_fails() {\n        let mut reader = Reader::new(ReaderMock {\n            seek_fails: false,\n            read_fails: true,\n        });\n        let mut record = Record::new();\n        assert!(\n            reader.read(\u0026mut record).is_err(),\n            \"read() should return Err if Read::read fails\"\n        );\n    }\n\n    #[test]\n    fn test_reader_read_fails_iter() {\n        let reader = Reader::new(ReaderMock {\n            seek_fails: false,\n            read_fails: true,\n        });\n        let mut records = reader.records();\n\n        assert!(\n            records.next().unwrap().is_err(),\n            \"next() should return Err if Read::read fails\"\n        );\n        assert!(\n            records.next().is_none(),\n            \"next() should return None after error has occurred\"\n        );\n    }\n\n    #[test]\n    fn test_reader_from_file_path_doesnt_exist_returns_err() {\n        let path = Path::new(\"/I/dont/exist.fasta\");\n        let error = Reader::from_file(path)\n            .unwrap_err()\n            .downcast::\u003cString\u003e()\n            .unwrap();\n\n        assert_eq!(\u0026error, \"Failed to read fasta from \\\"/I/dont/exist.fasta\\\"\")\n    }\n\n    #[test]\n    fn test_record_with_attrs_without_description() {\n        let record = Record::with_attrs(\"id_str\", None, b\"ATGCGGG\");\n        assert_eq!(record.id(), \"id_str\");\n        assert_eq!(record.desc(), None);\n        assert_eq!(record.seq(), b\"ATGCGGG\");\n    }\n\n    #[test]\n    fn test_record_with_attrs_with_description() {\n        let record = Record::with_attrs(\"id_str\", Some(\"desc\"), b\"ATGCGGG\");\n        assert_eq!(record.id(), \"id_str\");\n        assert_eq!(record.desc(), Some(\"desc\"));\n        assert_eq!(record.seq(), b\"ATGCGGG\");\n    }\n\n    #[test]\n    fn test_index_sequences() {\n        let reader = IndexedReader::new(io::Cursor::new(FASTA_FILE), FAI_FILE).unwrap();\n\n        let sequences = reader.index.sequences();\n        assert_eq!(sequences.len(), 2);\n        assert_eq!(\n            sequences[0],\n            Sequence {\n                name: \"id\".into(),\n                len: 52,\n            }\n        );\n        assert_eq!(\n            sequences[1],\n            Sequence {\n                name: \"id2\".into(),\n                len: 40,\n            }\n        );\n    }\n\n    #[test]\n    fn test_indexed_reader() {\n        _test_indexed_reader(\u0026FASTA_FILE, \u0026FAI_FILE, _read_buffer);\n        _test_indexed_reader_truncated(_read_buffer);\n        _test_indexed_reader_extreme_whitespace(_read_buffer);\n    }\n\n    #[test]\n    fn test_indexed_reader_crlf() {\n        _test_indexed_reader(\u0026FASTA_FILE_CRLF, \u0026FAI_FILE_CRLF, _read_buffer);\n    }\n\n    #[test]\n    fn test_indexed_reader_iter() {\n        _test_indexed_reader(\u0026FASTA_FILE, \u0026FAI_FILE, _read_iter);\n        _test_indexed_reader_truncated(_read_iter);\n        _test_indexed_reader_extreme_whitespace(_read_iter);\n    }\n\n    #[test]\n    fn test_indexed_reader_iter_crlf() {\n        _test_indexed_reader(\u0026FASTA_FILE_CRLF, \u0026FAI_FILE_CRLF, _read_iter);\n    }\n\n    fn _test_indexed_reader\u003c'a, F\u003e(fasta: \u0026'a [u8], fai: \u0026'a [u8], read: F)\n    where\n        F: Fn(\u0026mut IndexedReader\u003cio::Cursor\u003c\u0026'a [u8]\u003e\u003e, \u0026str, u64, u64) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e,\n    {\n        let mut reader = IndexedReader::new(io::Cursor::new(fasta), fai).unwrap();\n\n        // Test reading various substrings of the sequence\n        assert_eq!(read(\u0026mut reader, \"id\", 1, 5).unwrap(), b\"CCGT\");\n        assert_eq!(\n            read(\u0026mut reader, \"id\", 1, 31).unwrap(),\n            b\"CCGTAGGCTGACCGTAGGCTGAACGTAGGC\"\n        );\n        assert_eq!(read(\u0026mut reader, \"id\", 13, 23).unwrap(), b\"CGTAGGCTGA\");\n        assert_eq!(\n            read(\u0026mut reader, \"id\", 36, 52).unwrap(),\n            b\"GTAGGCTGAAAACCCC\"\n        );\n        assert_eq!(\n            read(\u0026mut reader, \"id2\", 12, 40).unwrap(),\n            b\"ATTGTTGTTTTAATTGTTGTTTTAGGGG\"\n        );\n        assert_eq!(read(\u0026mut reader, \"id2\", 12, 12).unwrap(), b\"\");\n        assert_eq!(read(\u0026mut reader, \"id2\", 12, 13).unwrap(), b\"A\");\n        // Minimal sequence spanning new-line\n        assert_eq!(read(\u0026mut reader, \"id\", 11, 13).unwrap(), b\"AC\");\n\n        assert!(read(\u0026mut reader, \"id2\", 12, 11).is_err());\n        assert!(read(\u0026mut reader, \"id2\", 12, 1000).is_err());\n        assert!(read(\u0026mut reader, \"id3\", 0, 1).is_err());\n    }\n\n    fn _test_indexed_reader_truncated\u003c'a, F\u003e(read: F)\n    where\n        F: Fn(\u0026mut IndexedReader\u003cio::Cursor\u003c\u0026'a [u8]\u003e\u003e, \u0026str, u64, u64) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e,\n    {\n        let mut reader = IndexedReader::new(io::Cursor::new(TRUNCATED_FASTA), FAI_FILE).unwrap();\n\n        assert_eq!(read(\u0026mut reader, \"id\", 0, 12).unwrap(), b\"ACCGTAGGCTGA\");\n        assert!(read(\u0026mut reader, \"id\", 0, 13).is_err()); // read past EOF\n        assert!(read(\u0026mut reader, \"id\", 36, 52).is_err()); // seek and read past EOF\n        assert!(read(\u0026mut reader, \"id2\", 12, 40).is_err()); // seek and read past EOF\n    }\n\n    fn _test_indexed_reader_extreme_whitespace\u003cF\u003e(read: F)\n    where\n        F: Fn(\u0026mut IndexedReader\u003cio::Cursor\u003cVec\u003cu8\u003e\u003e\u003e, \u0026str, u64, u64) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e,\n    {\n        // Test to exercise the case where we cannot consume all whitespace at once. More than\n        // DEFAULT_BUF_SIZE (a non-public constant set to 8 * 1024) whitespace is used to ensure\n        // that it can't all fit in the BufReader at once.\n        let mut seq = Vec::new();\n        seq.push(b'A');\n        seq.resize(10000, b' ');\n        seq.push(b'B');\n\n        let fasta = io::Cursor::new(seq);\n        let fai = io::Cursor::new(Vec::from(\u0026b\"id\\t2\\t0\\t1\\t10000\"[..]));\n        let mut reader = IndexedReader::new(fasta, fai).unwrap();\n\n        assert_eq!(read(\u0026mut reader, \"id\", 0, 2).unwrap(), b\"AB\");\n    }\n\n    fn _read_buffer\u003cT\u003e(\n        reader: \u0026mut IndexedReader\u003cT\u003e,\n        seqname: \u0026str,\n        start: u64,\n        stop: u64,\n    ) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e\n    where\n        T: Seek + Read,\n    {\n        let mut seq = vec![];\n        reader.fetch(seqname, start, stop)?;\n        reader.read(\u0026mut seq)?;\n\n        Ok(seq)\n    }\n\n    fn _read_iter\u003cT\u003e(\n        reader: \u0026mut IndexedReader\u003cT\u003e,\n        seqname: \u0026str,\n        start: u64,\n        stop: u64,\n    ) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e\n    where\n        T: Seek + Read,\n    {\n        let mut seq = vec![];\n        reader.fetch(seqname, start, stop)?;\n        for nuc in reader.read_iter()? {\n            seq.push(nuc?);\n        }\n\n        Ok(seq)\n    }\n\n    #[test]\n    fn test_indexed_reader_all() {\n        _test_indexed_reader_all(\u0026FASTA_FILE, \u0026FAI_FILE, _read_buffer_all);\n    }\n\n    #[test]\n    fn test_indexed_reader_crlf_all() {\n        _test_indexed_reader_all(\u0026FASTA_FILE_CRLF, \u0026FAI_FILE_CRLF, _read_buffer_all);\n    }\n\n    #[test]\n    fn test_indexed_reader_iter_all() {\n        _test_indexed_reader_all(\u0026FASTA_FILE, \u0026FAI_FILE, _read_iter_all);\n    }\n\n    #[test]\n    fn test_indexed_reader_iter_crlf_all() {\n        _test_indexed_reader_all(\u0026FASTA_FILE_CRLF, \u0026FAI_FILE_CRLF, _read_iter_all);\n    }\n\n    fn _test_indexed_reader_all\u003c'a, F\u003e(fasta: \u0026'a [u8], fai: \u0026'a [u8], read: F)\n    where\n        F: Fn(\u0026mut IndexedReader\u003cio::Cursor\u003c\u0026'a [u8]\u003e\u003e, \u0026str) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e,\n    {\n        let mut reader = IndexedReader::new(io::Cursor::new(fasta), fai).unwrap();\n\n        assert_eq!(\n            read(\u0026mut reader, \"id\").unwrap(),\n            \u0026b\"ACCGTAGGCTGACCGTAGGCTGAACGTAGGCTGAAAGTAGGCTGAAAACCCC\"[..]\n        );\n        assert_eq!(\n            read(\u0026mut reader, \"id2\").unwrap(),\n            \u0026b\"ATTGTTGTTTTAATTGTTGTTTTAATTGTTGTTTTAGGGG\"[..]\n        );\n    }\n\n    fn _read_buffer_all\u003cT\u003e(reader: \u0026mut IndexedReader\u003cT\u003e, seqname: \u0026str) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e\n    where\n        T: Seek + Read,\n    {\n        let mut seq = vec![];\n        reader.fetch_all(seqname)?;\n        reader.read(\u0026mut seq)?;\n\n        Ok(seq)\n    }\n\n    fn _read_iter_all\u003cT\u003e(reader: \u0026mut IndexedReader\u003cT\u003e, seqname: \u0026str) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e\n    where\n        T: Seek + Read,\n    {\n        let mut seq = vec![];\n        reader.fetch_all(seqname)?;\n        for nuc in reader.read_iter()? {\n            seq.push(nuc?);\n        }\n\n        Ok(seq)\n    }\n\n    #[test]\n    fn test_indexed_reader_by_rid_all() {\n        _test_indexed_reader_by_rid_all(\u0026FASTA_FILE, \u0026FAI_FILE, _read_buffer_by_rid_all);\n    }\n\n    #[test]\n    fn test_indexed_reader_crlf_by_rid_all() {\n        _test_indexed_reader_by_rid_all(\u0026FASTA_FILE_CRLF, \u0026FAI_FILE_CRLF, _read_buffer_by_rid_all);\n    }\n\n    #[test]\n    fn test_indexed_reader_iter_by_rid_all() {\n        _test_indexed_reader_by_rid_all(\u0026FASTA_FILE, \u0026FAI_FILE, _read_iter_by_rid_all);\n    }\n\n    #[test]\n    fn test_indexed_reader_iter_crlf_by_rid_all() {\n        _test_indexed_reader_by_rid_all(\u0026FASTA_FILE_CRLF, \u0026FAI_FILE_CRLF, _read_iter_by_rid_all);\n    }\n\n    fn _test_indexed_reader_by_rid_all\u003c'a, F\u003e(fasta: \u0026'a [u8], fai: \u0026'a [u8], read: F)\n    where\n        F: Fn(\u0026mut IndexedReader\u003cio::Cursor\u003c\u0026'a [u8]\u003e\u003e, usize) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e,\n    {\n        let mut reader = IndexedReader::new(io::Cursor::new(fasta), fai).unwrap();\n\n        assert_eq!(\n            read(\u0026mut reader, 0).unwrap(),\n            \u0026b\"ACCGTAGGCTGACCGTAGGCTGAACGTAGGCTGAAAGTAGGCTGAAAACCCC\"[..]\n        );\n        assert_eq!(\n            read(\u0026mut reader, 1).unwrap(),\n            \u0026b\"ATTGTTGTTTTAATTGTTGTTTTAATTGTTGTTTTAGGGG\"[..]\n        );\n    }\n\n    fn _read_buffer_by_rid_all\u003cT\u003e(\n        reader: \u0026mut IndexedReader\u003cT\u003e,\n        seq_index: usize,\n    ) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e\n    where\n        T: Seek + Read,\n    {\n        let mut seq = vec![];\n        reader.fetch_all_by_rid(seq_index)?;\n        reader.read(\u0026mut seq)?;\n\n        Ok(seq)\n    }\n\n    fn _read_iter_by_rid_all\u003cT\u003e(\n        reader: \u0026mut IndexedReader\u003cT\u003e,\n        seq_index: usize,\n    ) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e\n    where\n        T: Seek + Read,\n    {\n        let mut seq = vec![];\n        reader.fetch_all_by_rid(seq_index)?;\n        for nuc in reader.read_iter()? {\n            seq.push(nuc?);\n        }\n\n        Ok(seq)\n    }\n\n    #[test]\n    fn test_indexed_reader_iter_size_hint() {\n        let mut reader = IndexedReader::new(io::Cursor::new(FASTA_FILE), FAI_FILE).unwrap();\n        reader.fetch(\"id\", 2, 4).unwrap();\n        let mut iterator = reader.read_iter().unwrap();\n\n        assert_eq!(iterator.size_hint(), (2, Some(2)));\n        assert_eq!(iterator.next().unwrap().unwrap(), b'C');\n        assert_eq!(iterator.size_hint(), (1, Some(1)));\n        assert_eq!(iterator.next().unwrap().unwrap(), b'G');\n        assert_eq!(iterator.size_hint(), (0, Some(0)));\n        assert!(iterator.next().is_none());\n        assert_eq!(iterator.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_indexed_reader_reused_buffer() {\n        let mut reader = IndexedReader::new(io::Cursor::new(FASTA_FILE), FAI_FILE).unwrap();\n        let mut seq = Vec::new();\n\n        reader.fetch(\"id\", 1, 5).unwrap();\n        reader.read(\u0026mut seq).unwrap();\n        assert_eq!(seq, b\"CCGT\");\n\n        reader.fetch(\"id\", 13, 23).unwrap();\n        reader.read(\u0026mut seq).unwrap();\n        assert_eq!(seq, b\"CGTAGGCTGA\");\n    }\n\n    #[test]\n    fn test_indexed_reader_no_trailing_lf() {\n        let mut reader = IndexedReader::new(\n            io::Cursor::new(FASTA_FILE_NO_TRAILING_LF),\n            FAI_FILE_NO_TRAILING_LF,\n        )\n        .unwrap();\n        let mut seq = Vec::new();\n\n        reader.fetch(\"id\", 0, 16).unwrap();\n        reader.read(\u0026mut seq).unwrap();\n        assert_eq!(seq, b\"GTAGGCTGAAAACCCC\");\n    }\n\n    #[test]\n    fn test_indexed_reader_bad_reader() {\n        let bad_reader = ReaderMock {\n            seek_fails: false,\n            read_fails: false,\n        };\n        let mut reader = IndexedReader::new(bad_reader, FAI_FILE).unwrap();\n        let mut seq = Vec::new();\n        reader.fetch(\"id\", 0, 10).unwrap();\n        assert!(reader.read(\u0026mut seq).is_ok())\n    }\n\n    #[test]\n    fn test_indexed_reader_read_seek_fails() {\n        let bad_reader = ReaderMock {\n            seek_fails: true,\n            read_fails: false,\n        };\n        let mut reader = IndexedReader::new(bad_reader, FAI_FILE).unwrap();\n        let mut seq = Vec::new();\n        reader.fetch(\"id\", 0, 10).unwrap();\n        assert!(reader.read(\u0026mut seq).is_err());\n    }\n\n    #[test]\n    fn test_indexed_reader_read_read_fails() {\n        let bad_reader = ReaderMock {\n            seek_fails: false,\n            read_fails: true,\n        };\n        let mut reader = IndexedReader::new(bad_reader, FAI_FILE).unwrap();\n        let mut seq = Vec::new();\n        reader.fetch(\"id\", 0, 10).unwrap();\n        assert!(reader.read(\u0026mut seq).is_err());\n    }\n\n    #[test]\n    fn test_indexed_reader_iter_seek_fails() {\n        let bad_reader = ReaderMock {\n            seek_fails: true,\n            read_fails: false,\n        };\n        let mut reader = IndexedReader::new(bad_reader, FAI_FILE).unwrap();\n        reader.fetch(\"id\", 0, 10).unwrap();\n        assert!(reader.read_iter().is_err());\n    }\n\n    #[test]\n    fn test_indexed_reader_iter_read_fails() {\n        let bad_reader = ReaderMock {\n            seek_fails: false,\n            read_fails: true,\n        };\n        let mut reader = IndexedReader::new(bad_reader, FAI_FILE).unwrap();\n        reader.fetch(\"id\", 0, 10).unwrap();\n        let mut iterator = reader.read_iter().unwrap();\n        assert!(iterator.next().unwrap().is_err());\n        assert!(\n            iterator.next().is_none(),\n            \"next() should return none after error has occurred\"\n        );\n    }\n\n    #[test]\n    fn test_indexed_reader_no_fetch_read_fails() {\n        let reader = ReaderMock {\n            seek_fails: false,\n            read_fails: false,\n        };\n        let mut reader = IndexedReader::new(reader, FAI_FILE).unwrap();\n        let mut seq = vec![];\n        assert!(reader.read(\u0026mut seq).is_err());\n    }\n\n    #[test]\n    fn test_indexed_reader_no_fetch_read_iter_fails() {\n        let reader = ReaderMock {\n            seek_fails: false,\n            read_fails: false,\n        };\n        let mut reader = IndexedReader::new(reader, FAI_FILE).unwrap();\n        assert!(reader.read_iter().is_err());\n    }\n\n    #[test]\n    fn test_writer() {\n        let mut writer = Writer::new(Vec::new());\n        writer.write(\"id\", Some(\"desc\"), b\"ACCGTAGGCTGA\").unwrap();\n        writer.write(\"id2\", None, b\"ATTGTTGTTTTA\").unwrap();\n        writer.flush().unwrap();\n        assert_eq!(writer.writer.get_ref(), \u0026WRITE_FASTA_FILE);\n    }\n\n    #[test]\n    fn test_display_record_no_desc_id_without_space_after() {\n        let fasta: \u0026'static [u8] = b\"\u003eid\\nACGT\\n\";\n        let mut records = Reader::new(fasta).records().map(|r| r.unwrap());\n        let record = records.next().unwrap();\n        let mut actual = String::new();\n        write!(actual, \"{}\", record).unwrap();\n\n        let expected = std::str::from_utf8(fasta).unwrap();\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_display_record_with_desc_id_has_space_between_id_and_desc() {\n        let fasta: \u0026'static [u8] = b\"\u003eid comment1 comment2\\nACGT\\n\";\n        let mut records = Reader::new(fasta).records().map(|r| r.unwrap());\n        let record = records.next().unwrap();\n        let mut actual = String::new();\n        write!(actual, \"{}\", record).unwrap();\n\n        let expected = std::str::from_utf8(fasta).unwrap();\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_index_record_idx_by_rid_invalid_index_returns_error() {\n        let reader = ReaderMock {\n            seek_fails: false,\n            read_fails: false,\n        };\n        let index_reader = IndexedReader::new(reader, FAI_FILE).unwrap();\n\n        let actual = index_reader.idx_by_rid(99999).unwrap_err();\n        let expected = io::Error::new(io::ErrorKind::Other, \"Invalid record index in fasta file.\");\n\n        assert_eq!(actual.kind(), expected.kind());\n        assert_eq!(actual.to_string(), expected.to_string())\n    }\n\n    #[test]\n    fn test_index_record_fetch_by_rid_second_index_returns_second_record() {\n        let reader = ReaderMock {\n            seek_fails: false,\n            read_fails: false,\n        };\n        let mut index_reader = IndexedReader::new(reader, FAI_FILE).unwrap();\n\n        let actual = index_reader.fetch_by_rid(1, 1, 3);\n\n        assert!(actual.is_ok());\n        assert_eq!(\n            index_reader.fetched_idx,\n            Some(IndexRecord {\n                name: String::from(\"id2\"),\n                len: 40,\n                offset: 71,\n                line_bases: 12,\n                line_bytes: 13\n            })\n        )\n    }\n\n    #[test]\n    fn test_writer_to_file_dir_doesnt_exist_returns_err() {\n        let path = Path::new(\"/I/dont/exist.fa\");\n\n        let actual = Writer::to_file(path).unwrap_err();\n        let expected = io::Error::new(io::ErrorKind::NotFound, \"foo\");\n\n        assert_eq!(actual.kind(), expected.kind());\n    }\n\n    #[test]\n    fn test_writer_to_file_dir_exists_returns_ok() {\n        let file = tempfile::NamedTempFile::new().expect(\"Could not create temp file\");\n        let path = file.path();\n\n        assert!(Writer::to_file(path).is_ok())\n    }\n\n    #[test]\n    fn test_write_record() {\n        let path = Path::new(\"test.fa\");\n        let file = fs::File::create(path).unwrap();\n        {\n            let handle = io::BufWriter::new(file);\n            let mut writer = Writer { writer: handle };\n            let record = Record::with_attrs(\"id\", Some(\"desc\"), b\"ACGT\");\n\n            let write_result = writer.write_record(\u0026record);\n            assert!(write_result.is_ok());\n        }\n\n        let actual = fs::read_to_string(path).unwrap();\n        let expected = \"\u003eid desc\\nACGT\\n\";\n\n        assert!(fs::remove_file(path).is_ok());\n        assert_eq!(actual, expected)\n    }\n}\n","traces":[{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[5273824],"length":1,"stats":{"Line":1},"fn_name":"sequences"},{"line":336,"address":[5273856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":338,"address":[5166368,5166435],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":339,"address":[5166405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[5166431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":598,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":623,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":690,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":710,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":713,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":723,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":727,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":744,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":752,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":785,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":786,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":790,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":791,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":793,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":794,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":798,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":806,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":820,"address":[5274146,5274158,5273968],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":822,"address":[5273981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":824,"address":[5274005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":841,"address":[5274160,5274743],"length":1,"stats":{"Line":1},"fn_name":"with_attrs"},{"line":842,"address":[5274247,5274393],"length":1,"stats":{"Line":2},"fn_name":null},{"line":843,"address":[5274255,5274355],"length":1,"stats":{"Line":2},"fn_name":null},{"line":844,"address":[5274316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":847,"address":[5274348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":849,"address":[5274439,5274515,5274563],"length":1,"stats":{"Line":4},"fn_name":null},{"line":854,"address":[5274784],"length":1,"stats":{"Line":1},"fn_name":"is_empty"},{"line":855,"address":[5274798],"length":1,"stats":{"Line":1},"fn_name":null},{"line":859,"address":[5274912],"length":1,"stats":{"Line":1},"fn_name":"check"},{"line":860,"address":[5274926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":861,"address":[5274997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":863,"address":[5275043,5274976],"length":1,"stats":{"Line":2},"fn_name":null},{"line":864,"address":[5275073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":867,"address":[5275062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":871,"address":[5275104],"length":1,"stats":{"Line":1},"fn_name":"id"},{"line":872,"address":[5275113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":876,"address":[5275152],"length":1,"stats":{"Line":1},"fn_name":"desc"},{"line":877,"address":[5275161,5275207,5275196],"length":1,"stats":{"Line":2},"fn_name":null},{"line":878,"address":[5275176,5275209],"length":1,"stats":{"Line":2},"fn_name":null},{"line":879,"address":[5275198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":884,"address":[5275280],"length":1,"stats":{"Line":1},"fn_name":"seq"},{"line":885,"address":[5275289],"length":1,"stats":{"Line":1},"fn_name":null},{"line":889,"address":[5275328,5275438],"length":1,"stats":{"Line":1},"fn_name":"clear"},{"line":890,"address":[5275341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":891,"address":[5275350,5275420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":892,"address":[5275405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":925,"address":[5276045,5275472],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":926,"address":[5275511,5275559,5276108],"length":1,"stats":{"Line":2},"fn_name":null},{"line":927,"address":[5276110,5275604,5275536,5276060],"length":1,"stats":{"Line":3},"fn_name":null},{"line":928,"address":[5276199,5275569],"length":1,"stats":{"Line":2},"fn_name":null},{"line":930,"address":[5276360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":931,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":933,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":934,"address":[5276156,5276284,5276224],"length":1,"stats":{"Line":3},"fn_name":null},{"line":949,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":950,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":951,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":953,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":954,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":955,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":956,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":957,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":958,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":959,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1023,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1024,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1025,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1027,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1033,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1034,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1035,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1036,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1038,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1047,"address":[6179600,6179605],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1048,"address":[9030807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1049,"address":[9030840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1050,"address":[9030894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1051,"address":[9030997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1056,"address":[9031254,9031051,9031282,9032948],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1057,"address":[9031690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1058,"address":[9032020,9031820,9032070],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1059,"address":[9032034,9032134,9032351],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1060,"address":[9032318,9032629,9032416],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1061,"address":[9032596,9032893,9032694],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1066,"address":[6179637,6179632],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1067,"address":[9033031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1068,"address":[9033261,9033058,9033386],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1069,"address":[9033101,9033238,9033137],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1070,"address":[9033363,9033107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1074,"address":[9033301],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1075,"address":[9033388,9033498],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1077,"address":[9033608,9033818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1078,"address":[9033782,9034031,9033874],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1079,"address":[9034088,9034241,9033998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1080,"address":[9034356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1081,"address":[9034208,9034298],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1082,"address":[9034317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1087,"address":[6179664,6179669],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1088,"address":[9034695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1089,"address":[9034749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1090,"address":[9034931,9035017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1091,"address":[9034766,9034836],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1097,"address":[6179701,6179696],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1098,"address":[9035095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1099,"address":[9035152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1100,"address":[9035172,9035242],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1101,"address":[9035444,9035423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1102,"address":[9035349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1108,"address":[6179728,6179733],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1109,"address":[9035527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1110,"address":[9035584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1111,"address":[9035604,9035674],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1112,"address":[9035855,9035876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1113,"address":[9035781],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1119,"address":[6179760,6179765],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1120,"address":[9035959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1124,"address":[9036003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1125,"address":[9036185,9036271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1126,"address":[9036020,9036090],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1132,"address":[6179792,6179797],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1133,"address":[9036359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1137,"address":[9036398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1139,"address":[9036551,9036640],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1140,"address":[9036534,9036452],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1143,"address":[9036781,9036697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1144,"address":[9036633,9036680],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1150,"address":[6179824,6179829],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1151,"address":[9036855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1152,"address":[9036908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1157,"address":[9036982,9037146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1161,"address":[6179861,6179856],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1162,"address":[9037223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1163,"address":[9037299,9037535,9037488],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1164,"address":[9037591,9037502,9037744],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1165,"address":[9037801,9037938,9037711],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1169,"address":[6179893,6179888],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1170,"address":[9038023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1171,"address":[9038350,9038114,9038303],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1172,"address":[9038317,9038406,9038559],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1173,"address":[9038753,9038526,9038616],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1177,"address":[6179920,6179925],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1178,"address":[9038839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1180,"address":[9038922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1181,"address":[9039190,9038953,9039010],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1182,"address":[9039317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1183,"address":[9039146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1184,"address":[9039273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1185,"address":[9039241],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1189,"address":[9039631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1190,"address":[9039520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1191,"address":[9039587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1192,"address":[9039555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1199,"address":[6179952,6179957],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1200,"address":[9039889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1201,"address":[9039922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1202,"address":[9039927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1206,"address":[6179989,6179984],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1207,"address":[9039937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1211,"address":[6180021,6180016],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1212,"address":[9039985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1213,"address":[9040018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1214,"address":[9040023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1218,"address":[6180048,6180053],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1219,"address":[9040033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1222,"address":[6153264,6157456,6161614,6157422],"length":1,"stats":{"Line":2},"fn_name":"_test_indexed_reader\u003cfn(\u0026mut bio::io::fasta::IndexedReader\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e, \u0026str, u64, u64) -\u003e core::result::Result\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, std::io::error::Error\u003e\u003e"},{"line":1226,"address":[6157614,6153422,6153349,6157541],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1229,"address":[6153460,6153666,6157858,6157652],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1230,"address":[6154064,6158256],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1231,"address":[6153898,6158090],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1234,"address":[6154297,6158489],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1235,"address":[6159054,6154862],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1236,"address":[6158888,6154696],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1239,"address":[6155249,6159441],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1240,"address":[6155083,6159275],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1243,"address":[6159656,6155464],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1244,"address":[6160037,6155845],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1246,"address":[6156226,6160418],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1248,"address":[6156972,6156607,6160799,6161164],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1249,"address":[6157242,6157013,6161205,6161036,6156844,6161434],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1250,"address":[6157283,6161475,6161579,6161306,6157114,6157387],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1253,"address":[6162984,6164344,6163008,6161648],"length":1,"stats":{"Line":2},"fn_name":"_test_indexed_reader_truncated\u003cfn(\u0026mut bio::io::fasta::IndexedReader\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e, \u0026str, u64, u64) -\u003e core::result::Result\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, std::io::error::Error\u003e\u003e"},{"line":1257,"address":[6161744,6161655,6163104,6163015],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1259,"address":[6161976,6163136,6161776,6163336],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1260,"address":[6162187,6163547,6163903,6162543],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1261,"address":[6163778,6162807,6162418,6162584,6164167,6163944],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1262,"address":[6162682,6162949,6164042,6162848,6164208,6164309],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1265,"address":[6166355,6165347,6165376,6164368],"length":1,"stats":{"Line":2},"fn_name":"_test_indexed_reader_extreme_whitespace\u003cfn(\u0026mut bio::io::fasta::IndexedReader\u003cstd::io::cursor::Cursor\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e\u003e, \u0026str, u64, u64) -\u003e core::result::Result\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, std::io::error::Error\u003e\u003e"},{"line":1272,"address":[6164375,6165383],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1273,"address":[6164407,6165415],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1274,"address":[6164463,6165471],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1275,"address":[6164527,6165535],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1277,"address":[6164548,6165556],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1278,"address":[6164608,6165719,6164711,6165616],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1279,"address":[6165746,6164738],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1281,"address":[6165881,6166084,6164873,6165076],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1284,"address":[6167186,6167216,6166384,6168018],"length":1,"stats":{"Line":2},"fn_name":"_read_buffer\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":1293,"address":[6166466,6167298],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1294,"address":[6167583,6167334,6166751,6166808,6166502,6167490,6167640,6166658],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1295,"address":[6166861,6167159,6167693,6167931,6167555,6167991,6166723,6167099],"length":1,"stats":{"Line":7},"fn_name":null},{"line":1297,"address":[6167004,6167836],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1300,"address":[6168048,6169539,6171074,6169568,6171059,6169554],"length":1,"stats":{"Line":2},"fn_name":"_read_iter\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":1309,"address":[6168130,6169650],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1310,"address":[6168402,6168328,6168456,6169922,6168174,6169848,6169694,6169976],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1311,"address":[6168390,6168996,6170035,6169409,6170405,6170929,6168885,6169024,6168515,6170516,6170544,6169910],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1312,"address":[6170881,6169361,6169168,6170688],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1315,"address":[6170972,6169452],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1319,"address":[6180080,6180085],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1320,"address":[9040081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1324,"address":[6180112,6180117],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1325,"address":[9040129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1329,"address":[6180144,6180149],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1330,"address":[9040177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1334,"address":[6180176,6180181],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1335,"address":[9040225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1338,"address":[6172087,6172112,6171088,6173111],"length":1,"stats":{"Line":2},"fn_name":"_test_indexed_reader_all\u003cfn(\u0026mut bio::io::fasta::IndexedReader\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e, \u0026str) -\u003e core::result::Result\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, std::io::error::Error\u003e\u003e"},{"line":1342,"address":[6171228,6172185,6172252,6171161],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1344,"address":[6171477,6172501],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1345,"address":[6172284,6171260],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1346,"address":[6171406,6172430],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1348,"address":[6171867,6172891],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1349,"address":[6171687,6172711],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1350,"address":[6172820,6171796],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1354,"address":[6173896,6173136],"length":1,"stats":{"Line":1},"fn_name":"_read_buffer_all\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":1358,"address":[6173192],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1359,"address":[6173467,6173218,6173374,6173524],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1360,"address":[6173869,6173809,6173439,6173577],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1362,"address":[6173720],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1365,"address":[6175382,6173936,6175397],"length":1,"stats":{"Line":1},"fn_name":"_read_iter_all\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":1369,"address":[6173992],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1370,"address":[6174026,6174245,6174171,6174299],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1371,"address":[6174867,6174233,6175252,6174358,6174728,6174839],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1372,"address":[6175204,6175011],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1375,"address":[6175295],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1379,"address":[6180213,6180208],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1380,"address":[9040273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1384,"address":[6180240,6180245],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1385,"address":[9040321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1389,"address":[6180277,6180272],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1390,"address":[9040369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1394,"address":[6180309,6180304],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1395,"address":[9040417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1398,"address":[6177337,6176361,6175408,6176384],"length":1,"stats":{"Line":2},"fn_name":"_test_indexed_reader_by_rid_all\u003cfn(\u0026mut bio::io::fasta::IndexedReader\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e, usize) -\u003e core::result::Result\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, std::io::error::Error\u003e\u003e"},{"line":1402,"address":[6176524,6175548,6175481,6176457],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1404,"address":[6176750,6175774],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1405,"address":[6175580,6176556],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1406,"address":[6175703,6176679],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1408,"address":[6177117,6176141],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1409,"address":[6176960,6175984],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1410,"address":[6176070,6177046],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1414,"address":[6178104,6177360],"length":1,"stats":{"Line":1},"fn_name":"_read_buffer_by_rid_all\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":1421,"address":[6177403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1422,"address":[6177730,6177424,6177673,6177580],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1423,"address":[6178017,6178077,6177783,6177645],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1425,"address":[6177928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1428,"address":[6178144,6179574,6179589],"length":1,"stats":{"Line":1},"fn_name":"_read_iter_by_rid_all\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":1435,"address":[6178187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1436,"address":[6178363,6178437,6178216,6178491],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1437,"address":[6179059,6179444,6178920,6179031,6178425,6178550],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1438,"address":[6179203,6179396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1441,"address":[6179487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1445,"address":[6180336,6180341],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1446,"address":[9040471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1447,"address":[9040557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1448,"address":[9040749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1450,"address":[9040990,9040948,9040802],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1451,"address":[9041223,9040970,9041036],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1452,"address":[9041404,9041206,9041283],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1453,"address":[9041387,9041451,9041638],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1454,"address":[9041819,9041621,9041698],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1455,"address":[9041802,9041986,9041874],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1456,"address":[9041979,9042027,9042138],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1460,"address":[6180373,6180368],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1461,"address":[9042231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1462,"address":[9042314],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1464,"address":[9042333,9042431],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1465,"address":[9042544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1466,"address":[9042796,9042647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1468,"address":[9042735,9042852],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1469,"address":[9042927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1470,"address":[9043147,9043030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1474,"address":[6180400,6180405],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1476,"address":[9043239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1480,"address":[9043322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1482,"address":[9043341,9043438],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1483,"address":[9043551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1484,"address":[9043769,9043654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1488,"address":[6180432,6180437],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1493,"address":[9043873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1494,"address":[9043943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1495,"address":[9044059,9043962],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1496,"address":[9044172,9044362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1500,"address":[6180464,6180469],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1505,"address":[9044449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1506,"address":[9044519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1507,"address":[9044635,9044538],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1508,"address":[9044748,9044938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1512,"address":[6180501,6180496],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1517,"address":[9045025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1518,"address":[9045095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1519,"address":[9045211,9045114],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1520,"address":[9045514,9045324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1524,"address":[6180528,6180533],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1529,"address":[9045601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1530,"address":[9045671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1531,"address":[9045843,9045956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1535,"address":[6180565,6180560],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1540,"address":[9046033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1541,"address":[9046103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1542,"address":[9046275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1543,"address":[9046522,9046328,9046413],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1544,"address":[9046579,9046666],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1545,"address":[9046515,9046562],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1551,"address":[6180597,6180592],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1556,"address":[9046753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1557,"address":[9046823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1558,"address":[9046925,9046855,9047024,9047117],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1562,"address":[6180629,6180624],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1567,"address":[9047201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1568,"address":[9047434,9047284,9047353],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1572,"address":[6180656,6180661],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1573,"address":[9047511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1574,"address":[9047543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1575,"address":[9047752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1576,"address":[9047914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1577,"address":[9048014,9048160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1581,"address":[6180693,6180688],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1582,"address":[9048247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1583,"address":[6180752,6180720],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1584,"address":[9048351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1585,"address":[9048433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1586,"address":[9048552,9048645,9048448],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1588,"address":[9048702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1590,"address":[9048927,9048809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1594,"address":[6180800,6180805],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1595,"address":[9049031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1596,"address":[6180864,6180832],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1597,"address":[9049135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1598,"address":[9049217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1599,"address":[9049429,9049336,9049232],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1601,"address":[9049486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1603,"address":[9049593,9049711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1607,"address":[6180917,6180912],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1612,"address":[9049825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1614,"address":[9049913,9050005],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1615,"address":[9050037],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1617,"address":[9050142,9050407,9050270,9050200],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1618,"address":[9050662,9050499,9050390,9050736,9050469],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1622,"address":[6180944,6180949],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1627,"address":[9051025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1629,"address":[9051110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1631,"address":[9051244,9051178,9051330],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1632,"address":[9051511,9051684,9051609,9051290],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1634,"address":[9051367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1635,"address":[9051303],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1645,"address":[6180976,6180981],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1646,"address":[9051847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1648,"address":[9051900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1649,"address":[9051969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1651,"address":[9052123,9052187,9052068,9052315],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1655,"address":[6181008,6181013],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1656,"address":[9052407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1657,"address":[9052457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1659,"address":[9052561,9052511,9052654],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1663,"address":[6181045,6181040],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":1664,"address":[9052727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1665,"address":[9052780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1667,"address":[9052822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1668,"address":[9052835],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1669,"address":[9052899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1671,"address":[9053002,9053075],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1672,"address":[9053107,9053238,9053173],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1675,"address":[9053325],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1676,"address":[9053376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1678,"address":[9053542,9053403,9053703],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1679,"address":[9053740,9053624,9053772],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":549,"coverable":586},{"path":["/","home","todd","rust-bio","src","io","fastq.rs"],"content":"// Copyright 2014-2018 Johannes Köster, Henning Timm.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Structs and trait to read and write files in FASTQ format.\n//!\n//! # Example\n//!\n//! ## Read\n//!\n//! In this example, we parse a fastq file from stdin and compute some statistics\n//!\n//! ```\n//! use bio::io::fastq;\n//! use std::io;\n//! let mut reader = fastq::Reader::new(io::stdin());\n//!\n//! let mut nb_reads = 0;\n//! let mut nb_bases = 0;\n//!\n//! for result in reader.records() {\n//!     let record = result.expect(\"Error during fastq record parsing\");\n//!\n//!     nb_reads += 1;\n//!     nb_bases += record.seq().len();\n//! }\n//!\n//! println!(\"Number of reads: {}\", nb_reads);\n//! println!(\"Number of bases: {}\", nb_bases);\n//! ```\n//!\n//! We can also use a `while` loop to iterate over records\n//! ```\n//! use bio::io::fastq;\n//! use std::io;\n//! let mut records = fastq::Reader::new(io::stdin()).records();\n//!\n//! let mut nb_reads = 0;\n//! let mut nb_bases = 0;\n//!\n//! while let Some(Ok(record)) = records.next() {\n//!     nb_reads += 1;\n//!     nb_bases += record.seq().len();\n//! }\n//!\n//! println!(\"Number of reads: {}\", nb_reads);\n//! println!(\"Number of bases: {}\", nb_bases);\n//! ```\n//!\n//! ## Write\n//!\n//! In this example we generate 10 random sequences with length 100 and write them to stdout.\n//!\n//! ```\n//! use std::io;\n//! use bio::io::fastq;\n//!\n//! let mut seed = 42;\n//!\n//! let nucleotides = [b'A', b'C', b'G', b'T'];\n//!\n//! let mut writer = fastq::Writer::new(io::stdout());\n//!\n//! for _ in 0..10 {\n//!     let seq = (0..100).map(|_| {\n//!         seed = ((seed ^ seed \u003c\u003c 13) ^ seed \u003e\u003e 7) ^ seed \u003c\u003c 17; // don't use this random generator\n//!         nucleotides[seed % 4]\n//!     }).collect::\u003cVec\u003cu8\u003e\u003e();\n//!\n//!     let qual = (0..100).map(|_| b'!').collect::\u003cVec\u003cu8\u003e\u003e();\n//!\n//!    writer.write(\"random\", None, seq.as_slice(), qual.as_slice());\n//! }\n//! ```\n//!\n//! ## Read and Write\n//!\n//! In this example we filter reads from stdin on mean quality (Phred + 33) and write them to stdout\n//!\n//! ```\n//! use bio::io::fastq;\n//! use bio::io::fastq::FastqRead;\n//! use std::io;\n//!\n//! let mut reader = fastq::Reader::new(io::stdin());\n//! let mut writer = fastq::Writer::new(io::stdout());\n//! let mut record = fastq::Record::new();\n//!\n//! while let Ok(()) = reader.read(\u0026mut record) {\n//!     if record.is_empty() {\n//!         let check = record.check();\n//!         break;\n//!     }\n//!\n//!     let mut sum_qual = record.qual().iter().sum::\u003cu8\u003e() as f64;\n//!\n//!     if (sum_qual / record.seq().len() as f64 - 33.0) \u003e 30.0 {\n//!         writer.write_record(\u0026record);\n//!     }\n//! }\n//! ```\n\nuse anyhow::Context;\nuse std::convert::AsRef;\nuse std::fmt;\nuse std::fs;\nuse std::io;\nuse std::io::prelude::*;\nuse std::path::{Path, PathBuf};\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum Error {\n    #[error(\"expected '@' at record start\")]\n    MissingAt,\n\n    #[error(\"can't open {path} file: {source}\")]\n    FileOpen { path: PathBuf, source: io::Error },\n\n    #[error(\"can't read input\")]\n    ReadError(#[from] io::Error),\n\n    #[error(\"Incomplete record. Each FastQ record has to consist of 4 lines: header, sequence, separator and qualities.\")]\n    IncompleteRecord,\n}\npub type Result\u003cT, E = Error\u003e = std::result::Result\u003cT, E\u003e;\n\nuse bio_types::sequence::SequenceRead;\n\nuse crate::utils::TextSlice;\n\n/// Trait for FastQ readers.\npub trait FastqRead {\n    fn read(\u0026mut self, record: \u0026mut Record) -\u003e Result\u003c()\u003e;\n}\n\n/// A FastQ reader.\n#[derive(Debug)]\npub struct Reader\u003cR: io::Read\u003e {\n    reader: io::BufReader\u003cR\u003e,\n    line_buffer: String,\n}\n\nimpl Reader\u003cfs::File\u003e {\n    /// Read from a given file.\n    pub fn from_file\u003cP: AsRef\u003cPath\u003e + std::fmt::Debug\u003e(path: P) -\u003e anyhow::Result\u003cSelf\u003e {\n        fs::File::open(path.as_ref())\n            .map_err(|e| Error::FileOpen {\n                path: path.as_ref().to_owned(),\n                source: e,\n            })\n            .map(Reader::new)\n            .with_context(|| format!(\"Failed to read fastq from {:#?}\", path))\n    }\n}\n\nimpl\u003cR: io::Read\u003e Reader\u003cR\u003e {\n    /// Read from a given [`io::Read`](https://doc.rust-lang.org/std/io/trait.Read.html).\n    pub fn new(reader: R) -\u003e Self {\n        Reader {\n            reader: io::BufReader::new(reader),\n            line_buffer: String::new(),\n        }\n    }\n\n    /// Return an iterator over the records of this FastQ file.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if a record is incomplete\n    /// or syntax is violated.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use bio::io::fastq;\n    ///\n    /// let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n!!!!\\n\";\n    /// let records = fastq::Reader::new(fq)\n    ///     .records()\n    ///     .map(|record| record.unwrap());\n    /// for record in records {\n    ///     assert!(record.check().is_ok())\n    /// }\n    /// ```\n    pub fn records(self) -\u003e Records\u003cR\u003e {\n        Records { reader: self }\n    }\n\n    pub(crate) fn new_with_line_buffer(reader: io::BufReader\u003cR\u003e, line_buffer: String) -\u003e Self {\n        Reader {\n            reader,\n            line_buffer,\n        }\n    }\n}\n\nimpl\u003cR\u003e FastqRead for Reader\u003cR\u003e\nwhere\n    R: io::Read,\n{\n    /// Read the next FastQ entry into the given [`Record`](#Record).\n    /// An empty record indicates that no more records can be read.\n    ///\n    /// This method is useful when you want to read records as fast as\n    /// possible because it allows the reuse of a `Record` allocation.\n    ///\n    /// A more ergonomic approach to reading FastQ records is the\n    /// [records](Reader::records) iterator.\n    ///\n    /// FastQ files with wrapped sequence and quality strings are allowed.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the record is incomplete,\n    /// syntax is violated or any form of I/O error is encountered.\n    /// Additionally, if the FastQ file has line-wrapped records, and the wrapping is not\n    /// consistent between the sequence and quality string for a record, parsing will fail.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use bio::io::fastq::Record;\n    /// use bio::io::fastq::{FastqRead, Reader};\n    /// const FASTQ_FILE: \u0026'static [u8] = b\"@id desc\n    /// AAAA\n    /// +\n    /// IIII\n    /// \";\n    /// let mut reader = Reader::new(FASTQ_FILE);\n    /// let mut record = Record::new();\n    ///\n    /// reader.read(\u0026mut record).unwrap();\n    ///\n    /// assert_eq!(record.id(), \"id\");\n    /// assert_eq!(record.desc().unwrap(), \"desc\");\n    /// assert_eq!(record.seq().to_vec(), b\"AAAA\");\n    /// assert_eq!(record.qual().to_vec(), b\"IIII\");\n    /// ```\n    fn read(\u0026mut self, record: \u0026mut Record) -\u003e Result\u003c()\u003e {\n        record.clear();\n        self.line_buffer.clear();\n\n        self.reader.read_line(\u0026mut self.line_buffer)?;\n\n        if !self.line_buffer.is_empty() {\n            if !self.line_buffer.starts_with('@') {\n                return Err(Error::MissingAt);\n            }\n            let mut header_fields = self.line_buffer[1..].trim_end().splitn(2, ' ');\n            record.id = header_fields.next().unwrap_or_default().to_owned();\n            record.desc = header_fields.next().map(|s| s.to_owned());\n            self.line_buffer.clear();\n\n            self.reader.read_line(\u0026mut self.line_buffer)?;\n\n            let mut lines_read = 0;\n            while !self.line_buffer.starts_with('+') {\n                record.seq.push_str(\u0026self.line_buffer.trim_end());\n                self.line_buffer.clear();\n                self.reader.read_line(\u0026mut self.line_buffer)?;\n                lines_read += 1;\n            }\n\n            for _ in 0..lines_read {\n                self.line_buffer.clear();\n                self.reader\n                    .read_line(\u0026mut self.line_buffer)\n                    .map_err(Error::ReadError)?;\n                record.qual.push_str(self.line_buffer.trim_end());\n            }\n\n            if record.qual.is_empty() {\n                return Err(Error::IncompleteRecord);\n            }\n        }\n\n        Ok(())\n    }\n}\n\n/// A FastQ record.\n#[derive(Debug, Clone, Default, Serialize, Deserialize, PartialEq)]\npub struct Record {\n    id: String,\n    desc: Option\u003cString\u003e,\n    seq: String,\n    qual: String,\n}\n\nimpl Record {\n    /// Create a new, empty FastQ record.\n    pub fn new() -\u003e Self {\n        Record {\n            id: String::new(),\n            desc: None,\n            seq: String::new(),\n            qual: String::new(),\n        }\n    }\n\n    /// Create a new FastQ record from given attributes.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use bio::io::fastq::Record;\n    ///\n    /// let record = Record::with_attrs(\"id_str\", Some(\"desc\"), b\"ATGCGGG\", b\"QQQQQQQ\");\n    /// assert_eq!(record.id(), \"id_str\");\n    /// assert_eq!(record.desc(), Some(\"desc\"));\n    /// assert_eq!(record.seq(), b\"ATGCGGG\");\n    /// assert_eq!(record.qual(), b\"QQQQQQQ\");\n    /// ```\n    pub fn with_attrs(id: \u0026str, desc: Option\u003c\u0026str\u003e, seq: TextSlice\u003c'_\u003e, qual: \u0026[u8]) -\u003e Self {\n        let desc = match desc {\n            Some(desc) =\u003e Some(desc.to_owned()),\n            _ =\u003e None,\n        };\n        Record {\n            id: id.to_owned(),\n            desc,\n            seq: String::from_utf8(seq.to_vec()).unwrap(),\n            qual: String::from_utf8(qual.to_vec()).unwrap(),\n        }\n    }\n\n    /// Check if a record is empty.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use bio::io::fastq::Record;\n    ///\n    /// let mut record = Record::new();\n    /// assert!(record.is_empty());\n    ///\n    /// record = Record::with_attrs(\"id_str\", Some(\"desc\"), b\"ATGCGGG\", b\"QQQQQQQ\");\n    /// assert!(!record.is_empty());\n    /// ```\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.id.is_empty() \u0026\u0026 self.desc.is_none() \u0026\u0026 self.seq.is_empty() \u0026\u0026 self.qual.is_empty()\n    }\n\n    /// Check the validity of a FastQ record.\n    ///\n    /// # Errors\n    /// This function will return an `Err` if one of the following conditions is met:\n    /// -   The record identifier is empty.\n    /// -   There is a non-ASCII character found in either the sequence or quality strings.\n    /// -   The sequence and quality strings do not have the same length.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use bio::io::fastq::Record;\n    ///\n    /// let mut record = Record::with_attrs(\"id\", None, \"Prüfung\".as_ref(), b\"!!!!!!!\");\n    /// let actual = record.check().unwrap_err();\n    /// let expected = \"Non-ascii character found in sequence.\";\n    /// assert_eq!(actual, expected);\n    ///\n    /// record = Record::with_attrs(\"id_str\", Some(\"desc\"), b\"ATGCGGG\", b\"QQQQQQQ\");\n    /// assert!(record.check().is_ok());\n    /// ```\n    pub fn check(\u0026self) -\u003e Result\u003c(), \u0026str\u003e {\n        if self.id().is_empty() {\n            return Err(\"Expecting id for FastQ record.\");\n        }\n        if !self.seq.is_ascii() {\n            return Err(\"Non-ascii character found in sequence.\");\n        }\n        if !self.qual.is_ascii() {\n            return Err(\"Non-ascii character found in qualities.\");\n        }\n        if self.seq().len() != self.qual().len() {\n            return Err(\"Unequal length of sequence an qualities.\");\n        }\n\n        Ok(())\n    }\n\n    /// Return the id of the record.\n    pub fn id(\u0026self) -\u003e \u0026str {\n        self.id.as_ref()\n    }\n\n    /// Return descriptions if present.\n    pub fn desc(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        match self.desc.as_ref() {\n            Some(desc) =\u003e Some(\u0026desc),\n            None =\u003e None,\n        }\n    }\n\n    /// Return the sequence of the record.\n    pub fn seq(\u0026self) -\u003e TextSlice\u003c'_\u003e {\n        self.seq.trim_end().as_bytes()\n    }\n\n    /// Return the base qualities of the record.\n    pub fn qual(\u0026self) -\u003e \u0026[u8] {\n        self.qual.trim_end().as_bytes()\n    }\n\n    /// Clear the record.\n    fn clear(\u0026mut self) {\n        self.id.clear();\n        self.desc = None;\n        self.seq.clear();\n        self.qual.clear();\n    }\n}\n\nimpl fmt::Display for Record {\n    /// Allows for using `Record` in a given formatter `f`. In general this is for\n    /// creating a `String` representation of a `Record` and, optionally, writing it to\n    /// a file.\n    ///\n    /// # Errors\n    /// Returns [`std::fmt::Error`](https://doc.rust-lang.org/std/fmt/struct.Error.html)\n    /// if there is an issue formatting to the stream.\n    ///\n    /// # Examples\n    ///\n    /// Read in a Fastq `Record` and create a `String` representation of it.\n    ///\n    /// ```rust\n    /// use bio::io::fastq::Reader;\n    /// use std::fmt::Write;\n    /// // create a \"fake\" fastq file\n    /// let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n!!!!\\n\";\n    /// let mut records = Reader::new(fq).records().map(|r| r.unwrap());\n    /// let record = records.next().unwrap();\n    ///\n    /// let mut actual = String::new();\n    /// // populate `actual` with a string representation of our record\n    /// write!(actual, \"{}\", record).unwrap();\n    ///\n    /// let expected = std::str::from_utf8(fq).unwrap();\n    ///\n    /// assert_eq!(actual, expected)\n    /// ```\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e Result\u003c(), fmt::Error\u003e {\n        let header = match self.desc() {\n            Some(d) =\u003e format!(\"{} {}\", self.id().to_owned(), d),\n            None =\u003e self.id().to_owned(),\n        };\n        write!(\n            f,\n            \"@{}\\n{}\\n+\\n{}\\n\",\n            header,\n            std::str::from_utf8(self.seq()).unwrap(),\n            std::str::from_utf8(self.qual()).unwrap()\n        )\n    }\n}\n\nimpl SequenceRead for Record {\n    fn name(\u0026self) -\u003e \u0026[u8] {\n        self.id.as_bytes()\n    }\n\n    fn base(\u0026self, i: usize) -\u003e u8 {\n        self.seq()[i]\n    }\n\n    fn base_qual(\u0026self, i: usize) -\u003e u8 {\n        self.qual()[i]\n    }\n\n    fn len(\u0026self) -\u003e usize {\n        self.seq().len()\n    }\n}\n\n/// An iterator over the records of a FastQ file.\n#[derive(Debug)]\npub struct Records\u003cR: io::Read\u003e {\n    reader: Reader\u003cR\u003e,\n}\n\nimpl\u003cR: io::Read\u003e Iterator for Records\u003cR\u003e {\n    type Item = Result\u003cRecord\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cResult\u003cRecord\u003e\u003e {\n        let mut record = Record::new();\n        match self.reader.read(\u0026mut record) {\n            Ok(()) if record.is_empty() =\u003e None,\n            Ok(()) =\u003e Some(Ok(record)),\n            Err(err) =\u003e Some(Err(err)),\n        }\n    }\n}\n\n/// A FastQ writer.\n#[derive(Debug)]\npub struct Writer\u003cW: io::Write\u003e {\n    writer: io::BufWriter\u003cW\u003e,\n}\n\nimpl Writer\u003cfs::File\u003e {\n    /// Write to a given file path.\n    #[allow(clippy::wrong_self_convention)]\n    pub fn to_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e io::Result\u003cSelf\u003e {\n        fs::File::create(path).map(Writer::new)\n    }\n}\n\nimpl\u003cW: io::Write\u003e Writer\u003cW\u003e {\n    /// Write to a given `io::Write`.\n    pub fn new(writer: W) -\u003e Self {\n        Writer {\n            writer: io::BufWriter::new(writer),\n        }\n    }\n\n    /// Directly write a FastQ record.\n    pub fn write_record(\u0026mut self, record: \u0026Record) -\u003e io::Result\u003c()\u003e {\n        self.write(record.id(), record.desc(), record.seq(), record.qual())\n    }\n\n    /// Write a FastQ record with given id, optional description, sequence and qualities.\n    pub fn write(\n        \u0026mut self,\n        id: \u0026str,\n        desc: Option\u003c\u0026str\u003e,\n        seq: TextSlice\u003c'_\u003e,\n        qual: \u0026[u8],\n    ) -\u003e io::Result\u003c()\u003e {\n        self.writer.write_all(b\"@\")?;\n        self.writer.write_all(id.as_bytes())?;\n        if let Some(desc) = desc {\n            self.writer.write_all(b\" \")?;\n            self.writer.write_all(desc.as_bytes())?;\n        }\n        self.writer.write_all(b\"\\n\")?;\n        self.writer.write_all(seq)?;\n        self.writer.write_all(b\"\\n+\\n\")?;\n        self.writer.write_all(qual)?;\n        self.writer.write_all(b\"\\n\")?;\n\n        Ok(())\n    }\n\n    /// Flush the writer, ensuring that everything is written.\n    pub fn flush(\u0026mut self) -\u003e io::Result\u003c()\u003e {\n        self.writer.flush()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fmt::Write as FmtWrite;\n    use std::io;\n\n    const FASTQ_FILE: \u0026[u8] = b\"@id desc\nACCGTAGGCTGA\n+\nIIIIIIJJJJJJ\n\";\n\n    #[test]\n    fn test_reader() {\n        let reader = Reader::new(FASTQ_FILE);\n        let records: Vec\u003cResult\u003cRecord\u003e\u003e = reader.records().collect();\n        assert_eq!(records.len(), 1);\n        for res in records {\n            let record = res.unwrap();\n            assert_eq!(record.check(), Ok(()));\n            assert_eq!(record.id(), \"id\");\n            assert_eq!(record.desc(), Some(\"desc\"));\n            assert_eq!(record.seq(), b\"ACCGTAGGCTGA\");\n            assert_eq!(record.qual(), b\"IIIIIIJJJJJJ\");\n        }\n    }\n\n    #[test]\n    fn test_display_record_no_desc_id_without_space_after() {\n        let fq: \u0026'static [u8] = b\"@id\\nACGT\\n+\\n!!!!\\n\";\n        let mut records = Reader::new(fq).records().map(|r| r.unwrap());\n        let record = records.next().unwrap();\n        let mut actual = String::new();\n        write!(actual, \"{}\", record).unwrap();\n\n        let expected = std::str::from_utf8(fq).unwrap();\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_display_record_with_desc_id_has_space_between_id_and_desc() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n!!!!\\n\";\n        let mut records = Reader::new(fq).records().map(|r| r.unwrap());\n        let record = records.next().unwrap();\n        let mut actual = String::new();\n        write!(actual, \"{}\", record).unwrap();\n\n        let expected = std::str::from_utf8(fq).unwrap();\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_fqread_trait() {\n        let path = \"reads.fq.gz\";\n        let mut fq_reader: Box\u003cdyn FastqRead\u003e = match path.ends_with(\".gz\") {\n            true =\u003e Box::new(Reader::new(io::BufReader::new(FASTQ_FILE))),\n            false =\u003e Box::new(Reader::new(FASTQ_FILE)),\n        };\n        // The read method can be called, since it is implemented by\n        // `Read`. Right now, the records method would not work.\n        let mut record = Record::new();\n        fq_reader.read(\u0026mut record).unwrap();\n        // Check if the returned result is correct.\n        assert_eq!(record.check(), Ok(()));\n        assert_eq!(record.id(), \"id\");\n        assert_eq!(record.desc(), Some(\"desc\"));\n        assert_eq!(record.seq(), b\"ACCGTAGGCTGA\");\n        assert_eq!(record.qual(), b\"IIIIIIJJJJJJ\");\n    }\n\n    #[test]\n    fn test_record_with_attrs() {\n        let record = Record::with_attrs(\"id_str\", Some(\"desc\"), b\"ATGCGGG\", b\"QQQQQQQ\");\n        assert_eq!(record.id(), \"id_str\");\n        assert_eq!(record.desc(), Some(\"desc\"));\n        assert_eq!(record.seq(), b\"ATGCGGG\");\n        assert_eq!(record.qual(), b\"QQQQQQQ\");\n    }\n\n    #[test]\n    fn test_writer() {\n        let mut writer = Writer::new(Vec::new());\n        writer\n            .write(\"id\", Some(\"desc\"), b\"ACCGTAGGCTGA\", b\"IIIIIIJJJJJJ\")\n            .expect(\"Expected successful write\");\n        writer.flush().expect(\"Expected successful write\");\n        assert_eq!(writer.writer.get_ref(), \u0026FASTQ_FILE);\n    }\n\n    #[test]\n    fn test_check_record_id_is_empty_raises_err() {\n        let record = Record::with_attrs(\"\", None, b\"ACGT\", b\"!!!!\");\n\n        let actual = record.check().unwrap_err();\n        let expected = \"Expecting id for FastQ record.\";\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_check_record_seq_is_not_ascii_raises_err() {\n        let record = Record::with_attrs(\"id\", None, \"Prüfung\".as_ref(), b\"!!!!\");\n\n        let actual = record.check().unwrap_err();\n        let expected = \"Non-ascii character found in sequence.\";\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_check_record_quality_is_not_ascii_raises_err() {\n        let record = Record::with_attrs(\"id\", None, b\"ACGT\", \"Qualität\".as_ref());\n\n        let actual = record.check().unwrap_err();\n        let expected = \"Non-ascii character found in qualities.\";\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_check_record_quality_and_seq_diff_len_raises_err() {\n        let record = Record::with_attrs(\"id\", None, b\"ACGT\", b\"!!!\");\n\n        let actual = record.check().unwrap_err();\n        let expected = \"Unequal length of sequence an qualities.\";\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_check_valid_record() {\n        let record = Record::with_attrs(\"id\", None, b\"ACGT\", b\"!!!!\");\n\n        assert!(record.check().is_ok())\n    }\n\n    #[test]\n    fn test_read_header_does_not_start_with_correct_char_raises_err() {\n        let fq: \u0026'static [u8] = b\"\u003eid description\\nACGT\\n+\\n!!!!\\n\";\n        let mut reader = Reader::new(fq);\n        let mut record = Record::new();\n\n        let error = reader.read(\u0026mut record).unwrap_err();\n\n        assert!(matches!(error, Error::MissingAt))\n    }\n\n    #[test]\n    fn test_read_quality_is_empty_raises_err() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n\";\n        let mut reader = Reader::new(fq);\n        let mut record = Record::new();\n\n        let error = reader.read(\u0026mut record).unwrap_err();\n\n        assert!(matches!(error, Error::IncompleteRecord))\n    }\n\n    #[test]\n    fn test_read_sequence_and_quality_are_wrapped_is_handled_with_one_sequence() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\nGGGG\\nC\\n+\\n@@@@\\n!!!!\\n$\\n\";\n        let mut reader = Reader::new(fq);\n\n        let mut actual = Record::new();\n        reader.read(\u0026mut actual).unwrap();\n        let expected = Record::with_attrs(\"id\", Some(\"description\"), b\"ACGTGGGGC\", b\"@@@@!!!!$\");\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_read_sequence_and_quality_are_wrapped_is_handled_with_three_sequences() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\nGGGG\\nC\\n+\\n@@@@\\n!!!!\\n$\\n@id2 description\\nACGT\\nGGGG\\nC\\n+\\n@@@@\\n!!!!\\n$\\n@id3 desc1 desc2\\nAAA\\nAAA\\nAA\\n+\\n^^^\\n^^^\\n^^\\n\";\n        let mut reader = Reader::new(fq);\n\n        let mut actual = Record::new();\n        reader.read(\u0026mut actual).unwrap();\n        let expected = Record::with_attrs(\"id\", Some(\"description\"), b\"ACGTGGGGC\", b\"@@@@!!!!$\");\n\n        assert_eq!(actual, expected);\n\n        reader.read(\u0026mut actual).unwrap();\n        let expected = Record::with_attrs(\"id2\", Some(\"description\"), b\"ACGTGGGGC\", b\"@@@@!!!!$\");\n\n        assert_eq!(actual, expected);\n\n        reader.read(\u0026mut actual).unwrap();\n        let expected = Record::with_attrs(\"id3\", Some(\"desc1 desc2\"), b\"AAAAAAAA\", b\"^^^^^^^^\");\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_read_wrapped_record_with_inconsistent_wrapping_errors() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\nGGGG\\nC\\n+\\n@@@@\\n!!!!$\\n@id2 description\\nACGT\\nGGGG\\nC\\n+\\n@@@@\\n!!!!\\n$\\n@id3 desc1 desc2\\nAAA\\nAAA\\nAA\\n+\\n^^^\\n^^^\\n^^\\n\";\n        let mut reader = Reader::new(fq);\n\n        let mut record = Record::new();\n        reader.read(\u0026mut record).unwrap();\n        let error = reader.read(\u0026mut record).unwrap_err();\n\n        assert!(matches!(error, Error::MissingAt))\n    }\n\n    #[test]\n    fn test_record_iterator_next_read_returns_err_causes_next_to_return_some_err() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n\";\n        let mut records = Reader::new(fq).records();\n\n        let error = records.next().unwrap().unwrap_err();\n\n        assert!(matches!(error, Error::IncompleteRecord));\n    }\n\n    #[test]\n    fn test_reader_from_file_path_doesnt_exist_returns_err() {\n        let path = Path::new(\"/I/dont/exist.fq\");\n        let error = Reader::from_file(path)\n            .unwrap_err()\n            .downcast::\u003cString\u003e()\n            .unwrap();\n\n        assert_eq!(\u0026error, \"Failed to read fastq from \\\"/I/dont/exist.fq\\\"\")\n    }\n\n    #[test]\n    fn test_reader_from_file_path_exists_returns_ok() {\n        let path = Path::new(\"Cargo.toml\");\n\n        assert!(Reader::from_file(path).is_ok())\n    }\n\n    #[test]\n    fn test_sequence_read_for_record_trait_method_name() {\n        let record = Record::with_attrs(\"id\", None, b\"ACGT\", b\"!!!!\");\n\n        let actual = record.name();\n        let expected = b\"id\";\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_sequence_read_for_record_trait_method_base_idx_in_range() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n!!!!\\n\";\n        let mut reader = Reader::new(fq);\n        let mut record = Record::new();\n        reader.read(\u0026mut record).unwrap();\n        let idx = 2;\n\n        let actual = record.base(idx);\n        let expected = b'G';\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_sequence_read_for_record_trait_method_base_idx_out_of_range() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n!!!!\\n\";\n        let mut reader = Reader::new(fq);\n        let mut record = Record::new();\n        reader.read(\u0026mut record).unwrap();\n        // idx 4 is where the newline character would be - we dont want that included\n        let idx = 4;\n\n        record.base(idx);\n    }\n\n    #[test]\n    fn test_sequence_read_for_record_trait_method_base_qual_idx_in_range() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n!!!!\\n\";\n        let mut reader = Reader::new(fq);\n        let mut record = Record::new();\n        reader.read(\u0026mut record).unwrap();\n        let idx = 2;\n\n        let actual = record.base_qual(idx);\n        let expected = b'!';\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_sequence_read_for_record_trait_method_base_qual_idx_out_of_range() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n!!!!\\n\";\n        let mut reader = Reader::new(fq);\n        let mut record = Record::new();\n        reader.read(\u0026mut record).unwrap();\n        // idx 4 is where the newline character would be - we dont want that included\n        let idx = 4;\n\n        record.base_qual(idx);\n    }\n\n    #[test]\n    fn test_sequence_read_for_record_trait_method_len() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n!!!!\\n\";\n        let mut reader = Reader::new(fq);\n        let mut record = Record::new();\n        reader.read(\u0026mut record).unwrap();\n\n        let actual = record.len();\n        let expected = 4;\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_writer_to_file_dir_doesnt_exist_returns_err() {\n        let path = Path::new(\"/I/dont/exist.fq\");\n\n        let actual = Writer::to_file(path).unwrap_err();\n        let expected = io::Error::new(io::ErrorKind::NotFound, \"foo\");\n\n        assert_eq!(actual.kind(), expected.kind());\n    }\n\n    #[test]\n    fn test_writer_to_file_dir_exists_returns_ok() {\n        let file = tempfile::NamedTempFile::new().expect(\"Could not create temp file\");\n        let path = file.path();\n\n        assert!(Writer::to_file(path).is_ok())\n    }\n\n    #[test]\n    fn test_write_record() {\n        let path = Path::new(\"test.fq\");\n        let file = fs::File::create(path).unwrap();\n        {\n            let handle = io::BufWriter::new(file);\n            let mut writer = Writer { writer: handle };\n            let record = Record::with_attrs(\"id\", Some(\"desc\"), b\"ACGT\", b\"!!!!\");\n\n            let write_result = writer.write_record(\u0026record);\n            assert!(write_result.is_ok());\n        }\n\n        let actual = fs::read_to_string(path).unwrap();\n        let expected = \"@id desc\\nACGT\\n+\\n!!!!\\n\";\n\n        assert!(fs::remove_file(path).is_ok());\n        assert_eq!(actual, expected)\n    }\n}\n","traces":[{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":566,"address":[4532872,4530432],"length":1,"stats":{"Line":3},"fn_name":"test_reader"},{"line":567,"address":[4530439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":568,"address":[4530480],"length":1,"stats":{"Line":1},"fn_name":null},{"line":569,"address":[4530812,4530564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":570,"address":[4532818,4530863,4531015,4530733,4531043],"length":1,"stats":{"Line":4},"fn_name":null},{"line":571,"address":[4531507],"length":1,"stats":{"Line":1},"fn_name":null},{"line":572,"address":[4531657,4531860,4531919],"length":1,"stats":{"Line":2},"fn_name":null},{"line":573,"address":[4531874,4531982,4532151],"length":1,"stats":{"Line":2},"fn_name":null},{"line":574,"address":[4532361,4532208,4532115],"length":1,"stats":{"Line":2},"fn_name":null},{"line":575,"address":[4532418,4532571,4532328],"length":1,"stats":{"Line":2},"fn_name":null},{"line":576,"address":[4532628,4532538,4532763],"length":1,"stats":{"Line":2},"fn_name":null},{"line":581,"address":[4532912,4533672],"length":1,"stats":{"Line":3},"fn_name":"test_display_record_no_desc_id_without_space_after"},{"line":582,"address":[4532919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":583,"address":[4532946],"length":1,"stats":{"Line":3},"fn_name":null},{"line":584,"address":[4533023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":585,"address":[4533105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":586,"address":[4533120,4533224,4533317],"length":1,"stats":{"Line":3},"fn_name":null},{"line":588,"address":[4533374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":590,"address":[4533599,4533481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":594,"address":[4534456,4533696],"length":1,"stats":{"Line":3},"fn_name":"test_display_record_with_desc_id_has_space_between_id_and_desc"},{"line":595,"address":[4533703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":596,"address":[4533730],"length":1,"stats":{"Line":3},"fn_name":null},{"line":597,"address":[4533807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":598,"address":[4533889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":599,"address":[4534008,4534101,4533904],"length":1,"stats":{"Line":3},"fn_name":null},{"line":601,"address":[4534158],"length":1,"stats":{"Line":1},"fn_name":null},{"line":603,"address":[4534265,4534383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":607,"address":[4534480,4536118],"length":1,"stats":{"Line":3},"fn_name":"test_fqread_trait"},{"line":608,"address":[4534487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":609,"address":[4534514,4534717,4534842],"length":1,"stats":{"Line":2},"fn_name":null},{"line":610,"address":[4534557,4534593,4534694],"length":1,"stats":{"Line":3},"fn_name":null},{"line":611,"address":[4534563,4534819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[4534757],"length":1,"stats":{"Line":1},"fn_name":null},{"line":616,"address":[4534924,4534844],"length":1,"stats":{"Line":2},"fn_name":null},{"line":618,"address":[4535213,4534991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":619,"address":[4535444,4535275,4535168],"length":1,"stats":{"Line":2},"fn_name":null},{"line":620,"address":[4535654,4535408,4535501],"length":1,"stats":{"Line":2},"fn_name":null},{"line":621,"address":[4535621,4535864,4535711],"length":1,"stats":{"Line":2},"fn_name":null},{"line":622,"address":[4536056,4535831,4535921],"length":1,"stats":{"Line":2},"fn_name":null},{"line":626,"address":[4536144,4537195],"length":1,"stats":{"Line":3},"fn_name":"test_record_with_attrs"},{"line":627,"address":[4536151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":628,"address":[4536263,4536470,4536529],"length":1,"stats":{"Line":2},"fn_name":null},{"line":629,"address":[4536484,4536591,4536744],"length":1,"stats":{"Line":2},"fn_name":null},{"line":630,"address":[4536954,4536711,4536801],"length":1,"stats":{"Line":2},"fn_name":null},{"line":631,"address":[4537011,4537148,4536921],"length":1,"stats":{"Line":2},"fn_name":null},{"line":635,"address":[4537820,4537232],"length":1,"stats":{"Line":3},"fn_name":"test_writer"},{"line":636,"address":[4537239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":637,"address":[4537298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":638,"address":[4537271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":640,"address":[4537516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":641,"address":[4537628,4537774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[4538275,4537856],"length":1,"stats":{"Line":3},"fn_name":"test_check_record_id_is_empty_raises_err"},{"line":646,"address":[4537863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":648,"address":[4538063,4537953],"length":1,"stats":{"Line":2},"fn_name":null},{"line":649,"address":[4538079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":651,"address":[4538229,4538114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":655,"address":[4538750,4538304],"length":1,"stats":{"Line":3},"fn_name":"test_check_record_seq_is_not_ascii_raises_err"},{"line":656,"address":[4538311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":658,"address":[4538428,4538538],"length":1,"stats":{"Line":2},"fn_name":null},{"line":659,"address":[4538554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":661,"address":[4538704,4538589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":665,"address":[4539230,4538784],"length":1,"stats":{"Line":3},"fn_name":"test_check_record_quality_is_not_ascii_raises_err"},{"line":666,"address":[4538791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":668,"address":[4538908,4539018],"length":1,"stats":{"Line":2},"fn_name":null},{"line":669,"address":[4539034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":671,"address":[4539184,4539069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":675,"address":[4539684,4539264],"length":1,"stats":{"Line":3},"fn_name":"test_check_record_quality_and_seq_diff_len_raises_err"},{"line":676,"address":[4539271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":678,"address":[4539362,4539472],"length":1,"stats":{"Line":2},"fn_name":null},{"line":679,"address":[4539488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":681,"address":[4539638,4539523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":685,"address":[4539968,4539712],"length":1,"stats":{"Line":3},"fn_name":"test_check_valid_record"},{"line":686,"address":[4539719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":688,"address":[4539810,4539918,4539936],"length":1,"stats":{"Line":2},"fn_name":null},{"line":692,"address":[4540000,4540347],"length":1,"stats":{"Line":3},"fn_name":"test_read_header_does_not_start_with_correct_char_raises_err"},{"line":693,"address":[4540007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":694,"address":[4540034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":695,"address":[4540061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":697,"address":[4540086,4540130],"length":1,"stats":{"Line":2},"fn_name":null},{"line":699,"address":[4540194,4540251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":703,"address":[4540384,4540731],"length":1,"stats":{"Line":3},"fn_name":"test_read_quality_is_empty_raises_err"},{"line":704,"address":[4540391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":705,"address":[4540418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":706,"address":[4540445],"length":1,"stats":{"Line":1},"fn_name":null},{"line":708,"address":[4540470,4540514],"length":1,"stats":{"Line":2},"fn_name":null},{"line":710,"address":[4540635,4540578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":714,"address":[4541306,4540768],"length":1,"stats":{"Line":3},"fn_name":"test_read_sequence_and_quality_are_wrapped_is_handled_with_one_sequence"},{"line":715,"address":[4540775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":716,"address":[4540802],"length":1,"stats":{"Line":1},"fn_name":null},{"line":718,"address":[4540832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":719,"address":[4540904,4540860],"length":1,"stats":{"Line":2},"fn_name":null},{"line":720,"address":[4540963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":722,"address":[4541233,4541077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":726,"address":[4542616,4541344],"length":1,"stats":{"Line":3},"fn_name":"test_read_sequence_and_quality_are_wrapped_is_handled_with_three_sequences"},{"line":727,"address":[4541351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":728,"address":[4541378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":730,"address":[4541408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":731,"address":[4541436,4541480],"length":1,"stats":{"Line":2},"fn_name":null},{"line":732,"address":[4541539],"length":1,"stats":{"Line":1},"fn_name":null},{"line":734,"address":[4541822,4541653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":736,"address":[4541868,4541805],"length":1,"stats":{"Line":2},"fn_name":null},{"line":737,"address":[4541890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":739,"address":[4542004,4542173],"length":1,"stats":{"Line":1},"fn_name":null},{"line":741,"address":[4542220,4542156],"length":1,"stats":{"Line":2},"fn_name":null},{"line":742,"address":[4542242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":744,"address":[4542356,4542512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":748,"address":[4543034,4542640],"length":1,"stats":{"Line":3},"fn_name":"test_read_wrapped_record_with_inconsistent_wrapping_errors"},{"line":749,"address":[4542647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":750,"address":[4542674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":752,"address":[4542701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":753,"address":[4542726,4542770],"length":1,"stats":{"Line":2},"fn_name":null},{"line":754,"address":[4542844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":756,"address":[4542881,4542938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":760,"address":[4543072,4543393],"length":1,"stats":{"Line":3},"fn_name":"test_record_iterator_next_read_returns_err_causes_next_to_return_some_err"},{"line":761,"address":[4543079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":762,"address":[4543106],"length":1,"stats":{"Line":1},"fn_name":null},{"line":764,"address":[4543224,4543152],"length":1,"stats":{"Line":2},"fn_name":null},{"line":766,"address":[4543254,4543311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":770,"address":[4543424,4543768],"length":1,"stats":{"Line":3},"fn_name":"test_reader_from_file_path_doesnt_exist_returns_err"},{"line":771,"address":[4543431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":772,"address":[4543484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":777,"address":[4543558,4543722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":781,"address":[4543792,4543927],"length":1,"stats":{"Line":3},"fn_name":"test_reader_from_file_path_exists_returns_ok"},{"line":782,"address":[4543799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":784,"address":[4543846,4543987,4543957,4543943],"length":1,"stats":{"Line":2},"fn_name":null},{"line":788,"address":[4544361,4544000],"length":1,"stats":{"Line":3},"fn_name":"test_sequence_read_for_record_trait_method_name"},{"line":789,"address":[4544007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":791,"address":[4544098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":792,"address":[4544147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":794,"address":[4544287,4544170,4544315],"length":1,"stats":{"Line":2},"fn_name":null},{"line":798,"address":[4544794,4544384],"length":1,"stats":{"Line":3},"fn_name":"test_sequence_read_for_record_trait_method_base_idx_in_range"},{"line":799,"address":[4544391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":800,"address":[4544418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":801,"address":[4544445],"length":1,"stats":{"Line":1},"fn_name":null},{"line":802,"address":[4544470,4544514],"length":1,"stats":{"Line":2},"fn_name":null},{"line":803,"address":[4544570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":805,"address":[4544592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":806,"address":[4544616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":808,"address":[4544624,4544731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":813,"address":[4544832,4545071],"length":1,"stats":{"Line":4},"fn_name":"test_sequence_read_for_record_trait_method_base_idx_out_of_range"},{"line":814,"address":[4544839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":815,"address":[4544866],"length":1,"stats":{"Line":1},"fn_name":null},{"line":816,"address":[4544893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":817,"address":[4544962,4544918],"length":1,"stats":{"Line":2},"fn_name":null},{"line":819,"address":[4545018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":821,"address":[4545040],"length":1,"stats":{"Line":1},"fn_name":null},{"line":825,"address":[4545514,4545104],"length":1,"stats":{"Line":3},"fn_name":"test_sequence_read_for_record_trait_method_base_qual_idx_in_range"},{"line":826,"address":[4545111],"length":1,"stats":{"Line":1},"fn_name":null},{"line":827,"address":[4545138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":828,"address":[4545165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":829,"address":[4545234,4545190],"length":1,"stats":{"Line":2},"fn_name":null},{"line":830,"address":[4545290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":832,"address":[4545312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":833,"address":[4545336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":835,"address":[4545344,4545451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":840,"address":[4545552,4545791],"length":1,"stats":{"Line":4},"fn_name":"test_sequence_read_for_record_trait_method_base_qual_idx_out_of_range"},{"line":841,"address":[4545559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":842,"address":[4545586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":843,"address":[4545613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":844,"address":[4545638,4545682],"length":1,"stats":{"Line":2},"fn_name":null},{"line":846,"address":[4545738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":848,"address":[4545760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":852,"address":[4545824,4546227],"length":1,"stats":{"Line":3},"fn_name":"test_sequence_read_for_record_trait_method_len"},{"line":853,"address":[4545831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":854,"address":[4545858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":855,"address":[4545885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":856,"address":[4545954,4545910],"length":1,"stats":{"Line":2},"fn_name":null},{"line":858,"address":[4546015],"length":1,"stats":{"Line":1},"fn_name":null},{"line":859,"address":[4546043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":861,"address":[4546164,4546055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":865,"address":[4546790,4546256],"length":1,"stats":{"Line":3},"fn_name":"test_writer_to_file_dir_doesnt_exist_returns_err"},{"line":866,"address":[4546263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":868,"address":[4546316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":869,"address":[4546385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":871,"address":[4546603,4546731,4546539,4546484],"length":1,"stats":{"Line":3},"fn_name":null},{"line":875,"address":[4546816,4547102],"length":1,"stats":{"Line":3},"fn_name":"test_writer_to_file_dir_exists_returns_ok"},{"line":876,"address":[4546823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":877,"address":[4546873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":879,"address":[4546927,4546977,4547070],"length":1,"stats":{"Line":2},"fn_name":null},{"line":883,"address":[4547136,4547735],"length":1,"stats":{"Line":3},"fn_name":"test_write_record"},{"line":884,"address":[4547143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":885,"address":[4547196],"length":1,"stats":{"Line":1},"fn_name":null},{"line":887,"address":[4547238],"length":1,"stats":{"Line":1},"fn_name":null},{"line":888,"address":[4547251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":889,"address":[4547315],"length":1,"stats":{"Line":1},"fn_name":null},{"line":891,"address":[4547437,4547510],"length":1,"stats":{"Line":2},"fn_name":null},{"line":892,"address":[4547673,4547542,4547608],"length":1,"stats":{"Line":2},"fn_name":null},{"line":895,"address":[4547760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":896,"address":[4547811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":898,"address":[4548138,4547838,4547977],"length":1,"stats":{"Line":2},"fn_name":null},{"line":899,"address":[4548207,4548059,4548175],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":306,"coverable":311},{"path":["/","home","todd","rust-bio","src","io","fastx.rs"],"content":"// Copyright 2021 Todd Morse.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Traits and utilities to read and write files in the FASTA and FASTQ format interchangably\n//!\n//! Files in the FASTA and FASTQ format have several common fields: ID, Sequence, and Description.\n//! These utilities can be used to implement algorithms that only require these fields for files\n//! that are in either format.\n//!\n//! This module serves two use cases:\n//!\n//! 1. Implementing functions that can be used generically with FASTA/FASTQ records. In this use\n//! case the type may be known at compile time by the caller of your function.\n//! 2. Processing data that may be either in the FASTA/FASTQ format. In this use case the type\n//! cannot be known at compile time and you may or may not want to treat FASTA/FASTQ data\n//! differently.\n//!\n//! # Generic Implementation Examples\n//!\n//! ## Common Statistics\n//!\n//! In this example, we implement a count_bases function that for supports both the FASTA and FASTQ\n//! format.\n//!\n//! ```\n//! use bio::io::{fasta, fastq, fastx};\n//! use std::io;\n//!\n//! fn count_bases\u003cT, E, I\u003e(mut records: I) -\u003e Result\u003cusize, E\u003e\n//! where T: fastx::Record,\n//!     E: std::error::Error,\n//!     I: fastx::Records\u003cT, E\u003e {\n//!     let mut nb_bases = 0;\n//!     for result in records {\n//!         let record = result?;\n//!         nb_bases += record.seq().len();\n//!     }\n//!     Ok(nb_bases)\n//! }\n//!\n//! let mut raw_reader = io::Cursor::new(b\"\u003eid desc\n//! ACTG\n//! \");\n//!\n//! match fastx::get_kind_seek(\u0026mut raw_reader) {\n//!     Ok(fastx::Kind::FASTA) =\u003e {\n//!         let mut reader = fasta::Reader::new(raw_reader);\n//!         let nb_bases = count_bases(reader.records()).unwrap();\n//!         println!(\"Number of bases: {}\", nb_bases);\n//!     },\n//!     Ok(fastx::Kind::FASTQ) =\u003e {\n//!         let mut reader = fastq::Reader::new(raw_reader);\n//!         let nb_bases = count_bases(reader.records()).unwrap();\n//!         println!(\"Number of bases: {}\", nb_bases);\n//!     },\n//!     _ =\u003e println!(\"Encountered an error\"),\n//! }\n//! ```\n//!\n//! ## Filtration\n//!\n//! In this example, we define an at_least_n_bases function that can filter FASTA or FASTQ\n//! records based on their sequence lengths. It works seemlessly with `fasta::Record`s as if\n//! it was implemented just for them. In a realistic scenario this function might be\n//! defined in a library so callers could use it with both FASTA and FASTQ files as needed.\n//!\n//! ```\n//! use bio::io::{fasta, fastq, fastx};\n//! use std::io;\n//!\n//! fn at_least_n_bases\u003cT, E, I\u003e(mut records: I, n: usize) -\u003e impl Iterator\u003cItem = Result\u003cT, E\u003e\u003e\n//! where T: fastx::Record,\n//!     E: std::error::Error,\n//!     I: fastx::Records\u003cT, E\u003e {\n//!     records.filter(move |rr| match rr {\n//!         Ok(r) =\u003e r.seq().len() \u003e n,\n//!         _ =\u003e true,\n//!     })\n//! }\n//!\n//! let mut reader = fasta::Reader::new(io::stdin());\n//! let mut writer = fasta::Writer::new(io::stdout());\n//!\n//! for record in at_least_n_bases(reader.records(), 10) {\n//!     writer.write_record(\u0026record.unwrap());\n//! }\n//! ```\n//! # Unknown Type Examples\n//!\n//! If the type of a record is not known at compile time the record is a `fastx::EitherRecord`.\n//! This type is an enum containing either a `fasta::Record` or a `fastq::Record`. There are also\n//! utility functions defined on the enum so you can work with it without detecting the type.\n//!\n//! ## Parsing data of unknown type\n//!\n//! ```\n//! use bio::io::fastx::{Record, EitherRecords};\n//! use std::io;\n//! use std::str;\n//!\n//! let mut records = EitherRecords::from(io::stdin());\n//! while let Some(Ok(record)) = records.next() {\n//!     println!(\"id  : {}\", record.id());\n//!     println!(\"desc: {}\", record.desc().unwrap_or(\"none\"));\n//!     println!(\"seq : {}\", str::from_utf8(record.seq()).unwrap_or(\"error\"));\n//!     // Add a default quality in case we have a FASTA record\n//!     let default_qual = vec![b'I' ; record.seq().len()];\n//!     let qual = record.qual().unwrap_or(\u0026default_qual);\n//!     println!(\"qual: {}\", str::from_utf8(qual).unwrap_or(\"error\"));\n//!     println!(\"\")\n//! }\n//! ```\n//!\n//! # Utility Examples\n//!\n//! ## Type Detection\n//!\n//! This module provides utilities for detecting if some data is a FASTA/FASTQ.\n//!\n//! ```\n//! use bio::io::fastx::{get_kind, get_kind_seek, get_kind_file, Kind};\n//! use std::io;\n//! use std::io::Read;\n//! use std::fs;\n//! use std::fs::File;\n//! use std::io::prelude::*;\n//!\n//! // From a Read\n//!\n//! fn from_read() -\u003e io::Result\u003cKind\u003e {\n//!     let reader = io::stdin();\n//!     let (mut new_reader, kind) = get_kind(reader)?;\n//!     println!(\"{}\", kind);\n//!     // Read from start of your old reader\n//!     let mut buf = [0u8; 8];\n//!     new_reader.read(\u0026mut buf)?;\n//!     Ok(kind)\n//! }\n//!\n//!\n//! // From a Read + Seek\n//!\n//! fn from_read_seek() -\u003e io::Result\u003cKind\u003e {\n//!     let mut read_seek = io::Cursor::new(b\"\u003eid desc\n//! ACTG\n//! \");\n//!\n//!     get_kind_seek(\u0026mut read_seek)\n//! }\n//!\n//! // From a file path\n//!\n//! fn from_file_path() -\u003e io::Result\u003cKind\u003e {\n//!     get_kind_file(\"foo.fasta\")\n//! }\n//! ```\n//!\nuse anyhow::Context;\nuse std::convert::AsRef;\nuse std::fs;\nuse std::io::SeekFrom;\nuse std::io::prelude::*;\nuse std::io;\nuse std::mem;\nuse std::path::Path;\nuse thiserror::Error;\n\nuse crate::io::{fasta, fastq};\nuse crate::utils::TextSlice;\n\nmacro_rules! passthrough {\n    ($name:ident, $t:ty) =\u003e {\n        fn $name(\u0026self) -\u003e $t {\n            self.$name()\n        }\n    };\n}\n\nmacro_rules! matchthrough {\n    ($name:ident, $t:ty) =\u003e {\n        fn $name(\u0026self) -\u003e $t {\n            match self {\n                EitherRecord::FASTA(f) =\u003e Record::$name(f),\n                EitherRecord::FASTQ(f) =\u003e Record::$name(f),\n            }\n        }\n    };\n}\n\npub trait Record {\n    fn is_empty(\u0026self) -\u003e bool;\n    fn check(\u0026self) -\u003e Result\u003c(), \u0026str\u003e;\n    fn id(\u0026self) -\u003e \u0026str;\n    fn desc(\u0026self) -\u003e Option\u003c\u0026str\u003e;\n    fn seq(\u0026self) -\u003e TextSlice\u003c'_\u003e;\n    fn qual(\u0026self) -\u003e Option\u003c\u0026[u8]\u003e;\n    fn kind(\u0026self) -\u003e Kind;\n}\n\nimpl Record for super::fasta::Record {\n    passthrough!(is_empty, bool);\n    passthrough!(check, Result\u003c(), \u0026str\u003e);\n    passthrough!(id, \u0026str);\n    passthrough!(desc, Option\u003c\u0026str\u003e);\n    passthrough!(seq, TextSlice\u003c'_\u003e);\n\n    fn qual(\u0026self) -\u003e Option\u003c\u0026[u8]\u003e {\n        None\n    }\n\n    fn kind(\u0026self) -\u003e Kind {\n        Kind::FASTA\n    }\n}\n\nimpl Record for super::fastq::Record {\n    passthrough!(is_empty, bool);\n    passthrough!(check, Result\u003c(), \u0026str\u003e);\n    passthrough!(id, \u0026str);\n    passthrough!(desc, Option\u003c\u0026str\u003e);\n    passthrough!(seq, TextSlice\u003c'_\u003e);\n\n    fn qual(\u0026self) -\u003e Option\u003c\u0026[u8]\u003e {\n        Some(self.qual())\n    }\n\n    fn kind(\u0026self) -\u003e Kind {\n        Kind::FASTQ\n    }\n}\n\npub enum EitherRecord {\n    FASTA(fasta::Record),\n    FASTQ(fastq::Record),\n}\n\nimpl EitherRecord {\n    pub fn to_fasta(self) -\u003e fasta::Record {\n        return self.into();\n    }\n\n    pub fn to_fastq(self, default_qual: u8) -\u003e fastq::Record {\n        match self {\n            EitherRecord::FASTQ(f) =\u003e f,\n            EitherRecord::FASTA(f) =\u003e {\n                let qual = \u0026vec![default_qual; f.seq().len()];\n                fastq::Record::with_attrs(f.id(), f.desc(), f.seq(), qual)\n            }\n        }\n    }\n}\n\nimpl Into\u003cfasta::Record\u003e for EitherRecord {\n    fn into(self) -\u003e fasta::Record {\n        match self {\n            EitherRecord::FASTA(f) =\u003e f,\n            EitherRecord::FASTQ(f) =\u003e fasta::Record::with_attrs(f.id(), f.desc(), f.seq()),\n        }\n    }\n}\n\nimpl From\u003cfasta::Record\u003e for EitherRecord {\n    fn from(record: fasta::Record) -\u003e Self {\n        EitherRecord::FASTA(record)\n    }\n}\n\nimpl From\u003cfastq::Record\u003e for EitherRecord {\n    fn from(record: fastq::Record) -\u003e Self {\n        EitherRecord::FASTQ(record)\n    }\n}\n\nimpl Record for EitherRecord {\n    matchthrough!(is_empty, bool);\n    matchthrough!(check, Result\u003c(), \u0026str\u003e);\n    matchthrough!(id, \u0026str);\n    matchthrough!(desc, Option\u003c\u0026str\u003e);\n    matchthrough!(seq, TextSlice\u003c'_\u003e);\n\n    fn qual(\u0026self) -\u003e Option\u003c\u0026[u8]\u003e {\n        match \u0026self {\n            EitherRecord::FASTA(f) =\u003e Record::qual(f),\n            EitherRecord::FASTQ(f) =\u003e Record::qual(f),\n        }\n    }\n\n    matchthrough!(kind, Kind);\n}\n\npub trait Records\u003cR: Record, E\u003e: Iterator\u003cItem = Result\u003cR, E\u003e\u003e {}\n\nimpl\u003cT: io::Read\u003e Records\u003cfasta::Record, io::Error\u003e for fasta::Records\u003cT\u003e {}\n\nimpl\u003cT: io::Read\u003e Records\u003cfastq::Record, fastq::Error\u003e for fastq::Records\u003cT\u003e {}\n\n#[derive(Debug)]\nenum EitherRecordsInner\u003cR: io::Read\u003e {\n    FASTA(fasta::Records\u003cR\u003e),\n    FASTQ(fastq::Records\u003cR\u003e),\n}\n\n#[derive(Debug)]\npub struct EitherRecords\u003cR: io::Read\u003e {\n    records: Option\u003cEitherRecordsInner\u003cR\u003e\u003e,\n    reader: Option\u003cR\u003e,\n}\n\nimpl EitherRecords\u003cfs::File\u003e {\n    /// Read from a given file.\n    pub fn from_file\u003cP: AsRef\u003cPath\u003e + std::fmt::Debug\u003e(path: P) -\u003e anyhow::Result\u003cSelf\u003e {\n        fs::File::open(path.as_ref())\n            .map(EitherRecords::from)\n            .with_context(|| format!(\"Failed to read fastq from {:#?}\", path))\n    }\n}\n\nimpl\u003cR: io::Read\u003e EitherRecords\u003cR\u003e {\n    pub fn new(reader: R) -\u003e Self {\n        EitherRecords::from(reader)\n    }\n\n    pub fn kind(\u0026mut self) -\u003e io::Result\u003cKind\u003e {\n        self.initialize()?;\n        match self.records {\n            Some(EitherRecordsInner::FASTA(_)) =\u003e Ok(Kind::FASTA),\n            Some(EitherRecordsInner::FASTQ(_)) =\u003e Ok(Kind::FASTQ),\n            None =\u003e Err(io::Error::new(\n                io::ErrorKind::UnexpectedEof,\n                \"Data is empty\",\n            )),\n        }\n    }\n\n    fn initialize(\u0026mut self) -\u003e io::Result\u003c()\u003e {\n        if let Some(reader) = mem::replace(\u0026mut self.reader, None) {\n            let mut reader: io::BufReader\u003cR\u003e = io::BufReader::new(reader);\n            let mut line = String::new();\n            reader.read_line(\u0026mut line)?;\n            match line.chars().next() {\n                Some('\u003e') =\u003e {\n                    self.records = Some(EitherRecordsInner::FASTA(\n                        fasta::Reader::new_with_line(reader, line).records(),\n                    ))\n                }\n                Some('@') =\u003e {\n                    self.records = Some(EitherRecordsInner::FASTQ(\n                        fastq::Reader::new_with_line_buffer(reader, line).records(),\n                    ))\n                }\n                Some(c) =\u003e {\n                    return Err(io::Error::new(\n                        io::ErrorKind::InvalidData,\n                        format!(\n                            \"Data is not a valid FASTA/FASTQ, illegal start character '{}'\",\n                            c\n                        ),\n                    ))\n                }\n                None =\u003e (),\n            }\n        }\n        Ok(())\n    }\n}\n\nimpl\u003cR: io::Read\u003e Iterator for EitherRecords\u003cR\u003e {\n    type Item = Result\u003cEitherRecord\u003e;\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        if let Err(e) = self.initialize() {\n            return Some(Err(Error::IO(e)));\n        }\n        match \u0026mut self.records {\n            Some(EitherRecordsInner::FASTA(r)) =\u003e r\n                .next()\n                .map(|record_res| record_res.map(EitherRecord::from).map_err(Error::from)),\n            Some(EitherRecordsInner::FASTQ(r)) =\u003e r\n                .next()\n                .map(|record_res| record_res.map(EitherRecord::from).map_err(Error::from)),\n            None =\u003e None,\n        }\n    }\n}\n\nimpl\u003cR: io::Read\u003e From\u003cR\u003e for EitherRecords\u003cR\u003e {\n    fn from(reader: R) -\u003e Self {\n        EitherRecords {\n            records: None,\n            reader: Some(reader),\n        }\n    }\n}\n\n#[derive(Display, Debug, Error)]\npub enum Error {\n    IO(io::Error),\n    FASTQ(fastq::Error),\n}\n\nimpl From\u003cio::Error\u003e for Error {\n    fn from(err: io::Error) -\u003e Self {\n        Error::IO(err)\n    }\n}\n\nimpl From\u003cfastq::Error\u003e for Error {\n    fn from(err: fastq::Error) -\u003e Self {\n        Error::FASTQ(err)\n    }\n}\n\ntype Result\u003cT, E = Error\u003e = std::result::Result\u003cT, E\u003e;\n\n#[derive(Debug, Eq, PartialEq)]\npub enum Kind {\n    FASTQ,\n    FASTA,\n}\n\n/// Determine whether a [`Read`](Read) is a FastA or FastQ.\n///\n/// This method takes ownership of the [`Read`](Read) and returns a new [`Read`](Read)\n/// with position identical to the position of the input [`Read`](Read).\n/// This allows you to pass the returned [`Read`]#Read) directly into\n/// [`fasta::Reader::new`](fasta::Reader::new) or [`fastq::Reader::new`](fastq::Reader::new).\n///\n/// In general this function is superior to [`get_kind_preserve_read`](get_kind) unless\n/// you would like to do something with the [`Read`](Read) in cases where\n/// there is an error determining the type.\n///\n/// Due to the implementation of the function it is sometimes impossible to return\n///\n/// # Example\n///\n/// ```rust\n/// use bio::io::{fasta, fastq};\n/// use bio::io::fastx::{Kind, get_kind};\n/// use std::io;\n///\n/// fn count_records() -\u003e io::Result\u003cusize\u003e {\n///     let (reader, kind) = get_kind(io::stdin())?;\n///     match kind {\n///         Kind::FASTA =\u003e Ok(fasta::Reader::new(reader).records().count()),\n///         Kind::FASTQ =\u003e Ok(fastq::Reader::new(reader).records().count()),\n///     }\n/// }\n/// ```\npub fn get_kind\u003cR: io::Read\u003e(mut reader: R) -\u003e io::Result\u003c(impl io::Read, Kind)\u003e {\n    let mut buf = [0];\n    reader.read_exact(\u0026mut buf)?;\n    let first = char::from(buf[0]);\n    let new_reader = Box::new(io::Cursor::new(buf).chain(reader));\n\n    match first {\n        '\u003e' =\u003e Ok((new_reader, Kind::FASTA)),\n        '@' =\u003e Ok((new_reader, Kind::FASTQ)),\n        _ =\u003e Err(io::Error::new(\n            io::ErrorKind::InvalidData,\n            format!(\n                \"Data is not a valid FASTA/FASTQ, illegal start character '{}'\",\n                first\n            ),\n        )),\n    }\n}\n\n/// Determine whether a [`Read`](Read) is a FastA or FastQ.\n///\n/// You should only use this function if you would like to use your input [`Read`](Read)\n/// for something else if there is an error determining the data type. Otherwise,\n/// [`get_kind`](get_kind) is preferred.\n///\n/// This function is very similar to [`get_kind`](get_kind) with the\n/// differences being that [`get_kind_preserve_read`](get_kind_preserve_read):\n///\n/// - Returns the [`Read`](Read) in the correct location if there is an\n///   error in determining the data type\n/// - Returns a tuple containing a [`Result`](Result) instead of a\n///   [`Result`](Result), which can be less convenient to work with\n/// - Requires [`Box`](Box) and `dyn`\n///\n/// # Example\n///\n/// ```rust\n/// use bio::io::{fasta, fastq};\n/// use bio::io::fastx::{Kind, get_kind_preserve_read};\n/// use std::io;\n///\n/// fn print_type() -\u003e io::Result\u003c()\u003e {\n///     let (mut reader, kind) = get_kind_preserve_read(Box::new(io::stdin()));\n///     match kind {\n///         Ok(Kind::FASTA) =\u003e println!(\"{}\", Kind::FASTA),\n///         Ok(Kind::FASTQ) =\u003e println!(\"{}\", Kind::FASTQ),\n///         Err(e) =\u003e {\n///             println!(\"Error determining FastA/FastQ: {}\", e);\n///             println!(\"Data:\");\n///             io::copy(\u0026mut reader, \u0026mut io::stdout());\n///         }\n///     }\n///     Ok(())\n/// }\n/// ```\npub fn get_kind_preserve_read(\n    mut reader: Box\u003cdyn io::Read\u003e,\n) -\u003e (Box\u003cdyn io::Read\u003e, io::Result\u003cKind\u003e) {\n    let mut buf = [0];\n    if let Err(e) = reader.read_exact(\u0026mut buf) {\n        return (reader, Err(e));\n    }\n    let first = char::from(buf[0]);\n    let new_reader = Box::new(io::Cursor::new(buf).chain(reader));\n\n    match first {\n        '\u003e' =\u003e (new_reader, Ok(Kind::FASTA)),\n        '@' =\u003e (new_reader, Ok(Kind::FASTQ)),\n        _ =\u003e (\n            new_reader,\n            Err(io::Error::new(\n                io::ErrorKind::InvalidData,\n                format!(\n                    \"Data is not a valid FASTA/FASTQ, illegal start character '{}'\",\n                    first\n                ),\n            )),\n        ),\n    }\n}\n\n/// Determine whether a [`Read`](Read) + [`Seek`](Seek) is a FastA or FastQ.\n///\n/// The benefit of this this function compared to [`get_kind`](get_kind) is that\n/// this function does not take ownership of the [`Read`](Read) so it can\n/// be slightly more convenient to use.\npub fn get_kind_seek\u003cR: io::Read + io::Seek\u003e(reader: \u0026mut R) -\u003e io::Result\u003cKind\u003e {\n    let mut buf = [0];\n    reader.read_exact(\u0026mut buf)?;\n    reader.seek(SeekFrom::Current(-1))?;\n    let first = char::from(buf[0]);\n\n    match first {\n        '\u003e' =\u003e Ok(Kind::FASTA),\n        '@' =\u003e Ok(Kind::FASTQ),\n        _ =\u003e Err(io::Error::new(\n            io::ErrorKind::InvalidData,\n            format!(\n                \"Data is not a valid FASTA/FASTQ, illegal start character '{}'\",\n                first\n            ),\n        )),\n    }\n}\n\n/// Determine whether a file is a FastA or FastQ.\npub fn get_kind_file\u003cP: AsRef\u003cPath\u003e + std::fmt::Debug\u003e(path: P) -\u003e io::Result\u003cKind\u003e {\n    fs::File::open(\u0026path).and_then(|mut f| get_kind_seek(\u0026mut f))\n}\n\nimpl std::fmt::Display for Kind {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"{}\",\n            match self {\n                Kind::FASTA =\u003e \"FastA\",\n                Kind::FASTQ =\u003e \"FastQ\",\n            }\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use std::io::Cursor;\n\n    const FASTA_FILE: \u0026[u8] = b\"\u003eid desc\nACCGTAGGCTGA\nCCGTAGGCTGAA\nCGTAGGCTGAAA\nGTAGGCTGAAAA\nCCCC\n\u003eid2\nATTGTTGTTTTA\nATTGTTGTTTTA\nATTGTTGTTTTA\nGGGG\n\";\n\n    const FASTQ_FILE: \u0026[u8] = b\"@id desc\nACCGTAGGCTGA\n+\nIIIIIIJJJJJJ\n\";\n    #[test]\n    fn records_trait() {\n        fn count_records\u003cR: Record, E, I: Records\u003cR, E\u003e\u003e(records: I) -\u003e usize {\n            records.count()\n        }\n        let records = fasta::Reader::new(FASTA_FILE).records();\n        let count = count_records(records);\n        assert_eq!(count, 2);\n    }\n\n    #[test]\n    fn get_fasta_either_records() {\n        let mut records = EitherRecords::from(FASTA_FILE);\n        assert_eq!(records.next().unwrap().unwrap().id(), \"id\");\n        assert_eq!(records.next().unwrap().unwrap().id(), \"id2\");\n        assert!(records.next().is_none());\n        assert!(records.next().is_none());\n    }\n\n    #[test]\n    fn get_empty_either_records() {\n        let mut records = EitherRecords::from(b\"\".as_ref());\n        assert!(records.next().is_none());\n        // this second check is intentional\n        assert!(records.next().is_none());\n    }\n\n    #[test]\n    fn get_invalid_either_records() {\n        let mut records = EitherRecords::from(b\"(\".as_ref());\n        assert!(records.next().unwrap().is_err());\n        // this second check is intentional\n        assert!(records.next().is_none());\n    }\n\n    #[test]\n    fn test_get_kind_preserve_read_fasta() {\n        let (mut new_read, fastx_kind) = get_kind_preserve_read(Box::new(FASTA_FILE));\n        assert_eq!(Kind::FASTA, fastx_kind.unwrap());\n        let mut buf = [0u8; 1];\n        new_read.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(buf[0], FASTA_FILE[0]);\n    }\n\n    #[test]\n    fn test_get_kind_preserve_read_fastq() {\n        let (mut new_read, fastx_kind) = get_kind_preserve_read(Box::new(FASTQ_FILE));\n        assert_eq!(Kind::FASTQ, fastx_kind.unwrap());\n        let mut buf = [0u8; 1];\n        new_read.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(buf[0], FASTQ_FILE[0]);\n    }\n\n    #[test]\n    fn test_get_kind_preserve_read_empty() {\n        let (_, kind_res) = get_kind_preserve_read(Box::new(Cursor::new(b\"\")));\n        assert_eq!(kind_res.err().unwrap().kind(), io::ErrorKind::UnexpectedEof);\n    }\n\n    #[test]\n    fn test_get_kind_preserve_read_invalid() {\n        let read = Cursor::new(b\"*\");\n        let (mut new_read, res) = get_kind_preserve_read(Box::new(read));\n        assert_eq!(io::ErrorKind::InvalidData, res.err().unwrap().kind());\n        let mut buf = [0u8; 1];\n        new_read.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(b'*', buf[0]);\n    }\n\n    #[test]\n    fn test_get_kind_seek_fasta() {\n        let mut read_seeker = Cursor::new(FASTA_FILE);\n        let fastx_kind = get_kind_seek(\u0026mut read_seeker).unwrap();\n        assert_eq!(Kind::FASTA, fastx_kind);\n        assert_eq!(read_seeker.position(), 0);\n    }\n\n    #[test]\n    fn test_get_kind_seek_fastq() {\n        let mut read_seeker = Cursor::new(FASTQ_FILE);\n        let fastq_kind = get_kind_seek(\u0026mut read_seeker).unwrap();\n        assert_eq!(Kind::FASTQ, fastq_kind);\n        assert_eq!(read_seeker.position(), 0);\n    }\n\n    #[test]\n    fn test_get_kind_seek_empty() {\n        let mut read_seeker = Cursor::new(b\"\");\n        let e = get_kind_seek(\u0026mut read_seeker).unwrap_err();\n        assert_eq!(io::ErrorKind::UnexpectedEof, e.kind());\n    }\n\n    #[test]\n    fn test_get_kind_seek_invalid() {\n        let mut read_seeker = Cursor::new(b\"*\");\n        let e = get_kind_seek(\u0026mut read_seeker).unwrap_err();\n        assert_eq!(io::ErrorKind::InvalidData, e.kind());\n    }\n}\n","traces":[{"line":175,"address":[5280368,5280464,5280512,5280320,5280416],"length":1,"stats":{"Line":1},"fn_name":"is_empty"},{"line":176,"address":[5280473,5280377,5280329,5280521,5280425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[4284656,4285024,4284752,4285136,4285296,4284864],"length":1,"stats":{"Line":1},"fn_name":"is_empty"},{"line":184,"address":[4285007,4285279,4285321,4285281,4285050,4285009,4285162,4284681,4284890,4284778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[4285057,4284785,4284897,4284669,4285038,4285150,4284687,4284766,4284878,4285269,4285169,4285309,4285327,4284997],"length":1,"stats":{"Line":3},"fn_name":null},{"line":186,"address":[4284713,4284928,4285200,4285353,4284816,4285088],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[5276672],"length":1,"stats":{"Line":0},"fn_name":"qual"},{"line":210,"address":[5276681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[5276704],"length":1,"stats":{"Line":0},"fn_name":"kind"},{"line":214,"address":[5276713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[4283056,4284380],"length":1,"stats":{"Line":1},"fn_name":"get_kind_preserve_read"},{"line":508,"address":[4283083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[4283287,4283125],"length":1,"stats":{"Line":3},"fn_name":null},{"line":510,"address":[4283319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[4283476],"length":1,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[4283705,4283508],"length":1,"stats":{"Line":2},"fn_name":null},{"line":515,"address":[4283927,4284378,4284008],"length":1,"stats":{"Line":3},"fn_name":null},{"line":516,"address":[4283861,4283713],"length":1,"stats":{"Line":2},"fn_name":null},{"line":517,"address":[4283942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":518,"address":[4284319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":519,"address":[4283751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[4284179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[4283774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[4284023,4283790,4284120],"length":1,"stats":{"Line":3},"fn_name":null},{"line":536,"address":[4404896,4405696,4406496],"length":1,"stats":{"Line":3},"fn_name":"get_kind_seek\u003cstd::io::cursor::Cursor\u003c\u0026[u8; 1]\u003e\u003e"},{"line":537,"address":[4405734,4406534,4404934],"length":1,"stats":{"Line":3},"fn_name":null},{"line":538,"address":[4405749,4405142,4404949,4406549,4405942,4406742],"length":1,"stats":{"Line":4},"fn_name":null},{"line":539,"address":[4405082,4405192,4405882,4406873,4405992,4406792,4405273,4406073,4406682],"length":1,"stats":{"Line":4},"fn_name":null},{"line":540,"address":[4406849,4405249,4406049],"length":1,"stats":{"Line":2},"fn_name":null},{"line":542,"address":[4407037,4406479,4407284,4405684,4405679,4405437,4407054,4406484,4407279,4405454,4406237,4406254],"length":1,"stats":{"Line":3},"fn_name":null},{"line":543,"address":[4405430,4406931,4406230,4405331,4406131,4407030],"length":1,"stats":{"Line":3},"fn_name":null},{"line":544,"address":[4406247,4405447,4407047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":545,"address":[4405578,4407178,4406378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":546,"address":[4406160,4406960,4405360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":547,"address":[4406168,4405368,4406968,4407069,4406269,4405469],"length":1,"stats":{"Line":2},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[6355808],"length":1,"stats":{"Line":3},"fn_name":"records_trait"},{"line":599,"address":[9180640],"length":1,"stats":{"Line":1},"fn_name":"count_records\u003cbio::io::fasta::Record,std::io::error::Error,bio::io::fasta::Records\u003c\u0026[u8]\u003e\u003e"},{"line":600,"address":[9180647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":602,"address":[6355815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":603,"address":[6355852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":604,"address":[6355998,6355896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":608,"address":[6357123,6356048],"length":1,"stats":{"Line":3},"fn_name":"get_fasta_either_records"},{"line":609,"address":[6356055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":610,"address":[6356090,6356164],"length":1,"stats":{"Line":2},"fn_name":null},{"line":611,"address":[6356475],"length":1,"stats":{"Line":1},"fn_name":null},{"line":612,"address":[6356824,6356948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":613,"address":[6356941,6356989,6357090],"length":1,"stats":{"Line":2},"fn_name":null},{"line":617,"address":[6357152,6357546],"length":1,"stats":{"Line":3},"fn_name":"get_empty_either_records"},{"line":618,"address":[6357159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":619,"address":[6357214,6357283,6357372],"length":1,"stats":{"Line":2},"fn_name":null},{"line":621,"address":[6357513,6357412,6357365],"length":1,"stats":{"Line":2},"fn_name":null},{"line":625,"address":[6358008,6357584],"length":1,"stats":{"Line":3},"fn_name":"get_invalid_either_records"},{"line":626,"address":[6357591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":627,"address":[6357728,6357646,6357834],"length":1,"stats":{"Line":2},"fn_name":null},{"line":629,"address":[6357874,6357827,6357975],"length":1,"stats":{"Line":2},"fn_name":null},{"line":633,"address":[6358770,6358032],"length":1,"stats":{"Line":3},"fn_name":"test_get_kind_preserve_read_fasta"},{"line":634,"address":[6358039,6358120],"length":1,"stats":{"Line":2},"fn_name":null},{"line":635,"address":[6358191,6358462,6358397],"length":1,"stats":{"Line":2},"fn_name":null},{"line":636,"address":[6358403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":637,"address":[6358429,6358518],"length":1,"stats":{"Line":2},"fn_name":null},{"line":638,"address":[6358580,6358694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":642,"address":[6358800,6359538],"length":1,"stats":{"Line":3},"fn_name":"test_get_kind_preserve_read_fastq"},{"line":643,"address":[6358807,6358888],"length":1,"stats":{"Line":2},"fn_name":null},{"line":644,"address":[6359165,6359230,6358959],"length":1,"stats":{"Line":2},"fn_name":null},{"line":645,"address":[6359171],"length":1,"stats":{"Line":1},"fn_name":null},{"line":646,"address":[6359286,6359197],"length":1,"stats":{"Line":2},"fn_name":null},{"line":647,"address":[6359462,6359348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":651,"address":[6360233,6359568],"length":1,"stats":{"Line":3},"fn_name":"test_get_kind_preserve_read_empty"},{"line":652,"address":[6359676,6359575],"length":1,"stats":{"Line":2},"fn_name":null},{"line":653,"address":[6359855,6359739],"length":1,"stats":{"Line":2},"fn_name":null},{"line":657,"address":[6361282,6360272],"length":1,"stats":{"Line":3},"fn_name":"test_get_kind_preserve_read_invalid"},{"line":658,"address":[6360279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":659,"address":[6360396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":660,"address":[6360692,6360482],"length":1,"stats":{"Line":2},"fn_name":null},{"line":661,"address":[6360968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":662,"address":[6360994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":663,"address":[6361203,6361089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":667,"address":[6361312],"length":1,"stats":{"Line":3},"fn_name":"test_get_kind_seek_fasta"},{"line":668,"address":[6361319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":669,"address":[6361341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":670,"address":[6361379,6361486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":671,"address":[6361521,6361623,6361456],"length":1,"stats":{"Line":2},"fn_name":null},{"line":675,"address":[6361680],"length":1,"stats":{"Line":3},"fn_name":"test_get_kind_seek_fastq"},{"line":676,"address":[6361687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":677,"address":[6361709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":678,"address":[6361747,6361854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":679,"address":[6361824,6361991,6361889],"length":1,"stats":{"Line":2},"fn_name":null},{"line":683,"address":[6362351,6362048],"length":1,"stats":{"Line":3},"fn_name":"test_get_kind_seek_empty"},{"line":684,"address":[6362055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":685,"address":[6362077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[6362156,6362286,6362314],"length":1,"stats":{"Line":2},"fn_name":null},{"line":690,"address":[6362687,6362384],"length":1,"stats":{"Line":3},"fn_name":"test_get_kind_seek_invalid"},{"line":691,"address":[6362391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":692,"address":[6362413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":693,"address":[6362492,6362622,6362650],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":115,"coverable":174},{"path":["/","home","todd","rust-bio","src","io","gff.rs"],"content":"// Copyright 2016 Pierre Marijon.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! [GFF3] format reading and writing. [GFF2] is currently not supported.\n//!\n//! [GFF2]: http://gmod.org/wiki/GFF2 (not supported)\n//! [GTF2]: http://mblab.wustl.edu/GTF2.html (not supported)\n//! [GFF3]: http://gmod.org/wiki/GFF3#GFF3_Format\n//!\n//! # Example\n//!\n//! ```\n//! // import functions (at top of script)\n//! use bio::io::gff;\n//! use std::io;\n//! let mut reader = gff::Reader::new(io::stdin(), gff::GffType::GFF3);\n//! let mut writer = gff::Writer::new(vec![], gff::GffType::GFF3);\n//! for record in reader.records() {\n//!     let rec = record.ok().expect(\"Error reading record.\");\n//!     println!(\"{}\", rec.seqname());\n//!     writer.write(\u0026rec).ok().expect(\"Error writing record.\");\n//! }\n//! ```\n\nuse anyhow::Context;\nuse itertools::Itertools;\nuse multimap::MultiMap;\nuse regex::Regex;\nuse std::convert::AsRef;\nuse std::fs;\nuse std::io;\nuse std::path::Path;\nuse std::str::FromStr;\n\nuse bio_types::strand::Strand;\n\n/// `GffType`\n///\n/// We have three format in the GFF family.\n/// The change is in the last field of GFF.\n/// For each type we have key value separator and field separator\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum GffType {\n    /// Attribute format is: key1=value; key2=value1,value2\n    GFF3,\n    /// Attribute format is: key1 value; key2 value1; key2 value2\n    GFF2,\n    /// Same as GFF2 just possible keyword and possible value change\n    GTF2,\n    /// Any, first field of tuple separates key from value,\n    /// second field separates multiple key value pairs, and\n    /// third field separates multiple values for the same key\n    Any(u8, u8, u8),\n}\n\nimpl FromStr for GffType {\n    type Err = String;\n\n    /// Create a GffType from a string.\n    ///\n    /// # Arguments\n    ///\n    /// * `src_str` - The source string to convert to the GffType.\n    fn from_str(src_str: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        match src_str {\n            \"gff3\" =\u003e Ok(GffType::GFF3),\n            \"gff2\" =\u003e Ok(GffType::GFF2),\n            \"gtf2\" =\u003e Ok(GffType::GTF2),\n            _ =\u003e Err(format!(\n                \"String '{}' is not a valid GFFType (GFF/GTF format version).\",\n                src_str\n            )),\n        }\n    }\n}\n\nimpl GffType {\n    #[inline]\n    /// First field is key value separator.\n    /// Second field terminates a key value pair.\n    /// Third field\n    fn separator(self) -\u003e (u8, u8, u8) {\n        match self {\n            GffType::GFF3 =\u003e (b'=', b';', b','),\n            GffType::GFF2 =\u003e (b' ', b';', 0u8),\n            GffType::GTF2 =\u003e (b' ', b';', 0u8),\n            GffType::Any(x, y, z) =\u003e (x, y, z),\n        }\n    }\n}\n\n/// A GFF reader.\n#[derive(Debug)]\npub struct Reader\u003cR: io::Read\u003e {\n    inner: csv::Reader\u003cR\u003e,\n    gff_type: GffType,\n}\n\nimpl Reader\u003cfs::File\u003e {\n    /// Read GFF from given file path in given format.\n    pub fn from_file\u003cP: AsRef\u003cPath\u003e + std::fmt::Debug\u003e(\n        path: P,\n        fileformat: GffType,\n    ) -\u003e anyhow::Result\u003cSelf\u003e {\n        fs::File::open(\u0026path)\n            .map(|f| Reader::new(f, fileformat))\n            .with_context(|| format!(\"Failed to read GFF from {:#?}\", path))\n    }\n}\n\nimpl\u003cR: io::Read\u003e Reader\u003cR\u003e {\n    /// Create a new GFF reader given an instance of `io::Read`, in given format.\n    pub fn new(reader: R, fileformat: GffType) -\u003e Self {\n        Reader {\n            inner: csv::ReaderBuilder::new()\n                .delimiter(b'\\t')\n                .has_headers(false)\n                .comment(Some(b'#'))\n                .from_reader(reader),\n            gff_type: fileformat,\n        }\n    }\n\n    /// Iterate over all records.\n    pub fn records(\u0026mut self) -\u003e Records\u003c'_, R\u003e {\n        let (delim, term, vdelim) = self.gff_type.separator();\n        let r = format!(\n            r\" *(?P\u003ckey\u003e[^{delim}{term}\\t]+){delim}(?P\u003cvalue\u003e[^{delim}{term}\\t]+){term}?\",\n            delim = delim as char,\n            term = term as char\n        );\n        let attribute_re = Regex::new(\u0026r).unwrap();\n        Records {\n            inner: self.inner.deserialize(),\n            attribute_re,\n            value_delim: vdelim as char,\n        }\n    }\n}\n\ntype GffRecordInner = (\n    String,\n    String,\n    String,\n    u64,\n    u64,\n    String,\n    String,\n    String,\n    String,\n);\n\n/// An iterator over the records of a GFF file.\npub struct Records\u003c'a, R: io::Read\u003e {\n    inner: csv::DeserializeRecordsIter\u003c'a, R, GffRecordInner\u003e,\n    attribute_re: Regex,\n    value_delim: char,\n}\n\nimpl\u003c'a, R: io::Read\u003e Iterator for Records\u003c'a, R\u003e {\n    type Item = csv::Result\u003cRecord\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003ccsv::Result\u003cRecord\u003e\u003e {\n        self.inner.next().map(|res| {\n            res.map(\n                |(\n                    seqname,\n                    source,\n                    feature_type,\n                    start,\n                    end,\n                    score,\n                    strand,\n                    frame,\n                    raw_attributes,\n                )| {\n                    let trim_quotes = |s: \u0026str| s.trim_matches('\\'').trim_matches('\"').to_owned();\n                    let mut attributes = MultiMap::new();\n                    for caps in self.attribute_re.captures_iter(\u0026raw_attributes) {\n                        for value in caps[\"value\"].split(self.value_delim) {\n                            attributes.insert(trim_quotes(\u0026caps[\"key\"]), trim_quotes(value));\n                        }\n                    }\n                    Record {\n                        seqname,\n                        source,\n                        feature_type,\n                        start,\n                        end,\n                        score,\n                        strand,\n                        frame,\n                        attributes,\n                    }\n                },\n            )\n        })\n    }\n}\n\n/// A GFF writer.\n#[derive(Debug)]\npub struct Writer\u003cW: io::Write\u003e {\n    inner: csv::Writer\u003cW\u003e,\n    delimiter: char,\n    terminator: String,\n}\n\nimpl Writer\u003cfs::File\u003e {\n    /// Write to a given file path in given format.\n    #[allow(clippy::wrong_self_convention)]\n    pub fn to_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P, fileformat: GffType) -\u003e io::Result\u003cSelf\u003e {\n        fs::File::create(path).map(|f| Writer::new(f, fileformat))\n    }\n}\n\nimpl\u003cW: io::Write\u003e Writer\u003cW\u003e {\n    /// Write to a given writer.\n    pub fn new(writer: W, fileformat: GffType) -\u003e Self {\n        let (delim, termi, _) = fileformat.separator();\n\n        Writer {\n            inner: csv::WriterBuilder::new()\n                .delimiter(b'\\t')\n                .flexible(true)\n                .from_writer(writer),\n            delimiter: delim as char,\n            terminator: String::from_utf8(vec![termi]).unwrap(),\n        }\n    }\n\n    /// Write a given GFF record.\n    pub fn write(\u0026mut self, record: \u0026Record) -\u003e csv::Result\u003c()\u003e {\n        let attributes = if !record.attributes.is_empty() {\n            record\n                .attributes\n                .iter()\n                .map(|(a, b)| format!(\"{}{}{}\", a, self.delimiter, b))\n                .join(\u0026self.terminator)\n        } else {\n            \"\".to_owned()\n        };\n\n        self.inner.serialize((\n            \u0026record.seqname,\n            \u0026record.source,\n            \u0026record.feature_type,\n            record.start,\n            record.end,\n            \u0026record.score,\n            \u0026record.strand,\n            \u0026record.frame,\n            attributes,\n        ))\n    }\n}\n\n/// A GFF record\n#[derive(Debug, Default, Serialize, Deserialize, Clone)]\npub struct Record {\n    seqname: String,\n    source: String,\n    feature_type: String,\n    start: u64,\n    end: u64,\n    score: String,\n    strand: String,\n    frame: String,\n    attributes: MultiMap\u003cString, String\u003e,\n}\n\nimpl Record {\n    /// Create a new GFF record.\n    pub fn new() -\u003e Self {\n        Record {\n            seqname: \"\".to_owned(),\n            source: \"\".to_owned(),\n            feature_type: \"\".to_owned(),\n            start: 0,\n            end: 0,\n            score: \".\".to_owned(),\n            strand: \".\".to_owned(),\n            frame: \"\".to_owned(),\n            attributes: MultiMap::\u003cString, String\u003e::new(),\n        }\n    }\n\n    /// Sequence name of the feature.\n    pub fn seqname(\u0026self) -\u003e \u0026str {\n        \u0026self.seqname\n    }\n\n    /// Source of the feature.\n    pub fn source(\u0026self) -\u003e \u0026str {\n        \u0026self.source\n    }\n\n    /// Type of the feature.\n    pub fn feature_type(\u0026self) -\u003e \u0026str {\n        \u0026self.feature_type\n    }\n\n    /// Start position of feature (1-based).\n    pub fn start(\u0026self) -\u003e \u0026u64 {\n        \u0026self.start\n    }\n\n    /// End position of feature (1-based, not included).\n    pub fn end(\u0026self) -\u003e \u0026u64 {\n        \u0026self.end\n    }\n\n    /// Score of feature\n    pub fn score(\u0026self) -\u003e Option\u003cu64\u003e {\n        match self.score.as_ref() {\n            \".\" =\u003e None,\n            _ =\u003e self.score.parse::\u003cu64\u003e().ok(),\n        }\n    }\n\n    /// Strand of the feature.\n    pub fn strand(\u0026self) -\u003e Option\u003cStrand\u003e {\n        match self.strand.as_ref() {\n            \"+\" =\u003e Some(Strand::Forward),\n            \"-\" =\u003e Some(Strand::Reverse),\n            _ =\u003e None,\n        }\n    }\n\n    /// Frame of the feature.\n    pub fn frame(\u0026self) -\u003e \u0026str {\n        \u0026self.frame\n    }\n\n    /// Attribute of feature\n    pub fn attributes(\u0026self) -\u003e \u0026MultiMap\u003cString, String\u003e {\n        \u0026self.attributes\n    }\n\n    /// Get mutable reference on seqname of feature.\n    pub fn seqname_mut(\u0026mut self) -\u003e \u0026mut String {\n        \u0026mut self.seqname\n    }\n\n    /// Get mutable reference on source of feature.\n    pub fn source_mut(\u0026mut self) -\u003e \u0026mut String {\n        \u0026mut self.source\n    }\n\n    /// Get mutable reference on type of feature.\n    pub fn feature_type_mut(\u0026mut self) -\u003e \u0026mut String {\n        \u0026mut self.feature_type\n    }\n\n    /// Get mutable reference on start of feature.\n    pub fn start_mut(\u0026mut self) -\u003e \u0026mut u64 {\n        \u0026mut self.start\n    }\n\n    /// Get mutable reference on end of feature.\n    pub fn end_mut(\u0026mut self) -\u003e \u0026mut u64 {\n        \u0026mut self.end\n    }\n\n    /// Get mutable reference on score of feature.\n    pub fn score_mut(\u0026mut self) -\u003e \u0026mut String {\n        \u0026mut self.score\n    }\n\n    /// Get mutable reference on strand of feature.\n    pub fn strand_mut(\u0026mut self) -\u003e \u0026mut String {\n        \u0026mut self.strand\n    }\n\n    /// Get mutable reference on frame of feature.\n    pub fn frame_mut(\u0026mut self) -\u003e \u0026mut String {\n        \u0026mut self.frame\n    }\n\n    /// Get mutable reference on attributes of feature.\n    pub fn attributes_mut(\u0026mut self) -\u003e \u0026mut MultiMap\u003cString, String\u003e {\n        \u0026mut self.attributes\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bio_types::strand::Strand;\n    use multimap::MultiMap;\n\n    const GFF_FILE: \u0026[u8] = b\"P0A7B8\\tUniProtKB\\tInitiator methionine\\t1\\t1\\t.\\t.\\t.\\t\\\nNote=Removed,Obsolete;ID=test\nP0A7B8\\tUniProtKB\\tChain\\t2\\t176\\t50\\t+\\t.\\tNote=ATP-dependent protease subunit HslV;\\\nID=PRO_0000148105\";\n    const GFF_FILE_WITH_COMMENT: \u0026[u8] = b\"#comment\nP0A7B8\\tUniProtKB\\tInitiator methionine\\t1\\t1\\t.\\t.\\t.\\t\\\nNote=Removed,Obsolete;ID=test\n#comment\nP0A7B8\\tUniProtKB\\tChain\\t2\\t176\\t50\\t+\\t.\\tNote=ATP-dependent protease subunit HslV;\\\nID=PRO_0000148105\";\n    //required because MultiMap iter on element randomly\n    const GFF_FILE_ONE_ATTRIB: \u0026[u8] =\n        b\"P0A7B8\\tUniProtKB\\tInitiator methionine\\t1\\t1\\t.\\t.\\t.\\tNote=Removed\nP0A7B8\\tUniProtKB\\tChain\\t2\\t176\\t50\\t+\\t.\\tID=PRO_0000148105\n\";\n\n    const GTF_FILE: \u0026[u8] =\n        b\"P0A7B8\\tUniProtKB\\tInitiator methionine\\t1\\t1\\t.\\t.\\t.\\tNote Removed;ID test\nP0A7B8\\tUniProtKB\\tChain\\t2\\t176\\t50\\t+\\t.\\tNote ATP-dependent;ID PRO_0000148105\n\";\n\n    // Another variant of GTF file, modified from a published GENCODE GTF file.\n    const GTF_FILE_2: \u0026[u8] = b\"chr1\\tHAVANA\\tgene\\t11869\\t14409\\t.\\t+\\t.\\t\\\ngene_id \\\"ENSG00000223972.5\\\"; gene_type \\\"transcribed_unprocessed_pseudogene\\\";\nchr1\\tHAVANA\\ttranscript\\t11869\\t14409\\t.\\t+\\t.\\tgene_id \\\"ENSG00000223972.5\\\";\\\ntranscript_id \\\"ENST00000456328.2\\\"; gene_type \\\"transcribed_unprocessed_pseudogene\\\"\";\n\n    // GTF file with duplicate attribute keys, taken from a published GENCODE GTF file.\n    const GTF_FILE_DUP_ATTR_KEYS: \u0026[u8] = b\"chr1\\tENSEMBL\\ttranscript\\t182393\\t\\\n184158\\t.\\t+\\t.\\tgene_id \\\"ENSG00000279928.1\\\"; transcript_id \\\"ENST00000624431.1\\\";\\\ngene_type \\\"protein_coding\\\"; gene_status \\\"KNOWN\\\"; gene_name \\\"FO538757.2\\\";\\\ntranscript_type \\\"protein_coding\\\"; transcript_status \\\"KNOWN\\\";\\\ntranscript_name \\\"FO538757.2-201\\\"; level 3; protein_id \\\"ENSP00000485457.1\\\";\\\ntranscript_support_level \\\"1\\\"; tag \\\"basic\\\"; tag \\\"appris_principal_1\\\";\";\n\n    //required because MultiMap iter on element randomly\n    const GTF_FILE_ONE_ATTRIB: \u0026[u8] =\n        b\"P0A7B8\\tUniProtKB\\tInitiator methionine\\t1\\t1\\t.\\t.\\t.\\tNote Removed\nP0A7B8\\tUniProtKB\\tChain\\t2\\t176\\t50\\t+\\t.\\tID PRO_0000148105\n\";\n\n    #[test]\n    fn test_reader_gff3() {\n        let seqname = [\"P0A7B8\", \"P0A7B8\"];\n        let source = [\"UniProtKB\", \"UniProtKB\"];\n        let feature_type = [\"Initiator methionine\", \"Chain\"];\n        let starts = [1, 2];\n        let ends = [1, 176];\n        let scores = [None, Some(50)];\n        let strand = [None, Some(Strand::Forward)];\n        let frame = [\".\", \".\"];\n        let mut attributes = [MultiMap::new(), MultiMap::new()];\n        attributes[0].insert(\"ID\".to_owned(), \"test\".to_owned());\n        attributes[0].insert(\"Note\".to_owned(), \"Removed\".to_owned());\n        attributes[0].insert(\"Note\".to_owned(), \"Obsolete\".to_owned());\n        attributes[1].insert(\"ID\".to_owned(), \"PRO_0000148105\".to_owned());\n        attributes[1].insert(\n            \"Note\".to_owned(),\n            \"ATP-dependent protease subunit HslV\".to_owned(),\n        );\n\n        let mut reader = Reader::new(GFF_FILE, GffType::GFF3);\n        for (i, r) in reader.records().enumerate() {\n            let record = r.unwrap();\n            assert_eq!(record.seqname(), seqname[i]);\n            assert_eq!(record.source(), source[i]);\n            assert_eq!(record.feature_type(), feature_type[i]);\n            assert_eq!(*record.start(), starts[i]);\n            assert_eq!(*record.end(), ends[i]);\n            assert_eq!(record.score(), scores[i]);\n            assert_eq!(record.strand(), strand[i]);\n            assert_eq!(record.frame(), frame[i]);\n            assert_eq!(record.attributes(), \u0026attributes[i]);\n        }\n\n        let mut reader = Reader::new(GFF_FILE_WITH_COMMENT, GffType::GFF3);\n        for (i, r) in reader.records().enumerate() {\n            let record = r.unwrap();\n            assert_eq!(record.seqname(), seqname[i]);\n            assert_eq!(record.source(), source[i]);\n            assert_eq!(record.feature_type(), feature_type[i]);\n            assert_eq!(*record.start(), starts[i]);\n            assert_eq!(*record.end(), ends[i]);\n            assert_eq!(record.score(), scores[i]);\n            assert_eq!(record.strand(), strand[i]);\n            assert_eq!(record.frame(), frame[i]);\n            assert_eq!(record.attributes(), \u0026attributes[i]);\n        }\n    }\n\n    #[test]\n    fn test_reader_from_file_path_doesnt_exist_returns_err() {\n        let path = Path::new(\"/I/dont/exist.gff\");\n        let error = Reader::from_file(path, GffType::GFF3)\n            .unwrap_err()\n            .downcast::\u003cString\u003e()\n            .unwrap();\n\n        assert_eq!(\u0026error, \"Failed to read GFF from \\\"/I/dont/exist.gff\\\"\")\n    }\n\n    #[test]\n    fn test_gff_type_from_str() {\n        let gff3 = GffType::from_str(\"gff3\").expect(\"Error parsing\");\n        assert_eq!(gff3, GffType::GFF3);\n\n        let gff2 = GffType::from_str(\"gff2\").expect(\"Error parsing\");\n        assert_eq!(gff2, GffType::GFF2);\n\n        let gtf2 = GffType::from_str(\"gtf2\").expect(\"Error parsing\");\n        assert_eq!(gtf2, GffType::GTF2);\n\n        let unk = GffType::from_str(\"unknown\").unwrap_err();\n        assert_eq!(\n            unk,\n            \"String 'unknown' is not a valid GFFType (GFF/GTF format version).\"\n        )\n    }\n\n    #[test]\n    fn test_reader_gtf2() {\n        let seqname = [\"P0A7B8\", \"P0A7B8\"];\n        let source = [\"UniProtKB\", \"UniProtKB\"];\n        let feature_type = [\"Initiator methionine\", \"Chain\"];\n        let starts = [1, 2];\n        let ends = [1, 176];\n        let scores = [None, Some(50)];\n        let strand = [None, Some(Strand::Forward)];\n        let frame = [\".\", \".\"];\n        let mut attributes = [MultiMap::new(), MultiMap::new()];\n        attributes[0].insert(\"ID\".to_owned(), \"test\".to_owned());\n        attributes[0].insert(\"Note\".to_owned(), \"Removed\".to_owned());\n        attributes[1].insert(\"ID\".to_owned(), \"PRO_0000148105\".to_owned());\n        attributes[1].insert(\"Note\".to_owned(), \"ATP-dependent\".to_owned());\n\n        let mut reader = Reader::new(GTF_FILE, GffType::GTF2);\n        for (i, r) in reader.records().enumerate() {\n            let record = r.unwrap();\n            assert_eq!(record.seqname(), seqname[i]);\n            assert_eq!(record.source(), source[i]);\n            assert_eq!(record.feature_type(), feature_type[i]);\n            assert_eq!(*record.start(), starts[i]);\n            assert_eq!(*record.end(), ends[i]);\n            assert_eq!(record.score(), scores[i]);\n            assert_eq!(record.strand(), strand[i]);\n            assert_eq!(record.frame(), frame[i]);\n            assert_eq!(record.attributes(), \u0026attributes[i]);\n        }\n    }\n\n    #[test]\n    fn test_reader_gtf2_2() {\n        let seqname = [\"chr1\", \"chr1\"];\n        let source = [\"HAVANA\", \"HAVANA\"];\n        let feature_type = [\"gene\", \"transcript\"];\n        let starts = [11869, 11869];\n        let ends = [14409, 14409];\n        let scores = [None, None];\n        let strand = [Some(Strand::Forward), Some(Strand::Forward)];\n        let frame = [\".\", \".\"];\n        let mut attributes = [MultiMap::new(), MultiMap::new()];\n        attributes[0].insert(\"gene_id\".to_owned(), \"ENSG00000223972.5\".to_owned());\n        attributes[0].insert(\n            \"gene_type\".to_owned(),\n            \"transcribed_unprocessed_pseudogene\".to_owned(),\n        );\n        attributes[1].insert(\"gene_id\".to_owned(), \"ENSG00000223972.5\".to_owned());\n        attributes[1].insert(\"transcript_id\".to_owned(), \"ENST00000456328.2\".to_owned());\n        attributes[1].insert(\n            \"gene_type\".to_owned(),\n            \"transcribed_unprocessed_pseudogene\".to_owned(),\n        );\n\n        let mut reader = Reader::new(GTF_FILE_2, GffType::GTF2);\n        for (i, r) in reader.records().enumerate() {\n            let record = r.unwrap();\n            assert_eq!(record.seqname(), seqname[i]);\n            assert_eq!(record.source(), source[i]);\n            assert_eq!(record.feature_type(), feature_type[i]);\n            assert_eq!(*record.start(), starts[i]);\n            assert_eq!(*record.end(), ends[i]);\n            assert_eq!(record.score(), scores[i]);\n            assert_eq!(record.strand(), strand[i]);\n            assert_eq!(record.frame(), frame[i]);\n            assert_eq!(record.attributes(), \u0026attributes[i]);\n        }\n    }\n\n    #[test]\n    fn test_reader_gtf2_dup_attr_keys() {\n        let mut reader = Reader::new(GTF_FILE_DUP_ATTR_KEYS, GffType::GTF2);\n        let mut records = reader.records().collect::\u003cVec\u003c_\u003e\u003e();\n        assert_eq!(records.len(), 1);\n        let record = records.pop().unwrap().expect(\"expected one record\");\n        assert_eq!(record.attributes.get(\"tag\"), Some(\u0026\"basic\".to_owned()));\n        assert_eq!(\n            record.attributes.get_vec(\"tag\"),\n            Some(\u0026vec![\"basic\".to_owned(), \"appris_principal_1\".to_owned()])\n        );\n    }\n\n    #[test]\n    fn test_writer_gff3() {\n        let mut reader = Reader::new(GFF_FILE_ONE_ATTRIB, GffType::GFF3);\n        let mut writer = Writer::new(vec![], GffType::GFF3);\n        for r in reader.records() {\n            writer\n                .write(\u0026r.expect(\"Error reading record\"))\n                .expect(\"Error writing record\");\n        }\n        assert_eq!(writer.inner.into_inner().unwrap(), GFF_FILE_ONE_ATTRIB)\n    }\n\n    #[test]\n    fn test_writer_gtf2() {\n        let mut reader = Reader::new(GTF_FILE_ONE_ATTRIB, GffType::GTF2);\n        let mut writer = Writer::new(vec![], GffType::GTF2);\n        for r in reader.records() {\n            writer\n                .write(\u0026r.expect(\"Error reading record\"))\n                .expect(\"Error writing record\");\n        }\n        assert_eq!(writer.inner.into_inner().unwrap(), GTF_FILE_ONE_ATTRIB)\n    }\n\n    #[test]\n    fn test_convert_gtf2_to_gff3() {\n        let mut reader = Reader::new(GTF_FILE_ONE_ATTRIB, GffType::GTF2);\n        let mut writer = Writer::new(vec![], GffType::GFF3);\n        for r in reader.records() {\n            writer\n                .write(\u0026r.expect(\"Error reading record\"))\n                .expect(\"Error writing record\");\n        }\n        assert_eq!(writer.inner.into_inner().unwrap(), GFF_FILE_ONE_ATTRIB)\n    }\n\n    #[test]\n    fn test_unknown_gff_type() {\n        assert_eq!(\n            GffType::from_str(\"xtf9\"),\n            Err(\"String 'xtf9' is not a valid GFFType (GFF/GTF format version).\".to_string())\n        )\n    }\n}\n","traces":[{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[9181045,9181040],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":437,"address":[9438237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":438,"address":[9438347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[9438401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":440,"address":[9438455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":441,"address":[9438479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[9438503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":443,"address":[9438603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":444,"address":[9438647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":445,"address":[9438701,9438868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[9439000,9439116,9438841,9438920],"length":1,"stats":{"Line":3},"fn_name":null},{"line":447,"address":[9439297,9439089,9439135],"length":1,"stats":{"Line":2},"fn_name":null},{"line":448,"address":[9439316,9439478,9439270],"length":1,"stats":{"Line":2},"fn_name":null},{"line":449,"address":[9439659,9439435,9439497],"length":1,"stats":{"Line":2},"fn_name":null},{"line":450,"address":[9439616,9439721],"length":1,"stats":{"Line":2},"fn_name":null},{"line":451,"address":[9439632,9439678],"length":1,"stats":{"Line":2},"fn_name":null},{"line":452,"address":[9439686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":455,"address":[9439797],"length":1,"stats":{"Line":1},"fn_name":null},{"line":456,"address":[9440081,9439960,9440161,9439874,9443119],"length":1,"stats":{"Line":4},"fn_name":null},{"line":457,"address":[9440366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[9440406,9440539,9440742],"length":1,"stats":{"Line":2},"fn_name":null},{"line":459,"address":[9440810,9440697,9441051],"length":1,"stats":{"Line":2},"fn_name":null},{"line":460,"address":[9441352,9441122,9441006],"length":1,"stats":{"Line":2},"fn_name":null},{"line":461,"address":[9441318,9441407,9441608],"length":1,"stats":{"Line":2},"fn_name":null},{"line":462,"address":[9441880,9441668,9441574],"length":1,"stats":{"Line":2},"fn_name":null},{"line":463,"address":[9442184,9441835,9441956],"length":1,"stats":{"Line":2},"fn_name":null},{"line":464,"address":[9442152,9442246,9442470],"length":1,"stats":{"Line":2},"fn_name":null},{"line":465,"address":[9442425,9442771,9442541],"length":1,"stats":{"Line":2},"fn_name":null},{"line":466,"address":[9442737,9442834,9443064],"length":1,"stats":{"Line":2},"fn_name":null},{"line":469,"address":[9443161],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[9443219,9443305,9443426,9443506,9446361],"length":1,"stats":{"Line":4},"fn_name":null},{"line":471,"address":[9443711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[9444088,9443751,9443884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":473,"address":[9444043,9444159,9444400],"length":1,"stats":{"Line":2},"fn_name":null},{"line":474,"address":[9444701,9444355,9444471],"length":1,"stats":{"Line":2},"fn_name":null},{"line":475,"address":[9444957,9444756,9444667],"length":1,"stats":{"Line":2},"fn_name":null},{"line":476,"address":[9445017,9445226,9444923],"length":1,"stats":{"Line":2},"fn_name":null},{"line":477,"address":[9445299,9445506,9445184],"length":1,"stats":{"Line":2},"fn_name":null},{"line":478,"address":[9445765,9445483,9445565],"length":1,"stats":{"Line":2},"fn_name":null},{"line":479,"address":[9445732,9446039,9445830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":480,"address":[9446306,9446014,9446099],"length":1,"stats":{"Line":2},"fn_name":null},{"line":485,"address":[9181077,9181072],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":486,"address":[9446471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[9446524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":492,"address":[9446777,9446613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":496,"address":[9181109,9181104],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":497,"address":[9446855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":498,"address":[9446924,9447050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[9447013,9447094],"length":1,"stats":{"Line":2},"fn_name":null},{"line":501,"address":[9447276,9447147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[9447320,9447239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":504,"address":[9447373,9447502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":506,"address":[9447465,9447546],"length":1,"stats":{"Line":2},"fn_name":null},{"line":507,"address":[9447582,9447734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":514,"address":[9181141,9181136],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":515,"address":[9447815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":516,"address":[9447909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[9447963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":518,"address":[9448017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":519,"address":[9448041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[9448065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[9448165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[9448209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":523,"address":[9448263,9448430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[9448403,9448562,9448482,9448678],"length":1,"stats":{"Line":3},"fn_name":null},{"line":525,"address":[9448651,9448697,9448859],"length":1,"stats":{"Line":2},"fn_name":null},{"line":526,"address":[9448878,9448816,9449040],"length":1,"stats":{"Line":2},"fn_name":null},{"line":527,"address":[9449220,9448997,9449059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":529,"address":[9449178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":530,"address":[9449462,9452401,9449341,9449542,9449255],"length":1,"stats":{"Line":4},"fn_name":null},{"line":531,"address":[9449747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":532,"address":[9449920,9449787,9450123],"length":1,"stats":{"Line":2},"fn_name":null},{"line":533,"address":[9450191,9450078,9450432],"length":1,"stats":{"Line":2},"fn_name":null},{"line":534,"address":[9450387,9450733,9450503],"length":1,"stats":{"Line":2},"fn_name":null},{"line":535,"address":[9450989,9450699,9450788],"length":1,"stats":{"Line":2},"fn_name":null},{"line":536,"address":[9451261,9450955,9451049],"length":1,"stats":{"Line":2},"fn_name":null},{"line":537,"address":[9451216,9451544,9451337],"length":1,"stats":{"Line":2},"fn_name":null},{"line":538,"address":[9451521,9451603,9451803],"length":1,"stats":{"Line":2},"fn_name":null},{"line":539,"address":[9451868,9452077,9451770],"length":1,"stats":{"Line":2},"fn_name":null},{"line":540,"address":[9452052,9452137,9452346],"length":1,"stats":{"Line":2},"fn_name":null},{"line":545,"address":[9181168,9181173],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":546,"address":[9452487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":547,"address":[9452589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":548,"address":[9452643],"length":1,"stats":{"Line":1},"fn_name":null},{"line":549,"address":[9452697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":550,"address":[9452721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":551,"address":[9452745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[9452833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":553,"address":[9452877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":554,"address":[9452931,9453098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":555,"address":[9453230,9453346,9453071,9453150],"length":1,"stats":{"Line":3},"fn_name":null},{"line":556,"address":[9453408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":557,"address":[9453319,9453365],"length":1,"stats":{"Line":2},"fn_name":null},{"line":558,"address":[9453373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[9453484,9453708,9453546],"length":1,"stats":{"Line":2},"fn_name":null},{"line":561,"address":[9453889,9453665,9453727],"length":1,"stats":{"Line":2},"fn_name":null},{"line":562,"address":[9453846,9453951],"length":1,"stats":{"Line":2},"fn_name":null},{"line":563,"address":[9453862,9453908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":564,"address":[9453916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":567,"address":[9454027],"length":1,"stats":{"Line":1},"fn_name":null},{"line":568,"address":[9454104,9454190,9454311,9454391,9457242],"length":1,"stats":{"Line":4},"fn_name":null},{"line":569,"address":[9454596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":570,"address":[9454972,9454636,9454769],"length":1,"stats":{"Line":2},"fn_name":null},{"line":571,"address":[9455281,9455040,9454927],"length":1,"stats":{"Line":2},"fn_name":null},{"line":572,"address":[9455352,9455236,9455582],"length":1,"stats":{"Line":2},"fn_name":null},{"line":573,"address":[9455548,9455838,9455637],"length":1,"stats":{"Line":2},"fn_name":null},{"line":574,"address":[9455804,9456107,9455898],"length":1,"stats":{"Line":2},"fn_name":null},{"line":575,"address":[9456065,9456180,9456387],"length":1,"stats":{"Line":2},"fn_name":null},{"line":576,"address":[9456364,9456646,9456446],"length":1,"stats":{"Line":2},"fn_name":null},{"line":577,"address":[9456711,9456613,9456920],"length":1,"stats":{"Line":2},"fn_name":null},{"line":578,"address":[9456895,9457187,9456980],"length":1,"stats":{"Line":2},"fn_name":null},{"line":583,"address":[9181205,9181200],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":584,"address":[9457335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":585,"address":[9457385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":586,"address":[9457460,9457649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":587,"address":[9457700,9457632],"length":1,"stats":{"Line":2},"fn_name":null},{"line":588,"address":[9457772,9457895],"length":1,"stats":{"Line":2},"fn_name":null},{"line":589,"address":[9458415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":590,"address":[9458119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":591,"address":[9458177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":596,"address":[9181232,9181237],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":597,"address":[9458695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":598,"address":[9458748,9458842],"length":1,"stats":{"Line":2},"fn_name":null},{"line":599,"address":[9458863,9458934,9459421,9459048,9459119],"length":1,"stats":{"Line":4},"fn_name":null},{"line":600,"address":[9459312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":601,"address":[9459255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":604,"address":[9459697,9459778,9459459],"length":1,"stats":{"Line":2},"fn_name":null},{"line":608,"address":[9181264,9181269],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":609,"address":[9459959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":610,"address":[9460106,9460012],"length":1,"stats":{"Line":2},"fn_name":null},{"line":611,"address":[9460685,9460312,9460198,9460127,9460383],"length":1,"stats":{"Line":4},"fn_name":null},{"line":612,"address":[9460576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":613,"address":[9460519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":616,"address":[9460723,9460961,9461042],"length":1,"stats":{"Line":2},"fn_name":null},{"line":620,"address":[9181296,9181301],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":621,"address":[9461223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":622,"address":[9461370,9461276],"length":1,"stats":{"Line":2},"fn_name":null},{"line":623,"address":[9461391,9461462,9461647,9461949,9461576],"length":1,"stats":{"Line":4},"fn_name":null},{"line":624,"address":[9461840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":625,"address":[9461783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":628,"address":[9462225,9462306,9461987],"length":1,"stats":{"Line":2},"fn_name":null},{"line":632,"address":[9181328,9181333],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":633,"address":[9462730,9462563,9462667],"length":1,"stats":{"Line":2},"fn_name":null},{"line":634,"address":[9462487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":635,"address":[9462509],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":238,"coverable":275},{"path":["/","home","todd","rust-bio","src","io","mod.rs"],"content":"//! Readers and writers for common bioinformatics file formats.\n\npub mod bed;\npub mod fasta;\npub mod fastq;\npub mod fastx;\npub mod gff;\n#[cfg(feature = \"phylogeny\")]\npub mod newick;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","io","newick.rs"],"content":"// Copyright 2020 Franklin Delehelle.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A struct to read phylogenetic trees in the Newick format.\n//!\n//!  # Example\n//!\n//!  In this example, we parse a tree from a string and display all the taxons.\n//!  See `petgraph` documentation for more details on how to handle the tree.\n//!\n//!  ```\n//!  use bio::io::newick;\n//!\n//!  let tree = newick::from_string(\"(A:0.1,B:0.2,(C:0.3,D:0.4)E:0.5)F;\").unwrap();\n//!  for taxon in tree.raw_nodes() {\n//!      println!(\"{}\", taxon.weight);\n//!  }\n//!  ```\n\nuse bio_types::phylogeny::{Tree, TreeGraph};\nuse pest::iterators::Pair;\nuse pest::Parser;\nuse petgraph::graph::NodeIndex;\nuse std::fs;\nuse std::io;\nuse std::path::{Path, PathBuf};\nuse thiserror::Error;\n\n/// A `thiserror` error type gathering all the potential bad outcomes\n#[derive(Debug, Error)]\npub enum Error {\n    #[error(\"Error while opening {}: {}\", filename.display(), source)]\n    OpenFile {\n        filename: PathBuf,\n        source: std::io::Error,\n    },\n\n    #[error(\"Error while reading tree: {0}\")]\n    Read(#[from] std::io::Error),\n\n    #[error(\"Tree contains invalid UTF-8: {0}\")]\n    InvalidContent(#[from] std::str::Utf8Error),\n\n    #[error(\"Error while parsing tree: {0}\")]\n    ParsingError(#[from] pest::error::Error\u003ccrate::io::newick::Rule\u003e),\n}\ntype Result\u003cT, E = Error\u003e = std::result::Result\u003cT, E\u003e;\n\n/// The parser is automagically derived from the `newick.pest` grammar\n/// file\n#[derive(Parser)]\n#[grammar = \"io/newick.pest\"]\npub struct NewickParser;\n\n/// A hidden, temporary datatype used to collect the parser result\n/// before converting it to a `Tree`\nenum TreeValue {\n    Node {\n        name: Option\u003cString\u003e,\n        children: Option\u003cVec\u003cTreeValue\u003e\u003e,\n    },\n    Link {\n        weight: f32,\n        node: Box\u003cTreeValue\u003e,\n    },\n}\n\n/// Given a string representing a Newick tree, tries to parse it and\n/// returns the `TreeValue` of the root\nfn parse_newick_file(content: \u0026str) -\u003e Result\u003cTreeValue\u003e {\n    fn parse_value(pair: Pair\u003cRule\u003e) -\u003e TreeValue {\n        match pair.as_rule() {\n            Rule::Leaf =\u003e {\n                let name = pair.into_inner().next().unwrap().as_str();\n                TreeValue::Node {\n                    name: Some(name.into()),\n                    children: None,\n                }\n            }\n            Rule::Internal =\u003e {\n                let mut inner_rules = pair.into_inner();\n                let children = Some(\n                    inner_rules\n                        .next()\n                        .unwrap()\n                        .into_inner()\n                        .map(parse_value)\n                        .collect(),\n                );\n                let name = if let Some(clade) = inner_rules.next() {\n                    Some(clade.as_str().into())\n                } else {\n                    None\n                };\n                TreeValue::Node { children, name }\n            }\n\n            Rule::Branch =\u003e {\n                fn get_weight(mut inner: pest::iterators::Pairs\u003cRule\u003e) -\u003e f32 {\n                    if let Some(weight) = inner.next() {\n                        weight.as_str().parse::\u003cf32\u003e().unwrap()\n                    } else {\n                        f32::NAN\n                    }\n                }\n\n                let mut inner = pair.into_inner();\n                let (node, weight) = if let Some(next) = inner.next() {\n                    match next.as_rule() {\n                        Rule::SubTree =\u003e (parse_value(next), get_weight(inner)),\n                        _ =\u003e (\n                            TreeValue::Node {\n                                name: None,\n                                children: None,\n                            },\n                            next.as_str().parse::\u003cf32\u003e().unwrap(),\n                        ),\n                    }\n                } else {\n                    (\n                        TreeValue::Node {\n                            name: None,\n                            children: None,\n                        },\n                        get_weight(inner),\n                    )\n                };\n\n                TreeValue::Link {\n                    weight,\n                    node: Box::new(node),\n                }\n            }\n\n            Rule::SubTree =\u003e parse_value(pair.into_inner().next().unwrap()),\n            Rule::EOI\n            | Rule::WHITESPACE\n            | Rule::Tree\n            | Rule::Length\n            | Rule::BranchSet\n            | Rule::float\n            | Rule::safe\n            | Rule::name =\u003e unreachable!(),\n        }\n    }\n\n    let root = NewickParser::parse(Rule::Tree, \u0026content)\n        .map_err(Error::ParsingError)?\n        .next()\n        .unwrap();\n\n    Ok(parse_value(root))\n}\n\n/// Convert an intermediary `TreeValue` to the public `Tree` type\nfn newick_to_graph(root: TreeValue) -\u003e Result\u003cTree\u003e {\n    fn add_node(g: \u0026mut TreeGraph, t: TreeValue) -\u003e NodeIndex {\n        match t {\n            TreeValue::Node { name, children } =\u003e {\n                let node_id = g.add_node(name.unwrap_or(\"N/A\".into()).into());\n                if let Some(children) = children {\n                    for child in children {\n                        match child {\n                            TreeValue::Node { .. } =\u003e unimplemented!(),\n                            TreeValue::Link { weight, node } =\u003e {\n                                let child_id = add_node(g, *node);\n                                g.add_edge(node_id, child_id, weight);\n                            }\n                        }\n                    }\n                };\n                node_id\n            }\n            TreeValue::Link { .. } =\u003e unreachable!(),\n        }\n    }\n\n    let mut g = TreeGraph::new();\n    add_node(\u0026mut g, root);\n\n    Ok(Tree { g })\n}\n\n/// Reads a tree from an `\u0026str`-compatible type\npub fn from_string\u003cS: AsRef\u003cstr\u003e\u003e(content: S) -\u003e Result\u003cTree\u003e {\n    let raw_tree = parse_newick_file(content.as_ref())?;\n    newick_to_graph(raw_tree)\n}\n\n/// Reads a tree from a file\npub fn from_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e Result\u003cTree\u003e {\n    fs::File::open(\u0026path)\n        .map(read)\n        .map_err(|e| Error::OpenFile {\n            filename: path.as_ref().to_owned(),\n            source: e,\n        })?\n}\n\n/// Reads a tree from any type implementing `io::Read`\npub fn read\u003cR: io::Read\u003e(reader: R) -\u003e Result\u003cTree\u003e {\n    let content_bytes = reader\n        .bytes()\n        .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n        .map_err(Error::Read)?;\n    let content_str = std::str::from_utf8(\u0026content_bytes).map_err(Error::InvalidContent)?;\n    from_string(\u0026content_str)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","lib.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n#![doc(\n    html_logo_url = \"https://raw.githubusercontent.com/rust-bio/rust-bio/master/img/bioferris.svg\",\n    html_favicon_url = \"https://raw.githubusercontent.com/rust-bio/rust-bio/master/img/bioferris.svg\"\n)]\n\n//! # Rust-bio, a bioinformatics library for Rust.\n//! This library provides implementations of many algorithms and data structures\n//! that are useful for bioinformatics.\n//! All provided implementations are rigorously tested via continuous\n//! integration.\n//!\n//! For **getting started** with using `rust-bio`, see [the `Getting started` section below](#getting-started).\n//! For navigating the documentation of the available modules, see [the `Modules` section below](#modules).\n//! If you want to contribute to `rust-bio`, see [the `Contribute` section in the repo](https://github.com/rust-bio/rust-bio#contribute).\n//!\n//! Currently, rust-bio provides\n//!\n//! * most major pattern matching algorithms,\n//! * a convenient alphabet implementation,\n//! * pairwise alignment,\n//! * suffix arrays,\n//! * the [Burrows-Wheeler-transform (BWT)]()\n//! * the [Full-text index in Minute space index (FM-index)](https://doi.org/10.1109/SFCS.2000.892127),\n//! * FMD-Index for finding supermaximal exact matches,\n//! * a q-gram index,\n//! * utilities to work with [PSSMs](https://en.wikipedia.org/wiki/Position_weight_matrix),\n//! * an open reading frame (ORF) search algorithm,\n//! * a rank/select data structure,\n//! * [serde](https://github.com/serde-rs/serde) support for all data structures when built with `nightly` feature,\n//! * readers and writers for FASTQ, FASTA and BED,\n//! * helper functions for combinatorics and dealing with log probabilities,\n//! * an implementation of the Hidden Markov Model and related algorithms.\n//!\n//! For reading and writing SAM/BAM/CRAM, VCF/BCF files or tabix indexed files, have a look at [rust-htslib](https://docs.rs/rust-htslib).\n//!\n//! # Getting started\n//!\n//! We explain how to use Rust-Bio step-by-step.\n//! Users who already have experience with Rust can skip right to [Step 3: Use Rust-Bio in your project](https://docs.rs/bio/#step-3-use-rust-bio-in-your-project).\n//! Users who already know `rust-bio` might want to jump right into the [modules docs](https://docs.rs/bio/#modules)\n//!\n//! ## Step 1: Setting up Rust\n//!\n//! Rust can be installed following the instruction for [rustup](https://rustup.rs/).\n//!\n//!\n//! ## Step 2: Setting up a new Rust project\n//!\n//! Since Rust-Bio is a library, you need to setup your own new Rust project to use Rust-Bio.\n//! With Rust, projects and their dependencies are managed with the builtin package manager [Cargo](https://doc.rust-lang.org/cargo/index.html).\n//! To create a new Rust project, issue\n//!\n//! ```bash\n//! cargo new hello_world --bin\n//! cd hello_world\n//! ```\n//! in your terminal. The flag `--bin` tells Cargo to create an executable project instead of a library.\n//! In [this section](https://doc.rust-lang.org/nightly/book/hello-cargo.html#a-new-project) of the Rust docs, you find details about what Cargo just created for you.\n//!\n//! Your new project can be compiled with\n//! ```bash\n//! cargo build\n//! ```\n//! If dependencies in your project are out of date, update with\n//! ```bash\n//! cargo update\n//! ```\n//! Execute the compiled code with\n//! ```bash\n//! cargo run\n//! ```\n//! If you are new to Rust, we suggest to proceed with [learning Rust](https://www.rust-lang.org/learn) via the Rust docs.\n//!\n//! ## Step 3: Use Rust-Bio in your project\n//!\n//! To use Rust-Bio in your Rust project, add the following to your `Cargo.toml`\n//!\n//! ```toml\n//! [dependencies]\n//! bio = \"*\"\n//! ```\n//!\n//! and import the crate from your source code:\n//!\n//! ```rust\n//! extern crate bio;\n//! ```\n//!\n//! ## Example: FM-index and FASTQ\n//!\n//! An example of using `rust-bio`:\n//!\n//! ```rust\n//! // Import some modules\n//! use bio::alphabets;\n//! use bio::data_structures::bwt::{bwt, less, Occ};\n//! use bio::data_structures::fmindex::{FMIndex, FMIndexable};\n//! use bio::data_structures::suffix_array::suffix_array;\n//! use bio::io::fastq;\n//! use bio::io::fastq::FastqRead;\n//! use std::io;\n//!\n//! // a given text\n//! let text = b\"ACAGCTCGATCGGTA$\";\n//! let pattern = b\"ATCG\";\n//!\n//! // Create an FM-Index for the given text.\n//!\n//! // instantiate an alphabet\n//! let alphabet = alphabets::dna::iupac_alphabet();\n//! // calculate a suffix array\n//! let sa = suffix_array(text);\n//! // calculate the Burrows-Wheeler-transform\n//! let bwt = bwt(text, \u0026sa);\n//! // calculate the vectors less and Occ (occurrences)\n//! let less = less(\u0026bwt, \u0026alphabet);\n//! let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n//! // set up FMIndex\n//! let fmindex = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n//! // do a backwards search for the pattern\n//! let interval = fmindex.backward_search(pattern.iter());\n//! let positions = interval.occ(\u0026sa);\n//!\n//! // Iterate over a FASTQ file, use the alphabet to validate read\n//! // sequences and search for exact matches in the FM-Index.\n//!\n//! // create FASTQ reader\n//! let mut reader = fastq::Reader::new(io::stdin());\n//! let mut record = fastq::Record::new();\n//! reader.read(\u0026mut record).expect(\"Failed to parse record\");\n//! while !record.is_empty() {\n//!     let check = record.check();\n//!     if check.is_err() {\n//!         panic!(\"I got a rubbish record!\")\n//!     }\n//!     // obtain sequence\n//!     let seq = record.seq();\n//!     // check, whether seq is in the expected alphabet\n//!     if alphabet.is_word(seq) {\n//!         let interval = fmindex.backward_search(seq.iter());\n//!         let positions = interval.occ(\u0026positions);\n//!     }\n//!     reader.read(\u0026mut record).expect(\"Failed to parse record\");\n//! }\n//! ```\n//!\n//! Documentation and further examples for each module can be found in the module descriptions below.\n//!\n//!\n//! ## Example: Multithreaded\n//!\n//! ```rust\n//! use bio::alphabets;\n//! use bio::data_structures::bwt::{bwt, less, Occ};\n//! use bio::data_structures::fmindex::{FMIndex, FMIndexable};\n//! use bio::data_structures::suffix_array::suffix_array;\n//! use std::sync::Arc;\n//! use std::thread;\n//!\n//! let text = b\"ACGGATGCTGGATCGGATCGCGCTAGCTA$\";\n//! let patterns = vec![b\"ACCG\", b\"TGCT\"];\n//!\n//! // Create an FM-Index for a given text.\n//! let alphabet = alphabets::dna::iupac_alphabet();\n//! let sa = suffix_array(text);\n//! let bwt = Arc::new(bwt(text, \u0026sa));\n//! let less = Arc::new(less(bwt.as_ref(), \u0026alphabet));\n//! let occ = Arc::new(Occ::new(bwt.as_ref(), 3, \u0026alphabet));\n//! let fmindex = Arc::new(FMIndex::new(bwt, less, occ));\n//!\n//! // Spawn threads to perform backward searches for each interval\n//! let interval_calculators = patterns\n//!     .into_iter()\n//!     .map(|pattern| {\n//!         let fmindex = fmindex.clone();\n//!         thread::spawn(move || fmindex.backward_search(pattern.iter()))\n//!     })\n//!     .collect::\u003cVec\u003c_\u003e\u003e();\n//!\n//! // Loop through the results, extracting the positions array for each pattern\n//! for interval_calculator in interval_calculators {\n//!     let positions = interval_calculator.join().unwrap().occ(\u0026sa);\n//! }\n//! ```\n//!\n//! Documentation and further examples for each module can be found in the module descriptions below.\n//!\n//! # Benchmarks\n//!\n//! Since Rust-Bio is based on a compiled language, similar performance to C/C++ based libraries can be expected. Indeed, we find the pattern matching algorithms of Rust-Bio to perform in the range of the C++ library Seqan:\n//!\n//! | Algorithm | Rust-Bio | Seqan   |\n//! | --------- | -------: | ------: |\n//! | BNDM      | 77ms     | 80ms    |\n//! | Horspool  | 122ms    | 125ms   |\n//! | BOM       | 103ms    | 107ms   |\n//! | Shift-And | 241ms    | 545ms   |\n//!\n//! We measured 10000 iterations of searching pattern `GCGCGTACACACCGCCCG` in the sequence of the hg38 MT chromosome.\n//! Initialization time of each algorithm for the given pattern was included in each iteration. Benchmarks were conducted with *Cargo bench* for Rust-Bio and *Python timeit* for Seqan on an Intel Core i5-3427U CPU.\n//! Benchmarking Seqan from *Python timeit* entails an overhead of 1.46ms for calling a C++ binary. This overhead was subtracted from above Seqan run times.\n//! Note that this benchmark only compares the two libraries to exemplify that Rust-Bio has comparable speed to C++ libraries: all used algorithms have their advantages for specific text and pattern structures and lengths (see [the pattern matching section in the documentation](https://docs.rs/bio/0.28.2/bio/pattern_matching/index.html))./!\n\n#[macro_use]\nextern crate approx;\n\n#[macro_use]\nextern crate custom_derive;\n\n#[macro_use]\nextern crate lazy_static;\n\n#[macro_use]\nextern crate newtype_derive;\n\n#[macro_use]\nextern crate serde_derive;\n\n#[macro_use]\nextern crate strum_macros;\n\n#[macro_use]\nextern crate getset;\n\n#[cfg(feature = \"phylogeny\")]\n#[macro_use]\nextern crate pest_derive;\n\npub mod alignment;\npub mod alphabets;\npub mod data_structures;\npub mod io;\npub mod pattern_matching;\npub mod scores;\npub mod seq_analysis;\npub mod stats;\npub mod utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","pattern_matching","bndm.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Backward nondeterministic DAWG matching (BNDM).\n//! Best-case complexity: O(n / m) with pattern of length m \u003c= 64 and text of length n.\n//! Worst case complexity: O(n * m).\n//!\n//! # Example\n//!\n//! ```\n//! use bio::pattern_matching::bndm;\n//! let pattern = b\"GAAAA\";\n//! let text = b\"ACGGCTAGAAAAGGCTAGAAAA\";\n//! let bndm = bndm::BNDM::new(pattern);\n//! let occ: Vec\u003cusize\u003e = bndm.find_all(text).collect();\n//! assert_eq!(occ, [7, 17]);\n//! ```\n\nuse crate::pattern_matching::shift_and::masks;\nuse crate::utils::TextSlice;\nuse std::borrow::Borrow;\n\n/// BNDM algorithm.\npub struct BNDM {\n    m: usize,\n    masks: [u64; 256],\n    accept: u64,\n}\n\nimpl BNDM {\n    /// Create a new instance for a given pattern.\n    pub fn new\u003cC, P\u003e(pattern: P) -\u003e Self\n    where\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: DoubleEndedIterator + ExactSizeIterator,\n    {\n        let pattern = pattern.into_iter();\n        let m = pattern.len();\n        assert!(m \u003c= 64, \"Expecting a pattern of at most 64 symbols.\");\n        // take the reverse pattern and build nondeterministic\n        // suffix automaton\n        let (masks, accept) = masks(pattern.rev());\n\n        BNDM { m, masks, accept }\n    }\n\n    /// Find all matches of pattern with a given text. Matches are returned as iterator over start positions.\n    pub fn find_all\u003c'a\u003e(\u0026'a self, text: TextSlice\u003c'a\u003e) -\u003e Matches\u003c'_\u003e {\n        Matches {\n            bndm: self,\n            window: self.m,\n            text,\n        }\n    }\n}\n\n/// Iterator over start positions of matches.\npub struct Matches\u003c'a\u003e {\n    bndm: \u0026'a BNDM,\n    window: usize,\n    text: TextSlice\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e Iterator for Matches\u003c'a\u003e {\n    type Item = usize;\n\n    fn next(\u0026mut self) -\u003e Option\u003cusize\u003e {\n        while self.window \u003c= self.text.len() {\n            let mut occ = None;\n            // bit mask of ones, all states active\n            let mut active = (1u64 \u003c\u003c self.bndm.m) - 1;\n            let (mut j, mut lastsuffix) = (1, 0);\n            // while not in fail state\n            while active != 0 {\n                // process j-th symbol from right\n                active \u0026= self.bndm.masks[self.text[self.window - j] as usize];\n                if active \u0026 self.bndm.accept != 0 {\n                    // reached accepting state\n                    if j == self.bndm.m {\n                        occ = Some(self.window - self.bndm.m);\n                        break;\n                    } else {\n                        // we reached the accepting state\n                        // but not the end of the pattern\n                        // hence, a suffix of the reverse pattern\n                        // i.e. a prefix of the pattern of\n                        // length j matches\n                        // in case of a mismatch, we can shift\n                        // to this prefix\n                        lastsuffix = j;\n                    }\n                }\n                j += 1;\n                active \u003c\u003c= 1;\n            }\n            // shift the window\n            self.window += self.bndm.m - lastsuffix;\n            if occ.is_some() {\n                return occ;\n            }\n        }\n\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use itertools::Itertools;\n\n    #[test]\n    fn test_find_all() {\n        let text = b\"dhjalkjwqnnnannanaflkjdklfj\";\n        let pattern = b\"qnnnannan\";\n        let bndm = BNDM::new(pattern);\n        assert_eq!(bndm.find_all(text).collect_vec(), [8]);\n    }\n\n    #[test]\n    fn test_find_all_at_start() {\n        let text = b\"dhjalkjwqnnnannanaflkjdklfj\";\n        let pattern = b\"dhjalk\";\n        let bndm = BNDM::new(pattern);\n        assert_eq!(bndm.find_all(text).collect_vec(), [0]);\n    }\n}\n","traces":[{"line":34,"address":[4446096,4446647,4447223,4446672],"length":1,"stats":{"Line":2},"fn_name":"new\u003c\u0026u8,\u0026[u8; 6]\u003e"},{"line":40,"address":[4446716,4446140],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[4446343,4446919],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[4447028,4446927,4446452,4446351],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4446502,4447078,4446407,4446983],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[9359168],"length":1,"stats":{"Line":1},"fn_name":"find_all"},{"line":54,"address":[9359192],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[9359216],"length":1,"stats":{"Line":1},"fn_name":"next"},{"line":71,"address":[9360174,9359241],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[5324983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[5325128,5324995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[5325102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[5325158,5325126,5325717],"length":1,"stats":{"Line":4},"fn_name":null},{"line":79,"address":[5325179,5325395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[9359780,9359684,9359738],"length":1,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[9359748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[5325551,5325470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[5325444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[5325674,5325618],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[5325655,5325709],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[5325814,5325586,5325732],"length":1,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[5325794,5325848],"length":1,"stats":{"Line":4},"fn_name":null},{"line":102,"address":[5325859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[5324964],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[4872247,4871936],"length":1,"stats":{"Line":3},"fn_name":"test_find_all"},{"line":117,"address":[4871943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[4871958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[4871973],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[4871990],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[4872583,4872272],"length":1,"stats":{"Line":3},"fn_name":"test_find_all_at_start"},{"line":125,"address":[4872279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[4872294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[4872309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[4872326],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":34,"coverable":35},{"path":["/","home","todd","rust-bio","src","pattern_matching","bom.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Backward oracle matching algorithm.\n//! Best-case complexity: O(n / m) with pattern of length m and text of length n.\n//! Worst case complexity: O(n * m).\n//!\n//! # Example\n//!\n//! ```\n//! use bio::pattern_matching::bom::BOM;\n//! let text = b\"ACGGCTAGGAAAAAGACTGAGGACTGAAAA\";\n//! let pattern = b\"GAAAA\";\n//! let bom = BOM::new(pattern);\n//! let occ: Vec\u003cusize\u003e = bom.find_all(text).collect();\n//! assert_eq!(occ, [8, 25]);\n//! ```\n\nuse crate::utils::TextSlice;\nuse std::borrow::Borrow;\nuse std::cmp::Ord;\nuse std::iter::repeat;\n\nuse vec_map::VecMap;\n\n/// Backward oracle matching algorithm.\npub struct BOM {\n    m: usize,\n    table: Vec\u003cVecMap\u003cusize\u003e\u003e,\n}\n\nimpl BOM {\n    /// Create a new instance for a given pattern.\n    pub fn new\u003cC, P\u003e(pattern: P) -\u003e Self\n    where\n        C: Borrow\u003cu8\u003e + Ord,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: DoubleEndedIterator + ExactSizeIterator + Clone,\n    {\n        let pattern = pattern.into_iter();\n        let m = pattern.len();\n        let maxsym = *pattern\n            .clone()\n            .max()\n            .expect(\"Expecting non-empty pattern.\")\n            .borrow() as usize;\n        let mut table: Vec\u003cVecMap\u003cusize\u003e\u003e = Vec::with_capacity(m);\n        // init suffix table, initially all values unknown\n        // suff[i] is the state in which the longest suffix of\n        // pattern[..i+1] ends that does not end in i\n        let mut suff: Vec\u003cOption\u003cusize\u003e\u003e = repeat(None).take(m + 1).collect();\n\n        for (j, b) in pattern.rev().enumerate() {\n            let i = j + 1;\n            let a = *b.borrow() as usize;\n            let mut delta = VecMap::with_capacity(maxsym);\n            // reading symbol a leads into state i (this is an inner edge)\n            delta.insert(a, i);\n            // now, add edges for substrings ending with a\n            let mut k = suff[i - 1];\n\n            // for this iterate over the known suffixes until\n            // reaching an edge labelled with a or the start\n            while let Some(k_) = k {\n                if table[k_].contains_key(a) {\n                    break;\n                }\n                table[k_].insert(a, i);\n                k = suff[k_];\n            }\n\n            // the longest suffix is either 0 or the state\n            // reached by the edge labelled with a\n            suff[i] = Some(match k {\n                Some(k) =\u003e *table[k].get(a).unwrap(),\n                None =\u003e 0,\n            });\n\n            table.push(delta);\n        }\n\n        BOM { m, table }\n    }\n\n    fn delta(\u0026self, q: usize, a: u8) -\u003e Option\u003cusize\u003e {\n        if q \u003e= self.table.len() {\n            None\n        } else {\n            match self.table[q].get(a as usize) {\n                Some(\u0026q) =\u003e Some(q),\n                None =\u003e None,\n            }\n        }\n    }\n\n    /// Find all matches of the pattern in the given text. Matches are returned as an iterator over start positions.\n    pub fn find_all\u003c'a\u003e(\u0026'a self, text: TextSlice\u003c'a\u003e) -\u003e Matches\u003c'_\u003e {\n        Matches {\n            bom: self,\n            text,\n            window: self.m,\n        }\n    }\n}\n\n/// Iterator over start positions of matches.\npub struct Matches\u003c'a\u003e {\n    bom: \u0026'a BOM,\n    text: TextSlice\u003c'a\u003e,\n    window: usize,\n}\n\nimpl\u003c'a\u003e Iterator for Matches\u003c'a\u003e {\n    type Item = usize;\n\n    fn next(\u0026mut self) -\u003e Option\u003cusize\u003e {\n        while self.window \u003c= self.text.len() {\n            let (mut q, mut j) = (Some(0), 1);\n            while j \u003c= self.bom.m {\n                match q {\n                    Some(q_) =\u003e {\n                        q = self.bom.delta(q_, self.text[self.window - j]);\n                        j += 1;\n                    }\n                    None =\u003e break,\n                }\n            }\n            // putative start position\n            let i = self.window - self.bom.m;\n            self.window += self.bom.m + 2 - j;\n            if q.is_some() {\n                // return match\n                return Some(i);\n            }\n        }\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::BOM;\n    use itertools::Itertools;\n\n    #[test]\n    fn test_delta() {\n        let pattern = b\"qnnnannan\"; // reverse of nannannnq\n        let bom = BOM::new(pattern);\n        assert_eq!(bom.delta(0, b'n'), Some(1));\n        assert_eq!(bom.delta(1, b'a'), Some(2));\n        assert_eq!(bom.delta(2, b'n'), Some(3));\n        assert_eq!(bom.delta(3, b'n'), Some(4));\n        assert_eq!(bom.delta(4, b'a'), Some(5));\n        assert_eq!(bom.delta(5, b'n'), Some(6));\n        assert_eq!(bom.delta(6, b'n'), Some(7));\n        assert_eq!(bom.delta(7, b'n'), Some(8));\n        assert_eq!(bom.delta(8, b'q'), Some(9));\n\n        assert_eq!(bom.delta(0, b'a'), Some(2));\n        assert_eq!(bom.delta(0, b'q'), Some(9));\n        assert_eq!(bom.delta(1, b'n'), Some(4));\n        assert_eq!(bom.delta(1, b'q'), Some(9));\n        assert_eq!(bom.delta(4, b'n'), Some(8));\n        assert_eq!(bom.delta(4, b'q'), Some(9));\n        bom.delta(9, b'a');\n    }\n\n    #[test]\n    fn test_find_all() {\n        let text = b\"dhjalkjwqnnnannanaflkjdklfj\";\n        let pattern = b\"qnnnannan\";\n        let bom = BOM::new(pattern);\n        assert_eq!(bom.find_all(text).collect_vec(), [8]);\n    }\n\n    #[test]\n    fn test_find_all_at_start() {\n        let text = b\"dhjalkjwqnnnannanaflkjdklfj\";\n        let pattern = b\"dhjalk\";\n        let bom = BOM::new(pattern);\n        assert_eq!(bom.find_all(text).collect_vec(), [0]);\n    }\n}\n","traces":[{"line":36,"address":[5632966,5630608,5630582,5628224],"length":1,"stats":{"Line":2},"fn_name":"new\u003c\u0026u8,\u0026[u8; 9]\u003e"},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[5316288],"length":1,"stats":{"Line":1},"fn_name":"delta"},{"line":88,"address":[5316322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[5316386],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[5316497,5316419,5316495,5316362,5316455,5316466],"length":1,"stats":{"Line":5},"fn_name":null},{"line":92,"address":[5316435,5316468],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[5316457],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[5316512],"length":1,"stats":{"Line":2},"fn_name":"find_all"},{"line":103,"address":[5316558],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[5316592],"length":1,"stats":{"Line":2},"fn_name":"next"},{"line":119,"address":[5316617,5317417],"length":1,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[5316677],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[5316794,5317094],"length":1,"stats":{"Line":4},"fn_name":null},{"line":122,"address":[5316832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[5316815,5316844],"length":1,"stats":{"Line":4},"fn_name":null},{"line":124,"address":[5316865],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[5317057,5317099],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[5316834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[5317134,5317198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[5317377,5317174,5317233],"length":1,"stats":{"Line":3},"fn_name":null},{"line":133,"address":[5317411,5317357],"length":1,"stats":{"Line":4},"fn_name":null},{"line":135,"address":[5317427],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[5316660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[6378768,6382679],"length":1,"stats":{"Line":3},"fn_name":"test_delta"},{"line":149,"address":[6378775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[6378790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[6378827,6379103,6379034],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[6379361,6379170,6379058],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[6379620,6379316,6379429],"length":1,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[6379879,6379575,6379688],"length":1,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[6379947,6379834,6380138],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[6380397,6380093,6380206],"length":1,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[6380352,6380465,6380656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[6380915,6380611,6380724],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[6380983,6381173,6380870],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[6381241,6381431,6381128],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[6381386,6381499,6381690],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[6381937,6381758,6381645],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[6381999,6382166,6381901],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[6382395,6382228,6382133],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[6382457,6382362,6382612],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[6382590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[6382704,6383044],"length":1,"stats":{"Line":3},"fn_name":"test_find_all"},{"line":172,"address":[6382711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[6382726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[6382741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[6382758,6382846],"length":1,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[6383412,6383072],"length":1,"stats":{"Line":3},"fn_name":"test_find_all_at_start"},{"line":180,"address":[6383079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[6383094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[6383109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[6383214,6383126],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":71,"coverable":76},{"path":["/","home","todd","rust-bio","src","pattern_matching","horspool.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Algorithm of Horspool.\n//! Window-based, similar to but faster than Boyer-Moore.\n//!\n//! # Idea\n//! Look at a search window m, match pattern backwards.\n//! In case of a mismatch, you can jump behind that.\n//! Best case time complexity: O(n / m)\n//! Worst case time complexity: O(n * m)\n//! With a large alphabet, you are likely\n//! around the best case, and faster than the rather\n//! complicated Boyer-Moore.\n//!\n//! The algorithm has two phases (let a be the last symbol in the window):\n//!\n//! 1. test phase: compare the last symbol of the window.\n//!    If it matches, compare the whole pattern.\n//!    If it does not match, continue with the shift phase.\n//! 2. shift phase: let `l[a]` be the rightmost position of a in\n//!    the pattern without the last symbol. If it does not occur\n//!    let `l[a]` be -1. Shift the window by `m - 1 - l[a]`. i.e.\n//!    we shift the window such that the rightmost a matches\n//!    the a at the end of the last window.\n//!    If a does not occur in the pattern, we shift by the whole length.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::pattern_matching::horspool::Horspool;\n//! let text = b\"ACGGCTAGGAAAAAGACTGAGGACTGAAAA\";\n//! let pattern = b\"GAAAA\";\n//! let horspool = Horspool::new(pattern);\n//! let occ: Vec\u003cusize\u003e = horspool.find_all(text).collect();\n//! assert_eq!(occ, [8, 25]);\n//! ```\n\nuse crate::utils::TextSlice;\n\n/// Algorithm of Horspool.\npub struct Horspool\u003c'a\u003e {\n    shift: Vec\u003cusize\u003e,\n    m: usize,\n    pattern: TextSlice\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e Horspool\u003c'a\u003e {\n    /// Create a new instance for a given pattern.\n    pub fn new(pattern: TextSlice\u003c'a\u003e) -\u003e Self {\n        let m = pattern.len();\n        let mut shift = vec![m; 256];\n        // shift is m for all not occurring characters\n        // and m - 1 - j for all others\n        for (j, \u0026a) in pattern[..m - 1].iter().enumerate() {\n            shift[a as usize] = m - 1 - j;\n        }\n\n        Horspool { m, shift, pattern }\n    }\n\n    /// Find all matches with a given text. Matches are returned as an iterator over start\n    /// positions.\n    pub fn find_all\u003c'b\u003e(\u0026'b self, text: TextSlice\u003c'b\u003e) -\u003e Matches\u003c'_\u003e {\n        Matches {\n            horspool: self,\n            text,\n            n: text.len(),\n            last: self.m - 1,\n            pattern_last: self.pattern[self.m - 1],\n        }\n    }\n}\n\n/// Iterator over start positions of matches.\npub struct Matches\u003c'a\u003e {\n    horspool: \u0026'a Horspool\u003c'a\u003e,\n    text: TextSlice\u003c'a\u003e,\n    n: usize,\n    last: usize,\n    pattern_last: u8,\n}\n\nimpl\u003c'a\u003e Iterator for Matches\u003c'a\u003e {\n    type Item = usize;\n\n    fn next(\u0026mut self) -\u003e Option\u003cusize\u003e {\n        loop {\n            // shift until the last symbol matches\n            while self.last \u003c self.n \u0026\u0026 self.text[self.last] != self.pattern_last {\n                self.last += self.horspool.shift[self.text[self.last] as usize];\n            }\n            // stop if end of text is reached\n            if self.last \u003e= self.n {\n                return None;\n            }\n\n            // putative start position\n            let i = self.last + 1 - self.horspool.m;\n            let j = self.last;\n\n            // shift again (after both match and mismatch, this makes sense)\n            self.last += self.horspool.shift[self.pattern_last as usize];\n\n            if self.text[i..j] == self.horspool.pattern[..self.horspool.m - 1] {\n                return Some(i);\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Horspool;\n    use itertools::Itertools;\n\n    #[test]\n    fn test_shift() {\n        let pattern = b\"AACB\";\n        let horspool = Horspool::new(pattern);\n        assert_eq!(horspool.shift[b'A' as usize], 2);\n        assert_eq!(horspool.shift[b'C' as usize], 1);\n        assert_eq!(horspool.shift[b'B' as usize], 4);\n        assert_eq!(horspool.shift[b'X' as usize], 4);\n    }\n\n    #[test]\n    fn test_find_all() {\n        let text = b\"dhjalkjwqnnnannanaflkjdklfj\";\n        let pattern = b\"qnnnannan\";\n        let horspool = Horspool::new(pattern);\n        assert_eq!(horspool.find_all(text).collect_vec(), [8]);\n    }\n\n    #[test]\n    fn test_find_all_at_start() {\n        let text = b\"dhjalkjwqnnnannanaflkjdklfj\";\n        let pattern = b\"dhjalk\";\n        let horspool = Horspool::new(pattern);\n        assert_eq!(horspool.find_all(text).collect_vec(), [0]);\n    }\n}\n","traces":[{"line":52,"address":[5323465,5323480,5322576],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":53,"address":[9382094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[9382124],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[9382916,9382677,9382151,9382315],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[9382751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[9382944],"length":1,"stats":{"Line":1},"fn_name":"find_all"},{"line":70,"address":[5323548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[5323564,5323611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[5323651,5323589,5323787,5323805],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[5323808],"length":1,"stats":{"Line":1},"fn_name":"next"},{"line":90,"address":[5324800],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[5324206,5323839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[5324022,5324211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[5323995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[5324271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[5324438,5324320,5324249],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[5324392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[5324592,5324481,5324409],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[5324630,5324527],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[5324810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[9181525,9181520],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":121,"address":[9520439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[9520454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[9520476,9520680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[9520860,9520736,9520634],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[9521041,9520814,9520917],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[9520995,9521196,9521098],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[9181552,9181557],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":131,"address":[9521287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[9521302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[9521317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[9521339,9521427],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[9181589,9181584],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":139,"address":[9521655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[9521670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[9521685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[9521707,9521795],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":37,"coverable":37},{"path":["/","home","todd","rust-bio","src","pattern_matching","kmp.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Algorithm of Knuth Morris and Pratt.\n//! Constructs an automaton recognizing the pattern, and scans linearly over\n//! a text of length n. Complexity: O(n).\n//! The transition function delta is simulated via the lps-function, that assigns to each position\n//! q in the pattern the longest prefix of the pattern that is suffix of pattern[..q+1].\n//! Then, in the NFA for the pattern, active states after reading position q are\n//! {q, lps(q), lps(lps(q)), ... 0}.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::pattern_matching::kmp::KMP;\n//! let text = b\"aaaaabbabbbbbbbabbab\";\n//! let pattern = b\"abbab\";\n//! let kmp = KMP::new(pattern);\n//! let occ: Vec\u003cusize\u003e = kmp.find_all(text).collect();\n//! assert_eq!(occ, [4, 15]);\n//! ```\n\nuse std::borrow::Borrow;\nuse std::iter::{repeat, Enumerate};\n\nuse crate::utils::TextSlice;\n\ntype LPS = Vec\u003cusize\u003e;\n\n/// KMP algorithm.\npub struct KMP\u003c'a\u003e {\n    m: usize,\n    lps: LPS,\n    pattern: TextSlice\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e KMP\u003c'a\u003e {\n    /// Create a new instance for a given pattern.\n    pub fn new(pattern: TextSlice\u003c'a\u003e) -\u003e Self {\n        let m = pattern.len();\n        let lps = lps(pattern);\n\n        KMP { lps, m, pattern }\n    }\n\n    fn delta(\u0026self, mut q: usize, a: u8) -\u003e usize {\n        while q == self.m || (self.pattern[q] != a \u0026\u0026 q \u003e 0) {\n            q = self.lps[q - 1];\n        }\n        if self.pattern[q] == a {\n            q += 1;\n        }\n\n        q\n    }\n\n    /// Find all matches of pattern in a given text. Matches are returned as iterator over start\n    /// positions.\n    pub fn find_all\u003cC, T\u003e(\u0026self, text: T) -\u003e Matches\u003cC, T::IntoIter\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        Matches {\n            kmp: self,\n            q: 0,\n            text: text.into_iter().enumerate(),\n        }\n    }\n}\n\nfn lps(pattern: \u0026[u8]) -\u003e LPS {\n    let (m, mut q) = (pattern.len(), 0);\n    let mut lps: LPS = repeat(0).take(m).collect();\n    for i in 1..m {\n        while q \u003e 0 \u0026\u0026 pattern[q] != pattern[i] {\n            q = lps[q - 1];\n        }\n        if pattern[q] == pattern[i] {\n            q += 1;\n        }\n        lps[i] = q;\n    }\n\n    lps\n}\n\n/// Iterator over start positions of matches.\npub struct Matches\u003c'a, C, T\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    kmp: \u0026'a KMP\u003c'a\u003e,\n    q: usize,\n    text: Enumerate\u003cT\u003e,\n}\n\nimpl\u003c'a, C, T\u003e Iterator for Matches\u003c'a, C, T\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    type Item = usize;\n\n    fn next(\u0026mut self) -\u003e Option\u003cusize\u003e {\n        for (i, c) in self.text.by_ref() {\n            self.q = self.kmp.delta(self.q, *c.borrow());\n            if self.q == self.kmp.m {\n                return Some(1 + i - self.kmp.m);\n            }\n        }\n\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{lps, KMP};\n    use itertools::Itertools;\n\n    #[test]\n    fn test_find_all() {\n        let text = b\"dhjalkjwqnnnannanaflkjdklfj\";\n        let pattern = b\"qnnnannan\";\n        let kmp = KMP::new(pattern);\n        assert_eq!(kmp.find_all(text).collect_vec(), [8]);\n    }\n\n    #[test]\n    fn test_find_all_at_start() {\n        let text = b\"dhjalkjwqnnnannanaflkjdklfj\";\n        let pattern = b\"dhjalk\";\n        let kmp = KMP::new(pattern);\n        assert_eq!(kmp.find_all(text).collect_vec(), [0]);\n    }\n\n    #[test]\n    fn test_lps() {\n        let pattern = b\"ababaca\";\n        let lps = lps(pattern);\n        assert_eq!(lps, [0, 0, 1, 2, 3, 0, 1]);\n    }\n\n    #[test]\n    fn test_delta() {\n        let pattern = b\"abbab\";\n        let kmp = KMP::new(pattern);\n        assert_eq!(kmp.delta(0, b'a'), 1);\n        assert_eq!(kmp.delta(0, b'b'), 0);\n        assert_eq!(kmp.delta(1, b'a'), 1);\n        assert_eq!(kmp.delta(1, b'b'), 2);\n        assert_eq!(kmp.delta(2, b'a'), 1);\n        assert_eq!(kmp.delta(2, b'b'), 3);\n        assert_eq!(kmp.delta(3, b'a'), 4);\n        assert_eq!(kmp.delta(3, b'b'), 0);\n        assert_eq!(kmp.delta(4, b'a'), 1);\n        assert_eq!(kmp.delta(4, b'b'), 5);\n        assert_eq!(kmp.delta(5, b'a'), 1);\n        assert_eq!(kmp.delta(5, b'b'), 3);\n    }\n}\n","traces":[{"line":41,"address":[4698544],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4698770,4699068],"length":1,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4870224],"length":1,"stats":{"Line":2},"fn_name":"find_all\u003c\u0026u8,\u0026[u8; 27]\u003e"},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[4700372,4699216,4700357],"length":1,"stats":{"Line":1},"fn_name":"lps"},{"line":75,"address":[4699293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[4699371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4700352,4699582,4699678,4699450],"length":1,"stats":{"Line":13},"fn_name":null},{"line":78,"address":[4699715,4700073],"length":1,"stats":{"Line":4},"fn_name":null},{"line":79,"address":[4699961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[4700104,4700254,4699933],"length":1,"stats":{"Line":9},"fn_name":null},{"line":82,"address":[4700217,4700256],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[4700302],"length":1,"stats":{"Line":4},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[9136112,9136454],"length":1,"stats":{"Line":3},"fn_name":"test_find_all"},{"line":127,"address":[9136119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[9136134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[9136149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[9136171,9136254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[9136822,9136480],"length":1,"stats":{"Line":3},"fn_name":"test_find_all_at_start"},{"line":135,"address":[9136487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[9136502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[9136517],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[9136539,9136622],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[9137070,9136848],"length":1,"stats":{"Line":3},"fn_name":"test_lps"},{"line":143,"address":[9136855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[9136870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[9137033,9136897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[9139651,9137104],"length":1,"stats":{"Line":3},"fn_name":"test_delta"},{"line":150,"address":[9137111],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[9137126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[9137168,9137387],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[9137598,9137446,9137353],"length":1,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[9137658,9137810,9137564],"length":1,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[9137776,9137870,9138022],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[9138082,9138234,9137988],"length":1,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[9138294,9138200,9138446],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[9138506,9138649,9138412],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[9138843,9138706,9138621],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[9138818,9138900,9139037],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[9139012,9139094,9139231],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[9139425,9139206,9139288],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[9139400,9139599,9139482],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":55,"coverable":55},{"path":["/","home","todd","rust-bio","src","pattern_matching","mod.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! This module contains various useful pattern matching algorithms.\n//! The implementations are based on the lecture notes\n//! \"Algorithmen auf Sequenzen\", Kopczynski, Marschall, Martin and Rahmann, 2008 - 2015.\n//!\n//! * Algorithm of Horspool: fastest for a sufficiently large alphabet\n//! * Shift And algorithm: fast for patterns with less than 64 symbols and very small alphabets.\n//! * BNDM algorithm: fast for patterns with less than 64 symbols.\n//! * BOM algorithm: fast for long patterns and small alphabet.\n//! * KMP algorithm: the classical ancestor.\n//! * Ukkonens algorithm: approximate pattern matching with dynamic programming.\n//! * Myers algorithm: linear-time approximate pattern matching with edit distance for small patterns\n//!\n//! Another fast pattern matching algorithm is available in the twoway crate: https://crates.io/crates/twoway\n\npub mod bndm;\npub mod bom;\npub mod horspool;\npub mod kmp;\npub mod myers;\npub mod pssm;\npub mod shift_and;\npub mod ukkonen;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","pattern_matching","myers","builder.rs"],"content":"use std::borrow::Borrow;\nuse std::collections::HashMap;\n\nuse super::long::Myers as MyersLong;\nuse super::{BitVec, Myers};\n\n/// Builds a Myers instance, allowing to specify ambiguities.\n///\n/// # Example:\n///\n/// This example shows how recognition of IUPAC ambiguities in patterns can be implemented:\n///\n/// ```\n/// # extern crate bio;\n/// use bio::pattern_matching::myers::MyersBuilder;\n///\n/// # fn main() {\n/// let ambigs = [\n///     (b'M', \u0026b\"AC\"[..]),\n///     (b'R', \u0026b\"AG\"[..]),\n///     (b'W', \u0026b\"AT\"[..]),\n///     (b'S', \u0026b\"CG\"[..]),\n///     (b'Y', \u0026b\"CT\"[..]),\n///     (b'K', \u0026b\"GT\"[..]),\n///     (b'V', \u0026b\"ACGMRS\"[..]),\n///     (b'H', \u0026b\"ACTMWY\"[..]),\n///     (b'D', \u0026b\"AGTRWK\"[..]),\n///     (b'B', \u0026b\"CGTSYK\"[..]),\n///     (b'N', \u0026b\"ACGTMRWSYKVHDB\"[..]),\n/// ];\n///\n/// let mut builder = MyersBuilder::new();\n///\n/// for \u0026(base, equivalents) in \u0026ambigs {\n///     builder.ambig(base, equivalents);\n/// }\n///\n/// let text = b\"GGATGNGCGCCATAG\";\n/// let pattern = b\"TRANCGG\";\n/// //                *   * (mismatch)\n///\n/// let myers = builder.build_64(pattern);\n/// assert_eq!(myers.distance(text), 2);\n/// # }\n/// ```\n///\n/// Note that only ambiguities in the pattern are recognized. The reverse is not true; ambiguities\n/// in the search text are not matched by multiple symbols in the pattern. This would require\n/// specifying additional ambiguities (`builder.ambig(b'A', b\"MRWVHDN\")`, etc...).\n#[derive(Default, Clone, Eq, PartialEq)]\npub struct MyersBuilder {\n    ambigs: HashMap\u003cu8, Vec\u003cu8\u003e\u003e,\n    wildcards: Vec\u003cu8\u003e,\n}\n\nimpl MyersBuilder {\n    pub fn new() -\u003e MyersBuilder {\n        Self::default()\n    }\n\n    /// Allows to specify ambiguous symbols and their equivalents. Note that the ambiguous symbol\n    /// will always be matched by itself. Explicitly including it in the equivalents is not\n    /// necessary.\n    ///\n    /// # Example:\n    ///\n    /// ```\n    /// # extern crate bio;\n    /// use bio::pattern_matching::myers::MyersBuilder;\n    ///\n    /// # fn main() {\n    /// let text = b\"GGATGAGCGCCATAG\";\n    /// let pattern = b\"TGAGCGN\";\n    ///\n    /// let myers = MyersBuilder::new()\n    ///     .ambig(b'N', b\"ACGT\")\n    ///     .build_64(pattern);\n    ///\n    /// assert_eq!(myers.distance(text), 0);\n    /// # }\n    pub fn ambig\u003cI, B\u003e(\u0026mut self, byte: u8, equivalents: I) -\u003e \u0026mut Self\n    where\n        I: IntoIterator\u003cItem = B\u003e,\n        B: Borrow\u003cu8\u003e,\n    {\n        let eq = equivalents\n            .into_iter()\n            .map(|b| *b.borrow())\n            .chain(Some(byte))\n            .collect();\n        self.ambigs.insert(byte, eq);\n        self\n    }\n\n    /// Allows to specify a wildcard symbol, that upon appearance in the search text\n    /// shall be matched by any symbol of the pattern. Multiple wildcards are possible.\n    /// For the inverse, that is, wildcards in the pattern matching any symbol in search\n    /// text, use `ambig(byte, 0..255)`.\n    ///\n    /// # Example:\n    ///\n    /// ```\n    /// # extern crate bio;\n    /// use bio::pattern_matching::myers::MyersBuilder;\n    ///\n    /// # fn main() {\n    /// let text = b\"GGATGAGCG*CATAG\";\n    /// let pattern = b\"TGAGCGT\";\n    ///\n    /// let myers = MyersBuilder::new()\n    ///     .text_wildcard(b'*')\n    ///     .build_64(pattern);\n    ///\n    /// assert_eq!(myers.distance(text), 0);\n    /// # }\n    pub fn text_wildcard(\u0026mut self, wildcard: u8) -\u003e \u0026mut Self {\n        self.wildcards.push(wildcard);\n        self\n    }\n\n    /// Creates a Myers instance given a pattern, using `u64` as bit vector type.\n    /// Pattern length is restricted to at most 64 symbols.\n    pub fn build_64\u003cC, P\u003e(\u0026self, pattern: P) -\u003e Myers\u003cu64\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        self.build(pattern)\n    }\n\n    /// Creates a Myers instance given a pattern, using `u128` as bit vector type.\n    /// Pattern length is restricted to at most 128 symbols.\n    #[cfg(has_u128)]\n    pub fn build_128\u003cC, P\u003e(\u0026self, pattern: P) -\u003e Myers\u003cu128\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        self.build(pattern)\n    }\n\n    /// Creates a Myers instance given a pattern, using any desired type for bit vectors.\n    /// Pattern length is restricted to the size of the bit vector `T`.\n    ///\n    /// # Example:\n    ///\n    /// ```\n    /// # extern crate bio;\n    /// use bio::pattern_matching::myers::{MyersBuilder, Myers};\n    ///\n    /// # fn main() {\n    /// let myers: Myers\u003cu32\u003e = MyersBuilder::new()\n    ///     .text_wildcard(b'*')\n    ///     .build(b\"TGAGCG*\");\n    /// // ...\n    /// # }\n    pub fn build\u003cT, C, P\u003e(\u0026self, pattern: P) -\u003e Myers\u003cT\u003e\n    where\n        T: BitVec,\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        Myers::new_ambig(pattern, Some(\u0026self.ambigs), Some(\u0026self.wildcards))\n    }\n\n    /// Creates a `long::Myers` instance given a pattern, using `u64` as bit vector type.\n    /// Pattern length is not restricted regardless of the type of the bit vector.\n    pub fn build_long_64\u003cC, P\u003e(\u0026self, pattern: P) -\u003e MyersLong\u003cu64\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        self.build_long(pattern)\n    }\n\n    /// Creates a `long::Myers` instance given a pattern, using `u128` as bit vector type.\n    /// Pattern length is not restricted regardless of the type of the bit vector.\n    #[cfg(has_u128)]\n    pub fn build_long_128\u003cC, P\u003e(\u0026self, pattern: P) -\u003e MyersLong\u003cu128\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        self.build_long(pattern)\n    }\n\n    /// Creates a `long::Myers` instance given a pattern, using any desired type for bit vectors.\n    /// Pattern length is not restricted regardless of the type of the bit vector.\n    pub fn build_long\u003cT, C, P\u003e(\u0026self, pattern: P) -\u003e MyersLong\u003cT\u003e\n    where\n        T: BitVec,\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        MyersLong::new_ambig(pattern, Some(\u0026self.ambigs), Some(\u0026self.wildcards))\n    }\n}\n","traces":[{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[9533664],"length":1,"stats":{"Line":1},"fn_name":"ambig\u003c\u0026[u8; 2],\u0026u8\u003e"},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[9533939,9533920],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}\u003c\u0026[u8; 2],\u0026u8\u003e"},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[9534112,9534016,9534064],"length":1,"stats":{"Line":3},"fn_name":"build_64\u003c\u0026u8,\u0026[u8; 8]\u003e"},{"line":129,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[9534761,9534345,9534368,9534160,9534553,9534576],"length":1,"stats":{"Line":4},"fn_name":"build\u003cu64,\u0026u8,\u0026[u8; 7]\u003e"},{"line":166,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":13,"coverable":19},{"path":["/","home","todd","rust-bio","src","pattern_matching","myers","common_tests.rs"],"content":"macro_rules! impl_tests {\n    ($mod_:ident, $bitvec:ty, $dist_type:ty, $builder_method:ident) =\u003e {\n        use crate::alignment::AlignmentOperation::*;\n        use crate::alignment::{Alignment, AlignmentMode};\n        use crate::pattern_matching::myers::MyersBuilder;\n        use itertools::Itertools;\n        use $mod_::Myers;\n\n        #[test]\n        fn test_find_all_end() {\n            let text = \"ACCGTGGATGAGCGCCATAG\".to_string();\n            let patt = \"------GATGAGCGT-----\".replace('-', \"\");\n            let myers = Myers::\u003c$bitvec\u003e::new(patt.as_bytes());\n            let occ = myers.find_all_end(text.as_bytes(), 1).collect_vec();\n            assert_eq!(occ, [(13, 1), (14, 1)]);\n        }\n\n        #[test]\n        fn test_distance() {\n            let text = b\"TGAGCNTA\";\n            let patt = b\"TGAGCGT\";\n\n            let myers = Myers::\u003c$bitvec\u003e::new(patt);\n            assert_eq!(myers.distance(text), 1);\n\n            let myers_wildcard = MyersBuilder::new().text_wildcard(b'N').build_64(patt);\n            assert_eq!(myers_wildcard.distance(text), 0);\n        }\n\n        #[test]\n        fn test_full_position() {\n            let text = \"CAGACATCTT\".to_string();\n            let patt = \"-AGA------\".replace('-', \"\");\n\n            let mut myers = Myers::\u003c$bitvec\u003e::new(patt.as_bytes());\n            let matches: Vec\u003c_\u003e = myers.find_all(text.as_bytes(), 1).collect();\n            assert_eq!(\u0026matches, \u0026[(1, 3, 1), (1, 4, 0), (1, 5, 1), (3, 6, 1)]);\n        }\n\n        #[test]\n        fn test_traceback_path() {\n            let text = \"TCAGACAT-CTT\".replace('-', \"\");\n            let patt = \"TC-GACGTGCT\".replace('-', \"\");\n\n            let mut myers = Myers::\u003c$bitvec\u003e::new(patt.as_bytes());\n            let mut matches = myers.find_all(text.as_bytes(), 3);\n            let mut aln = vec![];\n            assert_eq!(matches.next_path(\u0026mut aln).unwrap(), (0, 10, 3));\n            assert_eq!(\n                aln,\n                \u0026[Match, Match, Del, Match, Match, Match, Subst, Match, Ins, Match, Match]\n            );\n        }\n\n        #[test]\n        fn test_traceback_path2() {\n            let text = \"TCAG--CAGATGGAGCTC\".replace('-', \"\");\n            let patt = \"TCAGAGCAG---------\".replace('-', \"\");\n\n            let mut myers = Myers::\u003c$bitvec\u003e::new(patt.as_bytes());\n            let mut matches = myers.find_all(text.as_bytes(), 2);\n            let mut aln = vec![];\n            assert_eq!(matches.next_path(\u0026mut aln).unwrap(), (0, 7, 2));\n            assert_eq!(\n                aln,\n                \u0026[Match, Match, Match, Match, Ins, Ins, Match, Match, Match]\n            );\n        }\n\n        #[test]\n        fn test_alignment() {\n            let text = \"GGTCCTGAGGGATTA\".to_string();\n            let patt = \"--TCCT-AGGGA---\".replace('-', \"\");\n\n            let mut myers = Myers::\u003c$bitvec\u003e::new(patt.as_bytes());\n            let expected = Alignment {\n                score: 1,\n                xstart: 0,\n                xend: 9,\n                xlen: 9,\n                ystart: 2,\n                yend: 12,\n                ylen: 15,\n                operations: vec![\n                    Match, Match, Match, Match, Del, Match, Match, Match, Match, Match,\n                ],\n                mode: AlignmentMode::Semiglobal,\n            };\n\n            let mut aln = Alignment::default();\n            {\n                let mut matches = myers.find_all(text.as_bytes(), 1);\n                assert!(matches.next_alignment(\u0026mut aln));\n                assert_eq!(\u0026aln, \u0026expected);\n\n                aln.score = -1;\n                matches.alignment(\u0026mut aln);\n                assert_eq!(\u0026aln, \u0026expected);\n            }\n            // Lazy API\n            aln.score = -1;\n            let end = expected.yend - 1;\n            let mut lazy_matches = myers.find_all_lazy(text.as_bytes(), 1);\n            assert!(!lazy_matches.alignment_at(end, \u0026mut aln));\n            // now search positions\n            aln.score = -1;\n            assert_eq!(\n                lazy_matches.next(),\n                Some((end, expected.score as $dist_type))\n            );\n            assert!(lazy_matches.alignment_at(end, \u0026mut aln));\n            assert_eq!(\u0026aln, \u0026expected);\n        }\n\n        #[test]\n        fn test_position_cmp() {\n            // same as position_at, but 0-based positions from\n            let text = \"CAGACATCTT\".to_string();\n            let patt = \"---AGA----\".replace('-', \"\");\n            let text = text.as_bytes();\n\n            let starts_exp = [1, 1, 1, 3];\n            let end_dist_exp = [(2, 1), (3, 0), (4, 1), (5, 1)];\n\n            let mut myers = Myers::\u003c$bitvec\u003e::new(patt.as_bytes());\n\n            // standard iterator with 0-based ends\n            let end_dist: Vec\u003c_\u003e = myers.find_all_end(text, 1).collect();\n            assert_eq!(\u0026end_dist, \u0026end_dist_exp);\n\n            // iterator over full ranges where ends are + 1\n            let full_hits: Vec\u003c_\u003e = myers.find_all(text, 1).collect();\n\n            // allows to retrive starting position later\n            let mut lazy_matches = myers.find_all_lazy(text, 1);\n\n            // compare with each other and lazy matches\n            for ((\u0026start, (end, dist)), (f_start, f_end, f_dist)) in\n                starts_exp.iter().zip(end_dist).zip(full_hits)\n            {\n                assert_eq!(start, f_start);\n                assert_eq!(dist, f_dist);\n                assert_eq!(end + 1, f_end);\n\n                // lazy API\n                let (lazy_end, lazy_dist) = lazy_matches.next().unwrap();\n                assert_eq!(end, lazy_end);\n                assert_eq!(dist, lazy_dist);\n                assert_eq!(lazy_matches.hit_at(end), Some((start, dist)));\n                // For positions above, information is not (yet) available\n                assert_eq!(lazy_matches.hit_at(end + 1), None);\n            }\n        }\n\n        #[test]\n        fn test_path_at() {\n            let text = \"CAGACATCTT\".to_string();\n            let patt = \"---AGA----\".replace('-', \"\");\n\n            let mut myers = Myers::\u003c$bitvec\u003e::new(patt.as_bytes());\n            let mut matches = myers.find_all_lazy(text.as_bytes(), 1);\n\n            let expected = \u0026[Match, Match, Ins];\n            let mut path = vec![];\n\n            // search first hit\n            assert_eq!(matches.next(), Some((2, 1)));\n\n            // retrieve first hit at 0-based end position (2)\n            assert_eq!(matches.hit_at(2), Some((1, 1)));\n            assert_eq!(matches.path_at(2, \u0026mut path), Some((1, 1)));\n            assert_eq!(\u0026path, expected);\n\n            // hit out of range\n            path.clear();\n            assert!(matches.path_at(3, \u0026mut path).is_none());\n            assert!(path.is_empty());\n\n            // now search the next hit\n            assert_eq!(matches.next(), Some((3, 0)));\n            // position 3 is now searched -\u003e path can be retrieved\n            assert_eq!(matches.path_at(3, \u0026mut path), Some((1, 0)));\n            assert_eq!(\u0026path, \u0026[Match, Match, Match])\n        }\n\n        #[test]\n        fn test_shorter() {\n            let text = \"-ATG\".replace('-', \"\");\n            let patt = \"CATGC\".to_string();\n\n            let mut myers = Myers::\u003c$bitvec\u003e::new(patt.as_bytes());\n            let mut matches = myers.find_all(text.as_bytes(), 2);\n            let mut aln = vec![];\n            assert_eq!(matches.next_path(\u0026mut aln).unwrap(), (0, 3, 2));\n            assert_eq!(aln, \u0026[Ins, Match, Match, Match, Ins]);\n        }\n\n        #[test]\n        fn test_long_shorter() {\n            let text =\n                \"C--------CACGCGTGGGTCCTGAGGGAGCTCGTCGGTGTGGGGTTCGGGGGGGTTTGT\".replace('-', \"\");\n            let patt = \"CGGGGTGTGCACGCGTGGGTCCTGAGGGAGCTCGTCGGTGTGGGGTTCGGGGGGGTTTGT\".to_string();\n\n            let mut myers = Myers::\u003c$bitvec\u003e::new(patt.as_bytes());\n            let mut matches = myers.find_all(text.as_bytes(), 8);\n            assert_eq!(matches.next().unwrap(), (0, 52, 8));\n        }\n\n        #[test]\n        fn test_ambig() {\n            let text = b\"TGABCNTR\";\n            let patt = b\"TGRRCGTR\";\n            //                x  x\n            // Matching is asymmetric here (A matches R and G matches N, but the reverse is not true)\n\n            let myers = MyersBuilder::new().ambig(b'R', b\"AG\").build_64(patt);\n            assert_eq!(myers.distance(text), 2);\n        }\n\n        #[test]\n        fn test_longest_possible() {\n            let text = b\"CCACGCGT\";\n\n            let mut myers: Myers\u003cu8\u003e = Myers::new(text);\n            assert_eq!(myers.find_all(text, 0).next(), Some((0, 8, 0)));\n        }\n\n        #[test]\n        fn test_large_dist() {\n            use std::iter::repeat;\n\n            let pattern: Vec\u003c_\u003e = repeat(b'T').take(64).collect();\n            let text: Vec\u003c_\u003e = repeat(b'A').take(64).collect();\n\n            let mut myers = Myers::\u003cu64\u003e::new(\u0026pattern);\n            let max_dist = myers\n                .find_all_end(\u0026text, 64)\n                .max_by_key(|\u0026(_, dist)| dist)\n                .unwrap()\n                .1;\n            assert_eq!(max_dist, 64);\n\n            let max_dist = myers\n                .find_all(\u0026text, 64)\n                .max_by_key(|\u0026(_, _, dist)| dist)\n                .unwrap()\n                .2;\n            assert_eq!(max_dist, 64);\n        }\n\n        // macro end\n    };\n}\n","traces":[{"line":10,"address":[7377392,7377961],"length":1,"stats":{"Line":6},"fn_name":"test_find_all_end"},{"line":11,"address":[7377399],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[7377421],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[7377467,7377543],"length":1,"stats":{"Line":4},"fn_name":null},{"line":14,"address":[7377699,7377590],"length":1,"stats":{"Line":4},"fn_name":null},{"line":15,"address":[7377874,7377714],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[7377984,7378628],"length":1,"stats":{"Line":6},"fn_name":"test_distance"},{"line":20,"address":[7377991],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[7378006],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[7378021],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[7378038,7378216],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[7378280,7378199],"length":1,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[7378564,7378377,7378449],"length":1,"stats":{"Line":4},"fn_name":null},{"line":31,"address":[7378656,7379236],"length":1,"stats":{"Line":6},"fn_name":"test_full_position"},{"line":32,"address":[7378663],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[7378685],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[7378807,7378731],"length":1,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[7378963,7378854],"length":1,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[7379149,7378978],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[7379264,7380116],"length":1,"stats":{"Line":6},"fn_name":"test_traceback_path"},{"line":42,"address":[7379271],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[7379310],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[7379356,7379435],"length":1,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[7379482],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[7379581],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[7379668,7379744,7379624,7379928],"length":1,"stats":{"Line":5},"fn_name":null},{"line":49,"address":[7380013,7379840,7379978],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[7380144,7380996],"length":1,"stats":{"Line":6},"fn_name":"test_traceback_path2"},{"line":57,"address":[7380151],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[7380190],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[7380236,7380315],"length":1,"stats":{"Line":4},"fn_name":null},{"line":61,"address":[7380362],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[7380461],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[7380624,7380808,7380548,7380504],"length":1,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[7380893,7380720,7380858],"length":1,"stats":{"Line":4},"fn_name":null},{"line":71,"address":[7381024,7383445],"length":1,"stats":{"Line":6},"fn_name":"test_alignment"},{"line":72,"address":[7381031],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[7381056],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[7381202,7381108],"length":1,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[7381672],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[7381257,7381393],"length":1,"stats":{"Line":4},"fn_name":null},{"line":85,"address":[7381273],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[7381664],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[7381809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[7381864,7381969],"length":1,"stats":{"Line":4},"fn_name":null},{"line":93,"address":[7382030,7382215],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[7382104,7382251,7382301],"length":1,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[7382257],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[7382284],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[7382499,7382353],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[7382546],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[7382625,7382557],"length":1,"stats":{"Line":3},"fn_name":null},{"line":103,"address":[7382690,7382602],"length":1,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[7382819,7382718],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[7382785],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[7383066,7382933],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[7382812],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[7382857],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[7383117,7383043,7383242],"length":1,"stats":{"Line":4},"fn_name":null},{"line":112,"address":[7383310,7383131,7383279],"length":1,"stats":{"Line":4},"fn_name":null},{"line":116,"address":[7386739,7383472],"length":1,"stats":{"Line":6},"fn_name":"test_position_cmp"},{"line":118,"address":[7383479],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[7383520],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[7383572,7383658],"length":1,"stats":{"Line":4},"fn_name":null},{"line":122,"address":[7383696],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[7383744],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[7384070,7383976],"length":1,"stats":{"Line":4},"fn_name":null},{"line":128,"address":[7384115,7384185],"length":1,"stats":{"Line":4},"fn_name":null},{"line":129,"address":[7384438,7384201],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[7384415,7384500],"length":1,"stats":{"Line":4},"fn_name":null},{"line":135,"address":[7384553],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[7386560,7384909,7384992],"length":1,"stats":{"Line":6},"fn_name":null},{"line":139,"address":[7384766,7384663,7384972,7384560],"length":1,"stats":{"Line":5},"fn_name":null},{"line":141,"address":[7385169,7385377],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[7385475,7385264],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[7385697,7385429,7385532],"length":1,"stats":{"Line":4},"fn_name":null},{"line":146,"address":[7385749,7385680],"length":1,"stats":{"Line":4},"fn_name":null},{"line":147,"address":[7385813,7386003],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[7385902,7386096],"length":1,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[7386148,7386055,7386357],"length":1,"stats":{"Line":4},"fn_name":null},{"line":151,"address":[7386425,7386574,7386321],"length":1,"stats":{"Line":4},"fn_name":null},{"line":156,"address":[7386768,7388777],"length":1,"stats":{"Line":6},"fn_name":"test_path_at"},{"line":157,"address":[7386775],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[7386800],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[7386852,7386946],"length":1,"stats":{"Line":4},"fn_name":null},{"line":161,"address":[7386999],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[7387113],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[7387128],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[7387400,7387350,7387163,7387215],"length":1,"stats":{"Line":5},"fn_name":null},{"line":170,"address":[7387454,7387606,7387377],"length":1,"stats":{"Line":4},"fn_name":null},{"line":171,"address":[7387862,7387583,7387661],"length":1,"stats":{"Line":4},"fn_name":null},{"line":172,"address":[7387757,7387944,7387913],"length":1,"stats":{"Line":4},"fn_name":null},{"line":175,"address":[7387927],"length":1,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[7388020,7388083],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[7388058,7388149,7388120],"length":1,"stats":{"Line":4},"fn_name":null},{"line":180,"address":[7388190,7388142,7388324],"length":1,"stats":{"Line":4},"fn_name":null},{"line":182,"address":[7388579,7388379,7388307],"length":1,"stats":{"Line":4},"fn_name":null},{"line":183,"address":[7388630,7388665,7388475],"length":1,"stats":{"Line":4},"fn_name":null},{"line":187,"address":[7388800,7389635],"length":1,"stats":{"Line":6},"fn_name":"test_shorter"},{"line":188,"address":[7388807],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[7388846],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[7388954,7388875],"length":1,"stats":{"Line":4},"fn_name":null},{"line":192,"address":[7389001],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[7389100],"length":1,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[7389447,7389187,7389143,7389263],"length":1,"stats":{"Line":5},"fn_name":null},{"line":195,"address":[7389497,7389359,7389532],"length":1,"stats":{"Line":4},"fn_name":null},{"line":199,"address":[7390251,7389664],"length":1,"stats":{"Line":6},"fn_name":"test_long_shorter"},{"line":201,"address":[7389671],"length":1,"stats":{"Line":2},"fn_name":null},{"line":202,"address":[7389710],"length":1,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[7389739,7389815],"length":1,"stats":{"Line":4},"fn_name":null},{"line":205,"address":[7389862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[7389971,7390053,7390164],"length":1,"stats":{"Line":3},"fn_name":null},{"line":210,"address":[7390449,7390288],"length":1,"stats":{"Line":6},"fn_name":"test_ambig"},{"line":211,"address":[7390295],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[7390310],"length":1,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[7390325],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[7390527,7390464,7390639],"length":1,"stats":{"Line":4},"fn_name":null},{"line":221,"address":[7390704,7391028],"length":1,"stats":{"Line":6},"fn_name":"test_longest_possible"},{"line":222,"address":[7390711],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[7390726],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[7390834,7390743],"length":1,"stats":{"Line":4},"fn_name":null},{"line":229,"address":[7391056,7391875],"length":1,"stats":{"Line":6},"fn_name":"test_large_dist"},{"line":232,"address":[7391063],"length":1,"stats":{"Line":2},"fn_name":null},{"line":233,"address":[7391225,7391130],"length":1,"stats":{"Line":4},"fn_name":null},{"line":235,"address":[7391253],"length":1,"stats":{"Line":2},"fn_name":null},{"line":236,"address":[7391286,7391344,7391388],"length":1,"stats":{"Line":6},"fn_name":null},{"line":238,"address":[9182733,9182208,9182720,9182221],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":241,"address":[7391434,7391563],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[7391546,7391630],"length":1,"stats":{"Line":4},"fn_name":null},{"line":245,"address":[9182253,9182240,9182752,9182765],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":248,"address":[7391683,7391794],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":131,"coverable":131},{"path":["/","home","todd","rust-bio","src","pattern_matching","myers","helpers.rs"],"content":"use std::fmt::{Binary, Debug};\nuse std::ops::*;\n\nuse num_traits::{AsPrimitive, FromPrimitive, PrimInt, ToPrimitive, WrappingAdd};\n\n/// Trait for types that should be used to store the distance score when using the simple\n/// Myers algorithm (not the block-based one, which always uses `usize`).\n///\n/// For all currently implemented BitVec types, the maximum possible distance\n/// can be stored in `u8`. Custom implementations using bigger integers can\n/// adjust `DistType` to hold bigger numbers. Note that due to how the traceback\n/// algorithm currently works, `DistType` should be able to represent numbers larger\n/// than the bit-width of the `BitVec` type. For instance, a hypothetical `BitVec` type\n/// of `u256` should use `u16` as distance, since `u8` cannot store numbers larger\n/// than 255.\npub trait DistType: Copy\n        + Debug\n        + Default\n        + AddAssign\n        + SubAssign\n        + PrimInt // includes Bounded, Num, Zero, One\n        + FromPrimitive\n        + ToPrimitive\n        + AsPrimitive\u003cusize\u003e + AsPrimitive\u003ci64\u003e\n        + WrappingAdd\n        + Sub\u003cOutput=Self\u003e {}\n\nimpl DistType for u8 {}\nimpl DistType for u16 {}\nimpl DistType for u32 {}\nimpl DistType for u64 {}\nimpl DistType for usize {}\n\n/// This trait must be implemented for integer types serving as bit vectors.\n/// Only unsigned integers will work correctly.\npub trait BitVec: Copy\n    + Debug\n    + Binary\n    + Default\n    + Add\n    + Sub\n    + BitOr\n    + BitOrAssign\n    + BitAnd\n    + BitXor\n    + Not\n    + Shl\u003cusize\u003e\n    + ShlAssign\u003cusize\u003e\n    + ShrAssign\u003cusize\u003e\n    // These num_traits traits are required; in addition there are Bounded, Zero and One,\n    // which are all required by PrimInt and thus included\n    + PrimInt\n    + WrappingAdd\n    + ToPrimitive\n    + FromPrimitive\n    + AsPrimitive\u003cusize\u003e + AsPrimitive\u003ci64\u003e\n{\n    /// Type that should be used to store the distance score when using the simple\n    /// Myers algorithm (not the block-based one, which always uses `usize`).\n    type DistType: DistType;\n}\n\nmacro_rules! impl_bitvec {\n    ($type:ty, $dist:ty) =\u003e {\n        impl BitVec for $type {\n            type DistType = $dist;\n        }\n    };\n}\n\nimpl_bitvec!(u8, u8);\nimpl_bitvec!(u16, u8);\nimpl_bitvec!(u32, u8);\nimpl_bitvec!(u64, u8);\n#[cfg(has_u128)]\nimpl_bitvec!(u128, u8);\n\nuse crate::alignment::{Alignment, AlignmentMode};\n\n/// Updates an `Alignment` instance with new data (except of path).\n/// Assumes *0-based* range end coordinates, they will be converted to 1-based ones\n#[inline(always)]\npub(crate) fn update_aln(\n    end_pos: usize,\n    aln_len: usize,\n    text_len: usize,\n    dist: usize,\n    m: usize,\n    aln: \u0026mut Alignment,\n) {\n    aln.xstart = 0;\n    aln.xend = m;\n    aln.xlen = m;\n    aln.ylen = text_len;\n    aln.yend = end_pos + 1;\n    aln.ystart = aln.yend - aln_len;\n    aln.mode = AlignmentMode::Semiglobal;\n    aln.score = dist as i32;\n}\n\n#[inline]\npub(crate) fn word_size\u003cT\u003e() -\u003e usize {\n    std::mem::size_of::\u003cT\u003e() * 8\n}\n\n#[inline]\npub(crate) fn ceil_div(x: usize, y: usize) -\u003e usize {\n    if x % y != 0 {\n        x / y + 1\n    } else {\n        x / y\n    }\n}\n","traces":[{"line":91,"address":[5203216,5207286],"length":1,"stats":{"Line":4},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[5203232,5207302],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":14,"coverable":14},{"path":["/","home","todd","rust-bio","src","pattern_matching","myers","long.rs"],"content":"//! Block-based version of the algorithm, which does not restrict pattern length.\n//!\n//! This module implements the block-based version of the Myers pattern matching algorithm.\n//! It can be used for searching patterns of any length and obtaining semiglobal alignments\n//! of the hits. Apart from that, the `Myers` object in this module provides exactly the same\n//! API as the 'simple' version `bio::pattern_matching::myers::Myers`.\n//! For short patterns, the 'simple' version is still to be preferred, as the block-based\n//! algorithm is slower.\n\nuse std::borrow::Borrow;\nuse std::cmp::{max, min};\nuse std::collections::HashMap;\nuse std::iter;\nuse std::marker::PhantomData;\nuse std::mem::replace;\nuse std::slice;\nuse std::u64;\n\nuse itertools::Itertools;\nuse num_traits::ToPrimitive;\n\nuse crate::pattern_matching::myers::traceback::{StatesHandler, TracebackHandler};\nuse crate::pattern_matching::myers::{ceil_div, State};\n\nuse super::word_size;\nuse super::BitVec;\n\nstruct Peq\u003cT: BitVec\u003e {\n    peq: [T; 256],\n    bound: T,\n}\n\n/// Myers algorithm.\npub struct Myers\u003cT = u64\u003e\nwhere\n    T: BitVec,\n{\n    peq: Vec\u003cPeq\u003cT\u003e\u003e,\n    pub(crate) m: usize,\n    pub(crate) states_store: Vec\u003cState\u003cT, usize\u003e\u003e,\n}\n\nimpl\u003cT: BitVec\u003e Myers\u003cT\u003e {\n    /// Create a new instance of Myers algorithm for a given pattern.\n    #[inline]\n    pub fn new\u003cP, C\u003e(pattern: P) -\u003e Self\n    where\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        Self::new_ambig(pattern, None, None)\n    }\n\n    #[inline]\n    pub(crate) fn new_ambig\u003cP, C\u003e(\n        pattern: P,\n        opt_ambigs: Option\u003c\u0026HashMap\u003cu8, Vec\u003cu8\u003e\u003e\u003e,\n        opt_wildcards: Option\u003c\u0026[u8]\u003e,\n    ) -\u003e Self\n    where\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        let w = word_size::\u003cT\u003e();\n        let pattern = pattern.into_iter();\n        let m = pattern.len();\n        assert!(m \u003e 0, \"Pattern is empty\");\n        assert!(m \u003c= usize::max_value() / 2, \"Pattern too long\");\n\n        // build peq\n        let mut peq = vec![];\n        for chunk in pattern.chunks(w).into_iter() {\n            let mut peq_block = [T::zero(); 256];\n            let mut i = 0;\n            for symbol in chunk {\n                let symbol = *symbol.borrow();\n                let mask = T::one() \u003c\u003c i;\n                // equivalent\n                peq_block[symbol as usize] |= mask;\n                // ambiguities\n                if let Some(equivalents) = opt_ambigs.and_then(|ambigs| ambigs.get(\u0026symbol)) {\n                    for \u0026eq in equivalents {\n                        peq_block[eq as usize] |= mask;\n                    }\n                }\n                i += 1;\n            }\n            // wildcards\n            if let Some(wildcards) = opt_wildcards {\n                for \u0026w in wildcards {\n                    peq_block[w as usize] = T::max_value();\n                }\n            }\n\n            peq.push(Peq {\n                peq: peq_block,\n                bound: T::one() \u003c\u003c (i - 1),\n            });\n        }\n\n        Myers {\n            peq,\n            m,\n            states_store: vec![],\n        }\n    }\n\n    #[inline]\n    fn step(\u0026self, state: \u0026mut States\u003cT\u003e, a: u8, max_dist: usize) {\n        state.step(a, \u0026self.peq, max_dist)\n    }\n\n    #[inline]\n    fn initial_state(\u0026self, m: usize, max_dist: usize) -\u003e States\u003cT\u003e {\n        States::new(m, max_dist)\n    }\n}\n\n#[inline]\nfn advance_block\u003cT: BitVec\u003e(state: \u0026mut State\u003cT, usize\u003e, p: \u0026Peq\u003cT\u003e, a: u8, hin: i8) -\u003e i8 {\n    let mut eq = p.peq[a as usize];\n    let xv = eq | state.mv;\n    if hin \u003c 0 {\n        eq |= T::one();\n    }\n    let xh = ((eq \u0026 state.pv).wrapping_add(\u0026state.pv) ^ state.pv) | eq;\n\n    let mut ph = state.mv | !(xh | state.pv);\n    let mut mh = state.pv \u0026 xh;\n\n    // let hout = if ph \u0026 p.bound \u003e T::zero() {\n    //     state.dist += 1;\n    //     1\n    // } else if mh \u0026 p.bound \u003e T::zero() {\n    //     state.dist -= 1;\n    //     -1\n    // } else {\n    //     0\n    // };\n\n    // apparently faster than uncommented code above\n    let mut hout = ((ph \u0026 p.bound) != T::zero()) as i8;\n    hout -= ((mh \u0026 p.bound) != T::zero()) as i8;\n    state.dist = state.dist.wrapping_add(hout as usize);\n\n    ph \u003c\u003c= 1;\n    mh \u003c\u003c= 1;\n\n    if hin \u003c 0 {\n        mh |= T::one();\n    }\n    if hin \u003e 0 {\n        ph |= T::one();\n    }\n    // not faster:\n    // mh |= T::from_u8((hin \u003c 0) as u8).unwrap();\n    // ph |= T::from_u8((hin \u003e 0) as u8).unwrap();\n\n    state.pv = mh | !(xv | ph);\n    state.mv = ph \u0026 xv;\n\n    hout\n}\n\npub(super) struct States\u003cT: BitVec\u003e {\n    states: Vec\u003cState\u003cT, usize\u003e\u003e,\n    max_block: usize,\n    last_m: usize,\n}\n\nimpl\u003cT\u003e States\u003cT\u003e\nwhere\n    T: BitVec,\n{\n    fn new(m: usize, max_dist: usize) -\u003e Self {\n        let w = word_size::\u003cT\u003e();\n        let mut s = States {\n            states: vec![],\n            max_block: ceil_div(m, w) - 1,\n            last_m: m % w,\n        };\n        let min_blocks = max(1, ceil_div(min(max_dist, m), w));\n        for _ in 0..min_blocks {\n            s.add_state(0);\n        }\n        s\n    }\n\n    #[inline]\n    fn add_state(\u0026mut self, offset: i8) {\n        let prev_dist = self.states.last().map(|s| s.dist).unwrap_or(0);\n        // delta: number of bits of the new state covered by the pattern\n        // For the last block, we add m % w, not all bits are necessarily used.\n        // This strategy differs from the solution by Myers (p. 407, note 4).\n        // We wanted to avoid having to pad pattern and sequence.\n        let delta = if self.states.len() == self.max_block \u0026\u0026 self.last_m \u003e 0 {\n            self.last_m\n        } else {\n            word_size::\u003cT\u003e()\n        };\n        self.states.push(State::init(\n            (prev_dist)\n                .wrapping_add(delta)\n                .wrapping_add(offset as usize)\n                .to_usize()\n                .unwrap(),\n        ));\n    }\n\n    #[inline]\n    fn step(\u0026mut self, a: u8, peq: \u0026[Peq\u003cT\u003e], max_dist: usize) {\n        let mut carry = 0;\n        let mut last_block = self.states.len() - 1;\n\n        for (state, block_peq) in self.states.iter_mut().zip(peq) {\n            carry = advance_block(state, block_peq, a, carry);\n        }\n\n        let w = word_size::\u003cT\u003e();\n        let last_dist = self.states[last_block].dist;\n        if (last_dist as isize - carry as isize) as usize \u003c= max_dist\n            \u0026\u0026 last_block \u003c self.max_block\n            \u0026\u0026 (peq[last_block + 1].peq[a as usize] \u0026 T::one() == T::one() || carry \u003c 0)\n        {\n            last_block += 1;\n            self.add_state(-carry as i8);\n            advance_block(\u0026mut self.states[last_block], \u0026peq[last_block], a, carry);\n        } else {\n            while last_block \u003e 0 \u0026\u0026 self.states[last_block].dist \u003e= max_dist + w {\n                last_block -= 1;\n            }\n            self.states.truncate(last_block + 1);\n        }\n    }\n\n    /// Returns the last distance score of the traceback column if known\n    /// (only if all blocks were computed).\n    #[inline]\n    fn known_dist(\u0026self) -\u003e Option\u003cusize\u003e {\n        self.states.get(self.max_block).map(|s| s.dist)\n    }\n}\n\n#[derive(Default)]\npub(super) struct LongStatesHandler\u003c'a\u003e {\n    n_blocks: usize,\n    _a: PhantomData\u003c\u0026'a ()\u003e,\n}\n\nimpl\u003c'a\u003e LongStatesHandler\u003c'a\u003e {\n    #[inline]\n    pub fn new() -\u003e Self {\n        LongStatesHandler {\n            n_blocks: 0,\n            _a: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'a, T\u003e StatesHandler\u003c'a, T, usize\u003e for LongStatesHandler\u003c'a\u003e\nwhere\n    T: BitVec + 'a,\n{\n    type TracebackHandler = LongTracebackHandler\u003c'a, T\u003e;\n    type TracebackColumn = States\u003cT\u003e;\n\n    #[inline]\n    fn init(\u0026mut self, n: usize, m: usize) -\u003e usize {\n        let w = word_size::\u003cT\u003e();\n        self.n_blocks = ceil_div(m.to_usize().unwrap(), w);\n        n * self.n_blocks\n    }\n\n    #[inline]\n    fn set_max_state(\u0026self, pos: usize, states: \u0026mut [State\u003cT, usize\u003e]) {\n        let pos = pos * self.n_blocks;\n        for s in states.iter_mut().skip(pos).take(self.n_blocks) {\n            *s = State::max();\n        }\n    }\n\n    #[inline]\n    fn add_state(\n        \u0026self,\n        source: \u0026Self::TracebackColumn,\n        pos: usize,\n        states: \u0026mut [State\u003cT, usize\u003e],\n    ) {\n        let source = \u0026source.states;\n        let pos = pos * self.n_blocks;\n        states[pos..pos + source.len()].clone_from_slice(source);\n\n        if source.len() \u003c self.n_blocks {\n            // When following the traceback path, it can happen that the block to the\n            // left was not computed because it is outside of the band.\n            // In order to prevent the algorithm from going left in this case,\n            // we initialize the block below the last computed block with meaningful\n            // defaults.\n            states[pos + source.len()] = State {\n                dist: usize::max_value(),\n                pv: T::zero(),\n                mv: T::zero(),\n            };\n        }\n    }\n\n    #[inline]\n    fn init_traceback(\n        \u0026self,\n        m: usize,\n        pos: usize,\n        states: \u0026'a [State\u003cT, usize\u003e],\n    ) -\u003e Self::TracebackHandler {\n        LongTracebackHandler::new(self.n_blocks, m, pos, states)\n    }\n}\n\ntype RevColIter\u003c'a, T\u003e = iter::Rev\u003cslice::Chunks\u003c'a, State\u003cT, usize\u003e\u003e\u003e;\n\npub(super) struct LongTracebackHandler\u003c'a, T: BitVec\u003e {\n    states_iter: iter::Chain\u003cRevColIter\u003c'a, T\u003e, iter::Cycle\u003cRevColIter\u003c'a, T\u003e\u003e\u003e,\n    block_pos: usize,\n    left_block_pos: usize,\n    col: \u0026'a [State\u003cT, usize\u003e],\n    left_col: \u0026'a [State\u003cT, usize\u003e],\n    block: State\u003cT, usize\u003e,\n    left_block: State\u003cT, usize\u003e,\n    left_max_mask: T,\n    pos_bitvec: T,\n    left_mask: T,\n    _a: PhantomData\u003c\u0026'a ()\u003e,\n}\n\nimpl\u003c'a, T: BitVec\u003e LongTracebackHandler\u003c'a, T\u003e {\n    #[inline]\n    fn new(n_blocks: usize, m: usize, pos: usize, states: \u0026'a [State\u003cT, usize\u003e]) -\u003e Self {\n        let mut last_m = m.to_usize().unwrap() % word_size::\u003cT\u003e();\n        if last_m == 0 {\n            last_m = word_size::\u003cT\u003e();\n        }\n        let mask0 = T::one() \u003c\u003c (last_m - 1);\n\n        let pos = n_blocks * (pos + 1);\n        let mut states_iter = states[..pos]\n            .chunks(n_blocks)\n            .rev()\n            .chain(states.chunks(n_blocks).rev().cycle());\n\n        let col = states_iter.next().unwrap();\n        let left_col = states_iter.next().unwrap();\n\n        // This bit mask is supplied to State::adjust_by_mask() in order to adjust the distance\n        // of the left block. It is adjusted with every `move_up_left`\n        let left_mask = if last_m != 1 {\n            T::zero()\n        } else {\n            T::from_usize(0b10).unwrap()\n        };\n\n        LongTracebackHandler {\n            block_pos: n_blocks - 1,\n            left_block_pos: n_blocks - 1,\n            block: col.last().unwrap().clone(),\n            left_block: left_col.last().unwrap().clone(),\n            col,\n            left_col,\n            states_iter,\n            pos_bitvec: mask0,\n            left_mask,\n            left_max_mask: mask0,\n            _a: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'a, T: BitVec + 'a\u003e TracebackHandler\u003c'a, T, usize\u003e for LongTracebackHandler\u003c'a, T\u003e {\n    #[inline]\n    fn block(\u0026self) -\u003e \u0026State\u003cT, usize\u003e {\n        \u0026self.block\n    }\n\n    #[inline]\n    fn block_mut(\u0026mut self) -\u003e \u0026mut State\u003cT, usize\u003e {\n        \u0026mut self.block\n    }\n\n    #[inline]\n    fn left_block(\u0026self) -\u003e \u0026State\u003cT, usize\u003e {\n        \u0026self.left_block\n    }\n\n    #[inline]\n    fn left_block_mut(\u0026mut self) -\u003e \u0026mut State\u003cT, usize\u003e {\n        \u0026mut self.left_block\n    }\n\n    #[inline]\n    fn pos_bitvec(\u0026self) -\u003e T {\n        self.pos_bitvec\n    }\n\n    #[inline]\n    fn move_up(\u0026mut self, adjust_dist: bool) {\n        // If the block boundary has not been reached yet, we can shift to the\n        // upper position. Otherwise, we move to a new block (if there is one!)\n        if self.pos_bitvec != T::one() || self.block_pos == 0 {\n            if adjust_dist {\n                self.block.adjust_dist(self.pos_bitvec);\n            }\n            self.pos_bitvec \u003e\u003e= 1;\n        } else {\n            // move to upper block\n            self.pos_bitvec = T::one() \u003c\u003c (word_size::\u003cT\u003e() - 1);\n            self.block_pos -= 1;\n            if adjust_dist {\n                self.block = self.col[self.block_pos].clone();\n            }\n        }\n    }\n\n    #[inline]\n    fn move_up_left(\u0026mut self, adjust_dist: bool) {\n        // If the block boundary has not been reached yet, we can extend the range mask by\n        // activating a new bit.\n        // However, we switch to a new block (if there is one!) before the mask would cover\n        // the whole block.\n        if self.left_mask \u0026 T::from_usize(0b10).unwrap() == T::zero() || self.left_block_pos == 0 {\n            self.left_mask = (self.left_mask \u003e\u003e 1) | self.left_max_mask;\n            if adjust_dist {\n                self.left_block.adjust_dist(self.pos_bitvec);\n            }\n        } else {\n            self.left_max_mask = T::one() \u003c\u003c (word_size::\u003cT\u003e() - 1);\n            self.left_mask = T::zero();\n            self.left_block_pos -= 1;\n            if adjust_dist {\n                self.left_block = self.left_col[self.left_block_pos].clone();\n            }\n        }\n    }\n\n    #[inline]\n    fn move_to_left(\u0026mut self) {\n        self.col = self.left_col;\n        self.left_col = self.states_iter.next().unwrap();\n        self.block = replace(\n            \u0026mut self.left_block,\n            self.left_col[self.left_block_pos].clone(),\n        );\n        self.left_block.adjust_by_mask(self.left_mask);\n    }\n\n    #[inline]\n    fn move_left_down_if_better(\u0026mut self) -\u003e bool {\n        if self.left_mask != T::zero() {\n            // simple case: not at block boundary\n            if self.left_block.mv \u0026 self.pos_bitvec != T::zero() {\n                self.left_block.dist -= 1;\n                return true;\n            }\n        } else if let Some(b) = self.left_col.get(self.left_block_pos + 1) {\n            // more complicated: at lower block boundary, and there is a lower block\n            if b.mv \u0026 T::one() == T::one() {\n                let d = self.left_block().dist - 1;\n                self.left_block = b.clone();\n                self.left_block.dist = d;\n                return true;\n            }\n        }\n        false\n    }\n\n    #[inline]\n    fn column_slice(\u0026self) -\u003e \u0026[State\u003cT, usize\u003e] {\n        self.col\n    }\n\n    #[inline]\n    fn finished(\u0026self) -\u003e bool {\n        self.pos_bitvec == T::zero() \u0026\u0026 self.block_pos == 0\n    }\n}\n\nimpl_myers!(\n    usize,\n    Myers\u003cT\u003e,\n    crate::pattern_matching::myers::long::States\u003cT\u003e,\n    crate::pattern_matching::myers::long::LongStatesHandler\u003c'a\u003e\n);\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    impl_tests!(super, u8, usize, build_64);\n\n    #[test]\n    fn test_myers_long_overflow() {\n        let pattern = b\"AAGACGAGAAAAGAAAGTCTAAAGGACTTTTGTGGCAAGACCATCCCTGTTCCCAACCCGACCCCTGGACCTCCCGCCCCGGGCACTCCCGACCCCCCGACCCCCCGACTCCTGGACCAGGAGACTGA\";\n        let text = b\"GGCAAGGGGGACTGTAGATGGGTGAAAAGAGCAGTCAGGGACCAGGTCCTCAGCCCCCCAGCCCCCCAGCCCTCCAGGTCCCCAGCCCTCCAGGTCCCCAGCCCAACCCTTGTCCTTACCAGAACGTTGTTTTCAGGAAGTCTGAAAGACAAGAGCAGAAAGTCAGTCCCATGGAATTTTCGCTTCCCACAG\".to_vec();\n\n        let myers: Myers\u003cu64\u003e = Myers::new(pattern.iter().cloned());\n\n        let hits: Vec\u003c_\u003e = myers.find_all_end(text, usize::max_value() - 64).collect();\n        dbg!(hits);\n    }\n}\n","traces":[{"line":46,"address":[5262016,5262144,5262288,5262080,5262224],"length":1,"stats":{"Line":5},"fn_name":"new\u003cu8,\u0026[u8; 7],\u0026u8\u003e"},{"line":52,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":500,"address":[7393157,7391904],"length":1,"stats":{"Line":3},"fn_name":"test_myers_long_overflow"},{"line":501,"address":[7391911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":502,"address":[7391942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":504,"address":[7391976,7392131],"length":1,"stats":{"Line":2},"fn_name":null},{"line":506,"address":[7392399,7392138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":507,"address":[7392415],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":164,"coverable":184},{"path":["/","home","todd","rust-bio","src","pattern_matching","myers","mod.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Myers bit-parallel approximate pattern matching algorithm.\n//! Finds all matches up to a given edit distance. The pattern has to fit into a bitvector,\n//! and is thus limited to 64 or (since stable Rust version 1.26) to 128 symbols.\n//! Complexity: O(n)\n//!\n//! Traceback allows obtaining the starting position and the alignment path of the hit.\n//! Its implementation is somehow similar to the one by Edlib (Šošić and Šikić 2017),\n//! although there can be small differences when there is more than one possible alignment\n//! path with then same edit distance at a position: Edlib prefers to make insertions\n//! and deletions to the pattern (query) over substitutions\n//! (Insertion \u003e Deletion \u003e Substitution) while our implementation prefers substitutions\n//! (Substitution \u003e Insertion \u003e Deletion).\n//!\n//! *Myers, G. (1999). A fast bit-vector algorithm for approximate string matching based on dynamic\n//!  programming. Journal of the ACM (JACM) 46, 395–415.*\n//!\n//! *Šošić, M., and Šikić, M. (2017). Edlib: a C/C ++ library for fast, exact sequence alignment\n//! using edit distance. Bioinformatics 33, 1394–1395.*\n//!\n//! # Example\n//!\n//! Iterating over matches in pairs of `(end, distance)` using `u64` as bitvector type:\n//!\n//! ```\n//! # extern crate bio;\n//! use bio::pattern_matching::myers::Myers;\n//!\n//! # fn main() {\n//! let text = b\"CGGTCCTGAGGGATTAGCAC\";\n//! let pattern = b\"TCCTAGGGC\";\n//!\n//! let myers = Myers::\u003cu64\u003e::new(pattern);\n//! let occ: Vec\u003c_\u003e = myers.find_all_end(text, 2).collect();\n//!\n//! assert_eq!(occ, [(11, 2), (12, 2)]);\n//! # }\n//! ```\n//!\n//! Starting with stable Rust 1.26, it is also possible to use `u128` as bitvector\n//! (`Myers::\u003cu128\u003e`), which enables longer patterns, but is somewhat slower.\n//!\n//! # Long patterns\n//!\n//! With the default implementation, query (pattern) length is limited by the size of the\n//! bit-vector; 64 symbols for `Myers::\u003cu64\u003e`. Patterns longer than 128 symbols (when using\n//! `u128` as bit-vector) can only be handled by using the block-based Myers implementation,\n//! which lives in the [`long`](long/index.html) submodule. An example:\n//!\n//! ```\n//! # extern crate bio;\n//! use bio::pattern_matching::myers::{long, Myers};\n//!\n//! # fn main() {\n//! let text = b\"CGGTCCTGAGGGATTAGCAC\";\n//! let pattern = b\"TCCTAGGGC\";\n//!\n//! let myers_64 = Myers::\u003cu64\u003e::new(pattern);\n//! let occ_64: Vec\u003c_\u003e = myers_64.find_all_end(text, 2).collect();\n//!\n//! // the pattern of length 9 is too long to fit into a single `u8` bit-vector\n//! // (panics!)\n//! // let myers_8 = Myers::\u003cu8\u003e::new(pattern);\n//!\n//! // However, we can use the block-based implementation with `u8` bit-vectors\n//! let myers_long_8 = long::Myers::\u003cu8\u003e::new(pattern);\n//! let occ_long_8: Vec\u003c_\u003e = myers_long_8\n//!     .find_all_end(text, 2)\n//!     .map(|(end, dist)| (end, dist as u8))\n//!     .collect();\n//!\n//! assert_eq!(occ_64, occ_long_8);\n//! # }\n//! ```\n//! Note that `u8` just used for demonstration, using `u64` is still the best in most cases.\n//!\n//! # Obtaining the starting position of a match\n//!\n//! The `Myers::find_all` method provides an iterator over tuples of `(start, end, distance)`.\n//! Calculating the starting position requires finding the alignment path, therefore this is\n//! slower than `Myers::find_all_end`. Note that the end positions differ from above by one.\n//! This is intentional, as the iterator returns a range rather an index, and ranges in Rust\n//! do not include the end position by default.\n//!\n//! ```\n//! # extern crate bio;\n//! use bio::pattern_matching::myers::Myers;\n//!\n//! # fn main() {\n//! let text = b\"CGGTCCTGAGGGATTAGCAC\";\n//! let pattern = b\"TCCTAGGGC\";\n//!\n//! let mut myers = Myers::\u003cu64\u003e::new(pattern);\n//! let occ: Vec\u003c_\u003e = myers.find_all(text, 2).collect();\n//!\n//! assert_eq!(occ, [(3, 12, 2), (3, 13, 2)]);\n//! # }\n//! ```\n//!\n//! # Obtaining alignments\n//!\n//! [`FullMatches`](struct.FullMatches.html) returned by `Myers::find_all()` also provide a method\n//! for obtaining an alignment path:\n//!\n//! ```\n//! # extern crate bio;\n//! use bio::alignment::Alignment;\n//! use bio::pattern_matching::myers::Myers;\n//!\n//! # fn main() {\n//! let text = b\"CGGTCCTGAGGGATTAGCAC\";\n//! let pattern = b\"TCCTAGGGC\";\n//!\n//! let mut myers = Myers::\u003cu64\u003e::new(pattern);\n//! // create an 'empty' alignment instance, which can be reused\n//! let mut aln = Alignment::default();\n//!\n//! let mut matches = myers.find_all(text, 3);\n//! while matches.next_alignment(\u0026mut aln) {\n//!     //println!(\"Hit fond in range: {}..{} (distance: {})\", aln.ystart, aln.yend, aln.score);\n//!     //println!(\"{}\", aln.pretty(pattern, text));\n//! }\n//! # }\n//! ```\n//! **Output:**\n//!\n//! \u003cpre\u003e\n//! Hit fond in range: 3..10 (distance: 3)\n//!    TCCTAGGGC\n//!    ||||+|\\|+\n//! TCCTCCT-GAG-GGATTAGCAC\n//!\n//! Hit fond in range: 3..11 (distance: 3)\n//!    TCCTAGGGC\n//!    ||||+|\\|\\\n//! TCCTCCT-GAGGGATTAGCAC\n//!\n//! Hit fond in range: 3..12 (distance: 2)\n//!    TCCT-AGGGC\n//!    ||||x||||+\n//! TCCTCCTGAGGG-ATTAGCAC\n//!\n//! Hit fond in range: 3..13 (distance: 2)\n//!    TCCT-AGGGC\n//!    ||||x||||\\\n//! TCCTCCTGAGGGATTAGCAC\n//!\n//! ... (truncated)\n//!\n//! \u003c/pre\u003e\n//!\n//! **Note** that the [`Alignment`](../../alignment/struct.Alignment.html) instance is only created\n//! once and then reused. Because the Myers algorithm is very fast, the allocation necessary for\n//! `Alignment::operations` can have a non-negligible impact on performance; and thus, recycling\n//! makes sense.\n//!\n//! # Finding the best hit\n//!\n//! In many cases, only the match with the smallest edit distance is actually of interest.\n//! Calculating an alignment for every hit is therefore not necessary.\n//! [`LazyMatches`](struct.LazyMatches.html) returned by `Myers::find_all_lazy()`\n//! provide an iterator over tuples of `(end, distance)` like `Myers::find_all_end()`, but\n//! additionally keep the data necessary for calculating the alignment path later at any desired\n//! position. Storing the data itself has a slight performance impact and requires more memory\n//! compared to `Myers::find_all_end()` [O(n) as opposed to O(m + k)]. Still the following code\n//! is faster than using `FullMatches`:\n//!\n//! ```\n//! # extern crate bio;\n//! use bio::alignment::Alignment;\n//! use bio::pattern_matching::myers::Myers;\n//!\n//! # fn main() {\n//! let text = b\"CGGTCCTGAGGGATTAGCAC\";\n//! let pattern = b\"TCCTAGGGC\";\n//!\n//! let mut myers = Myers::\u003cu64\u003e::new(pattern);\n//! let mut aln = Alignment::default();\n//!\n//! let mut matches = myers.find_all_lazy(text, 2);\n//!\n//! // first, find the best hit\n//! let (best_end, _) = matches.by_ref().min_by_key(|\u0026(_, dist)| dist).unwrap();\n//!\n//! // now calculate the alignment\n//! matches.alignment_at(best_end, \u0026mut aln);\n//! println!(\n//!     \"Best alignment at {}..{} (distance: {})\",\n//!     aln.ystart, aln.yend, aln.score\n//! );\n//! println!(\"{}\", aln.pretty(pattern, text));\n//! # }\n//! ```\n//!\n//! **Output:**\n//!\n//! \u003cpre\u003e\n//! Best alignment at 3..12 (distance: 2)\n//!    TCCT-AGGGC\n//!    ||||x||||+\n//! TCCTCCTGAGGG-ATTAGCAC\n//! \u003c/pre\u003e\n//!\n//! Actually as seen in the previous chapters, there are two hits with the same distance of 2.\n//! It may make sense to consider both of them.\n//!\n//! # Dealing with ambiguities\n//!\n//! Matching multiple or all symbols at once can be achieved using `MyersBuilder`. This example\n//! allows `N` in the search pattern to match all four DNA bases in the text:\n//!\n//! ```\n//! # extern crate bio;\n//! use bio::pattern_matching::myers::MyersBuilder;\n//!\n//! # fn main() {\n//! let text = b\"GTCTGATCTTACC\";\n//! let pattern = b\"TGATCNT\";\n//!\n//! let myers = MyersBuilder::new().ambig(b'N', b\"ACGT\").build_64(pattern);\n//! assert_eq!(myers.distance(text), 0);\n//! # }\n//! ```\n//!\n//! For more examples see the documentation of [`MyersBuilder`](struct.MyersBuilder.html).\n\n#[macro_use]\nmod myers_impl;\nmod builder;\nmod helpers;\n#[cfg(test)]\n#[macro_use]\npub(crate) mod common_tests;\npub mod long;\nmod simple;\nmod traceback;\n\npub use self::builder::MyersBuilder;\npub use self::helpers::*;\nuse self::myers_impl::*;\npub use self::simple::*;\n\n#[cfg(test)]\nmod tests {\n    // from common_tests.rs\n    impl_tests!(super, u64, u8, build_64);\n\n    use std::iter::repeat;\n\n    #[test]\n    #[should_panic(expected = \"Pattern too long\")]\n    fn test_pattern_too_long() {\n        let pattern: Vec\u003c_\u003e = repeat(b'T').take(65).collect();\n        super::Myers::\u003cu8\u003e::new(\u0026pattern);\n    }\n\n    #[test]\n    #[should_panic(expected = \"Pattern too long\")]\n    fn test_pattern_too_long_builder() {\n        let pattern: Vec\u003c_\u003e = repeat(b'T').take(65).collect();\n        super::MyersBuilder::new().build_64(\u0026pattern);\n    }\n}\n","traces":[{"line":256,"address":[9073136,9073280],"length":1,"stats":{"Line":4},"fn_name":"test_pattern_too_long"},{"line":257,"address":[9073143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[9073213],"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[9073312,9073531],"length":1,"stats":{"Line":4},"fn_name":"test_pattern_too_long_builder"},{"line":264,"address":[9073319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[9073387,9073459],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","todd","rust-bio","src","pattern_matching","myers","myers_impl.rs"],"content":"use crate::pattern_matching::myers::{BitVec, DistType};\nuse num_traits::ToPrimitive;\n\n/// The current algorithm state.\n#[derive(Clone, Default, Debug)]\npub(crate) struct State\u003cT, D\u003e\nwhere\n    T: BitVec,\n    D: std::fmt::Debug,\n{\n    pub pv: T,\n    pub mv: T,\n    pub dist: D,\n}\n\nimpl\u003cT, D\u003e State\u003cT, D\u003e\nwhere\n    T: BitVec,\n    D: DistType,\n{\n    /// Create and initiate leftmost block given the maximum pattern length\n    // it should represent (m)\n    #[inline]\n    pub fn init(m: D) -\u003e Self {\n        State {\n            pv: T::max_value(),\n            mv: T::zero(),\n            dist: m,\n        }\n    }\n\n    #[inline]\n    pub fn max() -\u003e Self {\n        Self::init(D::max_value())\n    }\n\n    #[inline]\n    pub fn known_dist(\u0026self) -\u003e Option\u003cD\u003e {\n        Some(self.dist)\n    }\n\n    pub fn is_new(\u0026self) -\u003e bool {\n        self.dist == D::zero() \u0026\u0026 self.pv == T::zero() \u0026\u0026 self.mv == T::zero()\n    }\n\n    pub fn is_max(\u0026self) -\u003e bool {\n        self.pv \u003e= (T::max_value() \u003e\u003e 1) \u0026\u0026 self.mv == T::zero()\n    }\n\n    // Adjust the distance of the block ('moving the cursor up in the traceback matrix')\n    // given a range bit mask that specifies which positions should be crossed.\n    #[inline]\n    pub fn adjust_by_mask(\u0026mut self, mask: T) {\n        let p = (self.pv \u0026 mask).count_ones();\n        let m = (self.mv \u0026 mask).count_ones();\n        let mut dist = self.dist.to_u64().unwrap();\n        dist = dist.wrapping_add(m.to_u64().unwrap());\n        dist = dist.wrapping_sub(p.to_u64().unwrap());\n        self.dist = D::from_u64(dist).unwrap();\n    }\n\n    #[inline]\n    pub fn adjust_dist(\u0026mut self, pos_mask: T) {\n        //debug_assert!(!self.is_max());\n        if self.pv \u0026 pos_mask != T::zero() {\n            self.dist -= D::one();\n        } else if self.mv \u0026 pos_mask != T::zero() {\n            self.dist += D::one();\n        }\n\n        // not faster:\n        // let diff = ((self.mv \u0026 pos_mask) != T::zero()) as isize - ((self.pv \u0026 pos_mask) != T::zero()) as isize;\n        // self.dist = D::from_usize(self.dist.to_usize().unwrap().wrapping_add(diff as usize)).unwrap();\n    }\n\n    /// This method may be used for performance comparison instead of adjust_by_mask()\n    #[inline]\n    #[allow(dead_code)]\n    pub fn adjust_many(\u0026mut self, pos_mask: T, n: usize) {\n        let mut pos_mask = pos_mask;\n        for _ in 0..n {\n            self.adjust_dist(pos_mask);\n            pos_mask \u003c\u003c= 1;\n        }\n    }\n\n    /// Writes a distance matrix column to the vector 'out'\n    /// (excluding the uppermost state distance).\n    /// This is done in a reverse order (lowest / highest value first).\n    /// Used for debugging.\n    pub fn write_dist_column(\u0026self, m: usize, out: \u0026mut Vec\u003cD\u003e) {\n        let mut pos_mask = T::one() \u003c\u003c (m - 1);\n        let mut dist = self.dist;\n        for _ in 0..m {\n            out.push(dist);\n            if dist != D::max_value() {\n                if self.pv \u0026 pos_mask != T::zero() {\n                    dist -= D::one();\n                } else if self.mv \u0026 pos_mask != T::zero() {\n                    dist += D::one();\n                }\n            }\n            pos_mask \u003e\u003e= 1;\n        }\n    }\n}\n\n#[rustfmt::skip]\n// rustfmt::skip prevents automatic indentation.\n// This is not optimal, as no checks are done at all..\nmacro_rules! impl_myers {\n    ($DistType:ty, $Myers:ty, $State:ty, $TbHandler:ty) =\u003e {\n        mod myers_impl {\n// Macro implementing common methods in Myers object. Wrapped in a module\n// and then re-exported from there to avoid mixing of namespaces.\n// Indented at top level for readability.\n\nuse super::Myers;\nuse crate::pattern_matching::myers::traceback::Traceback;\nuse crate::pattern_matching::myers::{update_aln, BitVec};\nuse crate::alignment::{Alignment, AlignmentOperation};\n#[allow(unused_imports)] // Bounded is required for \u003c$DistType\u003e::max_value()\nuse num_traits::{Bounded, ToPrimitive};\nuse std::borrow::Borrow;\nuse std::cmp::min;\nuse std::iter;\n\nimpl\u003cT: BitVec\u003e $Myers {\n    // Combining these two steps into one function seems beneficial for performance\n    fn step_trace\u003c'a\u003e(\n        \u0026mut self,\n        mut state: \u0026mut $State,\n        a: u8,\n        max_dist: $DistType,\n        traceback: \u0026mut Traceback\u003c'a, T, $DistType, $TbHandler\u003e,\n    ) {\n        self.step(\u0026mut state, a, max_dist);\n        traceback.add_state(\u0026state, \u0026mut self.states_store);\n    }\n\n    /// Calculate the global distance of the pattern to the given text.\n    pub fn distance\u003cC, I\u003e(\u0026self, text: I) -\u003e $DistType\n    where\n        C: Borrow\u003cu8\u003e,\n        I: IntoIterator\u003cItem = C\u003e,\n    {\n        let max_dist = \u003c$DistType\u003e::max_value();\n        let mut dist = max_dist;\n        let m = self.m;\n        let mut state = self.initial_state(m, max_dist);\n        for a in text {\n            self.step(\u0026mut state, *a.borrow(), max_dist);\n            if let Some(d) = state.known_dist() {\n                if d \u003c dist {\n                    dist = d;\n                }\n            }\n        }\n        dist\n    }\n\n    /// Finds all matches of pattern in the given text up to a given maximum distance.\n    /// Matches are returned as an iterator over pairs of end position and distance.\n    pub fn find_all_end\u003cC, I\u003e(\n        \u0026self,\n        text: I,\n        max_dist: $DistType,\n    ) -\u003e Matches\u003cT, C, I::IntoIter\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        I: IntoIterator\u003cItem = C\u003e,\n    {\n        Matches::new(self, text.into_iter(), max_dist)\n    }\n\n    /// Find the best match of the pattern in the given text.\n    /// if multiple end positions have the same distance, the first is returned.\n    pub fn find_best_end\u003cC, I\u003e(\u0026self, text: I) -\u003e (usize, $DistType)\n    where\n        C: Borrow\u003cu8\u003e,\n        I: IntoIterator\u003cItem = C\u003e,\n    {\n        self.find_all_end(text, \u003c$DistType\u003e::max_value())\n            .min_by_key(|\u0026(_, dist)| dist)\n            .unwrap()\n    }\n\n    /// Finds all matches of pattern in the given text up to a given maximum distance.\n    /// In contrast to `find_all_end`, matches are returned as an iterator over ranges\n    /// of `(start, end, distance)`. Note that the end coordinate is not included in the\n    /// range and thus and thus greater by one compared to the end index returned by\n    /// `find_all_end()`.\n    pub fn find_all\u003cC, I\u003e(\n        \u0026mut self,\n        text: I,\n        max_dist: $DistType,\n    ) -\u003e FullMatches\u003c'_, T, C, I::IntoIter\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        I: IntoIterator\u003cItem = C\u003e,\n        I::IntoIter: ExactSizeIterator,\n    {\n        FullMatches::new(self, text.into_iter(), max_dist)\n    }\n\n    /// As `find_all_end`, this function returns an iterator over tuples of `(end, distance)`.\n    /// Additionally, it keeps the data necessary for later obtaining the starting positions and/or\n    /// the alignment path at *any* position that was already searched.\n    pub fn find_all_lazy\u003cC, I\u003e(\n        \u0026mut self,\n        text: I,\n        max_dist: $DistType,\n    ) -\u003e LazyMatches\u003c'_, T, C, I::IntoIter\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        I: IntoIterator\u003cItem = C\u003e,\n        I::IntoIter: ExactSizeIterator,\n    {\n        LazyMatches::new(self, text.into_iter(), max_dist)\n    }\n}\n\n/// Iterator over pairs of end positions and distance of matches.\npub struct Matches\u003c'a, T, C, I\u003e\nwhere\n    T: BitVec,\n    C: Borrow\u003cu8\u003e,\n    I: Iterator\u003cItem = C\u003e,\n{\n    myers: \u0026'a $Myers,\n    state: $State,\n    text: iter::Enumerate\u003cI\u003e,\n    max_dist: $DistType,\n}\n\nimpl\u003c'a, T, C, I\u003e Matches\u003c'a, T, C, I\u003e\nwhere\n    T: BitVec,\n    C: Borrow\u003cu8\u003e,\n    I: Iterator\u003cItem = C\u003e,\n{\n    fn new(myers: \u0026'a Myers\u003cT\u003e, text: I, max_dist: $DistType) -\u003e Self {\n        let m = myers.m;\n        let state = myers.initial_state(m, max_dist);\n        Matches {\n            myers,\n            state,\n            text: text.enumerate(),\n            max_dist,\n        }\n    }\n}\n\nimpl\u003c'a, T, C, I\u003e Iterator for Matches\u003c'a, T, C, I\u003e\nwhere\n    T: BitVec,\n    C: Borrow\u003cu8\u003e,\n    I: Iterator\u003cItem = C\u003e,\n{\n    type Item = (usize, $DistType);\n\n    fn next(\u0026mut self) -\u003e Option\u003c(usize, $DistType)\u003e {\n        for (i, a) in self.text.by_ref() {\n            self.myers.step(\u0026mut self.state, *a.borrow(), self.max_dist);\n            if let Some(dist) = self.state.known_dist() {\n                if dist \u003c= self.max_dist {\n                    return Some((i, dist));\n                }\n            }\n        }\n        None\n    }\n}\n\n/// Iterator over tuples of starting position, end position and distance of matches. In addition,\n/// methods for obtaining the hit alignment path are provided.\npub struct FullMatches\u003c'a, T, C, I\u003e\nwhere\n    T: BitVec,\n    C: Borrow\u003cu8\u003e,\n    I: Iterator\u003cItem = C\u003e,\n{\n    myers: \u0026'a mut $Myers,\n    traceback: Traceback\u003c'a, T, $DistType, $TbHandler\u003e,\n    state: $State,\n    text: iter::Enumerate\u003cI\u003e,\n    text_len: usize,\n    m: $DistType,\n    max_dist: $DistType,\n    pos: usize, // current end position, has to be stored for alignment() method\n    unsuccessfully_finished: bool,\n}\n\nimpl\u003c'a, T, C, I\u003e FullMatches\u003c'a, T, C, I\u003e\nwhere\n    T: 'a + BitVec,\n    C: Borrow\u003cu8\u003e,\n    I: Iterator\u003cItem = C\u003e + ExactSizeIterator,\n{\n    fn new(myers: \u0026'a mut $Myers, text_iter: I, max_dist: $DistType) -\u003e Self {\n        let state = myers.initial_state(myers.m, max_dist);\n        // Calculate maximum number of traceback columns possibly used by a match\n        let m = myers.m.to_usize().unwrap();\n        let num_cols = m + min(max_dist.to_usize().unwrap(), m);\n        let tb = Traceback::new(\n            \u0026mut myers.states_store,\n            \u0026state,\n            num_cols.to_usize().unwrap(),\n            myers.m,\n            \u003c$TbHandler\u003e::new(),\n        );\n        FullMatches {\n            m: myers.m,\n            myers,\n            traceback: tb,\n            state,\n            text_len: text_iter.len(),\n            text: text_iter.enumerate(),\n            max_dist,\n            pos: 0,\n            unsuccessfully_finished: false,\n        }\n    }\n\n    /// Searches the next match and returns a tuple of end position and distance\n    /// if found. This involves *no* searching for a starting position and is thus\n    /// faster than just iterating over `FullMatches`\n    #[inline]\n    pub fn next_end(\u0026mut self) -\u003e Option\u003c(usize, $DistType)\u003e {\n        for (i, a) in self.text.by_ref() {\n            self.pos = i; // used in alignment()\n            self.myers.step_trace(\n                \u0026mut self.state,\n                *a.borrow(),\n                self.max_dist,\n                \u0026mut self.traceback,\n            );\n            if let Some(dist) = self.state.known_dist() {\n                if dist \u003c= self.max_dist {\n                    return Some((i, dist));\n                }\n            }\n        }\n        self.unsuccessfully_finished = true;\n        None\n    }\n\n    /// Searches the next match and returns a tuple of starting position, end position and\n    /// distance, or `None` if no match was found. In addition, the alignment path is added to\n    /// `ops`. Existing data in the vector will be cleared beforehand.\n    #[inline]\n    pub fn next_path(\n        \u0026mut self,\n        ops: \u0026mut Vec\u003cAlignmentOperation\u003e,\n    ) -\u003e Option\u003c(usize, usize, $DistType)\u003e {\n        self.next_end()\n            .map(|(end, dist)| (self.path(ops).unwrap(), end + 1, dist))\n    }\n\n    /// Like `FullMatches::path_reverse()`, but the operations will be in reverse order. This\n    /// is slightly faster, as the traceback algorithm adds them in reverse order,\n    /// and `path()` needs to reverse them. Existing data in the vector will be cleared\n    /// beforehand.\n    #[inline]\n    pub fn next_path_reverse(\n        \u0026mut self,\n        ops: \u0026mut Vec\u003cAlignmentOperation\u003e,\n    ) -\u003e Option\u003c(usize, usize, $DistType)\u003e {\n        self.next_end()\n            .map(|(end, dist)| (self.path_reverse(ops).unwrap(), end + 1, dist))\n    }\n\n    /// Searches the next match and updates the given `Alignment` with its position\n    /// and alignment path if found. The distance is stored in `Alignment::score`.\n    /// If no next hit is found, `false` is returned and `aln` remains unchanged.\n    #[inline]\n    pub fn next_alignment(\u0026mut self, aln: \u0026mut Alignment) -\u003e bool {\n        if self.next_end().is_some() {\n            self.alignment(aln);\n            return true;\n        }\n        false\n    }\n\n    /// Returns the starting position of the current hit. If the search is finished and no hit was\n    /// found, `None` is returned.\n    #[inline]\n    pub fn start(\u0026self) -\u003e Option\u003cusize\u003e {\n        if self.unsuccessfully_finished {\n            return None;\n        }\n        let (len, _) = self.traceback.traceback(None, \u0026self.myers.states_store);\n        Some(self.pos + 1 - len.to_usize().unwrap())\n    }\n\n    /// Adds the path of the current hit alignment to `ops` and returns the starting position of\n    /// the current hit. If the search is finished and no hit was found, `None` is returned.\n    /// Adds the path of the current hit alignment to `ops` and returns the starting position of\n    /// the current hit. If the search is finished and no hit was found, `None` is returned.\n    /// Existing data in the vector will be cleared beforehand.\n    #[inline]\n    pub fn path(\u0026self, ops: \u0026mut Vec\u003cAlignmentOperation\u003e) -\u003e Option\u003cusize\u003e {\n        self.path_reverse(ops).map(|pos| {\n            ops.reverse();\n            pos\n        })\n    }\n\n    /// Like `FullMatches::path()`, but the operations will be in reverse order. This\n    /// is slightly faster, as the traceback algorithm adds them in reverse order,\n    /// and `path()` needs to reverse them.\n    /// Existing data in the vector will be cleared beforehand.\n    #[inline]\n    pub fn path_reverse(\u0026self, ops: \u0026mut Vec\u003cAlignmentOperation\u003e) -\u003e Option\u003cusize\u003e {\n        if self.unsuccessfully_finished {\n            return None;\n        }\n        ops.clear();\n        let (len, _) = self\n            .traceback\n            .traceback(Some(ops), \u0026self.myers.states_store);\n        Some(self.pos + 1 - len.to_usize().unwrap())\n    }\n\n    /// Updates the given `Alignment` with its position and alignment path. The edit distance is\n    /// stored in `Alignment::score`. If no hit has been found yet, then `false` will be returned\n    /// and nothing is done.\n    #[inline]\n    pub fn alignment(\u0026mut self, aln: \u0026mut Alignment) -\u003e bool {\n        if self.unsuccessfully_finished {\n            return false;\n        }\n        if let Some(dist) = self.state.known_dist() {\n            aln.operations.clear();\n            let (len, _) = self\n                .traceback\n                .traceback(Some(\u0026mut aln.operations), \u0026self.myers.states_store);\n            aln.operations.reverse();\n            update_aln(\n                self.pos,\n                len.to_usize().unwrap(),\n                self.text_len,\n                dist.to_usize().unwrap(), //self.state.dist().to_usize().unwrap(),\n                self.m.to_usize().unwrap(),\n                aln,\n            );\n            true\n        } else {\n            false\n        }\n    }\n}\n\nimpl\u003c'a, T, C, I\u003e Iterator for FullMatches\u003c'a, T, C, I\u003e\nwhere\n    T: 'a + BitVec,\n    C: Borrow\u003cu8\u003e,\n    I: Iterator\u003cItem = C\u003e + ExactSizeIterator,\n{\n    type Item = (usize, usize, $DistType);\n\n    #[inline]\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.next_end()\n            .map(|(end, dist)| (self.start().unwrap(), end + 1, dist))\n    }\n}\n\n/// Iterator over tuples of end position and distance of matches. In addition,\n/// methods for obtaining the hit alignment path are provided.\npub struct LazyMatches\u003c'a, T, C, I\u003e\nwhere\n    T: BitVec,\n    C: Borrow\u003cu8\u003e,\n    I: Iterator\u003cItem = C\u003e,\n{\n    myers: \u0026'a mut $Myers,\n    traceback: Traceback\u003c'a, T, $DistType, $TbHandler\u003e,\n    state: $State,\n    text: iter::Enumerate\u003cI\u003e,\n    text_len: usize,\n    m: $DistType,\n    max_dist: $DistType,\n}\n\nimpl\u003c'a, T, C, I\u003e Iterator for LazyMatches\u003c'a, T, C, I\u003e\nwhere\n    T: BitVec,\n    C: Borrow\u003cu8\u003e,\n    I: Iterator\u003cItem = C\u003e + ExactSizeIterator,\n{\n    type Item = (usize, $DistType);\n\n    fn next(\u0026mut self) -\u003e Option\u003c(usize, $DistType)\u003e {\n        for (i, a) in self.text.by_ref() {\n            self.myers.step_trace(\n                \u0026mut self.state,\n                *a.borrow(),\n                self.max_dist,\n                \u0026mut self.traceback,\n            );\n            // self.traceback\n            //     .add_state(\u0026self.state, \u0026mut self.myers.states_store);\n            if let Some(dist) = self.state.known_dist() {\n                if dist \u003c= self.max_dist {\n                    return Some((i, dist));\n                }\n            }\n        }\n        None\n    }\n}\n\nimpl\u003c'a, T, C, I\u003e LazyMatches\u003c'a, T, C, I\u003e\nwhere\n    T: 'a + BitVec,\n    C: Borrow\u003cu8\u003e,\n    I: Iterator\u003cItem = C\u003e + ExactSizeIterator,\n{\n    #[inline]\n    fn new(myers: \u0026'a mut Myers\u003cT\u003e, text_iter: I, max_dist: $DistType) -\u003e Self {\n        let state = myers.initial_state(myers.m, max_dist);\n        let tb = Traceback::new(\n            \u0026mut myers.states_store,\n            \u0026state,\n            text_iter.len(),\n            myers.m,\n            \u003c$TbHandler\u003e::new(),\n        );\n        LazyMatches {\n            m: myers.m,\n            myers,\n            traceback: tb,\n            state,\n            text_len: text_iter.len(),\n            text: text_iter.enumerate(),\n            max_dist,\n        }\n    }\n\n    /// Takes the end position of a hit (as returned by the `LazyMatches` iterator) and returns a\n    /// tuple of the corresponding starting position and the hit distance. If the end position is\n    /// greater than the end position of the previously returned hit, `None` is returned.\n    #[inline]\n    pub fn hit_at(\u0026self, end_pos: usize) -\u003e Option\u003c(usize, $DistType)\u003e {\n        self.traceback\n            .traceback_at(end_pos, None, \u0026self.myers.states_store)\n            .map(|(len, dist)| (end_pos + 1 - len.to_usize().unwrap(), dist))\n    }\n\n    /// Takes the end position of a hit and returns a tuple of the corresponding starting position\n    /// and the hit distance. The alignment path is added to `ops`.\n    /// As in `hit_at`, the end position has to be searched already, otherwise `None` is returned.\n    #[inline]\n    pub fn path_at(\n        \u0026self,\n        end_pos: usize,\n        ops: \u0026mut Vec\u003cAlignmentOperation\u003e,\n    ) -\u003e Option\u003c(usize, $DistType)\u003e {\n        self.path_at_reverse(end_pos, ops).map(|rv| {\n            ops.reverse();\n            rv\n        })\n    }\n\n    /// Like `LazyMatches::path_at()`, but the operations will be in reverse order. This\n    /// is slightly faster, as the traceback algorithm adds them in reverse order,\n    /// and `path_at()` needs to reverse them.\n    #[inline]\n    pub fn path_at_reverse(\n        \u0026self,\n        end_pos: usize,\n        ops: \u0026mut Vec\u003cAlignmentOperation\u003e,\n    ) -\u003e Option\u003c(usize, $DistType)\u003e {\n        self.traceback\n            .traceback_at(end_pos, Some(ops), \u0026self.myers.states_store)\n            .map(|(len, dist)| (end_pos + 1 - len.to_usize().unwrap(), dist))\n    }\n\n    /// Takes the end position of a hit and returns a tuple of the corresponding starting position\n    /// and the hit distance. The alignment `aln` is updated with the position, alignment path\n    /// and distance (stored in `Alignment::score`).\n    /// If the end position has not yet been searched, nothing is done and `false` is returned.\n    /// This function will succeed even if the edit distance at the given position is greater\n    /// than the maximum distance specified when calling `Myers::find_all_lazy`. However, this\n    /// is only true for the implementation with restricted pattern lengths (in module\n    /// `bio::pattern_matching::myers`). The block-based implementation (in the `long`\n    /// submodule) avoids computing blocks with values \u003e max_dist.\n    #[inline]\n    pub fn alignment_at(\u0026self, end_pos: usize, aln: \u0026mut Alignment) -\u003e bool {\n        aln.operations.clear();\n        if let Some((aln_len, dist)) = self.traceback.traceback_at(\n            end_pos,\n            Some(\u0026mut aln.operations),\n            \u0026self.myers.states_store,\n        ) {\n            aln.operations.reverse();\n            update_aln(\n                end_pos,\n                aln_len.to_usize().unwrap(),\n                self.text_len,\n                dist.to_usize().unwrap(),\n                self.m.to_usize().unwrap(),\n                aln,\n            );\n            return true;\n        }\n        false\n    }\n}\n\n// module end\n}\n\npub use myers_impl::*;\n\n// macro end\n};\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[5296944,5297072],"length":1,"stats":{"Line":6},"fn_name":"step_trace\u003cu64\u003e"},{"line":137,"address":[5296984,5297112],"length":1,"stats":{"Line":5},"fn_name":null},{"line":138,"address":[5297002,5297130],"length":1,"stats":{"Line":6},"fn_name":null},{"line":142,"address":[5297200,5297852],"length":1,"stats":{"Line":2},"fn_name":"distance\u003cu8,\u0026u8,\u0026[u8; 8]\u003e"},{"line":147,"address":[5297233],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[5297274],"length":1,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[5297283],"length":1,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[5297307],"length":1,"stats":{"Line":3},"fn_name":null},{"line":151,"address":[5297815,5297551,5297450,5297566,5297360],"length":1,"stats":{"Line":7},"fn_name":null},{"line":152,"address":[5297622],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[5297790,5297701],"length":1,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[5297781,5297805,5297794],"length":1,"stats":{"Line":6},"fn_name":null},{"line":155,"address":[5297800],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[5298000,5297872,5298112],"length":1,"stats":{"Line":5},"fn_name":"find_all_end\u003cu8,\u0026u8,\u0026[u8]\u003e"},{"line":173,"address":[5298145,5298052,5297942],"length":1,"stats":{"Line":5},"fn_name":null},{"line":193,"address":[5298448,5298224,5298336],"length":1,"stats":{"Line":6},"fn_name":"find_all\u003cu64,\u0026u8,\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":203,"address":[5298388,5298276,5298518],"length":1,"stats":{"Line":7},"fn_name":null},{"line":209,"address":[5298576],"length":1,"stats":{"Line":2},"fn_name":"find_all_lazy\u003cu8,\u0026u8,\u0026[u8]\u003e"},{"line":219,"address":[5298646],"length":1,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[5193904,5194237,5194648,5194272,5194672,5195048],"length":1,"stats":{"Line":4},"fn_name":"new\u003cu64,u8,alloc::vec::into_iter::IntoIter\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":243,"address":[5193951,5194365,5194765],"length":1,"stats":{"Line":5},"fn_name":null},{"line":244,"address":[5194798,5194398,5193984],"length":1,"stats":{"Line":5},"fn_name":null},{"line":245,"address":[5194526,5194926,5194128],"length":1,"stats":{"Line":4},"fn_name":null},{"line":247,"address":[5194415,5194815,5193996],"length":1,"stats":{"Line":4},"fn_name":null},{"line":248,"address":[5194026,5194448,5194848],"length":1,"stats":{"Line":4},"fn_name":null},{"line":262,"address":[5196352,5195744,5195072,5195714,5196321,5196994],"length":1,"stats":{"Line":4},"fn_name":"next\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":263,"address":[5195275,5196555,5195709,5196989,5195307,5195110,5196587,5195933,5195782,5195901,5196316,5196390],"length":1,"stats":{"Line":10},"fn_name":null},{"line":264,"address":[5196688,5196017,5195408],"length":1,"stats":{"Line":4},"fn_name":null},{"line":265,"address":[5196794,5196896,5196123,5196224,5196892,5195616,5195514,5196220,5195612],"length":1,"stats":{"Line":7},"fn_name":null},{"line":266,"address":[5196212,5196884,5195604],"length":1,"stats":{"Line":5},"fn_name":null},{"line":267,"address":[5196240,5195633,5196913],"length":1,"stats":{"Line":4},"fn_name":null},{"line":271,"address":[5196570,5195916,5195290],"length":1,"stats":{"Line":4},"fn_name":null},{"line":300,"address":[5198288,5197024,5198320,5199584],"length":1,"stats":{"Line":5},"fn_name":"new\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":301,"address":[5197087,5198383],"length":1,"stats":{"Line":5},"fn_name":null},{"line":303,"address":[5197244,5198540,5197319,5198615,5197154,5198450],"length":1,"stats":{"Line":12},"fn_name":null},{"line":304,"address":[5198823,5198631,5197335,5197527],"length":1,"stats":{"Line":4},"fn_name":null},{"line":305,"address":[5198959,5197663],"length":1,"stats":{"Line":6},"fn_name":null},{"line":306,"address":[5198783,5197487],"length":1,"stats":{"Line":4},"fn_name":null},{"line":308,"address":[5198800,5197569,5197504,5198865],"length":1,"stats":{"Line":9},"fn_name":null},{"line":309,"address":[5197603,5198899],"length":1,"stats":{"Line":4},"fn_name":null},{"line":310,"address":[5197612,5198908],"length":1,"stats":{"Line":5},"fn_name":null},{"line":312,"address":[5199390,5198094],"length":1,"stats":{"Line":4},"fn_name":null},{"line":313,"address":[5197678,5198974],"length":1,"stats":{"Line":5},"fn_name":null},{"line":315,"address":[5197687,5198983],"length":1,"stats":{"Line":4},"fn_name":null},{"line":316,"address":[5199047,5197751],"length":1,"stats":{"Line":5},"fn_name":null},{"line":318,"address":[5199279,5197983],"length":1,"stats":{"Line":4},"fn_name":null},{"line":319,"address":[5199378,5198082],"length":1,"stats":{"Line":4},"fn_name":null},{"line":329,"address":[5199616,5200975,5200304,5200287],"length":1,"stats":{"Line":4},"fn_name":"next_end\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":330,"address":[5200970,5199654,5200282,5200551,5200507,5200342,5199819,5199863],"length":1,"stats":{"Line":15},"fn_name":null},{"line":331,"address":[5200652,5199964],"length":1,"stats":{"Line":4},"fn_name":null},{"line":332,"address":[5200659,5199971,5200730,5200042],"length":1,"stats":{"Line":11},"fn_name":null},{"line":333,"address":[5199979,5200667],"length":1,"stats":{"Line":4},"fn_name":null},{"line":334,"address":[5199996,5200684],"length":1,"stats":{"Line":6},"fn_name":null},{"line":335,"address":[5200719,5200031],"length":1,"stats":{"Line":2},"fn_name":null},{"line":336,"address":[5200726,5200038],"length":1,"stats":{"Line":6},"fn_name":null},{"line":338,"address":[5200084,5200189,5200772,5200877,5200185,5200873],"length":1,"stats":{"Line":9},"fn_name":null},{"line":339,"address":[5200174,5200862],"length":1,"stats":{"Line":7},"fn_name":null},{"line":340,"address":[5200206,5200894],"length":1,"stats":{"Line":4},"fn_name":null},{"line":344,"address":[5199839,5200527],"length":1,"stats":{"Line":5},"fn_name":null},{"line":345,"address":[5199846,5200534],"length":1,"stats":{"Line":5},"fn_name":null},{"line":352,"address":[5200992],"length":1,"stats":{"Line":2},"fn_name":"next_path\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":356,"address":[5201015,5201054],"length":1,"stats":{"Line":4},"fn_name":null},{"line":357,"address":[5201034,5201088,5201132],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":377,"address":[5201296],"length":1,"stats":{"Line":2},"fn_name":"next_alignment\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":378,"address":[5201326],"length":1,"stats":{"Line":2},"fn_name":null},{"line":379,"address":[5201378],"length":1,"stats":{"Line":2},"fn_name":null},{"line":380,"address":[5201383],"length":1,"stats":{"Line":2},"fn_name":null},{"line":382,"address":[5201361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[5201744,5201408],"length":1,"stats":{"Line":5},"fn_name":"start\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":389,"address":[5201422,5201758],"length":1,"stats":{"Line":4},"fn_name":null},{"line":390,"address":[5201817,5201481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[5201856,5201772,5201436,5201520],"length":1,"stats":{"Line":10},"fn_name":null},{"line":393,"address":[5201700,5201730,5201550,5201886,5202036,5202066],"length":1,"stats":{"Line":4},"fn_name":null},{"line":402,"address":[5202080],"length":1,"stats":{"Line":2},"fn_name":"path\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":403,"address":[5202094,5202176],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":404,"address":[5202194],"length":1,"stats":{"Line":4},"fn_name":null},{"line":414,"address":[5202240],"length":1,"stats":{"Line":3},"fn_name":"path_reverse\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":415,"address":[5202270],"length":1,"stats":{"Line":2},"fn_name":null},{"line":416,"address":[5202291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[5202284],"length":1,"stats":{"Line":3},"fn_name":null},{"line":419,"address":[5202328,5202382],"length":1,"stats":{"Line":4},"fn_name":null},{"line":421,"address":[5202340],"length":1,"stats":{"Line":4},"fn_name":null},{"line":422,"address":[5202592,5202562,5202412],"length":1,"stats":{"Line":5},"fn_name":"alignment\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":429,"address":[5202592],"length":1,"stats":{"Line":2},"fn_name":"alignment\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":430,"address":[5202631],"length":1,"stats":{"Line":2},"fn_name":null},{"line":431,"address":[5202675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[5202648,5203405,5203410,5202757,5202703],"length":1,"stats":{"Line":6},"fn_name":null},{"line":434,"address":[5202738],"length":1,"stats":{"Line":2},"fn_name":null},{"line":435,"address":[5202775,5202854],"length":1,"stats":{"Line":4},"fn_name":null},{"line":437,"address":[5202790],"length":1,"stats":{"Line":2},"fn_name":null},{"line":438,"address":[5202899],"length":1,"stats":{"Line":2},"fn_name":null},{"line":440,"address":[5202943],"length":1,"stats":{"Line":2},"fn_name":null},{"line":441,"address":[5202955],"length":1,"stats":{"Line":2},"fn_name":null},{"line":442,"address":[5203014],"length":1,"stats":{"Line":2},"fn_name":null},{"line":443,"address":[5203026],"length":1,"stats":{"Line":2},"fn_name":null},{"line":444,"address":[5203085],"length":1,"stats":{"Line":2},"fn_name":null},{"line":447,"address":[5203397],"length":1,"stats":{"Line":2},"fn_name":null},{"line":449,"address":[5202749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[5203504,5203424],"length":1,"stats":{"Line":4},"fn_name":"next\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":464,"address":[5203442,5203522,5203471,5203551],"length":1,"stats":{"Line":8},"fn_name":null},{"line":465,"address":[5203541,5203461,5203815,5203776,5203623,5203584],"length":1,"stats":{"Line":14},"fn_name":"{{closure}}\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":494,"address":[5204620,5203968],"length":1,"stats":{"Line":2},"fn_name":"next\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":495,"address":[5204203,5204006,5204171,5204615],"length":1,"stats":{"Line":6},"fn_name":null},{"line":496,"address":[5204375,5204304],"length":1,"stats":{"Line":4},"fn_name":null},{"line":497,"address":[5204312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":498,"address":[5204329],"length":1,"stats":{"Line":2},"fn_name":null},{"line":499,"address":[5204364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[5204371],"length":1,"stats":{"Line":2},"fn_name":null},{"line":504,"address":[5204518,5204417,5204522],"length":1,"stats":{"Line":5},"fn_name":null},{"line":505,"address":[5204507],"length":1,"stats":{"Line":3},"fn_name":null},{"line":506,"address":[5204539],"length":1,"stats":{"Line":2},"fn_name":null},{"line":510,"address":[5204186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[5205735,5204640],"length":1,"stats":{"Line":2},"fn_name":"new\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":522,"address":[5204748],"length":1,"stats":{"Line":2},"fn_name":null},{"line":523,"address":[5205141],"length":1,"stats":{"Line":2},"fn_name":null},{"line":524,"address":[5204807],"length":1,"stats":{"Line":2},"fn_name":null},{"line":527,"address":[5205043],"length":1,"stats":{"Line":2},"fn_name":null},{"line":528,"address":[5205052],"length":1,"stats":{"Line":2},"fn_name":null},{"line":530,"address":[5205559],"length":1,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[5205156],"length":1,"stats":{"Line":2},"fn_name":null},{"line":533,"address":[5205165],"length":1,"stats":{"Line":2},"fn_name":null},{"line":534,"address":[5205229],"length":1,"stats":{"Line":2},"fn_name":null},{"line":536,"address":[5205460],"length":1,"stats":{"Line":2},"fn_name":null},{"line":545,"address":[5205760],"length":1,"stats":{"Line":2},"fn_name":"hit_at\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":546,"address":[5205885,5205783,5205856],"length":1,"stats":{"Line":6},"fn_name":null},{"line":547,"address":[5205795],"length":1,"stats":{"Line":2},"fn_name":null},{"line":548,"address":[5205944,5205920,5205875],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":555,"address":[5206144],"length":1,"stats":{"Line":2},"fn_name":"path_at\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":560,"address":[5206240,5206172],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":561,"address":[5206268],"length":1,"stats":{"Line":2},"fn_name":null},{"line":570,"address":[5206320],"length":1,"stats":{"Line":2},"fn_name":"path_at_reverse\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":575,"address":[5206418,5206349,5206448],"length":1,"stats":{"Line":6},"fn_name":null},{"line":576,"address":[5206361],"length":1,"stats":{"Line":2},"fn_name":null},{"line":577,"address":[5206438,5206480,5206504],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":590,"address":[5206704],"length":1,"stats":{"Line":2},"fn_name":"alignment_at\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":591,"address":[5206778],"length":1,"stats":{"Line":2},"fn_name":null},{"line":592,"address":[5206803,5206884],"length":1,"stats":{"Line":4},"fn_name":null},{"line":594,"address":[5206815],"length":1,"stats":{"Line":2},"fn_name":null},{"line":595,"address":[5206827],"length":1,"stats":{"Line":2},"fn_name":null},{"line":597,"address":[5207016,5206956],"length":1,"stats":{"Line":4},"fn_name":null},{"line":600,"address":[5207022],"length":1,"stats":{"Line":2},"fn_name":null},{"line":601,"address":[5207081],"length":1,"stats":{"Line":2},"fn_name":null},{"line":602,"address":[5207093],"length":1,"stats":{"Line":2},"fn_name":null},{"line":603,"address":[5207152],"length":1,"stats":{"Line":2},"fn_name":null},{"line":606,"address":[5207467],"length":1,"stats":{"Line":2},"fn_name":null},{"line":608,"address":[5206978],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":159,"coverable":185},{"path":["/","home","todd","rust-bio","src","pattern_matching","myers","simple.rs"],"content":"use std::borrow::Borrow;\nuse std::collections::HashMap;\nuse std::iter;\nuse std::marker::PhantomData;\nuse std::mem::{replace, size_of};\nuse std::slice;\nuse std::u64;\n\nuse num_traits::{FromPrimitive, One, ToPrimitive, Zero};\n\nuse crate::pattern_matching::myers::traceback::{StatesHandler, TracebackHandler};\nuse crate::pattern_matching::myers::{BitVec, State};\n\n/// Myers algorithm.\npub struct Myers\u003cT = u64\u003e\nwhere\n    T: BitVec,\n{\n    pub(crate) peq: [T; 256],\n    pub(crate) bound: T,\n    pub(crate) m: T::DistType,\n    pub(crate) states_store: Vec\u003cState\u003cT, T::DistType\u003e\u003e,\n}\n\nimpl\u003cT: BitVec\u003e Myers\u003cT\u003e {\n    /// Create a new instance of Myers algorithm for a given pattern.\n    #[inline]\n    pub fn new\u003cP, C\u003e(pattern: P) -\u003e Self\n    where\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        Self::new_ambig(pattern, None, None)\n    }\n\n    #[inline]\n    pub(crate) fn new_ambig\u003cP, C\u003e(\n        pattern: P,\n        opt_ambigs: Option\u003c\u0026HashMap\u003cu8, Vec\u003cu8\u003e\u003e\u003e,\n        opt_wildcards: Option\u003c\u0026[u8]\u003e,\n    ) -\u003e Self\n    where\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        let maxsize = T::DistType::from_usize(size_of::\u003cT\u003e() * 8).unwrap();\n        let pattern = pattern.into_iter();\n        let m = T::DistType::from_usize(pattern.len()).unwrap();\n        assert!(m \u003c= maxsize, \"Pattern too long\");\n        assert!(m \u003e T::DistType::zero(), \"Pattern is empty\");\n\n        let mut peq = [T::zero(); 256];\n\n        for (i, symbol) in pattern.enumerate() {\n            let symbol = *symbol.borrow();\n            let mask = T::one() \u003c\u003c i;\n            // equivalent\n            peq[symbol as usize] |= mask;\n            // ambiguities\n            if let Some(equivalents) = opt_ambigs.and_then(|ambigs| ambigs.get(\u0026symbol)) {\n                for \u0026eq in equivalents {\n                    peq[eq as usize] |= mask;\n                }\n            }\n        }\n\n        if let Some(wildcards) = opt_wildcards {\n            for \u0026w in wildcards {\n                peq[w as usize] = T::max_value();\n            }\n        }\n\n        Myers {\n            peq,\n            bound: T::one() \u003c\u003c (m.to_usize().unwrap() - 1),\n            m,\n            states_store: vec![],\n        }\n    }\n\n    #[inline]\n    fn initial_state(\u0026self, m: T::DistType, _: T::DistType) -\u003e State\u003cT, T::DistType\u003e {\n        State::init(m)\n    }\n\n    #[inline]\n    fn step(\u0026self, state: \u0026mut State\u003cT, T::DistType\u003e, a: u8, _: T::DistType) {\n        self._step(state, a);\n    }\n\n    #[inline]\n    fn _step(\u0026self, state: \u0026mut State\u003cT, T::DistType\u003e, a: u8) {\n        let eq = self.peq[a as usize];\n        let xv = eq | state.mv;\n        let xh = ((eq \u0026 state.pv).wrapping_add(\u0026state.pv) ^ state.pv) | eq;\n\n        let mut ph = state.mv | !(xh | state.pv);\n        let mut mh = state.pv \u0026 xh;\n\n        // if ph \u0026 self.bound \u003e T::zero() {\n        //     state.dist += T::DistType::one();\n        // } else if mh \u0026 self.bound \u003e T::zero() {\n        //     state.dist -= T::DistType::one();\n        // }\n        let diff = ((ph \u0026 self.bound) != T::zero()) as i8 - ((mh \u0026 self.bound) != T::zero()) as i8;\n        state.dist =\n            T::DistType::from_usize(state.dist.to_usize().unwrap().wrapping_add(diff as usize))\n                .unwrap();\n\n        ph \u003c\u003c= 1;\n        mh \u003c\u003c= 1;\n        state.pv = mh | !(xv | ph);\n        state.mv = ph \u0026 xv;\n    }\n\n    #[inline]\n    pub fn m(\u0026self) -\u003e T::DistType {\n        self.m\n    }\n}\n\n#[derive(Default)]\npub(super) struct ShortStatesHandler\u003c'a\u003e(PhantomData\u003c\u0026'a ()\u003e);\n\nimpl\u003c'a\u003e ShortStatesHandler\u003c'a\u003e {\n    #[inline]\n    pub fn new() -\u003e Self {\n        ShortStatesHandler(PhantomData)\n    }\n}\n\nimpl\u003c'a, T: BitVec + 'a\u003e StatesHandler\u003c'a, T, T::DistType\u003e for ShortStatesHandler\u003c'a\u003e {\n    type TracebackHandler = ShortTracebackHandler\u003c'a, T\u003e;\n    type TracebackColumn = State\u003cT, T::DistType\u003e;\n\n    #[inline]\n    fn init(\u0026mut self, n: usize, _: T::DistType) -\u003e usize {\n        n\n    }\n\n    #[inline]\n    fn set_max_state(\u0026self, pos: usize, states: \u0026mut [State\u003cT, T::DistType\u003e]) {\n        //states[pos] = State::max();\n        *unsafe { states.get_unchecked_mut(pos) } = State::max();\n    }\n\n    #[inline]\n    fn add_state(\n        \u0026self,\n        source: \u0026Self::TracebackColumn,\n        pos: usize,\n        states: \u0026mut [State\u003cT, T::DistType\u003e],\n    ) {\n        //states[pos] = source.clone();\n        *unsafe { states.get_unchecked_mut(pos) } = source.clone();\n    }\n\n    #[inline]\n    fn init_traceback(\n        \u0026self,\n        m: T::DistType,\n        pos: usize,\n        states: \u0026'a [State\u003cT, T::DistType\u003e],\n    ) -\u003e Self::TracebackHandler {\n        ShortTracebackHandler::new(m, pos, states)\n    }\n}\n\ntype RevColIter\u003c'a, T\u003e = iter::Rev\u003cslice::Iter\u003c'a, State\u003cT, \u003cT as BitVec\u003e::DistType\u003e\u003e\u003e;\n\npub(super) struct ShortTracebackHandler\u003c'a, T: BitVec\u003e {\n    states_iter: iter::Chain\u003cRevColIter\u003c'a, T\u003e, iter::Cycle\u003cRevColIter\u003c'a, T\u003e\u003e\u003e,\n    state: State\u003cT, T::DistType\u003e,\n    left_state: State\u003cT, T::DistType\u003e,\n    max_mask: T,\n    pos_bitvec: T,\n    left_mask: T,\n    _a: PhantomData\u003c\u0026'a ()\u003e,\n}\n\nimpl\u003c'a, T: BitVec\u003e ShortTracebackHandler\u003c'a, T\u003e {\n    #[inline]\n    fn new(m: T::DistType, pos: usize, states: \u0026'a [State\u003cT, T::DistType\u003e]) -\u003e Self {\n        let mask0 = T::one() \u003c\u003c (m.to_usize().unwrap() - 1);\n\n        // Reverse iterator over states. If remembering all positions,\n        // the chain() and cycle() are not actually needed, but there seems\n        // to be almost no performance loss.\n        let mut states_iter = states[..=pos]\n            .iter()\n            .rev()\n            .chain(states.iter().rev().cycle());\n\n        // // Simpler alternative using skip() is slower in some cases:\n        // let mut states = states.iter().rev().cycle().skip(states.len() - pos - 1);\n\n        ShortTracebackHandler {\n            state: states_iter.next().unwrap().clone(),\n            left_state: states_iter.next().unwrap().clone(),\n            states_iter,\n            max_mask: mask0,\n            pos_bitvec: mask0,\n            left_mask: T::zero(),\n            _a: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'a, T\u003e TracebackHandler\u003c'a, T, T::DistType\u003e for ShortTracebackHandler\u003c'a, T\u003e\nwhere\n    T: BitVec + 'a,\n{\n    #[inline]\n    fn block(\u0026self) -\u003e \u0026State\u003cT, T::DistType\u003e {\n        \u0026self.state\n    }\n\n    #[inline]\n    fn block_mut(\u0026mut self) -\u003e \u0026mut State\u003cT, T::DistType\u003e {\n        \u0026mut self.state\n    }\n\n    #[inline]\n    fn left_block(\u0026self) -\u003e \u0026State\u003cT, T::DistType\u003e {\n        \u0026self.left_state\n    }\n\n    #[inline]\n    fn left_block_mut(\u0026mut self) -\u003e \u0026mut State\u003cT, T::DistType\u003e {\n        \u0026mut self.left_state\n    }\n\n    #[inline]\n    fn pos_bitvec(\u0026self) -\u003e T {\n        self.pos_bitvec\n    }\n\n    #[inline]\n    fn move_up(\u0026mut self, adjust_dist: bool) {\n        if adjust_dist {\n            self.state.adjust_dist(self.pos_bitvec);\n        }\n        self.pos_bitvec \u003e\u003e= 1;\n    }\n\n    #[inline]\n    fn move_up_left(\u0026mut self, adjust_dist: bool) {\n        self.left_mask = (self.left_mask \u003e\u003e 1) | self.max_mask;\n        if adjust_dist {\n            self.left_state.adjust_dist(self.pos_bitvec);\n        }\n    }\n\n    #[inline]\n    fn move_to_left(\u0026mut self) {\n        self.state = replace(\n            \u0026mut self.left_state,\n            self.states_iter.next().unwrap().clone(),\n        );\n        self.left_state.adjust_by_mask(self.left_mask);\n    }\n\n    #[inline]\n    fn move_left_down_if_better(\u0026mut self) -\u003e bool {\n        if self.left_state.mv \u0026 self.pos_bitvec != T::zero() {\n            self.left_state.dist -= T::DistType::one();\n            return true;\n        }\n        false\n    }\n\n    #[inline]\n    fn column_slice(\u0026self) -\u003e \u0026[State\u003cT, T::DistType\u003e] {\n        std::slice::from_ref(\u0026self.state)\n    }\n\n    #[inline]\n    fn finished(\u0026self) -\u003e bool {\n        self.pos_bitvec == T::zero()\n    }\n}\n\nimpl_myers!(\n    T::DistType,\n    Myers\u003cT\u003e,\n    crate::pattern_matching::myers::State\u003cT, T::DistType\u003e,\n    crate::pattern_matching::myers::simple::ShortStatesHandler\u003c'a\u003e\n);\n","traces":[{"line":28,"address":[5642800,5642992,5642864,5643056,5642928],"length":1,"stats":{"Line":5},"fn_name":"new\u003cu64,\u0026[u8; 7],\u0026u8\u003e"},{"line":34,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[4983664],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":79,"coverable":90},{"path":["/","home","todd","rust-bio","src","pattern_matching","myers","traceback.rs"],"content":"use std::default::Default;\nuse std::iter;\nuse std::marker::PhantomData;\nuse std::ops::Range;\n\nuse crate::alignment::AlignmentOperation;\n\nuse crate::pattern_matching::myers::{word_size, BitVec, DistType, State};\n\n/// Objects implementing this trait handle the addition of calculated blocks (State\u003cT, D\u003e)\n/// to a container, and are responsible for creating the respective `TracebackHandler` object.\npub(super) trait StatesHandler\u003c'a, T, D\u003e\nwhere\n    T: BitVec + 'a,\n    D: DistType,\n{\n    /// Object that helps obtaining a single traceback path\n    type TracebackHandler: TracebackHandler\u003c'a, T, D\u003e;\n    /// Type that represents a column in the traceback matrix\n    type TracebackColumn: ?Sized;\n\n    /// Prepare for a new search given n (maximum expected number of traceback columns) and\n    /// m (pattern length).\n    /// Returns the expected size of the vector storing the calculated blocks given this\n    /// information. The vector will then be initialized with the given number of 'empty'\n    /// State\u003cT, D\u003e objects and supplied to the other methods as slice.\n    fn init(\u0026mut self, n: usize, m: D) -\u003e usize;\n\n    /// Fill the column at `pos` with states initialized with the maximum distance\n    /// (`State::max()`).\n    fn set_max_state(\u0026self, pos: usize, states: \u0026mut [State\u003cT, D\u003e]);\n\n    /// This method copies over all blocks (or the one block) from a tracback column\n    /// into the mutable `states` slice at the given column position.\n    fn add_state(\u0026self, source: \u0026Self::TracebackColumn, pos: usize, states: \u0026mut [State\u003cT, D\u003e]);\n\n    /// Initiates a `TracebackHandler` object to assist with a traceback, 'starting'\n    /// at the given end position.\n    fn init_traceback(\u0026self, m: D, pos: usize, states: \u0026'a [State\u003cT, D\u003e])\n        -\u003e Self::TracebackHandler;\n}\n\n/// Objects implementing this trait should store states and have methods\n/// necessary for obtaining a single traceback path. This allows to use the\n/// same traceback code for the simple and the block-based Myers pattern\n/// matching approaches. It is designed to be as general as possible\n/// to allow different implementations.\n///\n/// Implementors of `TracebackHandler` keep two `State\u003cT, D\u003e` instances,\n/// which store the information from two horizontally adjacent traceback\n/// columns, encoded in the PV / MV bit vectors. The columns are accessible\n/// using the methods `block()` (current / right column) and `left_block()`\n/// (left column). Moving horizontally to the next position can be achieved\n/// using `move_left()`.\n///\n/// Implementors also track the vertical cursor positions within the current\n/// traceback columns (two separate cursors for left and right column).\n/// `block()` and `left_block()` will always return the block that currently\n/// contain the cursors.\n/// `pos_bitvec()` returns a bit vector with a single activated bit at the current\n/// vertical position within the *right (current)* column.\n/// Moving to the next vertical position is achieved by `move_up()` and\n/// `move_up_left()`. With the block based implementation, this may involve\n/// switching to a new block.\npub(super) trait TracebackHandler\u003c'a, T, D\u003e\nwhere\n    T: BitVec + 'a,\n    D: DistType,\n{\n    /// Returns a reference to the current (right) block.\n    fn block(\u0026self) -\u003e \u0026State\u003cT, D\u003e;\n\n    /// Returns a mutable reference to the current (right) block.\n    fn block_mut(\u0026mut self) -\u003e \u0026mut State\u003cT, D\u003e;\n\n    /// Returns a reference to the left block.\n    fn left_block(\u0026self) -\u003e \u0026State\u003cT, D\u003e;\n\n    /// Returns a mutable reference to the left block.\n    fn left_block_mut(\u0026mut self) -\u003e \u0026mut State\u003cT, D\u003e;\n\n    /// Bit vector representing the position in the traceback. Only the bit\n    /// at the current position should be on.\n    /// For a search pattern of length 4, the initial bit vector would be\n    /// `0b1000`. A call to `move_up_cursor()` will shift the vector, so another\n    /// call to `pos_bitvec()` results in `0b100`.\n    /// The bit vector has a width of `T`, meaning that it can store\n    /// the same number of positions as the PV and MV vectors. In the\n    /// case of the block based algorithm, the vector only stores the\n    /// position within the current block.\n    fn pos_bitvec(\u0026self) -\u003e T;\n\n    /// Move up cursor by one position in traceback matrix.\n    ///\n    /// # Arguments\n    ///\n    /// * adjust_dist: If true, the distance score of the block is adjusted\n    ///   based on the current cursor position before moving it up.\n    ///  *Note concerning the block based Myers algorithm:*\n    ///  The the active bit in bit vector returned by `pos_bitvec()`\n    ///  is expected to jump back to the maximum (lowest) position\n    ///  when reaching the uppermost position (like `rotate_right()` does).\n    fn move_up(\u0026mut self, adjust_dist: bool);\n\n    /// Move up left cursor by one position in traceback matrix.\n    ///\n    /// # Arguments\n    ///\n    /// * adjust_dist: If true, the distance score of the block is adjusted\n    ///   based on the current cursor position before moving it up.\n    ///   However, the current cursor position of the **right** block is used,\n    ///   **not** the one of the left block. This is an important oddity, which\n    ///   makes only sense because of the design of the traceback algorithm.\n    fn move_up_left(\u0026mut self, adjust_dist: bool);\n\n    /// Shift the view by one traceback column / block to the left. The\n    /// block that was on the left position previously moves to the right /\n    /// current block without changes. The cursor positions have to be\n    /// adjusted indepentedently if necessary using `move_up(false)` /\n    /// `move_up_left(false)`.\n    /// `move_left()` adjusts distance score of the new left block to\n    /// be correct for the left vertical cursor position. It is therefore\n    /// important that the cursor is moved *before* calling `move_left()`.\n    fn move_to_left(\u0026mut self);\n\n    /// Rather specialized method that allows having a simpler code in Traceback::_traceback_at()\n    /// Checks if the position below the left cursor has a smaller distance, and if so,\n    /// moves the cursor to this block and returns `true`.\n    ///\n    /// The problem is that the current implementation always keeps the left cursor in the\n    /// diagonal position for performance reasons. In this case, checking the actual left\n    /// distance score can be complicated with the block-based algorithm since the left cursor\n    /// may be at the lower block boundary. If so, the function thus has to check the topmost\n    /// position of the lower block and keep this block if the distance is better (lower).\n    fn move_left_down_if_better(\u0026mut self) -\u003e bool;\n\n    /// Returns a slice containing all blocks of the current traceback column\n    /// from top to bottom. Used for debugging only.\n    fn column_slice(\u0026self) -\u003e \u0026[State\u003cT, D\u003e];\n\n    /// Returns true if topmost position in the traceback matrix has been reached,\n    /// meaning that the traceback is complete.\n    /// Technically this means, that `move_up_cursor()` was called so many times\n    /// until the uppermost block was reached and the pos_bitvec() does not contain\n    /// any bit, since shifting has removed it from the vector.\n    fn finished(\u0026self) -\u003e bool;\n\n    /// For debugging only\n    fn print_state(\u0026self) {\n        println!(\n            \"--- TB dist ({:?} \u003c-\u003e {:?})\",\n            self.left_block().dist,\n            self.block().dist\n        );\n        println!(\n            \"{:064b} m\\n{:064b} + ({:?}) (left) d={:?}\\n{:064b} - ({:?})\\n \\\n             {:064b} + ({:?}) (current) d={:?}\\n{:064b} - ({:?})\\n\",\n            self.pos_bitvec(),\n            self.left_block().pv,\n            self.left_block().pv,\n            self.left_block().dist,\n            self.left_block().mv,\n            self.left_block().mv,\n            self.block().pv,\n            self.block().pv,\n            self.block().dist,\n            self.block().mv,\n            self.block().mv\n        );\n    }\n}\n\npub(super) struct Traceback\u003c'a, T, D, H\u003e\nwhere\n    T: BitVec + 'a,\n    D: DistType,\n    H: StatesHandler\u003c'a, T, D\u003e,\n{\n    m: D,\n    positions: iter::Cycle\u003cRange\u003cusize\u003e\u003e,\n    handler: H,\n    pos: usize,\n    _t: PhantomData\u003c\u0026'a T\u003e,\n}\n\nimpl\u003c'a, T, D, H\u003e Traceback\u003c'a, T, D, H\u003e\nwhere\n    T: BitVec,\n    D: DistType,\n    H: StatesHandler\u003c'a, T, D\u003e,\n{\n    #[inline]\n    pub fn new(\n        states: \u0026mut Vec\u003cState\u003cT, D\u003e\u003e,\n        initial_state: \u0026H::TracebackColumn,\n        num_cols: usize,\n        m: D,\n        mut handler: H,\n    ) -\u003e Self {\n        // Correct traceback needs two additional columns at the left of the matrix (see below).\n        // Therefore reserving additional space.\n        let num_cols = num_cols + 2;\n\n        let n_states = handler.init(num_cols, m);\n\n        let mut tb = Traceback {\n            m,\n            positions: (0..num_cols).cycle(),\n            handler,\n            pos: 0,\n            _t: PhantomData,\n        };\n\n        // extend or truncate states vector\n        let curr_len = states.len();\n        if n_states \u003e curr_len {\n            states.reserve(n_states);\n            states.extend((0..n_states - curr_len).map(|_| State::default()));\n        } else {\n            states.truncate(n_states);\n            states.shrink_to_fit();\n        }\n        // important if using unsafe in add_state(), and also for correct functioning of traceback\n        debug_assert!(states.len() == n_states);\n\n        // first column is used to ensure a correct path if the text (target)\n        // is shorter than the pattern (query)\n        tb.pos = tb.positions.next().unwrap();\n        tb.handler.set_max_state(tb.pos, states);\n\n        // initial state\n        tb.add_state(initial_state, states);\n\n        tb\n    }\n\n    #[inline]\n    pub fn add_state(\u0026mut self, column: \u0026H::TracebackColumn, states: \u0026mut [State\u003cT, D\u003e]) {\n        self.pos = self.positions.next().unwrap();\n        self.handler.add_state(column, self.pos, states);\n    }\n\n    /// Returns the length of the current match, optionally adding the\n    /// alignment path to `ops`\n    #[inline]\n    pub fn traceback(\n        \u0026self,\n        ops: Option\u003c\u0026mut Vec\u003cAlignmentOperation\u003e\u003e,\n        states: \u0026'a [State\u003cT, D\u003e],\n    ) -\u003e (D, D) {\n        self._traceback_at(self.pos, ops, states)\n    }\n\n    /// Returns the length of a match with a given end position, optionally adding the\n    /// alignment path to `ops`\n    /// only to be called if the `states` vec contains all states of the text\n    #[inline]\n    pub fn traceback_at(\n        \u0026self,\n        pos: usize,\n        ops: Option\u003c\u0026mut Vec\u003cAlignmentOperation\u003e\u003e,\n        states: \u0026'a [State\u003cT, D\u003e],\n    ) -\u003e Option\u003c(D, D)\u003e {\n        let pos = pos + 2; // in order to be comparable since self.pos starts at 2, not 0\n        if pos \u003c= self.pos {\n            return Some(self._traceback_at(pos, ops, states));\n        }\n        None\n    }\n\n    /// returns a tuple of alignment length and hit distance, optionally adding the alignment path\n    /// to `ops`\n    #[inline]\n    fn _traceback_at(\n        \u0026self,\n        pos: usize,\n        mut ops: Option\u003c\u0026mut Vec\u003cAlignmentOperation\u003e\u003e,\n        state_slice: \u0026'a [State\u003cT, D\u003e],\n    ) -\u003e (D, D) {\n        use self::AlignmentOperation::*;\n\n        // Generic object that holds the necessary data and methods\n        let mut h = self.handler.init_traceback(self.m, pos, state_slice);\n\n        // self.print_tb_matrix(pos, state_slice);\n\n        let ops = \u0026mut ops;\n\n        // horizontal column offset from starting point in traceback matrix (bottom right)\n        let mut h_offset = D::zero();\n\n        // distance of the match (will be returned)\n        let dist = h.block().dist;\n\n        // The cursor of the left state is always for diagonal position in the traceback matrix.\n        // This allows checking for a substitution by a simple comparison.\n        h.move_up_left(true);\n\n        // Loop for finding the traceback path\n        // If there are several possible solutions, substitutions are preferred over InDels\n        // (Subst \u003e Ins \u003e Del)\n        while !h.finished() {\n            let op;\n            // This loop is used to allow skipping `move_left()` using break (kind of similar\n            // to 'goto'). This was done to avoid having to inline move_left() three times,\n            // which would use more space.\n            #[allow(clippy::never_loop)]\n            loop {\n                // h.print_state();\n\n                if h.left_block().dist.wrapping_add(\u0026D::one()) == h.block().dist {\n                    // Diagonal (substitution)\n                    // Since the left cursor is always in the upper diagonal position,\n                    // a simple comparison of distances is enough to determine substitutions.\n                    h.move_up(false);\n                    h.move_up_left(false);\n                    op = Subst;\n                } else if h.block().pv \u0026 h.pos_bitvec() != T::zero() {\n                    // Up\n                    h.move_up(true);\n                    h.move_up_left(true);\n                    op = Ins;\n                    break;\n                } else if h.move_left_down_if_better() {\n                    // Left\n                    op = Del;\n                } else {\n                    // Diagonal (match)\n                    h.move_up(false);\n                    h.move_up_left(false);\n                    op = Match;\n                }\n\n                // Moving one position to the left, adjusting h_offset\n                h_offset += D::one();\n                h.move_to_left();\n                break;\n            }\n\n            // println!(\"{:?}\", op);\n\n            if let Some(o) = ops.as_mut() {\n                o.push(op);\n            }\n        }\n\n        (h_offset, dist)\n    }\n\n    // Useful for debugging\n    #[allow(dead_code)]\n    fn print_tb_matrix(\u0026self, pos: usize, state_slice: \u0026'a [State\u003cT, D\u003e]) {\n        let mut h = self.handler.init_traceback(self.m, pos, state_slice);\n        let m = self.m.to_usize().unwrap();\n        let mut out = vec![];\n        for _ in 0..state_slice.len() {\n            let mut col_out = vec![];\n            let mut empty = true;\n            for (i, state) in h.column_slice().iter().enumerate().rev() {\n                if !(state.is_new() || state.is_max()) {\n                    empty = false;\n                }\n                let w = word_size::\u003cT\u003e();\n                let end = (i + 1) * w;\n                let n = if end \u003c= m { w } else { m % w };\n                state.write_dist_column(n, \u0026mut col_out);\n            }\n            out.push(col_out);\n            h.move_to_left();\n            if empty {\n                break;\n            }\n        }\n\n        for j in (0..m).rev() {\n            print!(\"{:\u003e4}: \", m - j + 1);\n            for col in out.iter().rev() {\n                if let Some(d) = col.get(j) {\n                    if *d \u003e= (D::max_value() \u003e\u003e 1) {\n                        // missing value\n                        print!(\"    \");\n                    } else {\n                        print!(\"{:\u003e4?}\", d);\n                    }\n                } else {\n                    print!(\"   -\");\n                }\n            }\n            println!();\n        }\n    }\n}\n","traces":[{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[4355985,4356203,4356024,4356242],"length":1,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":48,"coverable":100},{"path":["/","home","todd","rust-bio","src","pattern_matching","pssm","dnamotif.rs"],"content":"// Copyright 2018 Kieran Hervold\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse super::*;\nuse ndarray::prelude::Array2;\nuse std::f32;\nuse std::f32::{INFINITY, NEG_INFINITY};\n\n/// Position-specific scoring matrix for DNA sequences\n#[derive(Clone, Debug, PartialEq)]\npub struct DNAMotif {\n    /// matrix holding weights at each position, indexed by [position, base]\n    pub scores: Array2\u003cf32\u003e,\n    /// sum of \"worst\" base at each position\n    pub min_score: f32,\n    /// sum of \"best\" base at each position\n    pub max_score: f32,\n}\n\nimpl DNAMotif {\n    /// Returns a Motif representing the sequences provided.\n    /// # Arguments\n    /// * `seqs` - sequences incorporated into motif\n    /// * `pseudos` - array slice with a pseudocount for each monomer;\n    ///    defaults to pssm::DEF_PSEUDO for all if None is supplied\n    ///\n    /// FIXME: pseudos should be an array of size MONO_CT, but that\n    /// is currently impossible - see\n    /// https://github.com/rust-lang/rust/issues/42863\n    pub fn from_seqs(seqs: \u0026[Vec\u003cu8\u003e], pseudos: Option\u003c\u0026[f32]\u003e) -\u003e Result\u003cSelf\u003e {\n        let w = Self::seqs_to_weights(seqs, pseudos)?;\n        let mut m = DNAMotif {\n            scores: w,\n            min_score: 0.0,\n            max_score: 0.0,\n        };\n        m.normalize();\n        m.calc_minmax();\n        Ok(m)\n    }\n\n    // helper function -- normalize self.scores\n    fn normalize(\u0026mut self) {\n        for i in 0..self.len() {\n            let mut tot: f32 = 0.0;\n            // FIXME: slices would be cleaner\n            for base_i in 0..4 {\n                tot += self.scores[[i, base_i]];\n            }\n            for base_i in 0..4 {\n                self.scores[[i, base_i]] /= tot;\n            }\n        }\n    }\n\n    // helper function: populate min_score and max_score\n    fn calc_minmax(\u0026mut self) {\n        let pssm_len = self.len();\n\n        // score corresponding to sum of \"worst\" bases at each position\n        self.min_score = 0.0;\n        for i in 0..pssm_len {\n            // can't use the regular min/max on f32, so we use f32::min\n            let min_sc = (0..4).map(|b| self.scores[[i, b]]).fold(INFINITY, f32::min);\n            self.min_score += min_sc;\n        }\n\n        // score corresponding to \"best\" base at each position\n        self.max_score = 0.0;\n        for i in 0..pssm_len {\n            let max_sc = (0..4)\n                .map(|b| self.scores[[i, b]])\n                .fold(NEG_INFINITY, f32::max);\n            self.max_score += max_sc;\n        }\n    }\n}\n\nimpl Motif for DNAMotif {\n    const LK: [u8; 127] = [\n        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 255, 3, 255, 255, 255, 2, 255,\n        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 1, 255, 255, 255, 255, 255, 255,\n        255, 255, 255, 255, 255, 255, 0, 255, 3, 255, 255, 255, 2, 255, 255, 255, 255, 255, 255,\n        255, 255, 255, 255, 255, 255, 1, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n    ];\n    const MONOS: \u0026'static [u8] = b\"ATGC\";\n    const MONO_CT: usize = 4;\n\n    fn rev_lk(idx: usize) -\u003e u8 {\n        match idx {\n            0 =\u003e b'A',\n            1 =\u003e b'T',\n            2 =\u003e b'G',\n            3 =\u003e b'C',\n            _ =\u003e INVALID_MONO,\n        }\n    }\n\n    fn len(\u0026self) -\u003e usize {\n        self.scores.dim().0\n    }\n\n    fn get_scores(\u0026self) -\u003e \u0026Array2\u003cf32\u003e {\n        \u0026self.scores\n    }\n    fn get_min_score(\u0026self) -\u003e f32 {\n        self.min_score\n    }\n    fn get_max_score(\u0026self) -\u003e f32 {\n        self.max_score\n    }\n    fn get_bits() -\u003e f32 {\n        2.0\n    }\n\n    fn degenerate_consensus(\u0026self) -\u003e Vec\u003cu8\u003e {\n        // derived from\n        // https://github.com/biopython/biopython/blob/master/Bio/motifs/matrix.py#L205\n        fn two(_a: u8, _b: u8) -\u003e u8 {\n            let (a, b) = if _b \u003e _a { (_a, _b) } else { (_b, _a) };\n            match (a, b) {\n                (b'A', b'C') =\u003e b'M',\n                (b'A', b'G') =\u003e b'R',\n                (b'A', b'T') =\u003e b'W',\n                (b'C', b'G') =\u003e b'S',\n                (b'C', b'T') =\u003e b'Y',\n                (b'G', b'T') =\u003e b'K',\n                _ =\u003e unreachable!(), // no other combinations exist\n            }\n        }\n        let len = self.len();\n        let mut res = Vec::with_capacity(len);\n        for pos in 0..len {\n            let mut fracs = (0..4)\n                .map(|b| (self.scores[[pos, b]], b))\n                .collect::\u003cVec\u003c(f32, usize)\u003e\u003e();\n            // note: reverse sort\n            fracs.sort_by(|a, b| b.partial_cmp(a).unwrap());\n\n            res.push(if fracs[0].0 \u003e 0.5 \u0026\u0026 fracs[0].0 \u003e 2.0 * fracs[1].0 {\n                Self::MONOS[fracs[0].1]\n            } else if 4.0 * (fracs[0].0 + fracs[1].0) \u003e 3.0 {\n                two(Self::MONOS[fracs[0].1], Self::MONOS[fracs[1].1])\n            } else if fracs[3].0 \u003c EPSILON {\n                let base = Self::MONOS[fracs[3].1];\n                match base {\n                    b'T' =\u003e b'V',\n                    b'G' =\u003e b'H',\n                    b'C' =\u003e b'D',\n                    b'A' =\u003e b'B',\n                    _ =\u003e unreachable!(), // no other bases exist\n                }\n            } else {\n                b'N'\n            });\n        }\n        res\n    }\n}\n\n/// Return a DNAMotif wrapping an Array2 representing amino acid\n/// weights at each position.  The dimensions and contents of this\n/// array are unchecked, and it is incumbent on the user to ensure\n/// the correct dimensions are used (ie, SEQ_LEN x 4), and no zeros\n/// appear in the array.\nimpl From\u003cArray2\u003cf32\u003e\u003e for DNAMotif {\n    fn from(scores: Array2\u003cf32\u003e) -\u003e Self {\n        let mut m = DNAMotif {\n            scores,\n            min_score: 0.0,\n            max_score: 0.0,\n        };\n        m.normalize();\n        m.calc_minmax();\n        m\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::pattern_matching::pssm::ScoredPos;\n    #[test]\n    fn simple_pssm() {\n        let pssm: DNAMotif = DNAMotif::from_seqs(\n            vec![\n                b\"AAAA\".to_vec(),\n                b\"TTTT\".to_vec(),\n                b\"GGGG\".to_vec(),\n                b\"CCCC\".to_vec(),\n            ]\n            .as_ref(),\n            None,\n        )\n        .unwrap();\n        assert_eq!(pssm.scores, Array2::from_elem((4, 4), 0.25));\n    }\n    #[test]\n    fn find_motif() {\n        let pssm = DNAMotif::from_seqs(vec![b\"ATGC\".to_vec()].as_ref(), None).unwrap();\n        let seq = b\"GGGGATGCGGGG\";\n        if let Ok(ScoredPos {\n            ref loc, ref sum, ..\n        }) = pssm.score(seq)\n        {\n            assert_eq!(*loc, 4);\n            assert_relative_eq!(*sum, 1.0, epsilon = f32::EPSILON);\n        } else {\n            assert!(false);\n        }\n    }\n\n    #[test]\n    fn test_info_content() {\n        // matrix w/ 100% match to A at each position\n        let pssm =\n            DNAMotif::from_seqs(vec![b\"AAAA\".to_vec()].as_ref(), Some(\u0026[0.0, 0.0, 0.0, 0.0]))\n                .unwrap();\n        // 4 bases * 2 bits per base = 8\n        assert_relative_eq!(pssm.info_content(), 8.0, epsilon = f32::EPSILON);\n    }\n\n    #[test]\n    fn test_mono_err() {\n        let pssm = DNAMotif::from_seqs(vec![b\"ATGC\".to_vec()].as_ref(), None).unwrap();\n        assert_eq!(\n            pssm.score(b\"AAAAXAAAAAAAAA\"),\n            Err(Error::InvalidMonomer { mono: b'X' })\n        );\n    }\n\n    #[test]\n    fn test_inconsist_err() {\n        assert_eq!(\n            DNAMotif::from_seqs(\n                vec![b\"AAAA\".to_vec(), b\"TTTT\".to_vec(), b\"C\".to_vec()].as_ref(),\n                Some(\u0026[0.0; 4])\n            ),\n            Err(Error::InconsistentLen)\n        );\n    }\n\n    #[test]\n    fn test_degenerate_consensus_same_bases() {\n        let pssm: DNAMotif = DNAMotif::from_seqs(\n            vec![b\"ATGC\".to_vec(), b\"ATGC\".to_vec()].as_ref(),\n            Some(\u0026[0., 0., 0., 0.]),\n        )\n        .unwrap();\n        assert_eq!(pssm.degenerate_consensus(), b\"ATGC\".to_vec());\n    }\n\n    #[test]\n    fn test_degenerate_consensus_two_bases() {\n        let pssm: DNAMotif = DNAMotif::from_seqs(\n            vec![b\"AAACCG\".to_vec(), b\"CGTGTT\".to_vec()].as_ref(),\n            Some(\u0026[0., 0., 0., 0.]),\n        )\n        .unwrap();\n        assert_eq!(pssm.degenerate_consensus(), b\"MRWSYK\".to_vec());\n    }\n\n    #[test]\n    fn test_degenerate_consensus_three_bases() {\n        let pssm: DNAMotif = DNAMotif::from_seqs(\n            vec![b\"AAAC\".to_vec(), b\"CCGG\".to_vec(), b\"GTTT\".to_vec()].as_ref(),\n            Some(\u0026[0., 0., 0., 0.]),\n        )\n        .unwrap();\n        assert_eq!(pssm.degenerate_consensus(), b\"VHDB\".to_vec());\n    }\n\n    #[test]\n    fn test_degenerate_consensus_n() {\n        let pssm: DNAMotif = DNAMotif::from_seqs(\n            vec![\n                b\"AAAA\".to_vec(),\n                b\"GGGG\".to_vec(),\n                b\"CCCC\".to_vec(),\n                b\"TTTT\".to_vec(),\n            ]\n            .as_ref(),\n            None,\n        )\n        .unwrap();\n        assert_eq!(pssm.degenerate_consensus(), b\"NNNN\".to_vec());\n    }\n}\n","traces":[{"line":32,"address":[5264297,5263648],"length":1,"stats":{"Line":1},"fn_name":"from_seqs"},{"line":33,"address":[5264036,5263696],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[5264025],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[5264166],"length":1,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[5264211],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[5264336],"length":1,"stats":{"Line":3},"fn_name":"normalize"},{"line":46,"address":[5264489,5264356,5264935],"length":1,"stats":{"Line":7},"fn_name":null},{"line":47,"address":[5264526],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[5264740,5264538,5264852],"length":1,"stats":{"Line":7},"fn_name":null},{"line":50,"address":[5264772],"length":1,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[5265073,5264867,5264950,5264672,5265078],"length":1,"stats":{"Line":11},"fn_name":null},{"line":53,"address":[5264982],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[5265088],"length":1,"stats":{"Line":2},"fn_name":"calc_minmax"},{"line":60,"address":[5265100],"length":1,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[5265129],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[5265142,5265317,5265496],"length":1,"stats":{"Line":8},"fn_name":null},{"line":66,"address":[5198832,5198846],"length":1,"stats":{"Line":8},"fn_name":"{{closure}}"},{"line":67,"address":[5265476],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[5265247],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[5265587,5265260,5265786,5265511,5265781],"length":1,"stats":{"Line":10},"fn_name":null},{"line":73,"address":[5265672,5265619],"length":1,"stats":{"Line":4},"fn_name":null},{"line":74,"address":[5198926,5198912],"length":1,"stats":{"Line":8},"fn_name":"{{closure}}"},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[5265761],"length":1,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[5265792],"length":1,"stats":{"Line":0},"fn_name":"rev_lk"},{"line":95,"address":[5265853,5265839,5265860,5265846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[5265841,5265801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[5265848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[5265855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[5265862],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[5265834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[5265888],"length":1,"stats":{"Line":3},"fn_name":"len"},{"line":105,"address":[5265897],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[5265920],"length":1,"stats":{"Line":1},"fn_name":"get_scores"},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[5265936],"length":1,"stats":{"Line":1},"fn_name":"get_min_score"},{"line":112,"address":[5265941],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[5265952],"length":1,"stats":{"Line":1},"fn_name":"get_max_score"},{"line":115,"address":[5265957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[5265968],"length":1,"stats":{"Line":1},"fn_name":"get_bits"},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[5267739,5265984,5267724],"length":1,"stats":{"Line":1},"fn_name":"degenerate_consensus"},{"line":124,"address":[5267744],"length":1,"stats":{"Line":1},"fn_name":"two"},{"line":125,"address":[5267770],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[5268001,5267980,5268010,5267987,5267824,5268008,5267994],"length":1,"stats":{"Line":6},"fn_name":null},{"line":127,"address":[5267832,5267989,5267896],"length":1,"stats":{"Line":3},"fn_name":null},{"line":128,"address":[5267996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[5268003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[5267975,5267930],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[5267982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[5267954],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[5266015],"length":1,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[5266061],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[5266327,5266219,5267719,5266075],"length":1,"stats":{"Line":7},"fn_name":null},{"line":139,"address":[5266415,5266359],"length":1,"stats":{"Line":4},"fn_name":null},{"line":140,"address":[5198992,5199011],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":143,"address":[5199120,5199152],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":145,"address":[5267008,5266603,5266968],"length":1,"stats":{"Line":4},"fn_name":null},{"line":146,"address":[5266881,5266975],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[5267035,5266840],"length":1,"stats":{"Line":3},"fn_name":null},{"line":148,"address":[5267166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[5267456,5267435,5267124],"length":1,"stats":{"Line":5},"fn_name":null},{"line":150,"address":[5267461,5267589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[5267656,5267682,5267669,5267695],"length":1,"stats":{"Line":4},"fn_name":null},{"line":152,"address":[5267549,5267648],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[5267661],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[5267674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[5267687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[5267615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[5267448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[5268172,5268184,5268016],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":178,"address":[5268116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[5268127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[9182848,9182853],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":191,"address":[9550353,9550835,9550496,9550433,9550565],"length":1,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[9550366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[9550397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[9550465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[9550534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[9550868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[9551005,9551110],"length":1,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[9182880,9182885],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":205,"address":[9551538,9551368],"length":1,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[9551713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[9551744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[9551806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[9551858,9552128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[9552316,9552206,9552028],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[9551948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[9182912,9182917],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":221,"address":[9553240,9553554,9553410],"length":1,"stats":{"Line":3},"fn_name":null},{"line":225,"address":[9553611,9553913,9553676],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[9182944,9182949],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":230,"address":[9554930,9554769],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[9555162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[9555090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[9182976,9182981],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":239,"address":[9555874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[9555846],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[9555786,9555409],"length":1,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[9555819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[9183008,9183013],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":251,"address":[9556145,9556417],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[9556450],"length":1,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[9556599,9556643],"length":1,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[9183045,9183040],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":261,"address":[9557265,9556993],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[9557298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[9557447,9557491],"length":1,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[9183072,9183077],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":271,"address":[9558218,9557841],"length":1,"stats":{"Line":2},"fn_name":null},{"line":272,"address":[9558251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":275,"address":[9558409,9558453],"length":1,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[9183109,9183104],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":281,"address":[9558881,9558944,9559013,9558801,9559283],"length":1,"stats":{"Line":2},"fn_name":null},{"line":282,"address":[9558814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[9558845],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[9558913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[9558982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":288,"address":[9559316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[9559494,9559450],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":105,"coverable":123},{"path":["/","home","todd","rust-bio","src","pattern_matching","pssm","errors.rs"],"content":"// Copyright 2019 Johannes Köster, University of Duisburg-Essen.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Error definitions for the `pssm` module.\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum Error {\n    #[error(\n        \"query length {} is shorter than motif length {}\",\n        query_len,\n        motif_len\n    )]\n    QueryTooShort { motif_len: usize, query_len: usize },\n    #[error(\"attempted to build a motif from sequences with mismatched lengths\")]\n    InconsistentLen,\n    #[error(\"monomer '{}' is invalid\", char::from(*mono))]\n    InvalidMonomer { mono: u8 },\n    #[error(\"motif cannot be created from zero sequences\")]\n    EmptyMotif,\n    #[error(\"information-free motif: a motif in which every monomer is equally likely at every position will result in a divide-by-zero exception\")]\n    NullMotif,\n    #[error(\"expected pseudo-score array of length {}; got {}\", expected, received)]\n    InvalidPseudos { expected: u8, received: u8 },\n}\n\npub type Result\u003cT, E = Error\u003e = std::result::Result\u003cT, E\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","pattern_matching","pssm","mod.rs"],"content":"// Copyright 2018 Kieran Hervold\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Create a weight matrix representing a set of aligned reference sequences\n//! that constitute a motif, and use this matrix to scan query sequences for\n//! occurrences of this motif.\n//! Complexity: O(n*m) for motif length n and query length m\n//!\n//! The position-specific scoring matrix (PSSM), aka position weight matrix (PWM),\n//! algorithm is implemented for both DNA and amino-acid sequences.\n//!\n//! # Examples\n//!\n//! use bio::pattern_matching::pssm::DNAMotif;\n//! let pssm = DNAMotif::from_seqs(vec![\n//!            b\"AAAA\".to_vec(),\n//!            b\"AATA\".to_vec(),\n//!            b\"AAGA\".to_vec(),\n//!            b\"AAAA\".to_vec(),\n//!        ].as_ref(), None).unwrap();\n//! let start_pos = pssm.score(b\"CCCCCAATA\").unwrap().loc;\n//! println!(\"motif found at position {}\", start_pos);\n//!\n//! /* amino acid sequences are supported, too */\n//! use pssm::pattern_matching::pssm::ProtMotif;\n//! let pssm = ProtMotif::from_seqs(vec![\n//!            b\"ARNNYM\".to_vec(),\n//!            b\"ARNRYM\".to_vec(),\n//!            b\"ARNNCM\".to_vec(),\n//!            b\"ARNNYM\".to_vec(),\n//!        ].as_ref(), None).unwrap();\n\nuse std::borrow::Borrow;\nuse std::f32::NEG_INFINITY;\n\nuse itertools::Itertools;\nuse ndarray::prelude::Array2;\n\nmod dnamotif;\npub mod errors;\nmod protmotif;\n\npub use self::dnamotif::DNAMotif;\npub use self::errors::{Error, Result};\npub use self::protmotif::ProtMotif;\n\n/// default pseudocount - used to prevent 0 tallies\npub const DEF_PSEUDO: f32 = 0.5;\n/// approximately zero\npub const EPSILON: f32 = 1e-5;\n/// value representing an invalid monomer in lookup table\npub const INVALID_MONO: u8 = 255;\n\n/// Represents motif score \u0026 location of match\n#[derive(Debug, Clone, PartialEq)]\npub struct ScoredPos {\n    pub loc: usize,\n    pub sum: f32,\n    pub scores: Vec\u003cf32\u003e,\n}\n\nimpl Default for ScoredPos {\n    fn default() -\u003e ScoredPos {\n        ScoredPos {\n            loc: 0,\n            sum: NEG_INFINITY,\n            scores: Vec::new(),\n        }\n    }\n}\n\n/// Trait containing code shared between DNA and protein implementations\n/// of the position-specific scoring matrix.\npub trait Motif {\n    /// Lookup table mapping monomer -\u003e index\n    const LK: [u8; 127] = [INVALID_MONO; 127];\n    /// All monomers, in order corresponding to lookup table\n    const MONOS: \u0026'static [u8] = b\"\";\n    /// Monomer count - equal to length of `MONOS`\n    const MONO_CT: usize = 0;\n\n    /// Returns a weight matrix representing the sequences provided.\n    /// This code is shared by implementations of `from_seqs`\n    /// # Arguments\n    /// * `seqs` - sequences incorporated into motif\n    /// * `pseudos` - array slice with a pseudocount for each monomer;\n    ///    defaults to DEF_PSEUDO for all if None is supplied\n    ///\n    /// FIXME: pseudos should be an array of size MONO_CT, but that\n    /// is currently unsupported\n    fn seqs_to_weights(seqs: \u0026[Vec\u003cu8\u003e], _pseudos: Option\u003c\u0026[f32]\u003e) -\u003e Result\u003cArray2\u003cf32\u003e\u003e {\n        let p1 = vec![DEF_PSEUDO; Self::MONO_CT];\n        let pseudos = match _pseudos {\n            Some(ref p2) =\u003e p2,\n            None =\u003e p1.as_slice(),\n        };\n\n        if pseudos.len() != Self::MONO_CT {\n            return Err(Error::InvalidPseudos {\n                expected: Self::MONO_CT as u8,\n                received: pseudos.len() as u8,\n            });\n        }\n\n        if seqs.is_empty() {\n            return Err(Error::EmptyMotif);\n        }\n\n        let seqlen = seqs[0].len();\n        let mut counts = Array2::zeros((seqlen, Self::MONO_CT));\n        for i in 0..seqlen {\n            for base in 0..Self::MONO_CT {\n                counts[[i, base]] = pseudos[base];\n            }\n        }\n\n        for seq in seqs.iter() {\n            if seq.len() != seqlen {\n                return Err(Error::InconsistentLen);\n            }\n\n            for (idx, base) in seq.iter().enumerate() {\n                match Self::lookup(*base) {\n                    Err(e) =\u003e return Err(e),\n                    Ok(pos) =\u003e counts[[idx, pos]] += 1.0,\n                }\n            }\n        }\n        Ok(counts)\n    }\n\n    /// Returns the index of given monomer in the scores matrix using the lookup table `LK`\n    /// # Arguments\n    /// * `mono` - monomer, eg, b'A' for DNA or b'R' for protein\n    /// # Errors\n    /// * `Error::InvalidMonomer(mono)` - `mono` wasn't found in the lookup table\n    fn lookup(mono: u8) -\u003e Result\u003cusize\u003e {\n        if mono \u003e= 127 {\n            Err(Error::InvalidMonomer { mono })\n        } else {\n            let idx = Self::LK[mono as usize];\n            if idx == INVALID_MONO {\n                Err(Error::InvalidMonomer { mono })\n            } else {\n                Ok(idx as usize)\n            }\n        }\n    }\n\n    /// Returns the monomer associated with the given index; the reverse of `lookup`.\n    /// Returns INVALID_MONO if the index isn't associated with a monomer.\n    /// # Arguments\n    /// * `idx` - the index in question\n    fn rev_lk(idx: usize) -\u003e u8;\n\n    /// Returns the length of motif\n    fn len(\u0026self) -\u003e usize;\n\n    fn is_empty(\u0026self) -\u003e bool {\n        self.len() == 0usize\n    }\n\n    /// Returns a representation of the motif using ambiguous codes.\n    /// Primarily useful for DNA motifs, where ambiguous codes are\n    /// common (eg, 'M' for 'A or C'); less so for proteins, where we\n    /// represent any position without a dominant amino acid as an 'X'\n    fn degenerate_consensus(\u0026self) -\u003e Vec\u003cu8\u003e;\n\n    /// Accessor - returns scores matrix\n    fn get_scores(\u0026self) -\u003e \u0026Array2\u003cf32\u003e;\n\n    /// Return sum of \"worst\" base at each position\n    fn get_min_score(\u0026self) -\u003e f32;\n\n    /// Return sum of \"best\" base at each position\n    fn get_max_score(\u0026self) -\u003e f32;\n\n    /// Returns information content of a single position.\n    /// Used `info_content` method.\n    /// FIXME: this should be replaced with a CTFE ... or maybe just a constant\n    fn get_bits() -\u003e f32;\n\n    /// Returns the un-normalized sum of matching bases, useful for comparing matches from\n    /// motifs of different lengths\n    ///\n    /// # Arguments\n    /// * `seq_it` - iterator representing the query sequence\n    ///\n    /// # Errors\n    /// * `Error::InvalidMonomer(mono)` - sequence `seq_it` contained invalid monomer `mono`\n    fn raw_score\u003cC, T\u003e(\u0026self, seq_it: T) -\u003e Result\u003c(usize, f32, Vec\u003cf32\u003e)\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        let pssm_len = self.len();\n\n        let mut best_start = 0;\n        let mut best_score = -1.0;\n        let mut best_m = Vec::new();\n        // we have to look at slices, so a simple iterator won't do\n        let seq = seq_it.into_iter().map(|c| *c.borrow()).collect_vec();\n        let scores = self.get_scores();\n        for start in 0..=seq.len() - pssm_len {\n            let m: Vec\u003cf32\u003e = match (0..pssm_len)\n                .map(|i| match Self::lookup(seq[start + i]) {\n                    Err(e) =\u003e Err(e),\n                    Ok(pos) =\u003e Ok(scores[[i, pos]]),\n                })\n                .collect()\n            {\n                Ok(m) =\u003e m,\n                Err(e) =\u003e return Err(e),\n            };\n            let tot = m.iter().sum();\n            if tot \u003e best_score {\n                best_score = tot;\n                best_start = start;\n                best_m = m;\n            }\n        }\n        Ok((best_start, best_score, best_m))\n    }\n\n    /// Returns a `ScoredPos` struct representing the best match within the query sequence\n    /// see:\n    ///   MATCHTM: a tool for searching transcription factor binding sites in DNA sequences\n    ///   Nucleic Acids Res. 2003 Jul 1; 31(13): 3576–3579\n    ///   https://www.ncbi.nlm.nih.gov/pmc/articles/PMC169193/\n    ///\n    /// # Arguments\n    /// * `seq_it` - iterator representing the query sequence\n    ///\n    /// # Errors\n    /// * `Error::InvalidMonomer(mono)` - sequence `seq_it` contained invalid monomer `mono`\n    /// * `Error::QueryTooShort` - sequence `seq_id` was too short\n    ///\n    /// # Example\n    /// let pssm = DNAMotif::from_seqs(vec![\n    ///            b\"AAAA\".to_vec(),\n    ///            b\"AATA\".to_vec(),\n    ///            b\"AAGA\".to_vec(),\n    ///            b\"AAAA\".to_vec(),\n    ///        ].as_ref(), None).unwrap();\n    /// let start_pos = pssm.score(b\"CCCCCAATA\").unwrap().loc;\n    fn score\u003cC, T\u003e(\u0026self, seq_it: T) -\u003e Result\u003cScoredPos\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        let pssm_len = self.len();\n        let seq = seq_it.into_iter().map(|c| *c.borrow()).collect_vec();\n        if seq.len() \u003c pssm_len {\n            return Err(Error::QueryTooShort {\n                motif_len: pssm_len,\n                query_len: seq.len(),\n            });\n        }\n        let min_score = self.get_min_score();\n        let max_score = self.get_max_score();\n\n        if abs_diff_eq!(max_score, min_score) {\n            return Err(Error::NullMotif);\n        }\n\n        let (best_start, best_score, best_m) = self.raw_score(\u0026seq)?;\n\n        Ok(ScoredPos {\n            loc: best_start,\n            sum: (best_score - min_score) / (max_score - min_score),\n            scores: best_m,\n        })\n    }\n\n    /// Returns a float representing the information content of a motif; roughly the\n    /// inverse of Shannon Entropy.\n    /// Adapted from the information content described here:\n    ///    https://en.wikipedia.org/wiki/Sequence_logo#Logo_creation\n    fn info_content(\u0026self) -\u003e f32 {\n        fn ent\u003c'a, I\u003e(probs: I) -\u003e f32\n        where\n            I: Iterator\u003cItem = \u0026'a f32\u003e,\n        {\n            probs\n                .map(|p| {\n                    if *p == 0.0 {\n                        0.0\n                    } else {\n                        -1.0 * *p * p.log(2.0)\n                    }\n                })\n                .sum()\n        }\n        let bits = Self::get_bits();\n        let scores = self.get_scores();\n        let mut tot = 0.0;\n        for row in scores.genrows() {\n            tot += bits - ent(row.iter());\n        }\n        tot\n    }\n}\n","traces":[{"line":65,"address":[5230000],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":69,"address":[5230013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[5201745,5199200,5201760],"length":1,"stats":{"Line":3},"fn_name":"seqs_to_weights\u003cbio::pattern_matching::pssm::dnamotif::DNAMotif\u003e"},{"line":94,"address":[4695271],"length":1,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[4695321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[4695364,4695298],"length":1,"stats":{"Line":6},"fn_name":null},{"line":97,"address":[4695466,4695323],"length":1,"stats":{"Line":4},"fn_name":null},{"line":100,"address":[4695412,4695533],"length":1,"stats":{"Line":7},"fn_name":null},{"line":101,"address":[4695632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[4695578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[4695555,4695724],"length":1,"stats":{"Line":8},"fn_name":null},{"line":108,"address":[4695760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[4695821,4695738],"length":1,"stats":{"Line":10},"fn_name":null},{"line":112,"address":[4695889],"length":1,"stats":{"Line":5},"fn_name":null},{"line":113,"address":[4695952,4696477,4696096,4696240],"length":1,"stats":{"Line":25},"fn_name":null},{"line":114,"address":[4696703,4696482,4696280],"length":1,"stats":{"Line":20},"fn_name":null},{"line":115,"address":[4696522],"length":1,"stats":{"Line":6},"fn_name":null},{"line":119,"address":[4696932,4696724,4697346,4696204],"length":1,"stats":{"Line":30},"fn_name":null},{"line":120,"address":[4696969],"length":1,"stats":{"Line":7},"fn_name":null},{"line":121,"address":[4697046],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[4697129,4697011,4697351,4697740],"length":1,"stats":{"Line":31},"fn_name":null},{"line":125,"address":[4697459,4697420],"length":1,"stats":{"Line":7},"fn_name":null},{"line":126,"address":[4697442,4697559],"length":1,"stats":{"Line":7},"fn_name":null},{"line":127,"address":[4697724,4697466],"length":1,"stats":{"Line":15},"fn_name":null},{"line":131,"address":[4696842],"length":1,"stats":{"Line":7},"fn_name":null},{"line":139,"address":[4697760],"length":1,"stats":{"Line":8},"fn_name":"lookup\u003cbio::pattern_matching::pssm::protmotif::ProtMotif\u003e"},{"line":140,"address":[4697791],"length":1,"stats":{"Line":7},"fn_name":null},{"line":141,"address":[4697851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[4697912,4697938,4697795],"length":1,"stats":{"Line":15},"fn_name":null},{"line":144,"address":[4698053,4697927,4698058,4697984],"length":1,"stats":{"Line":18},"fn_name":null},{"line":145,"address":[4697995],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[4697970],"length":1,"stats":{"Line":7},"fn_name":null},{"line":161,"address":[4698064],"length":1,"stats":{"Line":0},"fn_name":"is_empty\u003cbio::pattern_matching::pssm::protmotif::ProtMotif\u003e"},{"line":162,"address":[4698073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[9290656,9292441],"length":1,"stats":{"Line":3},"fn_name":"raw_score\u003cbio::pattern_matching::pssm::dnamotif::DNAMotif,\u0026u8,\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":198,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[9293648,9293619,9292464,9294803],"length":1,"stats":{"Line":4},"fn_name":"score\u003cbio::pattern_matching::pssm::dnamotif::DNAMotif,\u0026u8,\u0026[u8; 12]\u003e"},{"line":253,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[4698112],"length":1,"stats":{"Line":2},"fn_name":"info_content\u003cbio::pattern_matching::pssm::protmotif::ProtMotif\u003e"},{"line":282,"address":[5212384],"length":1,"stats":{"Line":1},"fn_name":"ent\u003cndarray::iterators::Iter\u003cf32, ndarray::dimension::dim::Dim\u003c[usize; 1]\u003e\u003e\u003e"},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[5212391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[5212464],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}\u003cndarray::iterators::Iter\u003cf32, ndarray::dimension::dim::Dim\u003c[usize; 1]\u003e\u003e\u003e"},{"line":288,"address":[5212589,5212587,5212483],"length":1,"stats":{"Line":2},"fn_name":null},{"line":289,"address":[5212546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[5212577,5212504],"length":1,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[4698132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":297,"address":[4698158],"length":1,"stats":{"Line":2},"fn_name":null},{"line":298,"address":[4698182],"length":1,"stats":{"Line":2},"fn_name":null},{"line":299,"address":[4698564,4698191,4698569,4698302],"length":1,"stats":{"Line":6},"fn_name":null},{"line":300,"address":[4698494],"length":1,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":68,"coverable":88},{"path":["/","home","todd","rust-bio","src","pattern_matching","pssm","protmotif.rs"],"content":"// Copyright 2018 Kieran Hervold\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse super::*;\nuse ndarray::prelude::Array2;\nuse std::f32;\nuse std::f32::{INFINITY, NEG_INFINITY};\n\n/// Position-specific scoring matrix for protein sequences\n#[derive(Clone, Debug, PartialEq)]\npub struct ProtMotif {\n    /// matrix holding weights at each position, indexed by [position, base]\n    pub scores: Array2\u003cf32\u003e,\n    /// sum of \"worst\" base at each position\n    pub min_score: f32,\n    /// sum of \"best\" base at each position\n    pub max_score: f32,\n}\n\nimpl ProtMotif {\n    /// Returns a Motif representing the sequences provided.\n    /// # Arguments\n    /// * `seqs` - sequences incorporated into motif\n    /// * `pseudos` - array slice with a pseudocount for each monomer;\n    ///    defaults to pssm::DEF_PSEUDO for all if None is supplied\n    ///\n    /// FIXME: pseudos should be an array of size MONO_CT, but that\n    /// is currently impossible - see\n    /// https://github.com/rust-lang/rust/issues/42863\n    pub fn from_seqs(seqs: \u0026[Vec\u003cu8\u003e], pseudos: Option\u003c\u0026[f32]\u003e) -\u003e Result\u003cSelf\u003e {\n        let w = Self::seqs_to_weights(seqs, pseudos)?;\n        let mut m = ProtMotif {\n            scores: w,\n            min_score: 0.0,\n            max_score: 0.0,\n        };\n        m.normalize();\n        m.calc_minmax();\n        Ok(m)\n    }\n\n    // helper function -- normalize self.scores\n    fn normalize(\u0026mut self) {\n        for i in 0..self.len() {\n            let mut tot: f32 = 0.0;\n            // FIXME: slices would be cleaner\n            for base_i in 0..20 {\n                tot += self.scores[[i, base_i]];\n            }\n            for base_i in 0..20 {\n                self.scores[[i, base_i]] /= tot;\n            }\n        }\n    }\n\n    // helper function\n    fn calc_minmax(\u0026mut self) {\n        let pssm_len = self.len();\n\n        // score corresponding to sum of \"worst\" bases at each position\n        // FIXME: iter ...\n        self.min_score = 0.0;\n        for i in 0..pssm_len {\n            // can't use the regular min/max on f32, so we use f32::min\n            let min_sc = (0..20)\n                .map(|b| self.scores[[i, b]])\n                .fold(INFINITY, f32::min);\n            self.min_score += min_sc;\n        }\n\n        // score corresponding to \"best\" base at each position\n        self.max_score = 0.0;\n        for i in 0..pssm_len {\n            let max_sc = (0..20)\n                .map(|b| self.scores[[i, b]])\n                .fold(NEG_INFINITY, f32::max);\n            self.max_score += max_sc;\n        }\n    }\n}\n\nimpl Motif for ProtMotif {\n    const LK: [u8; 127] = [\n        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 255, 4, 3, 5, 13, 7, 8, 9, 255,\n        11, 10, 12, 2, 255, 14, 6, 1, 15, 16, 255, 19, 17, 255, 18, 255, 255, 255, 255, 255, 255,\n        255, 0, 255, 4, 3, 5, 13, 7, 8, 9, 255, 11, 10, 12, 2, 255, 14, 6, 1, 15, 16, 255, 19, 17,\n        255, 18, 255, 255, 255, 255, 255,\n    ];\n    const MONOS: \u0026'static [u8] = b\"ARNDCEQGHILKMFPSTWYV\";\n    const MONO_CT: usize = 20;\n\n    fn rev_lk(idx: usize) -\u003e u8 {\n        if idx \u003e= Self::MONOS.len() {\n            INVALID_MONO\n        } else {\n            Self::MONOS[idx]\n        }\n    }\n\n    fn len(\u0026self) -\u003e usize {\n        self.scores.dim().0\n    }\n    fn get_scores(\u0026self) -\u003e \u0026Array2\u003cf32\u003e {\n        \u0026self.scores\n    }\n    fn get_min_score(\u0026self) -\u003e f32 {\n        self.min_score\n    }\n    fn get_max_score(\u0026self) -\u003e f32 {\n        self.max_score\n    }\n    fn get_bits() -\u003e f32 {\n        20f32.log2()\n    }\n    fn degenerate_consensus(\u0026self) -\u003e Vec\u003cu8\u003e {\n        let len = self.len();\n        let mut res = Vec::with_capacity(len);\n        for pos in 0..len {\n            let mut fracs = (0..20)\n                .map(|b| (self.scores[[pos, b]], b))\n                .collect::\u003cVec\u003c(f32, usize)\u003e\u003e();\n            // note: reverse sort\n            fracs.sort_by(|a, b| b.partial_cmp(a).unwrap());\n\n            res.push(if fracs[0].0 \u003e 0.5 \u0026\u0026 fracs[0].0 \u003e 2.0 * fracs[1].0 {\n                Self::MONOS[fracs[0].1]\n            } else {\n                b'X'\n            });\n        }\n        res\n    }\n}\n\n/// Return a ProtMotif wrapping an Array2 representing amino acid\n/// weights at each position.  The dimensions and contents of this\n/// array are unchecked, and it is incumbent on the user to ensure\n/// the correct dimensions are used (ie, SEQ_LEN x 20), and no zeros\n/// appear in the array.\nimpl From\u003cArray2\u003cf32\u003e\u003e for ProtMotif {\n    fn from(scores: Array2\u003cf32\u003e) -\u003e Self {\n        let mut m = ProtMotif {\n            scores,\n            min_score: 0.0,\n            max_score: 0.0,\n        };\n        m.normalize();\n        m.calc_minmax();\n        m\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use ndarray::Array;\n\n    #[test]\n    fn test_info_content() {\n        let pssm = ProtMotif::from_seqs(vec![b\"AAAA\".to_vec()].as_ref(), Some(\u0026[0.0; 20])).unwrap();\n        assert_relative_eq!(\n            pssm.info_content(),\n            ProtMotif::get_bits() * 4.0,\n            epsilon = f32::EPSILON\n        );\n    }\n\n    #[test]\n    fn test_scoring() {\n        // should match \"ARND\"\n        let m: Array2\u003cf32\u003e = Array::from(vec![\n            0.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,\n            0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,\n            0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,\n            0.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,\n            0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,\n            0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,\n        ])\n        .into_shape((4, 20))\n        .unwrap();\n        let pssm: ProtMotif = m.into();\n        let scored_pos = pssm.score(b\"AAAAARNDAAA\").unwrap();\n        assert_eq!(scored_pos.loc, 4);\n    }\n\n    #[test]\n    fn test_mono_err() {\n        let pssm = ProtMotif::from_seqs(vec![b\"ARGN\".to_vec()].as_ref(), None).unwrap();\n        assert!(matches!(\n            pssm.score(b\"AAAABAAAAAAAAA\"),\n            Err(Error::InvalidMonomer { mono: b'B' })\n        ));\n    }\n\n    #[test]\n    fn test_inconsist_err() {\n        assert!(matches!(\n            ProtMotif::from_seqs(\n                vec![b\"NNNNN\".to_vec(), b\"RRRRR\".to_vec(), b\"C\".to_vec()].as_ref(),\n                Some(\u0026[0.0; 20])\n            ),\n            Err(Error::InconsistentLen)\n        ));\n    }\n\n    #[test]\n    fn test_degenerate_consensus_same_bases() {\n        let pssm = ProtMotif::from_seqs(\n            vec![b\"QVTYNDSA\".to_vec(), b\"QVTYNDSA\".to_vec()].as_ref(),\n            Some(\u0026[0.0; 20]),\n        )\n        .unwrap();\n        assert_eq!(pssm.degenerate_consensus(), b\"QVTYNDSA\".to_vec());\n    }\n\n    #[test]\n    fn test_degenerate_consensus_x() {\n        let pssm = ProtMotif::from_seqs(\n            vec![b\"QVTYNDSA\".to_vec(), b\"ASDNYTVQ\".to_vec()].as_ref(),\n            Some(\u0026[0.0; 20]),\n        )\n        .unwrap();\n        assert_eq!(pssm.degenerate_consensus(), b\"XXXXXXXX\".to_vec());\n    }\n}\n","traces":[{"line":32,"address":[4874544,4875193],"length":1,"stats":{"Line":1},"fn_name":"from_seqs"},{"line":33,"address":[4874932,4874592],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[4874921],"length":1,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[4875062],"length":1,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[4875107],"length":1,"stats":{"Line":4},"fn_name":null},{"line":45,"address":[4875232],"length":1,"stats":{"Line":1},"fn_name":"normalize"},{"line":46,"address":[4875385,4875831,4875252],"length":1,"stats":{"Line":15},"fn_name":null},{"line":47,"address":[4875422],"length":1,"stats":{"Line":5},"fn_name":null},{"line":49,"address":[4875636,4875748,4875434],"length":1,"stats":{"Line":15},"fn_name":null},{"line":50,"address":[4875668],"length":1,"stats":{"Line":5},"fn_name":null},{"line":52,"address":[4875974,4875568,4875969,4875763,4875846],"length":1,"stats":{"Line":20},"fn_name":null},{"line":53,"address":[4875878],"length":1,"stats":{"Line":5},"fn_name":null},{"line":59,"address":[4875984],"length":1,"stats":{"Line":5},"fn_name":"calc_minmax"},{"line":60,"address":[4875996],"length":1,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[4876025],"length":1,"stats":{"Line":5},"fn_name":null},{"line":65,"address":[4876213,4876392,4876038],"length":1,"stats":{"Line":15},"fn_name":null},{"line":67,"address":[4876289,4876239],"length":1,"stats":{"Line":10},"fn_name":null},{"line":68,"address":[4694832,4694846],"length":1,"stats":{"Line":15},"fn_name":"{{closure}}"},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[4876372],"length":1,"stats":{"Line":5},"fn_name":null},{"line":74,"address":[4876143],"length":1,"stats":{"Line":5},"fn_name":null},{"line":75,"address":[4876677,4876156,4876483,4876407,4876682],"length":1,"stats":{"Line":20},"fn_name":null},{"line":76,"address":[4876515,4876568],"length":1,"stats":{"Line":10},"fn_name":null},{"line":77,"address":[4694926,4694912],"length":1,"stats":{"Line":15},"fn_name":"{{closure}}"},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[4876657],"length":1,"stats":{"Line":5},"fn_name":null},{"line":97,"address":[4876688],"length":1,"stats":{"Line":0},"fn_name":"rev_lk"},{"line":98,"address":[4876791,4876702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[4876758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[4876745,4876777,4876821,4876798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[4876832],"length":1,"stats":{"Line":5},"fn_name":"len"},{"line":106,"address":[4876841],"length":1,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[4876864],"length":1,"stats":{"Line":1},"fn_name":"get_scores"},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[4876880],"length":1,"stats":{"Line":1},"fn_name":"get_min_score"},{"line":112,"address":[4876885],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[4876896],"length":1,"stats":{"Line":2},"fn_name":"get_max_score"},{"line":115,"address":[4876901],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[4876912],"length":1,"stats":{"Line":1},"fn_name":"get_bits"},{"line":118,"address":[4876913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[4876944,4877908,4877893],"length":1,"stats":{"Line":2},"fn_name":"degenerate_consensus"},{"line":121,"address":[4876969],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[4877006],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[4877017,4877146,4877239,4877888],"length":1,"stats":{"Line":8},"fn_name":null},{"line":124,"address":[4877327,4877271],"length":1,"stats":{"Line":4},"fn_name":null},{"line":125,"address":[4695011,4694992],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":128,"address":[4695120,4695152],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":130,"address":[4877813,4877503,4877724,4877850],"length":1,"stats":{"Line":6},"fn_name":null},{"line":131,"address":[4877820,4877726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[4877716],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[4877920,4878076,4878088],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":152,"address":[4878020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[4878031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[5571168,5571339],"length":1,"stats":{"Line":3},"fn_name":"test_info_content"},{"line":165,"address":[5571362,5571192],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[5571912,5571691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[5571563,5571628],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[5571637],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[5574461,5572768],"length":1,"stats":{"Line":3},"fn_name":"test_scoring"},{"line":176,"address":[5574044,5572775],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[5574020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[5574100],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[5574144],"length":1,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[5574355,5574244],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[5574651,5574496],"length":1,"stats":{"Line":3},"fn_name":"test_mono_err"},{"line":193,"address":[5574674,5574513],"length":1,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[5574917,5574937,5574996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[5574828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[5574892,5574927],"length":1,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[5575040,5575408],"length":1,"stats":{"Line":3},"fn_name":"test_inconsist_err"},{"line":202,"address":[5575664,5575570,5575634,5575516],"length":1,"stats":{"Line":1},"fn_name":"test_degenerate_consensus_same_bases"},{"line":203,"address":[5575488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[5575057,5575428],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[5575461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[5575551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[5575935,5575664],"length":1,"stats":{"Line":3},"fn_name":"test_degenerate_consensus_same_bases"},{"line":214,"address":[5575958,5575686],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[5575991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[5576149,5576193],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[5576528,5576799],"length":1,"stats":{"Line":3},"fn_name":"test_degenerate_consensus_x"},{"line":224,"address":[5576822,5576550],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[5576855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[5577057,5577013],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":76,"coverable":85},{"path":["/","home","todd","rust-bio","src","pattern_matching","shift_and.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! `ShiftAnd` algorithm for pattern matching.\n//! Patterns may contain at most 64 symbols.\n//! Complexity: O(n) with text length n.\n//!\n//! # Example\n//!\n//! ```rust\n//! use bio::pattern_matching::shift_and;\n//! let pattern = b\"AAAA\";\n//! let text = b\"ACGGCTAGAAAAGGCTAG\";\n//! let shiftand = shift_and::ShiftAnd::new(pattern);\n//! let occ = shiftand.find_all(text).next().unwrap();\n//! assert_eq!(occ, 8);\n//! ```\n\nuse std::borrow::Borrow;\nuse std::iter::Enumerate;\n\n/// `ShiftAnd` algorithm.\npub struct ShiftAnd {\n    m: usize,\n    masks: [u64; 256],\n    accept: u64,\n}\n\nimpl ShiftAnd {\n    /// Create new ShiftAnd instance from a given pattern.\n    pub fn new\u003cC, P\u003e(pattern: P) -\u003e Self\n    where\n        P::IntoIter: ExactSizeIterator,\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n    {\n        let pattern = pattern.into_iter();\n        let m = pattern.len();\n        assert!(m \u003c= 64, \"Expecting a pattern of at most 64 symbols.\");\n        let (masks, accept) = masks(pattern);\n\n        ShiftAnd { m, masks, accept }\n    }\n\n    /// Find all matches of pattern in the given text. Matches are returned as an iterator\n    /// over start positions.\n    pub fn find_all\u003cC, T\u003e(\u0026self, text: T) -\u003e Matches\u003c'_, C, T::IntoIter\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        Matches {\n            shiftand: self,\n            active: 0,\n            text: text.into_iter().enumerate(),\n        }\n    }\n}\n\n/// Calculate ShiftAnd masks. This function is called automatically when instantiating\n/// a new ShiftAnd for a given pattern.\npub fn masks\u003cC, P\u003e(pattern: P) -\u003e ([u64; 256], u64)\nwhere\n    C: Borrow\u003cu8\u003e,\n    P: IntoIterator\u003cItem = C\u003e,\n{\n    let mut masks = [0; 256];\n\n    let mut bit = 1;\n    for c in pattern {\n        masks[*c.borrow() as usize] |= bit;\n        bit *= 2;\n    }\n\n    (masks, bit / 2)\n}\n\n/// Iterator over start positions of matches.\npub struct Matches\u003c'a, C, T\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    shiftand: \u0026'a ShiftAnd,\n    active: u64,\n    text: Enumerate\u003cT\u003e,\n}\n\nimpl\u003c'a, C, T\u003e Iterator for Matches\u003c'a, C, T\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    type Item = usize;\n\n    fn next(\u0026mut self) -\u003e Option\u003cusize\u003e {\n        for (i, c) in self.text.by_ref() {\n            self.active = ((self.active \u003c\u003c 1) | 1) \u0026 self.shiftand.masks[*c.borrow() as usize];\n            if self.active \u0026 self.shiftand.accept \u003e 0 {\n                return Some(i + 1 - self.shiftand.m);\n            }\n        }\n\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use itertools::Itertools;\n\n    #[test]\n    fn test_find_all() {\n        let text = b\"dhjalkjwqnnnannanaflkjdklfj\";\n        let pattern = b\"qnnnannan\";\n        let shiftand = ShiftAnd::new(pattern);\n        assert_eq!(shiftand.find_all(text).collect_vec(), [8]);\n    }\n\n    #[test]\n    fn test_issue_416() {\n        let text_pos_0 = b\"CCTTTTTTTTTTTTTTT\";\n        let pattern = b\"CC\";\n        let shiftand = ShiftAnd::new(pattern);\n        assert_eq!(shiftand.find_all(text_pos_0).collect_vec(), [0]);\n    }\n\n    #[test]\n    fn test_multiple_finds() {\n        let text = b\"CCTCCTCC\";\n        let pattern = b\"CC\";\n        let shiftand = ShiftAnd::new(pattern);\n        assert_eq!(shiftand.find_all(text).collect_vec(), [0, 3, 6]);\n    }\n}\n","traces":[{"line":33,"address":[6087296,6087266,6087810,6086752],"length":1,"stats":{"Line":2},"fn_name":"new\u003c\u0026u8,\u0026[u8; 9]\u003e"},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":49,"address":[6087984,6087840,6088128],"length":1,"stats":{"Line":3},"fn_name":"find_all\u003c\u0026u8,\u0026[u8; 17]\u003e"},{"line":57,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[6088272,6088928,6089466,6088810],"length":1,"stats":{"Line":2},"fn_name":"masks\u003c\u0026u8,core::iter::adapters::rev::Rev\u003ccore::slice::iter::Iter\u003cu8\u003e\u003e\u003e"},{"line":69,"address":[6088321,6088977],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[6089012,6088356],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[6089024,6088514,6088801,6089170,6088368,6089457,6088529,6089185],"length":1,"stats":{"Line":6},"fn_name":null},{"line":73,"address":[6088577,6088678,6089233,6089334,6088723,6089379],"length":1,"stats":{"Line":4},"fn_name":null},{"line":74,"address":[6089344,6089409,6088753,6089419,6088688,6088763],"length":1,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[6088825,6089481],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":116,"address":[4322068,4321760],"length":1,"stats":{"Line":3},"fn_name":"test_find_all"},{"line":117,"address":[4321767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[4321782],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[4321797],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[4321814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[4322404,4322096],"length":1,"stats":{"Line":3},"fn_name":"test_issue_416"},{"line":125,"address":[4322103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[4322118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[4322133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[4322150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[4322740,4322432],"length":1,"stats":{"Line":3},"fn_name":"test_multiple_finds"},{"line":133,"address":[4322439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[4322454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[4322469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[4322486],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":35,"coverable":35},{"path":["/","home","todd","rust-bio","src","pattern_matching","ukkonen.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Bounded version of Ukkonens DP algorithm for approximate pattern matching.\n//! Complexity: O(n * k) on random texts.\n//!\n//! The algorithm finds all matches of a pattern in a text with up to k errors.\n//! Idea is to use dynamic programming to column-wise explore the edit matrix, but to omit\n//! parts of the matrix for which the error exceeds k. To achieve this, a value `lastk` is\n//! maintained that provides the lower feasible boundary of the matrix.\n//! Initially, lastk = min(k, m). In each iteration (over a column), lastk can increase by at most 1.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::pattern_matching::ukkonen::{unit_cost, Ukkonen};\n//!\n//! let mut ukkonen = Ukkonen::with_capacity(10, unit_cost);\n//! let text = b\"ACCGTGGATGAGCGCCATAG\";\n//! let pattern = b\"TGAGCGA\";\n//! let occ: Vec\u003c(usize, usize)\u003e = ukkonen.find_all_end(pattern, text, 1).collect();\n//! assert_eq!(occ, [(13, 1), (14, 1)]);\n//! ```\n\nuse std::borrow::Borrow;\nuse std::cmp::min;\nuse std::iter;\nuse std::iter::repeat;\n\nuse crate::utils::TextSlice;\n\n/// Default cost function (unit costs).\npub fn unit_cost(a: u8, b: u8) -\u003e u32 {\n    (a != b) as u32\n}\n\n/// Ukkonens algorithm.\n#[allow(non_snake_case)]\npub struct Ukkonen\u003cF\u003e\nwhere\n    F: Fn(u8, u8) -\u003e u32,\n{\n    D: [Vec\u003cusize\u003e; 2],\n    cost: F,\n}\n\nimpl\u003cF\u003e Ukkonen\u003cF\u003e\nwhere\n    F: Fn(u8, u8) -\u003e u32,\n{\n    /// Initialize algorithm with given capacity and cost function.\n    pub fn with_capacity(m: usize, cost: F) -\u003e Self {\n        let get_vec = || Vec::with_capacity(m + 1);\n        Ukkonen {\n            D: [get_vec(), get_vec()],\n            cost,\n        }\n    }\n\n    /// Find all matches between pattern and text with up to k errors.\n    /// Matches are returned as an iterator over pairs of end position and distance.\n    pub fn find_all_end\u003c'a, C, T\u003e(\n        \u0026'a mut self,\n        pattern: TextSlice\u003c'a\u003e,\n        text: T,\n        k: usize,\n    ) -\u003e Matches\u003c'_, F, C, T::IntoIter\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        let m = pattern.len();\n        self.D[0].clear();\n        self.D[0].extend(repeat(k + 1).take(m + 1));\n        self.D[1].clear();\n        self.D[1].extend(0..=m);\n        Matches {\n            ukkonen: self,\n            pattern,\n            text: text.into_iter().enumerate(),\n            lastk: min(k, m),\n            m,\n            k,\n        }\n    }\n}\n\n/// Iterator over pairs of end positions and distance of matches.\npub struct Matches\u003c'a, F, C, T\u003e\nwhere\n    F: Fn(u8, u8) -\u003e u32,\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    ukkonen: \u0026'a mut Ukkonen\u003cF\u003e,\n    pattern: TextSlice\u003c'a\u003e,\n    text: iter::Enumerate\u003cT\u003e,\n    lastk: usize,\n    m: usize,\n    k: usize,\n}\n\nimpl\u003c'a, F, C, T\u003e Iterator for Matches\u003c'a, F, C, T\u003e\nwhere\n    F: 'a + Fn(u8, u8) -\u003e u32,\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    type Item = (usize, usize);\n\n    fn next(\u0026mut self) -\u003e Option\u003c(usize, usize)\u003e {\n        let cost = \u0026self.ukkonen.cost;\n        for (i, c) in \u0026mut self.text {\n            let col = i % 2;\n            let prev = 1 - col;\n\n            // start with zero edit distance (semi-global alignment)\n            self.ukkonen.D[col][0] = 0;\n            self.lastk = min(self.lastk + 1, self.m);\n            // in each column, go at most one cell further than before\n            // do not look at cells with too big k\n            for j in 1..=self.lastk {\n                self.ukkonen.D[col][j] = min(\n                    min(self.ukkonen.D[prev][j] + 1, self.ukkonen.D[col][j - 1] + 1),\n                    self.ukkonen.D[prev][j - 1] + (cost)(self.pattern[j - 1], *c.borrow()) as usize,\n                );\n            }\n\n            // reduce lastk as long as k is exceeded: while lastk can increase by at most 1, it can\n            // decrease more in one iteration.\n            while self.ukkonen.D[col][self.lastk] \u003e self.k {\n                self.lastk -= 1;\n            }\n\n            if self.lastk == self.m {\n                return Some((i, self.ukkonen.D[col][self.m]));\n            }\n        }\n\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_find_all_end() {\n        let mut ukkonen = Ukkonen::with_capacity(10, unit_cost);\n        let text = b\"ACCGTGGATGAGCGCCATAG\";\n        let pattern = b\"TGAGCGT\";\n        let occ: Vec\u003c(usize, usize)\u003e = ukkonen.find_all_end(pattern, text, 1).collect();\n        assert_eq!(occ, [(13, 1), (14, 1)]);\n    }\n\n    #[test]\n    fn test_find_start() {\n        let mut u = Ukkonen::with_capacity(10, unit_cost);\n\n        let pattern = b\"ACCGT\";\n        // hit begins at 1st position\n        let text1 = b\"ACCGTGGATGAGCGCCATAG\";\n        // hit begins at 2nd position\n        let text2 = b\"AACCGTGGATGAGCGCCATAG\";\n\n        let occ: Vec\u003c(usize, usize)\u003e = u.find_all_end(pattern, text1, 1).collect();\n        assert_eq!(occ, [(3, 1), (4, 0), (5, 1)]);\n        let occ: Vec\u003c(usize, usize)\u003e = u.find_all_end(pattern, text2, 1).collect();\n        assert_eq!(occ, [(4, 1), (5, 0), (6, 1)]);\n    }\n}\n","traces":[{"line":35,"address":[9178224],"length":1,"stats":{"Line":1},"fn_name":"unit_cost"},{"line":36,"address":[9178241],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[6350032,6350254,6350269],"length":1,"stats":{"Line":1},"fn_name":"with_capacity\u003cfn(u8, u8) -\u003e u32\u003e"},{"line":55,"address":[6350291,6350058,6350272],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}\u003cfn(u8, u8) -\u003e u32\u003e"},{"line":57,"address":[6350128,6350073,6350216],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[6351109,6351136,6351861,6350384],"length":1,"stats":{"Line":2},"fn_name":"find_all_end\u003cfn(u8, u8) -\u003e u32,\u0026u8,\u0026[u8; 20]\u003e"},{"line":74,"address":[6350488,6351240],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[6350547,6351299],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[6350614,6351366],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[6351704,6350952],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[6354461,6351888],"length":1,"stats":{"Line":1},"fn_name":"next\u003cfn(u8, u8) -\u003e u32,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":114,"address":[6351938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[6351965,6352161,6352131,6354456],"length":1,"stats":{"Line":3},"fn_name":null},{"line":116,"address":[6352265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[6352332,6352420],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[9183429,9183424],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":152,"address":[4319287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[4319302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[4319317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[4319353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[4319419,4319573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[4320311,4319664],"length":1,"stats":{"Line":3},"fn_name":"test_find_start"},{"line":161,"address":[4319671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[4319686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[4319701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[4319716],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[4319752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[4320001,4319818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[4319946,4320063],"length":1,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[4320078,4320236],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":44,"coverable":44},{"path":["/","home","todd","rust-bio","src","scores","blosum62.rs"],"content":"// Copyright 2014-2017 M. Rizky Luthfianto.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\nlazy_static! {\n    // taken from https://github.com/seqan/seqan/blob/master/include%2Fseqan%2Fscore%2Fscore_matrix_data.h#L327\n    static ref MAT: ndarray::Array2\u003ci32\u003e = ndarray::Array::from_shape_vec((27, 27), vec![\n         4, -2,  0, -2, -1, -2,  0, -2, -1, -1, -1, -1, -1, -2,  0, -1, -1, -1,  1,  0,  0,\n         0, -3, -2, -1,  0, -4,\n        -2,  4, -3,  4,  1, -3, -1,  0, -3, -4,  0, -4, -3,  3, -1, -2,  0, -1,  0, -1, -1,\n        -3, -4, -3,  1, -1, -4,\n         0, -3,  9, -3, -4, -2, -3, -3, -1, -1, -3, -1, -1, -3, -2, -3, -3, -3, -1, -1, -2,\n        -1, -2, -2, -3, -2, -4,\n        -2,  4, -3,  6,  2, -3, -1, -1, -3, -4, -1, -4, -3,  1, -1, -1,  0, -2,  0, -1, -1,\n        -3, -4, -3,  1, -1, -4,\n        -1,  1, -4,  2,  5, -3, -2,  0, -3, -3,  1, -3, -2,  0, -1, -1,  2,  0,  0, -1, -1,\n        -2, -3, -2,  4, -1, -4,\n        -2, -3, -2, -3, -3,  6, -3, -1,  0,  0, -3,  0,  0, -3, -1, -4, -3, -3, -2, -2, -1,\n        -1,  1,  3, -3, -1, -4,\n         0, -1, -3, -1, -2, -3,  6, -2, -4, -4, -2, -4, -3,  0, -1, -2, -2, -2,  0, -2, -1,\n        -3, -2, -3, -2, -1, -4,\n        -2,  0, -3, -1,  0, -1, -2,  8, -3, -3, -1, -3, -2,  1, -1, -2,  0,  0, -1, -2, -1,\n        -3, -2,  2,  0, -1, -4,\n        -1, -3, -1, -3, -3,  0, -4, -3,  4,  3, -3,  2,  1, -3, -1, -3, -3, -3, -2, -1, -1,\n         3, -3, -1, -3, -1, -4,\n        -1, -4, -1, -4, -3,  0, -4, -3,  3,  3, -3,  3,  2, -3, -1, -3, -3, -3, -2, -1, -1,\n         2, -3, -1, -3, -1, -4,\n        -1,  0, -3, -1,  1, -3, -2, -1, -3, -3,  5, -2, -1,  0, -1, -1,  1,  2,  0, -1, -1,\n        -2, -3, -2,  1, -1, -4,\n        -1, -4, -1, -4, -3,  0, -4, -3,  2,  3, -2,  4,  2, -3, -1, -3, -2, -2, -2, -1, -1,\n         1, -2, -1, -3, -1, -4,\n        -1, -3, -1, -3, -2,  0, -3, -2,  1,  2, -1,  2,  5, -2, -1, -2,  0, -1, -1, -1, -1,\n         1, -1, -1, -1, -1, -4,\n        -2,  3, -3,  1,  0, -3,  0,  1, -3, -3,  0, -3, -2,  6, -1, -2,  0,  0,  1,  0, -1,\n        -3, -4, -2,  0, -1, -4,\n         0, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1,  0,  0, -1,\n        -1, -2, -1, -1, -1, -4,\n        -1, -2, -3, -1, -1, -4, -2, -2, -3, -3, -1, -3, -2, -2, -2,  7, -1, -2, -1, -1, -2,\n        -2, -4, -3, -1, -2, -4,\n        -1,  0, -3,  0,  2, -3, -2,  0, -3, -3,  1, -2,  0,  0, -1, -1,  5,  1,  0, -1, -1,\n        -2, -2, -1,  3, -1, -4,\n        -1, -1, -3, -2,  0, -3, -2,  0, -3, -3,  2, -2, -1,  0, -1, -2,  1,  5, -1, -1, -1,\n        -3, -3, -2,  0, -1, -4,\n         1,  0, -1,  0,  0, -2,  0, -1, -2, -2,  0, -2, -1,  1,  0, -1,  0, -1,  4,  1,  0,\n        -2, -3, -2,  0,  0, -4,\n         0, -1, -1, -1, -1, -2, -2, -2, -1, -1, -1, -1, -1,  0,  0, -1, -1, -1,  1,  5,  0,\n         0, -2, -2, -1,  0, -4,\n         0, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1,  0,  0, -1,\n        -1, -2, -1, -1, -1, -4,\n         0, -3, -1, -3, -2, -1, -3, -3,  3,  2, -2,  1,  1, -3, -1, -2, -2, -3, -2,  0, -1,\n         4, -3, -1, -2, -1, -4,\n        -3, -4, -2, -4, -3,  1, -2, -2, -3, -3, -3, -2, -1, -4, -2, -4, -2, -3, -3, -2, -2,\n        -3, 11,  2, -3, -2, -4,\n        -2, -3, -2, -3, -2,  3, -3,  2, -1, -1, -2, -1, -1, -2, -1, -3, -1, -2, -2, -2, -1,\n        -1,  2,  7, -2, -1, -4,\n        -1,  1, -3,  1,  4, -3, -2,  0, -3, -3,  1, -3, -1,  0, -1, -1,  3,  0,  0, -1, -1,\n        -2, -3, -2,  4, -1, -4,\n         0, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1,  0,  0, -1,\n        -1, -2, -1, -1, -1, -4,\n        -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\n        -4, -4, -4, -4, -4,  1\n    ]).unwrap();\n}\n\n#[inline]\nfn lookup(a: u8) -\u003e usize {\n    if a == b'Y' {\n        23\n    } else if a == b'Z' {\n        24\n    } else if a == b'X' {\n        25\n    } else if a == b'*' {\n        26\n    } else {\n        (a - 65) as usize\n    }\n}\n\n/// Return the BLOSUM62 substitution matrix score of [a, b]\n///\n/// # Example\n///\n/// ```\n/// use bio::scores::blosum62;\n/// assert_eq!(blosum62(b'H', b'A'), -2);\n/// ```\npub fn blosum62(a: u8, b: u8) -\u003e i32 {\n    let a = lookup(a);\n    let b = lookup(b);\n\n    MAT[(a, b)]\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_blosum62() {\n        let score1 = blosum62(b'A', b'A');\n        assert_eq!(score1, 4);\n        let score2 = blosum62(b'O', b'*');\n        assert_eq!(score2, -4);\n        let score3 = blosum62(b'A', b'*');\n        assert_eq!(score3, -4);\n        let score4 = blosum62(b'*', b'*');\n        assert_eq!(score4, 1);\n        let score5 = blosum62(b'X', b'X');\n        assert_eq!(score5, -1);\n        let score6 = blosum62(b'X', b'Z');\n        assert_eq!(score6, -1);\n    }\n}\n","traces":[{"line":8,"address":[4532592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[9388528],"length":1,"stats":{"Line":1},"fn_name":"blosum62"},{"line":90,"address":[9388550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[9388572],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[9388590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[9183493,9183488],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":102,"address":[9548359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[9548479,9548375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[9548445],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[9548527,9548646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[9548612],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[9548810,9548694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[9548779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[9548974,9548858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[9548943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[9549141,9549022],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[9549107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[9549189,9549292],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":27,"coverable":28},{"path":["/","home","todd","rust-bio","src","scores","mod.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\npub use self::blosum62::blosum62;\npub use self::pam120::pam120;\npub use self::pam200::pam200;\npub use self::pam250::pam250;\npub use self::pam40::pam40;\n\npub mod blosum62;\npub mod pam120;\npub mod pam200;\npub mod pam250;\npub mod pam40;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","scores","pam120.rs"],"content":"// Copyright 2015 M. Rizky Luthfianto.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\nlazy_static! {\n    // taken from https://github.com/seqan/seqan/blob/master/include%2Fseqan%2Fscore%2\n    // Fscore_matrix_data.h#L614\n    // Copyright (c) 2006-2015, Knut Reinert, FU Berlin\n    static ref MAT: ndarray::Array2\u003ci32\u003e = ndarray::Array::from_shape_vec((27, 27), vec![\n         3,  0, -3,  0,  0, -4,  1, -3, -1, -2, -2, -3, -2, -1, -1,  1, -1, -3,  1,  1, -1,  0,\n        -7, -4, -1, -1, -8,\n         0,  4, -6,  4,  3, -5,  0,  1, -3, -4,  0, -4, -4,  3, -1, -2,  0, -2,  0,  0, -1, -3,\n        -6, -3,  2, -1, -8,\n        -3, -6,  9, -7, -7, -6, -4, -4, -3, -5, -7, -7, -6, -5, -4, -4, -7, -4,  0, -3, -4, -3,\n        -8, -1, -7, -4, -8,\n         0,  4, -7,  5,  3, -7,  0,  0, -3, -4, -1, -5, -4,  2, -2, -3,  1, -3,  0, -1, -2, -3,\n        -8, -5,  3, -2, -8,\n         0,  3, -7,  3,  5, -7, -1, -1, -3, -4, -1, -4, -3,  1, -1, -2,  2, -3, -1, -2, -1, -3,\n        -8, -5,  4, -1, -8,\n        -4, -5, -6, -7, -7,  8, -5, -3,  0,  0, -7,  0, -1, -4, -3, -5, -6, -5, -3, -4, -3, -3,\n        -1,  4, -6, -3, -8,\n         1,  0, -4,  0, -1, -5,  5, -4, -4, -5, -3, -5, -4,  0, -2, -2, -3, -4,  1, -1, -2, -2,\n        -8, -6, -2, -2, -8,\n        -3,  1, -4,  0, -1, -3, -4,  7, -4, -4, -2, -3, -4,  2, -2, -1,  3,  1, -2, -3, -2, -3,\n        -3, -1,  1, -2, -8,\n        -1, -3, -3, -3, -3,  0, -4, -4,  6,  4, -3,  1,  1, -2, -1, -3, -3, -2, -2,  0, -1,  3,\n        -6, -2, -3, -1, -8,\n        -2, -4, -5, -4, -4,  0, -5, -4,  4,  4, -4,  3,  2, -3, -2, -3, -3, -3, -3, -2, -2,  2,\n        -5, -2, -3, -2, -8,\n        -2,  0, -7, -1, -1, -7, -3, -2, -3, -4,  5, -4,  0,  1, -2, -2,  0,  2, -1, -1, -2, -4,\n        -5, -5, -1, -2, -8,\n        -3, -4, -7, -5, -4,  0, -5, -3,  1,  3, -4,  5,  3, -4, -2, -3, -2, -4, -4, -3, -2,  1,\n        -3, -2, -3, -2, -8,\n        -2, -4, -6, -4, -3, -1, -4, -4,  1,  2,  0,  3,  8, -3, -2, -3, -1, -1, -2, -1, -2,  1,\n        -6, -4, -2, -2, -8,\n        -1,  3, -5,  2,  1, -4,  0,  2, -2, -3,  1, -4, -3,  4, -1, -2,  0, -1,  1,  0, -1, -3,\n        -4, -2,  0, -1, -8,\n        -1, -1, -4, -2, -1, -3, -2, -2, -1, -2, -2, -2, -2, -1, -2, -2, -1, -2, -1, -1, -2, -1,\n        -5, -3, -1, -2, -8,\n         1, -2, -4, -3, -2, -5, -2, -1, -3, -3, -2, -3, -3, -2, -2,  6,  0, -1,  1, -1, -2, -2,\n        -7, -6, -1, -2, -8,\n        -1,  0, -7,  1,  2, -6, -3,  3, -3, -3,  0, -2, -1,  0, -1,  0,  6,  1, -2, -2, -1, -3,\n        -6, -5,  4, -1, -8,\n        -3, -2, -4, -3, -3, -5, -4,  1, -2, -3,  2, -4, -1, -1, -2, -1,  1,  6, -1, -2, -2, -3,\n         1, -5, -1, -2, -8,\n         1,  0,  0,  0, -1, -3,  1, -2, -2, -3, -1, -4, -2,  1, -1,  1, -2, -1,  3,  2, -1, -2,\n        -2, -3, -1, -1, -8,\n         1,  0, -3, -1, -2, -4, -1, -3,  0, -2, -1, -3, -1,  0, -1, -1, -2, -2,  2,  4, -1,  0,\n        -6, -3, -2, -1, -8,\n        -1, -1, -4, -2, -1, -3, -2, -2, -1, -2, -2, -2, -2, -1, -2, -2, -1, -2, -1, -1, -2, -1,\n        -5, -3, -1, -2, -8,\n         0, -3, -3, -3, -3, -3, -2, -3,  3,  2, -4,  1,  1, -3, -1, -2, -3, -3, -2,  0, -1,  5,\n        -8, -3, -3, -1, -8,\n        -7, -6, -8, -8, -8, -1, -8, -3, -6, -5, -5, -3, -6, -4, -5, -7, -6,  1, -2, -6, -5, -8,\n        12, -2, -7, -5, -8,\n        -4, -3, -1, -5, -5,  4, -6, -1, -2, -2, -5, -2, -4, -2, -3, -6, -5, -5, -3, -3, -3, -3,\n        -2,  8, -5, -3, -8,\n        -1,  2, -7,  3,  4, -6, -2,  1, -3, -3, -1, -3, -2,  0, -1, -1,  4, -1, -1, -2, -1, -3,\n        -7, -5,  4, -1, -8,\n        -1, -1, -4, -2, -1, -3, -2, -2, -1, -2, -2, -2, -2, -1, -2, -2, -1, -2, -1, -1, -2, -1,\n        -5, -3, -1, -2, -8,\n        -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8,\n        -8, -8, -8, -8,  1\n    ]).unwrap();\n}\n\n#[inline]\nfn lookup(a: u8) -\u003e usize {\n    if a == b'Y' {\n        23\n    } else if a == b'Z' {\n        24\n    } else if a == b'X' {\n        25\n    } else if a == b'*' {\n        26\n    } else {\n        (a - 65) as usize\n    }\n}\n\n/// Return the PAM120 substitution matrix score of [a, b]\n///\n/// # Example\n///\n/// ```\n/// use bio::scores::pam120;\n/// assert_eq!(pam120(b'H', b'A'), -3);\n/// ```\npub fn pam120(a: u8, b: u8) -\u003e i32 {\n    let a = lookup(a);\n    let b = lookup(b);\n\n    MAT[(a, b)]\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pam120() {\n        let score1 = pam120(b'A', b'A');\n        assert_eq!(score1, 3);\n        let score2 = pam120(b'*', b'*');\n        assert_eq!(score2, 1);\n        let score3 = pam120(b'A', b'*');\n        assert_eq!(score3, -8);\n        let score4 = pam120(b'*', b'*');\n        assert_eq!(score4, 1);\n        let score5 = pam120(b'X', b'X');\n        assert_eq!(score5, -2);\n        let score6 = pam120(b'X', b'Z');\n        assert_eq!(score6, -1);\n    }\n}\n","traces":[{"line":10,"address":[4517696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[9388832],"length":1,"stats":{"Line":1},"fn_name":"pam120"},{"line":92,"address":[9388854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[9388876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[9388894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[5160464],"length":1,"stats":{"Line":3},"fn_name":"test_pam120"},{"line":104,"address":[5160471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[5160487,5160588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[5160557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[5160636,5160755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[5160721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[5160803,5160919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[5160888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[5160967,5161083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[5161052],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[5161131,5161250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[5161216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[5161298,5161401],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":27,"coverable":28},{"path":["/","home","todd","rust-bio","src","scores","pam200.rs"],"content":"// Copyright 2015 M. Rizky Luthfianto.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\nlazy_static! {\n    // Taken from https://github.com/seqan/seqan/blob/master/include%2Fseqan%2Fscore\n    // %2Fscore_matrix_data.h#L710\n    // Copyright (c) 2006-2015, Knut Reinert, FU Berlin\n    static ref MAT: ndarray::Array2\u003ci32\u003e = ndarray::Array::from_shape_vec((27, 27), vec![\n         3,  0, -3,  0,  0, -4,  1, -2, -1, -2, -2, -2, -2,  0,  0,  1, -1, -2,  1,  1,  0,  0,\n        -7, -4,  0,  0, -9,\n         0,  3, -5,  4,  3, -6,  0,  1, -3, -4,  0, -4, -3,  3, -1, -1,  1, -1,  1,  0, -1, -3,\n        -6, -4,  2, -1, -9,\n        -3, -5, 12, -6, -7, -6, -4, -4, -3, -5, -7, -7, -6, -5, -4, -4, -7, -4,  0, -3, -4, -2,\n        -9,  0, -7, -4, -9,\n         0,  4, -6,  5,  4, -7,  0,  0, -3, -4,  0, -5, -4,  3, -1, -2,  2, -2,  0,  0, -1, -3,\n        -8, -5,  3, -1, -9,\n         0,  3, -7,  4,  5, -7,  0,  0, -3, -4,  0, -4, -3,  2, -1, -1,  3, -2,  0, -1, -1, -2,\n        -9, -5,  4, -1, -9,\n        -4, -6, -6, -7, -7, 10, -6, -2,  1,  2, -7,  2,  0, -4, -3, -6, -6, -5, -4, -4, -3, -2,\n         0,  7, -6, -3, -9,\n         1,  0, -4,  0,  0, -6,  6, -3, -3, -4, -2, -5, -4,  0, -1, -1, -2, -4,  1,  0, -1, -2,\n        -8, -6, -1, -1, -9,\n        -2,  1, -4,  0,  0, -2, -3,  8, -3, -3, -1, -3, -3,  2, -1, -1,  3,  2, -1, -2, -1, -3,\n        -3,  0,  2, -1, -9,\n        -1, -3, -3, -3, -3,  1, -3, -3,  6,  4, -2,  2,  2, -2, -1, -3, -3, -2, -2,  0, -1,  4,\n        -6, -2, -3, -1, -9,\n        -2, -4, -5, -4, -4,  2, -4, -3,  4,  5, -3,  5,  3, -3, -2, -3, -3, -3, -3, -1, -2,  3,\n        -4, -2, -3, -2, -9,\n        -2,  0, -7,  0,  0, -7, -2, -1, -2, -3,  6, -4,  1,  1, -1, -2,  1,  4,  0,  0, -1, -3,\n        -4, -5,  0, -1, -9,\n        -2, -4, -7, -5, -4,  2, -5, -3,  2,  5, -4,  7,  4, -4, -2, -3, -2, -4, -4, -2, -2,  2,\n        -2, -2, -3, -2, -9,\n        -2, -3, -6, -4, -3,  0, -4, -3,  2,  3,  1,  4,  8, -2, -1, -3, -1, -1, -2, -1, -1,  2,\n        -5, -3, -2, -1, -9,\n         0,  3, -5,  3,  2, -4,  0,  2, -2, -3,  1, -4, -2,  3,  0, -1,  1,  0,  1,  0,  0, -2,\n        -5, -2,  1,  0, -9,\n         0, -1, -4, -1, -1, -3, -1, -1, -1, -2, -1, -2, -1,  0, -1, -1, -1, -1,  0,  0, -1, -1,\n        -5, -3, -1, -1, -9,\n         1, -1, -4, -2, -1, -6, -1, -1, -3, -3, -2, -3, -3, -1, -1,  7,  0,  0,  1,  0, -1, -2,\n        -7, -6, -1, -1, -9,\n        -1,  1, -7,  2,  3, -6, -2,  3, -3, -3,  1, -2, -1,  1, -1,  0,  5,  1, -1, -1, -1, -3,\n        -6, -5,  4, -1, -9,\n        -2, -1, -4, -2, -2, -5, -4,  2, -2, -3,  4, -4, -1,  0, -1,  0,  1,  7, -1, -1, -1, -3,\n         2, -5,  0, -1, -9,\n         1,  1,  0,  0,  0, -4,  1, -1, -2, -3,  0, -4, -2,  1,  0,  1, -1, -1,  2,  2,  0, -1,\n        -3, -3, -1,  0, -9,\n         1,  0, -3,  0, -1, -4,  0, -2,  0, -1,  0, -2, -1,  0,  0,  0, -1, -1,  2,  4,  0,  0,\n        -6, -3, -1,  0, -9,\n         0, -1, -4, -1, -1, -3, -1, -1, -1, -2, -1, -2, -1,  0, -1, -1, -1, -1,  0,  0, -1, -1,\n        -5, -3, -1, -1, -9,\n         0, -3, -2, -3, -2, -2, -2, -3,  4,  3, -3,  2,  2, -2, -1, -2, -3, -3, -1,  0, -1,  5,\n        -8, -3, -2, -1, -9,\n        -7, -6, -9, -8, -9,  0, -8, -3, -6, -4, -4, -2, -5, -5, -5, -7, -6,  2, -3, -6, -5, -8,\n        18, -1, -7, -5, -9,\n        -4, -4,  0, -5, -5,  7, -6,  0, -2, -2, -5, -2, -3, -2, -3, -6, -5, -5, -3, -3, -3, -3,\n        -1, 11, -5, -3, -9,\n         0,  2, -7,  3,  4, -6, -1,  2, -3, -3,  0, -3, -2,  1, -1, -1,  4,  0, -1, -1, -1, -2,\n        -7, -5,  4, -1, -9,\n         0, -1, -4, -1, -1, -3, -1, -1, -1, -2, -1, -2, -1,  0, -1, -1, -1, -1,  0,  0, -1, -1,\n        -5, -3, -1, -1, -9,\n        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9,\n        -9, -9, -9, -9,  1\n    ]).unwrap();\n}\n\n#[inline]\nfn lookup(a: u8) -\u003e usize {\n    if a == b'Y' {\n        23\n    } else if a == b'Z' {\n        24\n    } else if a == b'X' {\n        25\n    } else if a == b'*' {\n        26\n    } else {\n        (a - 65) as usize\n    }\n}\n\n/// Return the PAM200 substitution matrix score of [a, b]\n///\n/// # Example\n///\n/// ```\n/// use bio::scores::pam200;\n/// assert_eq!(pam200(b'H', b'A'), -2);\n/// ```\npub fn pam200(a: u8, b: u8) -\u003e i32 {\n    let a = lookup(a);\n    let b = lookup(b);\n\n    MAT[(a, b)]\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pam200() {\n        let score1 = pam200(b'A', b'A');\n        assert_eq!(score1, 3);\n        let score2 = pam200(b'*', b'*');\n        assert_eq!(score2, 1);\n        let score3 = pam200(b'A', b'*');\n        assert_eq!(score3, -9);\n        let score4 = pam200(b'Y', b'Z');\n        assert_eq!(score4, -5);\n        let score5 = pam200(b'X', b'X');\n        assert_eq!(score5, -1);\n        let score6 = pam200(b'X', b'Z');\n        assert_eq!(score6, -1);\n    }\n}\n","traces":[{"line":10,"address":[4540160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[4244384],"length":1,"stats":{"Line":1},"fn_name":"pam200"},{"line":92,"address":[4244406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[4244428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[4244446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[5161456],"length":1,"stats":{"Line":3},"fn_name":"test_pam200"},{"line":104,"address":[5161463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[5161479,5161580],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[5161549],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[5161628,5161747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[5161713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[5161914,5161795],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[5161880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[5161962,5162078],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[5162047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[5162126,5162245],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[5162211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[5162293,5162396],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":28,"coverable":28},{"path":["/","home","todd","rust-bio","src","scores","pam250.rs"],"content":"// Copyright 2014 M. Rizky Luthfianto.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\nlazy_static! {\n    // taken from https://github.com/seqan/seqan/blob/master/include%2Fseqan\n    // %2Fscore%2Fscore_matrix_data.h#L806\n    // Copyright (c) 2006-2015, Knut Reinert, FU Berlin\n    static ref MAT: ndarray::Array2\u003ci32\u003e = ndarray::Array::from_shape_vec((27, 27), vec![\n         2,  0, -2,  0,  0, -3,  1, -1, -1, -2, -1, -2, -1,  0,  0,  1,  0, -2,  1,  1,  0,  0,\n        -6, -3,  0,  0, -8,\n         0,  3, -4,  3,  3, -4,  0,  1, -2, -3,  1, -3, -2,  2, -1, -1,  1, -1,  0,  0, -1, -2,\n        -5, -3,  2, -1, -8,\n        -2, -4, 12, -5, -5, -4, -3, -3, -2, -4, -5, -6, -5, -4, -3, -3, -5, -4,  0, -2, -3, -2,\n        -8,  0, -5, -3, -8,\n         0,  3, -5,  4,  3, -6,  1,  1, -2, -3,  0, -4, -3,  2, -1, -1,  2, -1,  0,  0, -1, -2,\n        -7, -4,  3, -1, -8,\n         0,  3, -5,  3,  4, -5,  0,  1, -2, -3,  0, -3, -2,  1, -1, -1,  2, -1,  0,  0, -1, -2,\n        -7, -4,  3, -1, -8,\n        -3, -4, -4, -6, -5,  9, -5, -2,  1,  2, -5,  2,  0, -3, -2, -5, -5, -4, -3, -3, -2, -1,\n         0,  7, -5, -2, -8,\n         1,  0, -3,  1,  0, -5,  5, -2, -3, -4, -2, -4, -3,  0, -1,  0, -1, -3,  1,  0, -1, -1,\n        -7, -5,  0, -1, -8,\n        -1,  1, -3,  1,  1, -2, -2,  6, -2, -2,  0, -2, -2,  2, -1,  0,  3,  2, -1, -1, -1, -2,\n        -3,  0,  2, -1, -8,\n        -1, -2, -2, -2, -2,  1, -3, -2,  5,  4, -2,  2,  2, -2, -1, -2, -2, -2, -1,  0, -1,  4,\n        -5, -1, -2, -1, -8,\n        -2, -3, -4, -3, -3,  2, -4, -2,  4,  4, -3,  4,  3, -3, -1, -3, -2, -3, -2, -1, -1,  3,\n        -4, -1, -3, -1, -8,\n        -1,  1, -5,  0,  0, -5, -2,  0, -2, -3,  5, -3,  0,  1, -1, -1,  1,  3,  0,  0, -1, -2,\n        -3, -4,  0, -1, -8,\n        -2, -3, -6, -4, -3,  2, -4, -2,  2,  4, -3,  6,  4, -3, -1, -3, -2, -3, -3, -2, -1,  2,\n        -2, -1, -3, -1, -8,\n        -1, -2, -5, -3, -2,  0, -3, -2,  2,  3,  0,  4,  6, -2, -1, -2, -1,  0, -2, -1, -1,  2,\n        -4, -2, -2, -1, -8,\n         0,  2, -4,  2,  1, -3,  0,  2, -2, -3,  1, -3, -2,  2,  0,  0,  1,  0,  1,  0,  0, -2,\n        -4, -2,  1,  0, -8,\n         0, -1, -3, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1,  0, -1, -1, -1, -1,  0,  0, -1, -1,\n        -4, -2, -1, -1, -8,\n         1, -1, -3, -1, -1, -5,  0,  0, -2, -3, -1, -3, -2,  0, -1,  6,  0,  0,  1,  0, -1, -1,\n        -6, -5,  0, -1, -8,\n         0,  1, -5,  2,  2, -5, -1,  3, -2, -2,  1, -2, -1,  1, -1,  0,  4,  1, -1, -1, -1, -2,\n        -5, -4,  3, -1, -8,\n        -2, -1, -4, -1, -1, -4, -3,  2, -2, -3,  3, -3,  0,  0, -1,  0,  1,  6,  0, -1, -1, -2,\n         2, -4,  0, -1, -8,\n         1,  0,  0,  0,  0, -3,  1, -1, -1, -2,  0, -3, -2,  1,  0,  1, -1,  0,  2,  1,  0, -1,\n        -2, -3,  0,  0, -8,\n         1,  0, -2,  0,  0, -3,  0, -1,  0, -1,  0, -2, -1,  0,  0,  0, -1, -1,  1,  3,  0,  0,\n        -5, -3, -1,  0, -8,\n         0, -1, -3, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1,  0, -1, -1, -1, -1,  0,  0, -1, -1,\n        -4, -2, -1, -1, -8,\n         0, -2, -2, -2, -2, -1, -1, -2,  4,  3, -2,  2,  2, -2, -1, -1, -2, -2, -1,  0, -1,  4,\n        -6, -2, -2, -1, -8,\n        -6, -5, -8, -7, -7,  0, -7, -3, -5, -4, -3, -2, -4, -4, -4, -6, -5,  2, -2, -5, -4, -6,\n        17,  0, -6, -4, -8,\n        -3, -3,  0, -4, -4,  7, -5,  0, -1, -1, -4, -1, -2, -2, -2, -5, -4, -4, -3, -3, -2, -2,\n         0, 10, -4, -2, -8,\n         0,  2, -5,  3,  3, -5,  0,  2, -2, -3,  0, -3, -2,  1, -1,  0,  3,  0,  0, -1, -1, -2,\n        -6, -4,  3, -1, -8,\n         0, -1, -3, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1,  0, -1, -1, -1, -1,  0,  0, -1, -1,\n        -4, -2, -1, -1, -8,\n        -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8,\n        -8, -8, -8, -8,  1,\n    ]).unwrap();\n}\n\n#[inline]\nfn lookup(a: u8) -\u003e usize {\n    if a == b'Y' {\n        23\n    } else if a == b'Z' {\n        24\n    } else if a == b'X' {\n        25\n    } else if a == b'*' {\n        26\n    } else {\n        (a - 65) as usize\n    }\n}\n\n/// Return the PAM250 substitution matrix score of [a, b]\n///\n/// # Example\n///\n/// ```\n/// use bio::scores::pam250;\n/// assert_eq!(pam250(b'H', b'A'), -1);\n/// ```\npub fn pam250(a: u8, b: u8) -\u003e i32 {\n    let a = lookup(a);\n    let b = lookup(b);\n\n    MAT[(a, b)]\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pam250() {\n        let score1 = pam250(b'A', b'A');\n        assert_eq!(score1, 2);\n        let score2 = pam250(b'*', b'*');\n        assert_eq!(score2, 1);\n        let score3 = pam250(b'A', b'*');\n        assert_eq!(score3, -8);\n        let score4 = pam250(b'*', b'*');\n        assert_eq!(score4, 1);\n        let score5 = pam250(b'X', b'X');\n        assert_eq!(score5, -1);\n        let score6 = pam250(b'X', b'Z');\n        assert_eq!(score6, -1);\n    }\n}\n","traces":[{"line":10,"address":[4525120],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[9389136],"length":1,"stats":{"Line":1},"fn_name":"pam250"},{"line":92,"address":[9389158],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[9389180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[9389198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[5554912],"length":1,"stats":{"Line":3},"fn_name":"test_pam250"},{"line":104,"address":[5554919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[5554935,5555036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[5555005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[5555084,5555203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[5555169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[5555251,5555367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[5555336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[5555531,5555415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[5555500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[5555698,5555579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[5555664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[5555746,5555849],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":27,"coverable":28},{"path":["/","home","todd","rust-bio","src","scores","pam40.rs"],"content":"// Copyright 2014 M. Rizky Luthfianto.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\nlazy_static! {\n    // taken from https://github.com/seqan/seqan/blob/master/include%2Fseqan%2Fscore%2Fscore_matrix_data.h#L806\n    static ref MAT: ndarray::Array2\u003ci32\u003e = ndarray::Array::from_shape_vec((27, 27), vec![\n         6,  -3,  -6,  -3,  -2,  -7,  -1,  -6,  -4,  -5,  -6,  -5,  -4,  -3,  -3,  -1,  -3,\n        -6,   0,   0,  -3,  -2, -12,  -7,  -2,  -3, -15,\n        -3,   6, -11,   6,   2,  -9,  -2,  -1,  -5,  -7,  -2,  -8,  -8,   6,  -4,  -6,  -2,\n        -6,  -1,  -2,  -4,  -7,  -9,  -6,   1,  -4, -15,\n        -6, -11,   9, -12, -12, -11,  -8,  -7,  -5,  -9, -12, -13, -12,  -9,  -8,  -7, -12,\n        -7,  -2,  -7,  -8,  -5, -14,  -3, -12,  -8, -15,\n        -3,   6, -12,   7,   3, -13,  -3,  -3,  -6,  -9,  -4, -11,  -9,   2,  -5,  -7,  -2,\n        -9,  -3,  -4,  -5,  -7, -13, -10,   2,  -5, -15,\n        -2,   2, -12,   3,   7, -12,  -3,  -4,  -5,  -7,  -4,  -8,  -6,  -1,  -4,  -5,   2,\n        -8,  -4,  -5,  -4,  -6, -15,  -8,   6,  -4, -15,\n        -7,  -9, -11, -13, -12,   9,  -8,  -5,  -2,  -2, -12,  -2,  -3,  -8,  -7,  -9, -11,\n        -8,  -6,  -8,  -7,  -7,  -4,   2, -12,  -7, -15,\n        -1,  -2,  -8,  -3,  -3,  -8,   6,  -8,  -9,  -9,  -6,  -9,  -7,  -2,  -4,  -5,  -6,\n        -8,  -1,  -5,  -4,  -5, -13, -12,  -4,  -4, -15,\n        -6,  -1,  -7,  -3,  -4,  -5,  -8,   9,  -8,  -7,  -5,  -5,  -9,   1,  -4,  -3,   1,\n        -1,  -5,  -6,  -4,  -6,  -6,  -3,   0,  -4, -15,\n        -4,  -5,  -5,  -6,  -5,  -2,  -9,  -8,   8,   4,  -5,  -1,   0,  -4,  -4,  -7,  -7,\n        -5,  -6,  -2,  -4,   2, -12,  -5,  -5,  -4, -15,\n        -5,  -7,  -9,  -9,  -7,  -2,  -9,  -7,   4,   4,  -6,   3,   1,  -5,  -5,  -7,  -6,\n        -7,  -7,  -4,  -5,   0,  -9,  -6,  -6,  -5, -15,\n        -6,  -2, -12,  -4,  -4, -12,  -6,  -5,  -5,  -6,   6,  -7,  -1,   0,  -4,  -6,  -2,\n         1,  -3,  -2,  -4,  -8, -10,  -8,  -3,  -4, -15,\n        -5,  -8, -13, -11,  -8,  -2,  -9,  -5,  -1,   3,  -7,   7,   1,  -6,  -5,  -6,  -4,\n        -8,  -7,  -6,  -5,  -2,  -5,  -6,  -6,  -5, -15,\n        -4,  -8, -12,  -9,  -6,  -3,  -7,  -9,   0,   1,  -1,   1,  11,  -7,  -4,  -7,  -3,\n        -3,  -5,  -3,  -4,  -1, -11, -10,  -4,  -4, -15,\n        -3,   6,  -9,   2,  -1,  -8,  -2,   1,  -4,  -5,   0,  -6,  -7,   7,  -3,  -5,  -3,\n        -5,   0,  -1,  -3,  -7,  -7,  -4,  -2,  -3, -15,\n        -3,  -4,  -8,  -5,  -4,  -7,  -4,  -4,  -4,  -5,  -4,  -5,  -4,  -3,  -4,  -4,  -4,\n        -5,  -2,  -3,  -4,  -4,  -9,  -7,  -4,  -4, -15,\n        -1,  -6,  -7,  -7,  -5,  -9,  -5,  -3,  -7,  -7,  -6,  -6,  -7,  -5,  -4,   8,  -2,\n        -3,  -1,  -3,  -4,  -5, -12, -12,  -3,  -4, -15,\n        -3,  -2, -12,  -2,   2, -11,  -6,   1,  -7,  -6,  -2,  -4,  -3,  -3,  -4,  -2,   8,\n        -1,  -4,  -5,  -4,  -6, -11, -10,   6,  -4, -15,\n        -6,  -6,  -7,  -9,  -8,  -8,  -8,  -1,  -5,  -7,   1,  -8,  -3,  -5,  -5,  -3,  -1,\n         8,  -2,  -5,  -5,  -7,  -1,  -9,  -3,  -5, -15,\n         0,  -1,  -2,  -3,  -4,  -6,  -1,  -5,  -6,  -7,  -3,  -7,  -5,   0,  -2,  -1,  -4,\n        -2,   6,   1,  -2,  -5,  -4,  -6,  -4,  -2, -15,\n         0,  -2,  -7,  -4,  -5,  -8,  -5,  -6,  -2,  -4,  -2,  -6,  -3,  -1,  -3,  -3,  -5,\n        -5,   1,   7,  -3,  -2, -11,  -6,  -5,  -3, -15,\n        -3,  -4,  -8,  -5,  -4,  -7,  -4,  -4,  -4,  -5,  -4,  -5,  -4,  -3,  -4,  -4,  -4,\n        -5,  -2,  -3,  -4,  -4,  -9,  -7,  -4,  -4, -15,\n        -2,  -7,  -5,  -7,  -6,  -7,  -5,  -6,   2,   0,  -8,  -2,  -1,  -7,  -4,  -5,  -6,\n        -7,  -5,  -2,  -4,   7, -14,  -6,  -6,  -4, -15,\n       -12,  -9, -14, -13, -15,  -4, -13,  -6, -12,  -9, -10,  -5, -11,  -7,  -9, -12, -11,\n        -1,  -4, -11,  -9, -14,  13,  -4, -13,  -9, -15,\n        -7,  -6,  -3, -10,  -8,   2, -12,  -3,  -5,  -6,  -8,  -6, -10,  -4,  -7, -12, -10,\n        -9,  -6,  -6,  -7,  -6,  -4,  10,  -8,  -7, -15,\n        -2,   1, -12,   2,   6, -12,  -4,   0,  -5,  -6,  -3,  -6,  -4,  -2,  -4,  -3,   6,\n        -3,  -4,  -5,  -4,  -6, -13,  -8,   6,  -4, -15,\n        -3,  -4,  -8,  -5,  -4,  -7,  -4,  -4,  -4,  -5,  -4,  -5,  -4,  -3,  -4,  -4,  -4,\n        -5,  -2,  -3,  -4,  -4,  -9,  -7,  -4,  -4, -15,\n       -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15,\n       -15, -15, -15, -15, -15, -15, -15, -15, -15,   1\n    ]).unwrap();\n}\n\n#[inline]\nfn lookup(a: u8) -\u003e usize {\n    if a == b'Y' {\n        23\n    } else if a == b'Z' {\n        24\n    } else if a == b'X' {\n        25\n    } else if a == b'*' {\n        26\n    } else {\n        (a - 65) as usize\n    }\n}\n\n/// Return the PAM40 substitution matrix score of [a, b]\n///\n/// # Example\n///\n/// ```\n/// use bio::scores::pam40;\n/// assert_eq!(pam40(b'H', b'A'), -6);\n/// ```\npub fn pam40(a: u8, b: u8) -\u003e i32 {\n    let a = lookup(a);\n    let b = lookup(b);\n\n    MAT[(a, b)]\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pam40() {\n        let score1 = pam40(b'A', b'A');\n        assert_eq!(score1, 6);\n        let score2 = pam40(b'*', b'*');\n        assert_eq!(score2, 1);\n        let score3 = pam40(b'A', b'*');\n        assert_eq!(score3, -15);\n        let score4 = pam40(b'*', b'*');\n        assert_eq!(score4, 1);\n        let score5 = pam40(b'X', b'X');\n        assert_eq!(score5, -4);\n        let score6 = pam40(b'X', b'Z');\n        assert_eq!(score6, -4);\n    }\n}\n","traces":[{"line":8,"address":[4510224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[9389440],"length":1,"stats":{"Line":1},"fn_name":"pam40"},{"line":90,"address":[9389462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[9389484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[9389502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[9183616,9183621],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":102,"address":[9549351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[9549367,9549468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[9549437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[9549516,9549635],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[9549601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[9549683,9549799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[9549768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[9549963,9549847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[9549932],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[9550130,9550011],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[9550096],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[9550178,9550281],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":27,"coverable":28},{"path":["/","home","todd","rust-bio","src","seq_analysis","gc.rs"],"content":"// Copyright 2014-2016 Johannes Köster, Martin Larralde.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! GC counter over an `IntoTextIterator` object.\n\n//! Complexity: O(n), where n is the length of the sequence.\n\nuse std::borrow::Borrow;\n\n/// Base gc content counter\nfn gcn_content\u003cC: Borrow\u003cu8\u003e, T: IntoIterator\u003cItem = C\u003e\u003e(sequence: T, step: usize) -\u003e f32 {\n    let (l, count) = sequence\n        .into_iter()\n        .step_by(step)\n        .fold((0usize, 0usize), |(l, count), n| match *n.borrow() {\n            b'c' | b'g' | b'G' | b'C' =\u003e (l + 1, count + 1),\n            _ =\u003e (l + 1, count),\n        });\n    count as f32 / l as f32\n}\n\n/// Returns the ratio of bases which are guanine or cytososine\n///\n/// # Arguments\n///\n/// * `sequence` - A sequence of bases\n///\n/// # Example\n///\n/// ```\n/// use bio::seq_analysis::gc::gc_content;\n///\n/// const seq: \u0026'static [u8] = b\"GATATACA\";\n/// use approx::assert_relative_eq;\n/// assert_relative_eq!(gc_content(seq), 2. / 8., epsilon = f32::EPSILON);\n/// ```\npub fn gc_content\u003cC: Borrow\u003cu8\u003e, T: IntoIterator\u003cItem = C\u003e\u003e(sequence: T) -\u003e f32 {\n    gcn_content(sequence, 1usize)\n}\n\n/// Returns the ratio of bases in the 3rd position which are guanine\n/// or cytososine.\n///\n/// # Arguments\n///\n/// * `sequence` - A sequence of bases\n///\n/// # Example\n///\n/// ```\n/// use approx::assert_relative_eq;\n/// use bio::seq_analysis::gc::gc3_content;\n/// const seq: \u0026'static [u8] = b\"GATATACA\";\n/// //                           ^  ^  ^\n/// assert_relative_eq!(gc3_content(seq), 2. / 3., epsilon = f32::EPSILON);\n/// ```\npub fn gc3_content\u003cC: Borrow\u003cu8\u003e, T: IntoIterator\u003cItem = C\u003e\u003e(sequence: T) -\u003e f32 {\n    gcn_content(sequence, 3usize)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_gc_content() {\n        let gc0 = b\"ATAT\";\n        assert_relative_eq!(gc_content(gc0), 0.0, epsilon = f32::EPSILON);\n        let gc50 = b\"ATGC\";\n        assert_relative_eq!(gc_content(gc50), 0.5, epsilon = f32::EPSILON);\n        let gc100 = b\"GCGC\";\n        assert_relative_eq!(gc_content(gc100), 1.0, epsilon = f32::EPSILON);\n    }\n\n    #[test]\n    fn test_gc_content_large() {\n        const LENGTH: usize = 10_000_000;\n        let mut s = vec![b'G'; LENGTH];\n        s.extend_from_slice(\u0026[b'T'; LENGTH]);\n        let gc_content = gc_content(s);\n        assert_relative_eq!(gc_content, 0.5, epsilon = f32::EPSILON);\n    }\n}\n","traces":[{"line":13,"address":[9360240,9360544],"length":1,"stats":{"Line":2},"fn_name":"gcn_content\u003c\u0026u8,\u0026[u8; 4]\u003e"},{"line":14,"address":[9360564,9360323,9360662,9360265],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[9361610,9361578,9361264,9361193,9361304,9361471,9361225,9361086,9360305,9360638,9360880,9360919],"length":1,"stats":{"Line":10},"fn_name":"{{closure}}\u003cu8,alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":18,"address":[9361580,9361433,9361127,9361048,9361195,9361512,9361339,9360954],"length":1,"stats":{"Line":6},"fn_name":null},{"line":19,"address":[9361410,9361461,9361473,9361025,9361076,9361088],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[9360724,9360379],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[9361696,9361648],"length":1,"stats":{"Line":2},"fn_name":"gc_content\u003c\u0026u8,\u0026[u8; 4]\u003e"},{"line":40,"address":[9361700,9361657],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[4675520],"length":1,"stats":{"Line":3},"fn_name":"test_gc_content"},{"line":69,"address":[4675532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[4675547,4675805],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[4675764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[4675779,4676739,4676502],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[4676698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[4676713,4677436,4677645],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[4678256,4679520],"length":1,"stats":{"Line":3},"fn_name":"test_gc_content_large"},{"line":80,"address":[4678270],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[4678310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[4678455,4678341],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[4678472,4678697],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":20,"coverable":20},{"path":["/","home","todd","rust-bio","src","seq_analysis","mod.rs"],"content":"// Copyright 2014-2016 Johannes Köster, Martin Larralde.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Sequence analysis algorithms.\n\npub mod gc;\npub mod orf;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","seq_analysis","orf.rs"],"content":"// Copyright 2014-2016 Johannes Köster, Martin Larralde.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! One-way open reading frame (ORF) finder algorithm.\n//!\n//! Complexity: O(n).\n//!\n//! # Example\n//!\n//! ```\n//! use bio::seq_analysis::orf::{Finder, Orf};\n//! let start_codons = vec![b\"ATG\"];\n//! let stop_codons = vec![b\"TGA\", b\"TAG\", b\"TAA\"];\n//! let min_len = 50;\n//! let finder = Finder::new(start_codons, stop_codons, min_len);\n//!\n//! let sequence = b\"ACGGCTAGAAAAGGCTAGAAAA\";\n//!\n//! for Orf { start, end, offset } in finder.find_all(sequence) {\n//!     let orf = \u0026sequence[start..end];\n//!     //...do something with orf sequence...\n//! }\n//! ```\n//!\n//! Right now the only way to check the reverse strand for ORF is to use\n//! the `alphabet::dna::RevComp` struct and to check for both sequences.\n//! But that's not so performance friendly, as the reverse complementation and the ORF research\n//! could go on at the same time.\n\nuse std::borrow::Borrow;\nuse std::collections::VecDeque;\nuse std::iter;\n\n/// An implementation of a naive algorithm finder\n// Implementation note:\n//\n// VecDeque is used rather than the obvious [u8; 3] to represent\n// codons because a VecDeque\u003cu8\u003e is used to represent a sliding codon\n// (see: State.codon) window which unfortunately, cannot be compared\n// to [u8; 3].\npub struct Finder {\n    start_codons: Vec\u003cVecDeque\u003cu8\u003e\u003e,\n    stop_codons: Vec\u003cVecDeque\u003cu8\u003e\u003e,\n    min_len: usize,\n}\n\nimpl Finder {\n    /// Create a new instance of a finder for the given start and stop codons and the minimum\n    /// length of an ORF.\n    pub fn new\u003c'a\u003e(\n        start_codons: Vec\u003c\u0026'a [u8; 3]\u003e,\n        stop_codons: Vec\u003c\u0026'a [u8; 3]\u003e,\n        min_len: usize,\n    ) -\u003e Self {\n        Finder {\n            start_codons: start_codons\n                .iter()\n                .map(|x| x.iter().map(|\u0026x| x as u8).collect::\u003cVecDeque\u003cu8\u003e\u003e())\n                .collect(),\n            stop_codons: stop_codons\n                .iter()\n                .map(|x| x.iter().map(|\u0026x| x as u8).collect::\u003cVecDeque\u003cu8\u003e\u003e())\n                .collect(),\n            min_len,\n        }\n    }\n\n    /// Find all ORFs in the given sequence\n    pub fn find_all\u003cC, T\u003e(\u0026self, seq: T) -\u003e Matches\u003c'_, C, T::IntoIter\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        Matches {\n            finder: self,\n            state: State::new(),\n            seq: seq.into_iter().enumerate(),\n        }\n    }\n}\n\n/// An ORF representation with start and end position of said ORF,\n/// as well as offset of the reading frame (1,2,3) and strand location\n// (current: +, reverse complementary: -).\n#[derive(Debug, PartialEq)]\npub struct Orf {\n    pub start: usize,\n    pub end: usize,\n    pub offset: i8,\n}\n\n/// The current algorithm state.\nstruct State {\n    start_pos: [Option\u003cusize\u003e; 3],\n    codon: VecDeque\u003cu8\u003e,\n}\n\nimpl State {\n    /// Create new state.\n    pub fn new() -\u003e Self {\n        State {\n            start_pos: [None, None, None],\n            codon: VecDeque::new(),\n        }\n    }\n}\n\n/// Iterator over offset, start position, end position and sequence of matched ORFs.\npub struct Matches\u003c'a, C, T\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    finder: \u0026'a Finder,\n    state: State,\n    seq: iter::Enumerate\u003cT\u003e,\n}\n\nimpl\u003c'a, C, T\u003e Iterator for Matches\u003c'a, C, T\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    type Item = Orf;\n\n    fn next(\u0026mut self) -\u003e Option\u003cOrf\u003e {\n        let mut result: Option\u003cOrf\u003e = None;\n        let mut offset: usize;\n\n        for (index, nuc) in self.seq.by_ref() {\n            // update the codon\n            if self.state.codon.len() \u003e= 3 {\n                self.state.codon.pop_front();\n            }\n            self.state.codon.push_back(*nuc.borrow());\n            offset = (index + 1) % 3;\n\n            // inside orf\n            if self.state.start_pos[offset].is_some() {\n                // check if leaving orf\n                if self.finder.stop_codons.contains(\u0026self.state.codon) {\n                    // check if length is sufficient\n                    if index + 1 - self.state.start_pos[offset].unwrap() \u003e self.finder.min_len {\n                        // build results\n                        result = Some(Orf {\n                            start: self.state.start_pos[offset].unwrap() - 2,\n                            end: index + 1,\n                            offset: offset as i8,\n                        });\n                    }\n                    // reinitialize\n                    self.state.start_pos[offset] = None;\n                }\n            // check if entering orf\n            } else if self.finder.start_codons.contains(\u0026self.state.codon) {\n                self.state.start_pos[offset] = Some(index);\n            }\n            if result.is_some() {\n                return result;\n            }\n        }\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn basic_finder() -\u003e Finder {\n        let start_codons = vec![b\"ATG\"];\n        let stop_codons = vec![b\"TGA\", b\"TAG\", b\"TAA\"];\n        let min_len = 5;\n        Finder::new(start_codons, stop_codons, min_len)\n    }\n\n    #[test]\n    fn test_no_orf() {\n        let finder = basic_finder();\n        let sequence = b\"ACGGCTAGAAAAGGCTAGAAAA\";\n        assert!(finder.find_all(sequence).next().is_none());\n    }\n\n    #[test]\n    fn test_one_orf_no_offset() {\n        let finder = basic_finder();\n        let sequence = b\"GGGATGGGGTGAGGG\";\n        let expected = vec![Orf {\n            start: 3,\n            end: 12,\n            offset: 0,\n        }];\n        assert_eq!(expected, finder.find_all(sequence).collect::\u003cVec\u003cOrf\u003e\u003e());\n    }\n\n    #[test]\n    fn test_one_orf_with_offset() {\n        let finder = basic_finder();\n        let sequence = b\"AGGGATGGGGTGAGGG\";\n        let expected = vec![Orf {\n            start: 4,\n            end: 13,\n            offset: 1,\n        }];\n        assert_eq!(expected, finder.find_all(sequence).collect::\u003cVec\u003cOrf\u003e\u003e());\n    }\n\n    #[test]\n    fn test_two_orfs_different_offsets() {\n        let finder = basic_finder();\n        let sequence = b\"ATGGGGTGAGGGGGATGGAAAAATAAG\";\n        let expected = vec![\n            Orf {\n                start: 0,\n                end: 9,\n                offset: 0,\n            },\n            Orf {\n                start: 14,\n                end: 26,\n                offset: 2,\n            },\n        ];\n        assert_eq!(expected, finder.find_all(sequence).collect::\u003cVec\u003cOrf\u003e\u003e());\n    }\n}\n","traces":[{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[4693123,4693008],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[4693282,4693176],"length":1,"stats":{"Line":4},"fn_name":null},{"line":71,"address":[5157264,5158524,5157564,5158204,5157584,5158224,5157884,5157904],"length":1,"stats":{"Line":4},"fn_name":"find_all\u003c\u0026u8,\u0026[u8; 16]\u003e"},{"line":78,"address":[5158291,5157651,5157971,5157331],"length":1,"stats":{"Line":4},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":102,"address":[4693488],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":104,"address":[4693505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4693592],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[5158544,5160442],"length":1,"stats":{"Line":1},"fn_name":"next\u003c\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[5158839,5160437,5158614,5158801],"length":1,"stats":{"Line":5},"fn_name":null},{"line":134,"address":[5159008,5158943],"length":1,"stats":{"Line":4},"fn_name":null},{"line":135,"address":[5159018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[5159042],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[5159165,5159108],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[5159152,5159210],"length":1,"stats":{"Line":4},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":145,"address":[5159993,5159407],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[9057306,9057040],"length":1,"stats":{"Line":1},"fn_name":"basic_finder"},{"line":173,"address":[9057056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[9057117],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[9057178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[9057190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[9057344,9057576],"length":1,"stats":{"Line":3},"fn_name":"test_no_orf"},{"line":181,"address":[9057351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[9057361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[9057386,9057452,9057544],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[9058057,9057600],"length":1,"stats":{"Line":3},"fn_name":"test_one_orf_no_offset"},{"line":188,"address":[9057607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":189,"address":[9057617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[9057642],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[9057707,9057833,9057787],"length":1,"stats":{"Line":3},"fn_name":null},{"line":199,"address":[9058080,9058537],"length":1,"stats":{"Line":3},"fn_name":"test_one_orf_with_offset"},{"line":200,"address":[9058087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[9058097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[9058122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[9058187,9058267,9058313],"length":1,"stats":{"Line":3},"fn_name":null},{"line":211,"address":[9058560,9059081],"length":1,"stats":{"Line":3},"fn_name":"test_two_orfs_different_offsets"},{"line":212,"address":[9058567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[9058577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[9058602,9058668],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[9058610],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[9058636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[9058809,9058729,9058855],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":54,"coverable":56},{"path":["/","home","todd","rust-bio","src","stats","bayesian","bayes_factors.rs"],"content":"use crate::stats::LogProb;\n\npub mod evidence {\n    /// Scale of evidence as defined by\n    /// [Kass and Raftery 1995](http://www.andrew.cmu.edu/user/kk3n/simplicity/KassRaftery1995.pdf).\n    #[derive(\n        Display,\n        Debug,\n        Clone,\n        Copy,\n        PartialEq,\n        Eq,\n        PartialOrd,\n        Ord,\n        Serialize,\n        Deserialize,\n        EnumString,\n        EnumIter,\n        IntoStaticStr,\n        EnumVariantNames,\n    )]\n    pub enum KassRaftery {\n        #[strum(serialize = \"none\")]\n        None,\n        #[strum(serialize = \"barely\")]\n        Barely,\n        #[strum(serialize = \"positive\")]\n        Positive,\n        #[strum(serialize = \"strong\")]\n        Strong,\n        #[strum(serialize = \"very-strong\")]\n        VeryStrong,\n    }\n}\n\ncustom_derive! {\n    /// A newtype for Bayes factors.\n    #[derive(\n        NewtypeFrom,\n        NewtypeDeref,\n        PartialEq,\n        PartialOrd,\n        Copy,\n        Clone,\n        Debug,\n    )]\n    pub struct BayesFactor(pub f64);\n}\n\nimpl BayesFactor {\n    /// Calculate Bayes factor from given probabilities.\n    pub fn new(a: LogProb, b: LogProb) -\u003e Self {\n        BayesFactor((a - b).exp())\n    }\n\n    /// Calculate strength of evidence as defined by\n    /// [Kass and Raftery 1995](http://www.andrew.cmu.edu/user/kk3n/simplicity/KassRaftery1995.pdf).\n    pub fn evidence_kass_raftery(\u0026self) -\u003e evidence::KassRaftery {\n        let k = **self;\n        if k \u003c= 1.0 {\n            evidence::KassRaftery::None\n        } else if k \u003c= 3.0 {\n            evidence::KassRaftery::Barely\n        } else if k \u003c= 20.0 {\n            evidence::KassRaftery::Positive\n        } else if k \u003c= 150.0 {\n            evidence::KassRaftery::Strong\n        } else {\n            evidence::KassRaftery::VeryStrong\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_bayes_factor() {\n        let bf = BayesFactor::new(LogProb(0.5_f64.ln()), LogProb(0.1_f64.ln()));\n        assert_relative_eq!(*bf, 5.0, epsilon = 1e-9);\n        assert_eq!(bf.evidence_kass_raftery(), evidence::KassRaftery::Positive);\n    }\n}\n","traces":[{"line":47,"address":[9362766,9362590,9362461,9362525,9362723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[9361895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[9361930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[9082688],"length":1,"stats":{"Line":3},"fn_name":"test_bayes_factor"},{"line":80,"address":[9082700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[9082812,9083054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[9083786,9083673,9083029],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":12,"coverable":18},{"path":["/","home","todd","rust-bio","src","stats","bayesian","mod.rs"],"content":"// Copyright 2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Utilities for Bayesian statistics.\n\npub mod bayes_factors;\npub mod model;\npub use self::bayes_factors::BayesFactor;\npub use self::model::Model;\n\nuse itertools::Itertools;\nuse ordered_float::OrderedFloat;\n\nuse crate::stats::LogProb;\n\n/// For each of the hypothesis tests given as posterior error probabilities\n/// (PEPs, i.e. the posterior probability of the null hypothesis), estimate the FDR\n/// for the case that all null hypotheses with at most this PEP are rejected.\n/// FDR is calculated as presented by Müller, Parmigiani, and Rice,\n/// \"FDR and Bayesian Multiple Comparisons Rules\" (July 2006).\n/// Johns Hopkin's University, Dept. of Biostatistics Working Papers. Working Paper 115.\n///\n/// # Returns\n///\n/// A vector of expected FDRs in the same order as the given PEPs.\npub fn expected_fdr(peps: \u0026[LogProb]) -\u003e Vec\u003cLogProb\u003e {\n    // sort indices\n    let sorted_idx =\n        (0..peps.len()).sorted_by(|\u0026i, \u0026j| OrderedFloat(*peps[i]).cmp(\u0026OrderedFloat(*peps[j])));\n    // estimate FDR\n    let mut expected_fdr = vec![LogProb::ln_zero(); peps.len()];\n    for (j, (expected_fp, i)) in LogProb::ln_cumsum_exp(sorted_idx.clone().map(|i| peps[i]))\n        .zip(sorted_idx)\n        .enumerate()\n    {\n        let fdr = LogProb(*expected_fp - ((j + 1) as f64).ln());\n        expected_fdr[i] = if fdr \u003c= LogProb::ln_one() {\n            fdr\n        } else {\n            LogProb::ln_one()\n        };\n    }\n\n    expected_fdr\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::stats::LogProb;\n\n    #[test]\n    fn test_expected_fdr() {\n        let peps = [\n            LogProb(0.1f64.ln()),\n            LogProb::ln_zero(),\n            LogProb(0.25f64.ln()),\n        ];\n        let fdrs = expected_fdr(\u0026peps);\n        println!(\"{:?}\", fdrs);\n\n        assert_relative_eq!(*fdrs[1], *LogProb::ln_zero());\n        assert_relative_eq!(*fdrs[0], *LogProb(0.05f64.ln()));\n        assert_relative_eq!(*fdrs[2], *LogProb((0.35 / 3.0f64).ln()), epsilon = 0.000001);\n    }\n}\n","traces":[{"line":28,"address":[5558246,5557088],"length":1,"stats":{"Line":1},"fn_name":"expected_fdr"},{"line":30,"address":[4699176,4699152],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":33,"address":[5557241,5557342],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[4699479,4699456],"length":1,"stats":{"Line":7},"fn_name":"{{closure}}"},{"line":35,"address":[5557483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[5557890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[5558055,5558163,5558207],"length":1,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[5558135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[5558191,5558122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[9183872,9183877],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":56,"address":[9569413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[9569310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[9569350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[9569364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[9569458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[9569492,9569665],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[9569684,9570008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[9571073,9569968,9570786],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[9572167,9571032,9571852],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":18,"coverable":19},{"path":["/","home","todd","rust-bio","src","stats","bayesian","model.rs"],"content":"// Copyright 2019 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A trait system for Bayesian statistical modelling.\n\nuse std::cmp::Eq;\nuse std::collections::HashMap;\nuse std::hash::Hash;\nuse std::marker::PhantomData;\n\nuse itertools::Itertools;\nuse ordered_float::NotNan;\n\nuse crate::stats::LogProb;\n\npub type JointProbUniverse\u003cEvent\u003e = HashMap\u003cEvent, LogProb\u003e;\n\n/// Likelihood model.\npub trait Likelihood\u003cPayload = ()\u003e {\n    type Event;\n    type Data;\n\n    /// Compute likelihood of event given the data. Optionally, the passed payload can be used\n    /// to e.g., cache intermediate results. One payload corresponds to one model instance.\n    fn compute(\u0026self, event: \u0026Self::Event, data: \u0026Self::Data, payload: \u0026mut Payload) -\u003e LogProb;\n}\n\n/// Prior model.\npub trait Prior {\n    type Event;\n\n    fn compute(\u0026self, event: \u0026Self::Event) -\u003e LogProb;\n}\n\n/// Posterior model.\npub trait Posterior {\n    type Event;\n    type BaseEvent;\n    type Data;\n\n    fn compute\u003cF: FnMut(\u0026Self::BaseEvent, \u0026Self::Data) -\u003e LogProb\u003e(\n        \u0026self,\n        event: \u0026Self::Event,\n        data: \u0026Self::Data,\n        joint_prob: \u0026mut F,\n    ) -\u003e LogProb;\n}\n\n/// Bayesian model, consisting of a prior, a posterior and a likelihood model.\n/// Thereby, `Payload` is a custom payload of the model instance.\n/// This can be used to define custom caching mechanisms. See\n/// [here](https://github.com/varlociraptor/varlociraptor/blob/694e994547e8f523e5b0013fdf951b694f3870fa/src/model/modes/generic.rs#L200)\n/// for an example.\n#[derive(Clone, Debug, Getters, MutGetters)]\npub struct Model\u003cL, Pr, Po, Payload = ()\u003e\nwhere\n    L: Likelihood\u003cPayload\u003e,\n    Pr: Prior,\n    Po: Posterior,\n    Payload: Default,\n{\n    #[get = \"pub\"]\n    #[get_mut = \"pub\"]\n    likelihood: L,\n    #[get = \"pub\"]\n    #[get_mut = \"pub\"]\n    prior: Pr,\n    #[get = \"pub\"]\n    #[get_mut = \"pub\"]\n    posterior: Po,\n    payload: PhantomData\u003cPayload\u003e,\n}\n\nimpl\u003cEvent, PosteriorEvent, Data, L, Pr, Po, Payload\u003e Model\u003cL, Pr, Po, Payload\u003e\nwhere\n    Payload: Default,\n    Event: Hash + Eq + Clone,\n    PosteriorEvent: Hash + Eq + Clone,\n    L: Likelihood\u003cPayload, Event = Event, Data = Data\u003e,\n    Pr: Prior\u003cEvent = Event\u003e,\n    Po: Posterior\u003cBaseEvent = Event, Event = PosteriorEvent, Data = Data\u003e,\n{\n    /// Create new instance.\n    pub fn new(likelihood: L, prior: Pr, posterior: Po) -\u003e Self {\n        Model {\n            likelihood,\n            prior,\n            posterior,\n            payload: PhantomData,\n        }\n    }\n\n    /// Calculate joint probability, i.e. `Pr(event) * Pr(data | event)`.\n    fn joint_prob(\u0026self, event: \u0026Event, data: \u0026Data, payload: \u0026mut Payload) -\u003e LogProb {\n        self.prior.compute(event) + self.likelihood.compute(event, data, payload)\n    }\n\n    /// Compute model for a given universe of events.\n    pub fn compute\u003cU: IntoIterator\u003cItem = PosteriorEvent\u003e\u003e(\n        \u0026self,\n        universe: U,\n        data: \u0026Data,\n    ) -\u003e ModelInstance\u003cEvent, PosteriorEvent\u003e {\n        let mut joint_probs = HashMap::new();\n        let mut payload = Payload::default();\n        let (posterior_probs, marginal) = {\n            let mut joint_prob = |event: \u0026Event, data: \u0026Data| {\n                let p = self.joint_prob(event, data, \u0026mut payload);\n                joint_probs.insert(event.clone(), p);\n                p\n            };\n\n            let posterior_probs: HashMap\u003cPosteriorEvent, LogProb\u003e = universe\n                .into_iter()\n                .map(|event| {\n                    let p = self.posterior.compute(\u0026event, data, \u0026mut joint_prob);\n                    (event, p)\n                })\n                .collect();\n            let marginal = LogProb::ln_sum_exp(\u0026posterior_probs.values().cloned().collect_vec());\n\n            (posterior_probs, marginal)\n        };\n\n        ModelInstance {\n            joint_probs,\n            posterior_probs,\n            marginal,\n        }\n    }\n}\n\n/// Instance of a model for given data and event universe.\n/// From the instance, posterior, marginal and MAP can be computed.\npub struct ModelInstance\u003cEvent, PosteriorEvent\u003e\nwhere\n    Event: Hash + Eq,\n    PosteriorEvent: Hash + Eq,\n{\n    joint_probs: HashMap\u003cEvent, LogProb\u003e,\n    posterior_probs: HashMap\u003cPosteriorEvent, LogProb\u003e,\n    marginal: LogProb,\n}\n\nimpl\u003cEvent, PosteriorEvent\u003e ModelInstance\u003cEvent, PosteriorEvent\u003e\nwhere\n    Event: Hash + Eq,\n    PosteriorEvent: Hash + Eq,\n{\n    /// Posterior probability of given event.\n    pub fn posterior(\u0026self, event: \u0026PosteriorEvent) -\u003e Option\u003cLogProb\u003e {\n        self.posterior_probs.get(event).map(|p| p - self.marginal)\n    }\n\n    /// Marginal probability.\n    pub fn marginal(\u0026self) -\u003e LogProb {\n        self.marginal\n    }\n\n    /// Maximum a posteriori estimate.\n    pub fn maximum_posterior(\u0026self) -\u003e Option\u003c\u0026Event\u003e {\n        self.joint_probs\n            .iter()\n            .max_by_key(|(_, prob)| NotNan::new(***prob).unwrap())\n            .map(|(event, _)| event)\n    }\n}\n\nimpl\u003cPosteriorEvent\u003e ModelInstance\u003cNotNan\u003cf64\u003e, PosteriorEvent\u003e\nwhere\n    PosteriorEvent: Hash + Eq,\n{\n    pub fn expected_value(\u0026self) -\u003e NotNan\u003cf64\u003e {\n        self.joint_probs\n            .iter()\n            .map(|(event, prob)| *event * NotNan::new(**prob).unwrap())\n            .fold(NotNan::default(), |s, e| s + e)\n    }\n}\n\nmod tests {}\n","traces":[{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":29},{"path":["/","home","todd","rust-bio","src","stats","combinatorics.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Combinations with and without replacement.\n\nuse std::cmp;\n\n/// Calculate the number of combinations when choosing\n/// k elements from n elements without replacement, multiplied by a scaling factor.\n/// Time complexity: O(min(k, n - k))\n///\n/// # Examples\n/// ```\n/// use approx::assert_relative_eq;\n/// use bio::stats::combinatorics::scaled_combinations;\n/// assert_relative_eq!(scaled_combinations(5, 3, 0.5), 5., epsilon = f64::EPSILON);\n/// ```\npub fn scaled_combinations(n: u64, k: u64, scale: f64) -\u003e f64 {\n    if k \u003e n {\n        0.0\n    } else {\n        let mut comb = scale;\n        for j in 0..cmp::min(k, n - k) {\n            comb /= (j + 1) as f64;\n            comb *= (n - j) as f64;\n        }\n        comb\n    }\n}\n\n/// Calculate the number of combinations when choosing\n/// k elements from n elements without replacement.\n/// This is also known as n over k, or the binomial coefficient.\n/// Time complexity: O(min(k, n - k))\n///\n/// # Examples\n/// ```\n/// use approx::assert_relative_eq;\n/// use bio::stats::combinatorics::combinations;\n/// assert_relative_eq!(combinations(5, 3), 10., epsilon = f64::EPSILON);\n/// ```\npub fn combinations(n: u64, k: u64) -\u003e f64 {\n    scaled_combinations(n, k, 1.0)\n}\n\n/// Calculate the number of combinations when choosing\n/// k elements from n elements with replacement.\n/// Time complexity: O(min(k, n - k))\n///\n/// # Examples\n/// ```\n/// use approx::assert_relative_eq;\n/// use bio::stats::combinatorics::combinations_with_repl;\n/// assert_relative_eq!(combinations_with_repl(5, 3), 35., epsilon = f64::EPSILON);\n/// ```\npub fn combinations_with_repl(n: u64, k: u64) -\u003e f64 {\n    combinations(n + k - 1, k)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_comb() {\n        assert_relative_eq!(combinations(10, 3), 120.0, epsilon = f64::EPSILON);\n        assert_relative_eq!(combinations_with_repl(10, 3), 220.0, epsilon = f64::EPSILON);\n        assert_relative_eq!(\n            combinations(200, 10),\n            22451004309013280.0,\n            epsilon = f64::EPSILON\n        );\n    }\n\n    #[test]\n    fn test_comb_scaled() {\n        assert_relative_eq!(\n            scaled_combinations(150, 80, 1e-5),\n            6.664_393_816_347_938_4e38,\n            epsilon = f64::EPSILON\n        );\n    }\n}\n","traces":[{"line":20,"address":[5634416],"length":1,"stats":{"Line":1},"fn_name":"scaled_combinations"},{"line":21,"address":[5634464,5634713],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[5634508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[5634485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[5634541,5634718,5634944,5634491],"length":1,"stats":{"Line":4},"fn_name":null},{"line":26,"address":[5634858,5634755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[5634949,5634893,5634979,5634841],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[5634701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[5634992],"length":1,"stats":{"Line":1},"fn_name":"combinations"},{"line":45,"address":[5635006],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[5635040],"length":1,"stats":{"Line":1},"fn_name":"combinations_with_repl"},{"line":59,"address":[5635059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[9169792],"length":1,"stats":{"Line":3},"fn_name":"test_comb"},{"line":68,"address":[9169804,9170053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[9170750,9170024,9170975],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[9171881,9171672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[9170946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[9172496],"length":1,"stats":{"Line":3},"fn_name":"test_comb_scaled"},{"line":79,"address":[9172540,9172749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[9172508],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":19,"coverable":20},{"path":["/","home","todd","rust-bio","src","stats","hmm","errors.rs"],"content":"// Copyright 2019 Johannes Köster, University of Duisburg-Essen.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Error definitions for the `hmm` module.\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum Error {\n    #[error(\n        \"inferred from A: N_0={}, N_1={} (must be equal), from B: N={}, M={}, from pi: N={}\",\n        an0,\n        an1,\n        bn,\n        bm,\n        pin\n    )]\n    InvalidDimension {\n        an0: usize,\n        an1: usize,\n        bn: usize,\n        bm: usize,\n        pin: usize,\n    },\n}\npub type Result\u003cT, E = Error\u003e = std::result::Result\u003cT, E\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","stats","hmm","mod.rs"],"content":"// Copyright 2018 Manuel Holtgrewe, Berlin Institute of Health.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! An implementation of Hidden Markov Models in Rust.\n//!\n//! ## Examples\n//!\n//! ### Discrete Emission Distribution\n//!\n//! We construct the example from Borodovsky \u0026 Ekisheva (2006), pp. 80 (also see\n//! [these slides](http://cecas.clemson.edu/~ahoover/ece854/refs/Gonze-ViterbiAlgorithm.pdf).\n//!\n//! ```rust\n//! use approx::assert_relative_eq;\n//! use bio::stats::hmm::discrete_emission::Model as DiscreteEmissionHMM;\n//! use bio::stats::hmm::viterbi;\n//! use bio::stats::Prob;\n//! use ndarray::array;\n//!\n//! let transition = array![[0.5, 0.5], [0.4, 0.6]];\n//! let observation = array![[0.2, 0.3, 0.3, 0.2], [0.3, 0.2, 0.2, 0.3]];\n//! let initial = array![0.5, 0.5];\n//!\n//! let hmm = DiscreteEmissionHMM::with_float(\u0026transition, \u0026observation, \u0026initial)\n//!     .expect(\"Dimensions should be consistent\");\n//! let (path, log_prob) = viterbi(\u0026hmm, \u0026vec![2, 2, 1, 0, 1, 3, 2, 0, 0]);\n//! let prob = Prob::from(log_prob);\n//! assert_relative_eq!(4.25e-8_f64, *prob, epsilon = 1e-9_f64);\n//! ```\n//!\n//! ### Continuous (Gaussian) Emission Distribution\n//!\n//! ```rust\n//! use approx::assert_relative_eq;\n//! use bio::stats::hmm::univariate_continuous_emission::GaussianModel as GaussianHMM;\n//! use bio::stats::hmm::viterbi;\n//! use bio::stats::Prob;\n//! use ndarray::array;\n//! use statrs::distribution::Normal;\n//!\n//! let transition = array![[0.5, 0.5], [0.4, 0.6]];\n//! let observation = vec![\n//!     Normal::new(0.0, 1.0).unwrap(),\n//!     Normal::new(2.0, 1.0).unwrap(),\n//! ];\n//! let initial = array![0.5, 0.5];\n//!\n//! let hmm = GaussianHMM::with_float(\u0026transition, observation, \u0026initial)\n//!     .expect(\"Dimensions should be consistent\");\n//! let (path, log_prob) = viterbi(\n//!     \u0026hmm,\n//!     \u0026vec![-0.1, 0.1, -0.2, 0.5, 0.8, 1.1, 1.2, 1.5, 0.5, 0.2],\n//! );\n//! let prob = Prob::from(log_prob);\n//! assert_relative_eq!(2.64e-8_f64, *prob, epsilon = 1e-9_f64);\n//! ```\n//!\n//! ## Numeric Stability\n//!\n//! The implementation uses log-scale probabilities for numeric stability.\n//!\n//! ## Limitations\n//!\n//! Currently, only discrete and single-variate Gaussian continuous HMMs are implemented.\n//! Also, only dense transition matrices are supported.\n//!\n//! ## References\n//!\n//! - Rabiner, Lawrence R. \"A tutorial on hidden Markov models and selected applications\n//!   in speech recognition.\" Proceedings of the IEEE 77, no. 2 (1989): 257-286.\n\npub mod errors;\n\nuse std::cmp::Ordering;\n\nuse ndarray::prelude::*;\nuse num_traits::Zero;\nuse ordered_float::OrderedFloat;\nuse statrs::distribution::Continuous;\n\npub use self::errors::{Error, Result};\n\nuse super::LogProb;\n\ncustom_derive! {\n    /// A newtype for HMM states.\n    #[derive(\n        NewtypeFrom,\n        NewtypeDeref,\n        PartialEq,\n        Copy,\n        Clone,\n        Debug\n    )]\n    // #[derive(Serialize, Deserialize)]\n    pub struct State(pub usize);\n}\n\n/// Iterate over the states of a `Model`.\npub struct StateIter {\n    nxt: usize,\n    max: usize,\n}\n\nimpl StateIter {\n    /// Constructor.\n    pub fn new(num_states: usize) -\u003e Self {\n        Self {\n            nxt: 0,\n            max: num_states,\n        }\n    }\n}\n\nimpl Iterator for StateIter {\n    type Item = State;\n\n    fn next(\u0026mut self) -\u003e Option\u003cState\u003e {\n        if self.nxt \u003c self.max {\n            let cur = self.nxt;\n            self.nxt += 1;\n            Some(State(cur))\n        } else {\n            None\n        }\n    }\n}\n\n/// Transition between two states in a `Model`.\n#[derive(Debug, Copy, Clone, PartialEq)]\npub struct StateTransition {\n    /// Source of the transition.\n    pub src: State,\n    /// Destination of the transition.\n    pub dst: State,\n}\n\nimpl StateTransition {\n    /// Constructor.\n    pub fn new(src: State, dst: State) -\u003e Self {\n        Self { src, dst }\n    }\n}\n\n/// Iterate over all state transitions of a `Model`.\npub struct StateTransitionIter {\n    nxt_a: usize,\n    nxt_b: usize,\n    max: usize,\n}\n\nimpl StateTransitionIter {\n    /// Constructor.\n    pub fn new(num_states: usize) -\u003e Self {\n        Self {\n            nxt_a: 0,\n            nxt_b: 0,\n            max: num_states,\n        }\n    }\n}\n\nimpl Iterator for StateTransitionIter {\n    type Item = StateTransition;\n\n    fn next(\u0026mut self) -\u003e Option\u003cStateTransition\u003e {\n        let cur_b = self.nxt_b;\n        let cur_a = self.nxt_a;\n        if self.nxt_b \u003c self.max {\n            self.nxt_b += 1;\n            Some(StateTransition::new(State(cur_a), State(cur_b)))\n        } else if self.nxt_a \u003c self.max {\n            self.nxt_b = 0;\n            self.nxt_a += 1;\n            Some(StateTransition::new(State(cur_a), State(cur_b)))\n        } else {\n            None\n        }\n    }\n}\n\n/// A trait for Hidden Markov Models (HMM) with generic `Observation` type.\n///\n/// Rabiner (1989) defines a Hidden Markov Model λ as the tiple (*A*, *B*, π) of transition matrix\n/// *A*, emission probabilities *B*, and initial state distribution π.  This has been generalized\n/// in `Model` such that you implement `transition_prob()`, `observation_prob()`, and\n/// `initial_prob()` (and the other methods; implementation of `transition_prob_idx()` can\n/// optionally be implemented and your implementation of `transition_prob()` can then panic).\n///\n/// The inference algorithm implementations `viterbi()`, `forward()`, and `backward()` will work\n/// with any implementation.\n///\n/// Consequently, this allows for the implementation of HMMs with both discrete and continuous\n/// emission distributions.\npub trait Model\u003cObservation\u003e {\n    /// The number of states in the model.\n    fn num_states(\u0026self) -\u003e usize;\n\n    /// Return iterator over the states of an HMM.\n    fn states(\u0026self) -\u003e StateIter;\n\n    /// Returns an iterator of all transitions.\n    fn transitions(\u0026self) -\u003e StateTransitionIter;\n\n    /// Transition probability between two states `from` and `to`.\n    fn transition_prob(\u0026self, from: State, to: State) -\u003e LogProb;\n\n    /// Transition probability between two states `from` and `to` for observation with index\n    /// `_to_idx` (index of `to`).\n    ///\n    /// This feature comes in handy in several applications of HMMs to biological sequences.\n    /// One prominent one is how XHMM by Fromer et al. (2014) uses the distance between target\n    /// regions for adjusting the transition probabilities.\n    ///\n    /// The default implementation return the result of the position-independent\n    /// `transition_prob()`.\n    fn transition_prob_idx(\u0026self, from: State, to: State, _to_idx: usize) -\u003e LogProb {\n        self.transition_prob(from, to)\n    }\n\n    /// Initial probability given the HMM `state`.\n    fn initial_prob(\u0026self, state: State) -\u003e LogProb;\n\n    /// Probability for the given observation in the given state.\n    fn observation_prob(\u0026self, state: State, observation: \u0026Observation) -\u003e LogProb;\n}\n\n/// Compute the probability Viterbi matrix and the pointers to the origin.\nfn viterbi_matrices\u003cO, M: Model\u003cO\u003e\u003e(\n    hmm: \u0026M,\n    observations: \u0026[O],\n) -\u003e (Array2\u003cLogProb\u003e, Array2\u003cusize\u003e) {\n    // The matrix with probabilities.\n    let mut vals = Array2::\u003cLogProb\u003e::zeros((observations.len(), hmm.num_states()));\n    // For each cell in `vals`, a pointer to the row in the previous column (for the traceback).\n    let mut from = Array2::\u003cusize\u003e::zeros((observations.len(), hmm.num_states()));\n\n    // Compute matrix.\n    for (i, o) in observations.iter().enumerate() {\n        if i == 0 {\n            // Initial column.\n            for s in hmm.states() {\n                vals[[0, *s]] = hmm.initial_prob(s) + hmm.observation_prob(s, o);\n                from[[0, *s]] = *s;\n            }\n        } else {\n            // Subsequent columns.\n            for j in hmm.states() {\n                let x = vals\n                    .index_axis(Axis(0), i - 1)\n                    .iter()\n                    .enumerate()\n                    .map(|(a, p)| (State(a), p))\n                    .max_by(|(a, \u0026x), (b, \u0026y)| {\n                        if x.is_zero() \u0026\u0026 y.is_zero() {\n                            Ordering::Equal\n                        } else if x.is_zero() {\n                            Ordering::Less\n                        } else if y.is_zero() {\n                            Ordering::Greater\n                        } else {\n                            (x + hmm.transition_prob_idx(*a, j, i))\n                                .partial_cmp(\u0026(y + hmm.transition_prob_idx(*b, j, i)))\n                                .unwrap()\n                        }\n                    })\n                    .map(|(x, y)| (x, *y))\n                    .unwrap();\n                vals[[i, *j]] =\n                    x.1 + hmm.transition_prob_idx(x.0, j, i) + hmm.observation_prob(j, o);\n                from[[i, *j]] = *x.0;\n            }\n        }\n    }\n\n    (vals, from)\n}\n\nfn viterbi_traceback(vals: Array2\u003cLogProb\u003e, from: Array2\u003cusize\u003e) -\u003e (Vec\u003cState\u003e, LogProb) {\n    // Traceback through matrix.\n    let n = vals.len_of(Axis(0));\n    let mut result: Vec\u003cState\u003e = Vec::new();\n    let mut curr = 0;\n    let mut res_prob = LogProb::ln_zero();\n    for (i, col) in vals.axis_iter(Axis(0)).rev().enumerate() {\n        if i == 0 {\n            let tmp = col\n                .iter()\n                .enumerate()\n                .max_by_key(|\u0026(_, item)| OrderedFloat(**item))\n                .unwrap();\n            curr = tmp.0;\n            res_prob = *tmp.1;\n        } else {\n            curr = from[[n - i, curr]];\n        }\n        result.push(State(curr));\n    }\n    result.reverse();\n\n    (result, res_prob)\n}\n\n/// Execute Viterbi algorithm on the given slice of `Observation` values to get the maximum a\n/// posteriori (MAP) probability.\n///\n/// ## Arguments\n///\n/// - `hmm` - the `Model` to run the Viterbi algorithm on\n/// - `observations` - a slice of observation values to use in the algorithm\n///\n/// ## Result\n///\n/// The resulting pair *(s, p)* is the `Vec\u003cState\u003e` of most probable states given `hmm`\n/// and `observations` as well as the probability (as `LogProb`) of path `s`.\n///\n/// ## Type Parameters\n///\n/// - `O` - the observation type\n/// - `M` - type `Model` type\npub fn viterbi\u003cO, M: Model\u003cO\u003e\u003e(hmm: \u0026M, observations: \u0026[O]) -\u003e (Vec\u003cState\u003e, LogProb) {\n    let (vals, from) = viterbi_matrices(hmm, observations);\n    viterbi_traceback(vals, from)\n}\n\n/// Execute the forward algorithm and return the forward probabilites as `LogProb` values\n/// and the resulting forward probability.\n///\n/// ## Arguments\n///\n/// - `hmm` - the `Model` to run the forward algorithm on\n/// - `observations` - a slice of observation values to use in the algorithm\n///\n/// ## Result\n///\n/// The resulting pair (*P*, *p*) is the forward probability table (`P[[s, o]]` is the entry\n/// for state `s` and observation `o`) and the overall probability for `observations` (as\n/// `LogProb`).\n///\n/// ## Type Parameters\n///\n/// - `O` - the observation type\n/// - `M` - type `Model` type\npub fn forward\u003cO, M: Model\u003cO\u003e\u003e(hmm: \u0026M, observations: \u0026[O]) -\u003e (Array2\u003cLogProb\u003e, LogProb) {\n    // The matrix with probabilities.\n    let mut vals = Array2::\u003cLogProb\u003e::zeros((observations.len(), hmm.num_states()));\n\n    // Compute matrix.\n    for (i, o) in observations.iter().enumerate() {\n        if i == 0 {\n            // Initial column.\n            for s in hmm.states() {\n                vals[[0, *s]] = hmm.initial_prob(s) + hmm.observation_prob(s, o);\n            }\n        } else {\n            // Subsequent columns.\n            for j in hmm.states() {\n                let xs = hmm\n                    .states()\n                    .map(|k| {\n                        vals[[i - 1, *k]]\n                            + hmm.transition_prob_idx(k, j, i)\n                            + hmm.observation_prob(j, o)\n                    })\n                    .collect::\u003cVec\u003cLogProb\u003e\u003e();\n                vals[[i, *j]] = LogProb::ln_sum_exp(\u0026xs);\n            }\n        }\n    }\n\n    // Compute final probability.\n    let prob = LogProb::ln_sum_exp(vals.row(observations.len() - 1).to_slice().unwrap());\n\n    (vals, prob)\n}\n\n/// Execute the backward algorithm and return the backward probabilities as `LogProb` values\n/// and the resulting backward probability.\n///\n/// ## Arguments\n///\n/// - `hmm` - the `Model` to run the backward algorithm on\n/// - `observations` - a slice of observation values to use in the algorithm\n///\n/// ## Result\n///\n/// The resulting pair (*P*, *p*) is the backward probability table (`P[[s, o]]` is the entry\n/// for state `s` and observation `o`) and the overall probability for `observations` (as\n/// `LogProb`).\n///\n/// ## Type Parameters\n///\n/// - `O` - the observation type\n/// - `M` - type `Model` type\npub fn backward\u003cO, M: Model\u003cO\u003e\u003e(hmm: \u0026M, observations: \u0026[O]) -\u003e (Array2\u003cLogProb\u003e, LogProb) {\n    // The matrix with probabilities.\n    let mut vals = Array2::\u003cLogProb\u003e::zeros((observations.len(), hmm.num_states()));\n\n    // Compute matrix.\n    let n = observations.len();\n    for (i, o) in observations.iter().rev().enumerate() {\n        if i == 0 {\n            for j in hmm.states() {\n                let maybe_initial = if i == observations.len() - 1 {\n                    hmm.initial_prob(j)\n                } else {\n                    LogProb::ln_one()\n                };\n                vals[[0, *j]] = LogProb::ln_one() + hmm.observation_prob(j, o) + maybe_initial;\n            }\n        } else {\n            // Previous columns.\n            for j in hmm.states() {\n                let maybe_initial = if i == observations.len() - 1 {\n                    hmm.initial_prob(j)\n                } else {\n                    LogProb::ln_one()\n                };\n                let xs = hmm\n                    .states()\n                    .map(|k| {\n                        vals[[i - 1, *k]]\n                            + hmm.transition_prob_idx(j, k, n - i)\n                            + hmm.observation_prob(j, o)\n                            + maybe_initial\n                    })\n                    .collect::\u003cVec\u003cLogProb\u003e\u003e();\n                vals[[i, *j]] = LogProb::ln_sum_exp(\u0026xs);\n            }\n        }\n    }\n\n    // Compute final probability.\n    let prob = LogProb::ln_sum_exp(vals.row(observations.len() - 1).to_slice().unwrap());\n\n    (vals, prob)\n}\n\n/// Implementation of Hidden Markov Model with emission values from discrete distributions.\npub mod discrete_emission {\n    use super::super::{LogProb, Prob};\n    use super::*;\n\n    /// Implementation of a `hmm::Model` with emission values from discrete distributions.\n    ///\n    /// Log-scale probabilities are used for numeric stability.\n    ///\n    /// In Rabiner's tutorial, a discrete emission value HMM has `N` states and `M` output symbols.\n    /// The state transition matrix with dimensions `NxN` is `A`, the observation probability\n    /// distribution is the matrix `B` with dimensions `NxM` and the initial state distribution `pi`\n    /// has length `N`.\n    #[derive(Debug, PartialEq)]\n    pub struct Model {\n        /// The state transition matrix (size `NxN`), `A` in Rabiner's tutorial.\n        transition: Array2\u003cLogProb\u003e,\n\n        /// The observation symbol probability distribution (size `NxM`), `B` in Rabiner's tutorial.\n        observation: Array2\u003cLogProb\u003e,\n\n        /// The initial state distribution (size `N`), `pi` in Rabiner's tutorial.\n        initial: Array1\u003cLogProb\u003e,\n    }\n\n    impl Model {\n        /// Construct new Hidden MarkovModel with the given transition, observation, and initial\n        /// state matrices and vectors already in log-probability space.\n        pub fn new(\n            transition: Array2\u003cLogProb\u003e,\n            observation: Array2\u003cLogProb\u003e,\n            initial: Array1\u003cLogProb\u003e,\n        ) -\u003e Result\u003cSelf\u003e {\n            let (an0, an1) = transition.dim();\n            let (bn, bm) = observation.dim();\n            let pin = initial.dim();\n\n            if an0 != an1 || an0 != bn || an0 != pin {\n                Err(Error::InvalidDimension {\n                    an0,\n                    an1,\n                    bn,\n                    bm,\n                    pin,\n                })\n            } else {\n                Ok(Self {\n                    transition,\n                    observation,\n                    initial,\n                })\n            }\n        }\n\n        /// Construct new Hidden MarkovModel with the given transition, observation, and initial\n        /// state matrices and vectors already as `Prob` values.\n        pub fn with_prob(\n            transition: \u0026Array2\u003cProb\u003e,\n            observation: \u0026Array2\u003cProb\u003e,\n            initial: \u0026Array1\u003cProb\u003e,\n        ) -\u003e Result\u003cSelf\u003e {\n            Self::new(\n                transition.map(|x| LogProb::from(*x)),\n                observation.map(|x| LogProb::from(*x)),\n                initial.map(|x| LogProb::from(*x)),\n            )\n        }\n\n        /// Construct new Hidden MarkovModel with the given transition, observation, and initial\n        /// state matrices and vectors with probabilities as `f64` values.\n        pub fn with_float(\n            transition: \u0026Array2\u003cf64\u003e,\n            observation: \u0026Array2\u003cf64\u003e,\n            initial: \u0026Array1\u003cf64\u003e,\n        ) -\u003e Result\u003cSelf\u003e {\n            Self::new(\n                transition.map(|x| LogProb::from(Prob(*x))),\n                observation.map(|x| LogProb::from(Prob(*x))),\n                initial.map(|x| LogProb::from(Prob(*x))),\n            )\n        }\n    }\n\n    impl super::Model\u003cusize\u003e for Model {\n        fn num_states(\u0026self) -\u003e usize {\n            self.transition.dim().0\n        }\n\n        fn states(\u0026self) -\u003e StateIter {\n            StateIter {\n                nxt: 0,\n                max: self.num_states(),\n            }\n        }\n\n        fn transitions(\u0026self) -\u003e StateTransitionIter {\n            StateTransitionIter {\n                nxt_a: 0,\n                nxt_b: 0,\n                max: self.num_states(),\n            }\n        }\n\n        fn transition_prob(\u0026self, from: State, to: State) -\u003e LogProb {\n            self.transition[[*from, *to]]\n        }\n\n        fn initial_prob(\u0026self, state: State) -\u003e LogProb {\n            self.initial[[*state]]\n        }\n\n        fn observation_prob(\u0026self, state: State, observation: \u0026usize) -\u003e LogProb {\n            self.observation[[*state, *observation]]\n        }\n    }\n}\n\n/// Implementation of Hidden Markov Models with emission values from univariate continuous\n/// distributions.\npub mod univariate_continuous_emission {\n    use super::super::{LogProb, Prob};\n    use super::*;\n\n    /// Implementation of a `hmm::Model` with emission values from univariate continuous distributions.\n    ///\n    /// Log-scale probabilities are used for numeric stability.\n    pub struct Model\u003cDist: Continuous\u003cf64, f64\u003e\u003e {\n        /// The state transition matrix (size `NxN`), `A` in Rabiner's tutorial.\n        transition: Array2\u003cLogProb\u003e,\n\n        /// The emission probability distributions.\n        observation: Vec\u003cDist\u003e,\n\n        /// The initial state distribution (size `N`), `pi` in Rabiner's tutorial.\n        initial: Array1\u003cLogProb\u003e,\n    }\n\n    impl\u003cDist: Continuous\u003cf64, f64\u003e\u003e Model\u003cDist\u003e {\n        /// Construct new Hidden MarkovModel with the given transition, observation, and initial\n        /// state matrices and vectors already in log-probability space.\n        pub fn new(\n            transition: Array2\u003cLogProb\u003e,\n            observation: Vec\u003cDist\u003e,\n            initial: Array1\u003cLogProb\u003e,\n        ) -\u003e Result\u003cSelf\u003e {\n            let (an0, an1) = transition.dim();\n            let bn = observation.len();\n            let pin = initial.dim();\n\n            if an0 != an1 || an0 != bn || an0 != pin {\n                Err(Error::InvalidDimension {\n                    an0,\n                    an1,\n                    bn,\n                    bm: bn,\n                    pin,\n                })\n            } else {\n                Ok(Self {\n                    transition,\n                    observation,\n                    initial,\n                })\n            }\n        }\n\n        /// Construct new Hidden MarkovModel with the given transition, observation, and initial\n        /// state matrices and vectors already as `Prob` values.\n        pub fn with_prob(\n            transition: \u0026Array2\u003cProb\u003e,\n            observation: Vec\u003cDist\u003e,\n            initial: \u0026Array1\u003cProb\u003e,\n        ) -\u003e Result\u003cSelf\u003e {\n            Self::new(\n                transition.map(|x| LogProb::from(*x)),\n                observation,\n                initial.map(|x| LogProb::from(*x)),\n            )\n        }\n\n        /// Construct new Hidden MarkovModel with the given transition, observation, and initial\n        /// state matrices and vectors with probabilities as `f64` values.\n        pub fn with_float(\n            transition: \u0026Array2\u003cf64\u003e,\n            observation: Vec\u003cDist\u003e,\n            initial: \u0026Array1\u003cf64\u003e,\n        ) -\u003e Result\u003cSelf\u003e {\n            Self::new(\n                transition.map(|x| LogProb::from(Prob(*x))),\n                observation,\n                initial.map(|x| LogProb::from(Prob(*x))),\n            )\n        }\n    }\n\n    impl\u003cDist: Continuous\u003cf64, f64\u003e\u003e super::Model\u003cf64\u003e for Model\u003cDist\u003e {\n        fn num_states(\u0026self) -\u003e usize {\n            self.transition.dim().0\n        }\n\n        fn states(\u0026self) -\u003e StateIter {\n            StateIter {\n                nxt: 0,\n                max: self.num_states(),\n            }\n        }\n\n        fn transitions(\u0026self) -\u003e StateTransitionIter {\n            StateTransitionIter {\n                nxt_a: 0,\n                nxt_b: 0,\n                max: self.num_states(),\n            }\n        }\n\n        fn transition_prob(\u0026self, from: State, to: State) -\u003e LogProb {\n            self.transition[[*from, *to]]\n        }\n\n        fn initial_prob(\u0026self, state: State) -\u003e LogProb {\n            self.initial[[*state]]\n        }\n\n        fn observation_prob(\u0026self, state: State, observation: \u0026f64) -\u003e LogProb {\n            LogProb::from(Prob::from(self.observation[*state].pdf(*observation)))\n        }\n    }\n\n    /// Shortcut for HMM with emission values from a Gaussian distribution.\n    pub type GaussianModel = Model\u003cstatrs::distribution::Normal\u003e;\n}\n\n#[cfg(test)]\nmod tests {\n    use super::super::Prob;\n    use ndarray::array;\n    use statrs::distribution::Normal;\n\n    use super::discrete_emission::Model as DiscreteEmissionHMM;\n    use super::univariate_continuous_emission::GaussianModel as GaussianHMM;\n    use super::*;\n\n    #[test]\n    fn test_discrete_viterbi_toy_example() {\n        // We construct the toy example from Borodovsky \u0026 Ekisheva (2006), pp. 80.\n        //\n        // http://cecas.clemson.edu/~ahoover/ece854/refs/Gonze-ViterbiAlgorithm.pdf\n        //\n        // States: 0=High GC content, 1=Low GC content\n        // Symbols: 0=A, 1=C, 2=G, 3=T\n        let transition = array![[0.5, 0.5], [0.4, 0.6]];\n        let observation = array![[0.2, 0.3, 0.3, 0.2], [0.3, 0.2, 0.2, 0.3]];\n        let initial = array![0.5, 0.5];\n\n        let hmm = DiscreteEmissionHMM::with_float(\u0026transition, \u0026observation, \u0026initial)\n            .expect(\"Dimensions should be consistent\");\n        let (path, log_prob) = viterbi(\u0026hmm, \u0026[2, 2, 1, 0, 1, 3, 2, 0, 0]);\n        let prob = Prob::from(log_prob);\n\n        let expected = vec![0, 0, 0, 1, 1, 1, 1, 1, 1]\n            .iter()\n            .map(|i| State(*i))\n            .collect::\u003cVec\u003cState\u003e\u003e();\n        assert_eq!(expected, path);\n        assert_relative_eq!(4.25e-8_f64, *prob, epsilon = 1e-9_f64);\n    }\n\n    #[test]\n    fn test_discrete_forward_toy_example() {\n        // Same toy example as above.\n        let transition = array![[0.5, 0.5], [0.4, 0.6]];\n        let observation = array![[0.2, 0.3, 0.3, 0.2], [0.3, 0.2, 0.2, 0.3]];\n        let initial = array![0.5, 0.5];\n\n        let hmm = DiscreteEmissionHMM::with_float(\u0026transition, \u0026observation, \u0026initial)\n            .expect(\"Dimensions should be consistent\");\n        let log_prob = forward(\u0026hmm, \u0026[2, 2, 1, 0]).1;\n        let prob = Prob::from(log_prob);\n\n        assert_relative_eq!(0.0038432_f64, *prob, epsilon = 0.0001);\n    }\n\n    #[test]\n    fn test_discrete_backward_toy_example() {\n        // Same toy example as above.\n        let transition = array![[0.5, 0.5], [0.4, 0.6]];\n        let observation = array![[0.2, 0.3, 0.3, 0.2], [0.3, 0.2, 0.2, 0.3]];\n        let initial = array![0.5, 0.5];\n\n        let hmm = DiscreteEmissionHMM::with_float(\u0026transition, \u0026observation, \u0026initial)\n            .expect(\"Dimensions should be consistent\");\n        let log_prob = backward(\u0026hmm, \u0026[2, 2, 1, 0]).1;\n        let prob = Prob::from(log_prob);\n\n        assert_relative_eq!(0.0038432_f64, *prob, epsilon = 0.0001);\n    }\n\n    #[test]\n    fn test_discrete_forward_equals_backward_toy_example() {\n        // Same toy example as above.\n        let transition = array![[0.5, 0.5], [0.4, 0.6]];\n        let observation = array![[0.2, 0.3, 0.3, 0.2], [0.3, 0.2, 0.2, 0.3]];\n        let initial = array![0.5, 0.5];\n        let hmm = DiscreteEmissionHMM::with_float(\u0026transition, \u0026observation, \u0026initial)\n            .expect(\"Dimensions should be consistent\");\n\n        for len in 1..10 {\n            let mut seq: Vec\u003cusize\u003e = vec![0; len];\n            while seq.iter().sum::\u003cusize\u003e() != len {\n                for i in 0..len {\n                    if seq[i] == 0 {\n                        seq[i] = 1;\n                        break;\n                    } else {\n                        seq[i] = 0;\n                    }\n                }\n\n                let prob_fwd = *Prob::from(forward(\u0026hmm, \u0026seq).1);\n                let prob_bck = *Prob::from(backward(\u0026hmm, \u0026seq).1);\n                assert_relative_eq!(prob_fwd, prob_bck, epsilon = 0.00001);\n            }\n        }\n    }\n\n    #[test]\n    fn test_gaussian_viterbi_simple_example() {\n        let transition = array![[0.5, 0.5], [0.4, 0.6]];\n        let observation = vec![\n            Normal::new(0.0, 1.0).unwrap(),\n            Normal::new(2.0, 1.0).unwrap(),\n        ];\n        let initial = array![0.5, 0.5];\n\n        let hmm = GaussianHMM::with_float(\u0026transition, observation, \u0026initial)\n            .expect(\"Dimensions should be consistent\");\n        let (path, log_prob) = viterbi(\u0026hmm, \u0026[-0.1, 0.1, -0.2, 0.5, 0.8, 1.1, 1.2, 1.5, 0.5, 0.2]);\n        let prob = Prob::from(log_prob);\n\n        let expected = vec![0, 0, 0, 0, 0, 1, 1, 1, 0, 0]\n            .iter()\n            .map(|i| State(*i))\n            .collect::\u003cVec\u003cState\u003e\u003e();\n        assert_eq!(expected, path);\n        assert_relative_eq!(2.64e-8_f64, *prob, epsilon = 1e-9_f64);\n    }\n\n    #[test]\n    fn test_gaussian_forward_simple_example() {\n        let transition = array![[0.5, 0.5], [0.4, 0.6]];\n        let observation = vec![\n            Normal::new(0.0, 1.0).unwrap(),\n            Normal::new(2.0, 1.0).unwrap(),\n        ];\n        let initial = array![0.5, 0.5];\n\n        let hmm = GaussianHMM::with_float(\u0026transition, observation, \u0026initial)\n            .expect(\"Dimensions should be consistent\");\n        let log_prob = forward(\u0026hmm, \u0026[0.1, 1.5, 1.8, 2.2, 0.5]).1;\n        let prob = Prob::from(log_prob);\n\n        assert_relative_eq!(7.820e-4_f64, *prob, epsilon = 1e-5_f64);\n    }\n\n    #[test]\n    fn test_gaussian_backward_simple_example() {\n        let transition = array![[0.5, 0.5], [0.4, 0.6]];\n        let observation = vec![\n            Normal::new(0.0, 1.0).unwrap(),\n            Normal::new(2.0, 1.0).unwrap(),\n        ];\n        let initial = array![0.5, 0.5];\n\n        let hmm = GaussianHMM::with_float(\u0026transition, observation, \u0026initial)\n            .expect(\"Dimensions should be consistent\");\n        let log_prob = backward(\u0026hmm, \u0026[0.1, 1.5, 1.8, 2.2, 0.5]).1;\n        let prob = Prob::from(log_prob);\n\n        assert_relative_eq!(7.820e-4_f64, *prob, epsilon = 1e-5_f64);\n    }\n\n    #[test]\n    fn test_gaussian_forward_equals_backward_simple_example() {\n        let transition = array![[0.5, 0.5], [0.4, 0.6]];\n        let observation = vec![\n            Normal::new(0.0, 1.0).unwrap(),\n            Normal::new(2.0, 1.0).unwrap(),\n        ];\n        let initial = array![0.5, 0.5];\n        let hmm = GaussianHMM::with_float(\u0026transition, observation, \u0026initial)\n            .expect(\"Dimensions should be consistent\");\n\n        let seqs = vec![vec![0.1, 0.5, 1.0, 1.5, 1.8, 2.1]];\n        for seq in \u0026seqs {\n            let prob_fwd = *Prob::from(forward(\u0026hmm, \u0026seq).1);\n            let prob_bck = *Prob::from(backward(\u0026hmm, \u0026seq).1);\n            assert_relative_eq!(prob_fwd, prob_bck, epsilon = 0.00001);\n        }\n    }\n}\n","traces":[{"line":98,"address":[5197453,5197501,5197571,5197614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[5195408],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":120,"address":[5195456],"length":1,"stats":{"Line":2},"fn_name":"next"},{"line":121,"address":[5195470,5195569,5195488],"length":1,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[5195495],"length":1,"stats":{"Line":3},"fn_name":null},{"line":123,"address":[5195571,5195508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[5195545],"length":1,"stats":{"Line":3},"fn_name":null},{"line":126,"address":[5195479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[5195616],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":156,"address":[5195664],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":168,"address":[5195696],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":169,"address":[5195726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[5195743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[5195759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[5195797,5195879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[5195841,5195924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[5196124,5195774,5196119,5195964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[5195971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[5196059,5195979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[5196104,5196021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[5195957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[5251056],"length":1,"stats":{"Line":2},"fn_name":"transition_prob_idx\u003cbio::stats::hmm::discrete_emission::Model,usize\u003e"},{"line":220,"address":[5251080],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[4459219,4456662,4456647,4459234,4456672,4454096],"length":1,"stats":{"Line":2},"fn_name":"viterbi_matrices\u003cusize,bio::stats::hmm::discrete_emission::Model\u003e"},{"line":236,"address":[4456757,4454181],"length":1,"stats":{"Line":2},"fn_name":null},{"line":238,"address":[4454293,4454397,4456869,4456973],"length":1,"stats":{"Line":4},"fn_name":null},{"line":241,"address":[4457437,4454568,4456110,4454865,4457144,4457036,4454460,4458682],"length":1,"stats":{"Line":8},"fn_name":null},{"line":242,"address":[4457509,4457762,4458828,4454937,4455190,4456256],"length":1,"stats":{"Line":6},"fn_name":null},{"line":244,"address":[4456261,4458833,4456642,4454948,4456131,4458703,4459214,4457520],"length":1,"stats":{"Line":8},"fn_name":null},{"line":245,"address":[4456293,4458865],"length":1,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[4456504,4459076],"length":1,"stats":{"Line":2},"fn_name":null},{"line":250,"address":[4455195,4457767,4457560,4458677,4454988,4456105],"length":1,"stats":{"Line":6},"fn_name":null},{"line":251,"address":[4458042,4455353,4455470,4457846,4455274,4457925],"length":1,"stats":{"Line":6},"fn_name":null},{"line":252,"address":[4457877,4455227,4457799,4455305],"length":1,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[4459312,4459267,4459248,4459331],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}\u003cusize,bio::stats::hmm::discrete_emission::Model\u003e"},{"line":256,"address":[4457986,4459412,4455414,4459860,4459376,4459824],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}\u003cf64,bio::stats::hmm::univariate_continuous_emission::Model\u003cstatrs::distribution::normal::Normal\u003e\u003e"},{"line":257,"address":[4459914,4459466],"length":1,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[4459992,4459544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[4460013,4459592,4459565,4459976,4460040,4459528],"length":1,"stats":{"Line":4},"fn_name":null},{"line":260,"address":[4459587,4460035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[4459598,4459667,4460019,4459571,4460046,4460115],"length":1,"stats":{"Line":4},"fn_name":null},{"line":262,"address":[4459662,4460110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[4460129,4459681,4460219,4460062,4459771,4459614],"length":1,"stats":{"Line":6},"fn_name":null},{"line":265,"address":[4459702,4460150],"length":1,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[4460272,4460350,4460336,4460286],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}\u003cf64,bio::stats::hmm::univariate_continuous_emission::Model\u003cstatrs::distribution::normal::Normal\u003e\u003e"},{"line":271,"address":[4455780,4458352],"length":1,"stats":{"Line":2},"fn_name":null},{"line":272,"address":[4458178,4455606],"length":1,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[4458507,4455935],"length":1,"stats":{"Line":2},"fn_name":null},{"line":278,"address":[4457313,4454741],"length":1,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[5196128,5197403],"length":1,"stats":{"Line":1},"fn_name":"viterbi_traceback"},{"line":283,"address":[5196166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[5196212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[5196269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[5196281],"length":1,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[5196314,5196394,5196591,5197239],"length":1,"stats":{"Line":4},"fn_name":null},{"line":288,"address":[5197234,5196852],"length":1,"stats":{"Line":2},"fn_name":null},{"line":289,"address":[5196858,5197083],"length":1,"stats":{"Line":2},"fn_name":null},{"line":292,"address":[5146638,5146624],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":294,"address":[5197213],"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[5197221],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[5196898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[5197037],"length":1,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[5196553,5197254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":303,"address":[5197275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":323,"address":[4460893,4460928,4461357,4460464],"length":1,"stats":{"Line":2},"fn_name":"viterbi\u003cusize,bio::stats::hmm::discrete_emission::Model\u003e"},{"line":324,"address":[4460968,4460504],"length":1,"stats":{"Line":2},"fn_name":null},{"line":325,"address":[4461124,4460660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":346,"address":[4463382,4463397,4461392,4465394,4465409,4463408],"length":1,"stats":{"Line":2},"fn_name":"forward\u003cusize,bio::stats::hmm::discrete_emission::Model\u003e"},{"line":348,"address":[4461477,4463493],"length":1,"stats":{"Line":2},"fn_name":null},{"line":351,"address":[4463605,4463923,4462714,4464726,4461589,4461697,4463713,4461911],"length":1,"stats":{"Line":8},"fn_name":null},{"line":352,"address":[4464240,4462860,4463987,4461975,4464872,4462228],"length":1,"stats":{"Line":6},"fn_name":null},{"line":354,"address":[4463100,4462735,4464747,4463998,4461986,4465112,4464877,4462865],"length":1,"stats":{"Line":8},"fn_name":null},{"line":355,"address":[4464909,4462897],"length":1,"stats":{"Line":2},"fn_name":null},{"line":359,"address":[4462233,4464038,4464721,4462709,4462026,4464245],"length":1,"stats":{"Line":6},"fn_name":null},{"line":360,"address":[4462265,4464426,4462414,4464277],"length":1,"stats":{"Line":4},"fn_name":null},{"line":362,"address":[4464338,4465424,4465728,4462326],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}\u003cusize,bio::stats::hmm::discrete_emission::Model\u003e"},{"line":363,"address":[4465949,4466009,4465705,4465443,4465645,4465747],"length":1,"stats":{"Line":6},"fn_name":null},{"line":364,"address":[4465900,4465596],"length":1,"stats":{"Line":2},"fn_name":null},{"line":365,"address":[4465965,4465661],"length":1,"stats":{"Line":2},"fn_name":null},{"line":368,"address":[4462553,4462452,4464565,4464464],"length":1,"stats":{"Line":4},"fn_name":null},{"line":374,"address":[4461886,4463113,4465125,4463898],"length":1,"stats":{"Line":4},"fn_name":null},{"line":376,"address":[4463296,4465308],"length":1,"stats":{"Line":2},"fn_name":null},{"line":397,"address":[4468633,4468640,4468618,4471226,4466032,4471241],"length":1,"stats":{"Line":2},"fn_name":"backward\u003cf64,bio::stats::hmm::univariate_continuous_emission::Model\u003cstatrs::distribution::normal::Normal\u003e\u003e"},{"line":399,"address":[4468725,4466117],"length":1,"stats":{"Line":2},"fn_name":null},{"line":402,"address":[4468837,4466229],"length":1,"stats":{"Line":2},"fn_name":null},{"line":403,"address":[4468980,4467705,4466642,4466372,4466283,4468891,4469250,4470313],"length":1,"stats":{"Line":8},"fn_name":null},{"line":404,"address":[4469567,4470483,4466959,4467875,4466706,4469314],"length":1,"stats":{"Line":6},"fn_name":null},{"line":405,"address":[4467896,4468332,4466717,4469325,4467726,4470504,4470940,4470334],"length":1,"stats":{"Line":8},"fn_name":null},{"line":406,"address":[4467928,4470536],"length":1,"stats":{"Line":2},"fn_name":null},{"line":407,"address":[4468056,4470664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":409,"address":[4468119,4470727,4468043,4470651],"length":1,"stats":{"Line":4},"fn_name":null},{"line":411,"address":[4470738,4470708,4468100,4468130],"length":1,"stats":{"Line":4},"fn_name":null},{"line":415,"address":[4466980,4469588,4470308,4466757,4469365,4467700],"length":1,"stats":{"Line":6},"fn_name":null},{"line":416,"address":[4467012,4469620],"length":1,"stats":{"Line":2},"fn_name":null},{"line":417,"address":[4467148,4469756],"length":1,"stats":{"Line":2},"fn_name":null},{"line":419,"address":[4467132,4469740,4467244,4469852],"length":1,"stats":{"Line":4},"fn_name":null},{"line":421,"address":[4467399,4470007,4467198,4469806],"length":1,"stats":{"Line":4},"fn_name":null},{"line":423,"address":[4467279,4469887,4471248,4471696],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}\u003cf64,bio::stats::hmm::univariate_continuous_emission::Model\u003cstatrs::distribution::normal::Normal\u003e\u003e"},{"line":424,"address":[4471633,4471273,4472021,4472081,4471573,4472111,4471663,4471721],"length":1,"stats":{"Line":8},"fn_name":null},{"line":425,"address":[4471438,4471886],"length":1,"stats":{"Line":2},"fn_name":null},{"line":426,"address":[4472037,4471589],"length":1,"stats":{"Line":2},"fn_name":null},{"line":427,"address":[4471655,4472103],"length":1,"stats":{"Line":2},"fn_name":null},{"line":430,"address":[4467538,4470146,4467437,4470045],"length":1,"stats":{"Line":4},"fn_name":null},{"line":436,"address":[4466617,4468345,4470953,4469225],"length":1,"stats":{"Line":5},"fn_name":null},{"line":438,"address":[4471139,4468531],"length":1,"stats":{"Line":3},"fn_name":null},{"line":469,"address":[5270848,5271728],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":474,"address":[5270888],"length":1,"stats":{"Line":3},"fn_name":null},{"line":475,"address":[5271010,5271087],"length":1,"stats":{"Line":4},"fn_name":null},{"line":476,"address":[5271119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[5271161,5271197,5271484],"length":1,"stats":{"Line":7},"fn_name":null},{"line":479,"address":[5271516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[5271356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[5271268],"length":1,"stats":{"Line":3},"fn_name":null},{"line":489,"address":[5271299],"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[5271330],"length":1,"stats":{"Line":3},"fn_name":null},{"line":497,"address":[5272102,5271792],"length":1,"stats":{"Line":0},"fn_name":"with_prob"},{"line":503,"address":[5251118,5251104],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":504,"address":[5251152,5251166],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":505,"address":[5251214,5251200],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":511,"address":[5272144,5272454],"length":1,"stats":{"Line":1},"fn_name":"with_float"},{"line":517,"address":[5251248,5251262],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":518,"address":[5251312,5251326],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":519,"address":[5251390,5251376],"length":1,"stats":{"Line":7},"fn_name":"{{closure}}"},{"line":525,"address":[5272496],"length":1,"stats":{"Line":1},"fn_name":"num_states"},{"line":526,"address":[5272505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":529,"address":[5272528],"length":1,"stats":{"Line":1},"fn_name":"states"},{"line":532,"address":[5272537],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[5272592],"length":1,"stats":{"Line":0},"fn_name":"transitions"},{"line":540,"address":[5272622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[5272672],"length":1,"stats":{"Line":1},"fn_name":"transition_prob"},{"line":545,"address":[5272696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":548,"address":[5272816],"length":1,"stats":{"Line":1},"fn_name":"initial_prob"},{"line":549,"address":[5272830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[5272928],"length":1,"stats":{"Line":2},"fn_name":"observation_prob"},{"line":553,"address":[5272952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":656,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":684,"address":[9183973,9183968],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":691,"address":[9471150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":692,"address":[9471332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":693,"address":[9471564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":695,"address":[9471708],"length":1,"stats":{"Line":1},"fn_name":null},{"line":697,"address":[9471797],"length":1,"stats":{"Line":1},"fn_name":null},{"line":698,"address":[9471947,9471882],"length":1,"stats":{"Line":2},"fn_name":null},{"line":700,"address":[9472264,9472117,9471966],"length":1,"stats":{"Line":3},"fn_name":null},{"line":702,"address":[9184014,9184000],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":704,"address":[9472534,9472351,9472486],"length":1,"stats":{"Line":2},"fn_name":null},{"line":705,"address":[9472500,9472588,9472808],"length":1,"stats":{"Line":2},"fn_name":null},{"line":709,"address":[9184032,9184037],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":711,"address":[9473758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":712,"address":[9473940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":713,"address":[9474172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":715,"address":[9474316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":717,"address":[9474405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":718,"address":[9474531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":720,"address":[9474573,9474819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":724,"address":[9184069,9184064],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":726,"address":[9475742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":727,"address":[9475924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":728,"address":[9476156],"length":1,"stats":{"Line":1},"fn_name":null},{"line":730,"address":[9476300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":732,"address":[9476389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":733,"address":[9476515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":735,"address":[9476557,9476803],"length":1,"stats":{"Line":1},"fn_name":null},{"line":739,"address":[9184096,9184101],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":741,"address":[9477726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":742,"address":[9477908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":743,"address":[9478140],"length":1,"stats":{"Line":1},"fn_name":null},{"line":744,"address":[9478284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":747,"address":[9478373,9478630,9480812,9478520],"length":1,"stats":{"Line":4},"fn_name":null},{"line":748,"address":[9478670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":749,"address":[9478840,9478693,9479984],"length":1,"stats":{"Line":3},"fn_name":null},{"line":750,"address":[9479107,9479303,9478909],"length":1,"stats":{"Line":3},"fn_name":null},{"line":751,"address":[9479147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":752,"address":[9479206,9479316],"length":1,"stats":{"Line":2},"fn_name":null},{"line":755,"address":[9479251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":759,"address":[9479323],"length":1,"stats":{"Line":1},"fn_name":null},{"line":760,"address":[9479548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":761,"address":[9479989,9479781],"length":1,"stats":{"Line":1},"fn_name":null},{"line":767,"address":[9184133,9184128],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":768,"address":[9480910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":769,"address":[9481381,9481438,9481194,9481100],"length":1,"stats":{"Line":3},"fn_name":null},{"line":770,"address":[9481116],"length":1,"stats":{"Line":1},"fn_name":null},{"line":771,"address":[9481262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":773,"address":[9481456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":775,"address":[9481591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":777,"address":[9481752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":778,"address":[9481902,9481837],"length":1,"stats":{"Line":2},"fn_name":null},{"line":780,"address":[9482080,9482227,9481921],"length":1,"stats":{"Line":3},"fn_name":null},{"line":782,"address":[9184174,9184160],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":784,"address":[9482497,9482314,9482449],"length":1,"stats":{"Line":2},"fn_name":null},{"line":785,"address":[9482463,9482551,9482771],"length":1,"stats":{"Line":2},"fn_name":null},{"line":789,"address":[9184197,9184192],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":790,"address":[9483742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":791,"address":[9484026,9484270,9483932,9484213],"length":1,"stats":{"Line":3},"fn_name":null},{"line":792,"address":[9483948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":793,"address":[9484094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":795,"address":[9484288],"length":1,"stats":{"Line":1},"fn_name":null},{"line":797,"address":[9484423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":799,"address":[9484584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":800,"address":[9484710],"length":1,"stats":{"Line":1},"fn_name":null},{"line":802,"address":[9484998,9484752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":806,"address":[9184229,9184224],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":807,"address":[9485934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":808,"address":[9486462,9486124,9486218,9486405],"length":1,"stats":{"Line":3},"fn_name":null},{"line":809,"address":[9486140],"length":1,"stats":{"Line":1},"fn_name":null},{"line":810,"address":[9486286],"length":1,"stats":{"Line":1},"fn_name":null},{"line":812,"address":[9486480],"length":1,"stats":{"Line":1},"fn_name":null},{"line":814,"address":[9486615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":816,"address":[9486776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":817,"address":[9486902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":819,"address":[9486944,9487190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":823,"address":[9184261,9184256],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":824,"address":[9488126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":825,"address":[9488316,9488410,9488654,9488597],"length":1,"stats":{"Line":3},"fn_name":null},{"line":826,"address":[9488332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":827,"address":[9488478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":829,"address":[9488672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":830,"address":[9488807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":833,"address":[9488986],"length":1,"stats":{"Line":1},"fn_name":null},{"line":834,"address":[9489448,9489241,9489371,9490141],"length":1,"stats":{"Line":4},"fn_name":null},{"line":835,"address":[9489480],"length":1,"stats":{"Line":1},"fn_name":null},{"line":836,"address":[9489705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":837,"address":[9489938,9490146],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":221,"coverable":262},{"path":["/","home","todd","rust-bio","src","stats","mod.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Mathematical and statistical tools.\n\npub mod bayesian;\npub mod combinatorics;\npub mod hmm;\npub mod pairhmm;\npub mod probs;\n\npub use crate::stats::probs::{LogProb, PHREDProb, Prob};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","stats","pairhmm","homopolypairhmm.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Copyright 2020 Till Hartmann.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A pair Hidden Markov Model for calculating the probability that two sequences are related to\n//! each other. Depending on the used parameters, this can, e.g., be used to calculate the\n//! probability that a certain sequencing read comes from a given position in a reference genome.\n//! In contrast to `PairHMM`, this `HomopolyPairHMM` takes into account homopolymer errors as\n//! often encountered e.g. in Oxford Nanopore Technologies sequencing.\n//!\n//! Time complexity: O(n * m) where `n = seq1.len()`, `m = seq2.len()` (or `m = min(seq2.len(), max_edit_dist)` with banding enabled).\n//! Memory complexity: O(m) where `m = seq2.len()`.\n//! Note that if the number of states weren't fixed in this implementation, we would have to include\n//! these in both time and memory complexity above as an additional factor.\n//!\n//! The `HomopolyPairHMM` introduces the term \"hop\" for starting and extending homopolymer runs\n//! by analogy with \"gap\". Therefore, the constructor needs an additional parameter `hop_params`\n//! implementing `HopParameters`. Also, the emission parameter needs to implement `Emission`,\n//! since this HMM model needs to be able to distinguish the four different match states for\n//! A, C, G and T (see Details below).\n//!\n//! # Details\n//! The HomopolyPairHMM defined in this module has one Match state for each character from [A, C, G, T],\n//! for each of those Match states two corresponding Hop (homopolymer run) states\n//! (one for a run in sequence `x`, one for a run in `y`),\n//! as well as the usual GapX and GapY states.\n//!\n//! In states `MatchV` (where `V` ∈ `{A, C, G, T}`), the probability to emit anything other than\n//! `(V, V)`, `(V, y != V)`, `(x != V, y)` should be zero.\n//!\n//! State `HopVZ` (where `V` ∈ `{A, C, G, T}`, `Z` ∈ `{X, Y}`) can only be transitioned to from\n//! corresponding state `MatchV`.\n//!\n//! The transition matrix is given below:\n//!     | MA | MC | MG | MT | HAX | HAY | HCX | HCY | HGX | HGY | HTX | HTY | GX | GY\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! MA  |  x |  x |  x |  x |  x  |  x  |     |     |     |     |     |     |  x |  x\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! MC  |  x |  x |  x |  x |     |     |  x  |  x  |     |     |     |     |  x |  x\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! MG  |  x |  x |  x |  x |     |     |     |     |  x  |  x  |     |     |  x |  x\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! MT  |  x |  x |  x |  x |     |     |     |     |     |     |  x  |  x  |  x |  x\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! HAX |  x |  x |  x |  x |  x  |     |     |     |     |     |     |     |    |\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! HAY |  x |  x |  x |  x |     |  x  |     |     |     |     |     |     |    |\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! HCX |  x |  x |  x |  x |     |     |  x  |     |     |     |     |     |    |\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! HCY |  x |  x |  x |  x |     |     |     |  x  |     |     |     |     |    |\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! HGX |  x |  x |  x |  x |     |     |     |     |  x  |     |     |     |    |\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! HGY |  x |  x |  x |  x |     |     |     |     |     |  x  |     |     |    |\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! HTX |  x |  x |  x |  x |     |     |     |     |     |     |  x  |     |    |\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! HTY |  x |  x |  x |  x |     |     |     |     |     |     |     |  x  |    |\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! GX  |  x |  x |  x |  x |     |     |     |     |     |     |     |     |  x |\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! GY  |  x |  x |  x |  x |     |     |     |     |     |     |     |     |    |  x\n\nuse std::cmp;\nuse std::fmt::Debug;\nuse std::iter::once;\nuse std::mem;\nuse std::ops::Shr;\nuse std::usize;\n\nuse enum_map::{Enum, EnumMap};\nuse itertools::Itertools;\nuse num_traits::Zero;\n\nuse crate::stats::pairhmm::homopolypairhmm::State::*;\nuse crate::stats::pairhmm::{\n    Emission, EmissionParameters, GapParameters, StartEndGapParameters, XYEmission,\n};\nuse crate::stats::probs::LogProb;\nuse crate::stats::Prob;\nuse std::collections::HashMap;\n\n#[derive(Eq, PartialEq, Debug, Enum, Clone, Copy)]\n#[repr(usize)]\npub enum State {\n    MatchA = 0,\n    MatchC = 1,\n    MatchG = 2,\n    MatchT = 3,\n    GapX = 4,\n    GapY = 5,\n    HopAX = 6,\n    HopAY = 7,\n    HopCX = 8,\n    HopCY = 9,\n    HopGX = 10,\n    HopGY = 11,\n    HopTX = 12,\n    HopTY = 13,\n}\n\nimpl State {\n    fn supports(\u0026self, x: u8, y: u8) -\u003e bool {\n        match self {\n            MatchA if x == b'A' || y == b'A' =\u003e true,\n            MatchC if x == b'C' || y == b'C' =\u003e true,\n            MatchG if x == b'G' || y == b'G' =\u003e true,\n            MatchT if x == b'T' || y == b'T' =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\nconst STATES: [State; 14] = [\n    MatchA, MatchC, MatchG, MatchT, GapX, GapY, HopAX, HopAY, HopCX, HopCY, HopGX, HopGY, HopTX,\n    HopTY,\n];\n\nconst MATCH_STATES: [State; 4] = [MatchA, MatchC, MatchG, MatchT];\nconst HOP_X_STATES: [State; 4] = [HopAX, HopCX, HopGX, HopTX];\nconst HOP_Y_STATES: [State; 4] = [HopAY, HopCY, HopGY, HopTY];\n\n// We define Shr (\u003e\u003e) for `State` such that a transition from State `a` to State `b` can be modeled\n// as `a \u003e\u003e b`, where `a \u003e\u003e b` is an integer in `0..(1 \u003c\u003c (2 * NUM_STATES)) - 1]` used for indexing\n// the transition table (see `build_transition_table`).\nimpl Shr for State {\n    type Output = usize;\n\n    fn shr(self, rhs: State) -\u003e Self::Output {\n        let a = self as u32;\n        let b = rhs as u32;\n        interleave_bits(a, b) as usize\n    }\n}\n\nfn space_bits(a: u32) -\u003e u64 {\n    let mut x = a as u64 \u0026 0x0000_0000_FFFF_FFFF;\n    x = (x | (x \u003c\u003c 16)) \u0026 0x0000_FFFF_0000_FFFF;\n    x = (x | (x \u003c\u003c 8)) \u0026 0x00FF_00FF_00FF_00FF;\n    x = (x | (x \u003c\u003c 4)) \u0026 0x0F0F_0F0F_0F0F_0F0F;\n    x = (x | (x \u003c\u003c 2)) \u0026 0x3333_3333_3333_3333;\n    x = (x | (x \u003c\u003c 1)) \u0026 0x5555_5555_5555_5555;\n    x\n}\n\nfn interleave_bits(a: u32, b: u32) -\u003e u64 {\n    space_bits(a) \u003c\u003c 1 | space_bits(b)\n}\n\n/// Trait for parametrization of `PairHMM` hop behavior.\npub trait HopParameters {\n    /// Probability to start hop in x.\n    fn prob_hop_x(\u0026self) -\u003e LogProb;\n\n    /// Probability to start hop in y.\n    fn prob_hop_y(\u0026self) -\u003e LogProb;\n\n    /// Probability to extend hop in x.\n    fn prob_hop_x_extend(\u0026self) -\u003e LogProb;\n\n    /// Probability to extend hop in y.\n    fn prob_hop_y_extend(\u0026self) -\u003e LogProb;\n}\n\n/// A pair Hidden Markov Model for comparing sequences x and y as described by\n/// Durbin, R., Eddy, S., Krogh, A., \u0026 Mitchison, G. (1998). Biological Sequence Analysis.\n/// Current Topics in Genome Analysis 2008. http://doi.org/10.1017/CBO9780511790492.\n/// The default model has been extended to consider homopolymer errors, at the cost of more states\n/// and transitions.\n#[derive(Debug, Clone)]\npub struct HomopolyPairHMM {\n    transition_probs: HashMap\u003cusize, LogProb\u003e,\n}\n\nimpl HomopolyPairHMM {\n    /// Create a new instance of a HomopolyPairHMM.\n    /// # Arguments\n    ///\n    /// * `gap_params` - parameters for opening or extending gaps\n    /// * `hop_params` - parameters for opening or extending hops\n    pub fn new\u003cG, H\u003e(gap_params: \u0026G, hop_params: \u0026H) -\u003e Self\n    where\n        G: GapParameters,\n        H: HopParameters,\n    {\n        Self {\n            transition_probs: build_transition_table(gap_params, hop_params),\n        }\n    }\n\n    /// Calculate the probability of sequence x being related to y via any alignment.\n    ///\n    /// # Arguments\n    ///\n    /// * `emission_params` - parameters for emission\n    /// * `alignment_mode` - parameters for free end/start gaps\n    /// * `max_edit_dist` - maximum edit distance to consider; if not `None`, perform banded alignment\n    pub fn prob_related\u003cE, A\u003e(\n        \u0026self,\n        emission_params: \u0026E,\n        alignment_mode: \u0026A,\n        max_edit_dist: Option\u003cusize\u003e,\n    ) -\u003e LogProb\n    where\n        E: EmissionParameters + Emission,\n        A: StartEndGapParameters,\n    {\n        let mut prev = 0;\n        let mut curr = 1;\n        let mut v: [EnumMap\u003cState, Vec\u003cLogProb\u003e\u003e; 2] = [EnumMap::new(), EnumMap::new()];\n        let transition_probs = \u0026self.transition_probs;\n\n        let len_y = emission_params.len_y();\n        let len_x = emission_params.len_x();\n        let mut min_edit_dist: [Vec\u003cusize\u003e; 2] =\n            [vec![usize::MAX; len_y + 1], vec![usize::MAX; len_y + 1]];\n        let free_end_gap_x = alignment_mode.free_end_gap_x();\n        let free_start_gap_x = alignment_mode.free_start_gap_x();\n\n        let mut prob_cols = Vec::with_capacity(len_x * STATES.len());\n\n        for state in \u0026STATES {\n            v[prev][*state] = vec![LogProb::zero(); len_y + 1];\n        }\n\n        v[curr] = v[prev].clone();\n\n        for \u0026m in \u0026MATCH_STATES {\n            v[prev][m][0] = LogProb::from(Prob(1. / 4.));\n        }\n\n        for i in 0..len_x {\n            if free_start_gap_x {\n                let prob_start_gap_x = LogProb(*alignment_mode.prob_start_gap_x(i) - 4f64.ln());\n                for \u0026m in \u0026MATCH_STATES {\n                    v[prev][m][0] = v[prev][m][0].ln_add_exp(prob_start_gap_x);\n                }\n                min_edit_dist[prev][0] = 0;\n            }\n\n            // cache probs for x[i]\n            let prob_emit_x_and_gap = emission_params.prob_emit_x(i);\n            let emission_x = emission_params.emission_x(i);\n\n            for j in 0..len_y {\n                let j_ = j + 1;\n                let j_minus_one = j_ - 1;\n\n                let min_edit_dist_topleft = min_edit_dist[prev][j_minus_one];\n                let min_edit_dist_top = min_edit_dist[curr][j_minus_one];\n                let min_edit_dist_left = min_edit_dist[prev][j_];\n\n                if let Some(max_edit_dist) = max_edit_dist {\n                    if min3(min_edit_dist_topleft, min_edit_dist_top, min_edit_dist_left)\n                        \u003e max_edit_dist\n                    {\n                        // skip this cell if best edit dist is already larger than given maximum\n                        continue;\n                    }\n                }\n\n                let emission_y = emission_params.emission_y(j);\n                let mut any_match = false;\n                for \u0026m in \u0026MATCH_STATES {\n                    if m.supports(emission_x, emission_y) {\n                        let emission = emission_params.prob_emit_xy(i, j);\n                        let emission_prob = match emission {\n                            XYEmission::Match(p) =\u003e p,\n                            // since we have separate match states, we need to halve mismatch probs\n                            // (since e.g. ('A', _) and (_, 'A') are distinct cases)\n                            XYEmission::Mismatch(p) =\u003e LogProb::from(*p - 2f64.ln()),\n                        };\n                        any_match |= emission.is_match();\n                        v[curr][m][j_] = emission_prob\n                            + LogProb::ln_sum_exp(\n                                \u0026STATES\n                                    .iter()\n                                    .map(|\u0026s| {\n                                        transition_probs.get(\u0026(s \u003e\u003e m)).unwrap_or(\u0026LogProb::zero())\n                                            + v[prev][s][j_minus_one]\n                                    })\n                                    .collect_vec(),\n                            );\n                    } else {\n                        v[curr][m][j_] = LogProb::zero();\n                    }\n                }\n\n                v[curr][GapY][j_] = prob_emit_x_and_gap\n                    + LogProb::ln_sum_exp(\n                        \u0026MATCH_STATES\n                            .iter()\n                            .map(|\u0026s| transition_probs[\u0026(s \u003e\u003e GapY)] + v[prev][s][j_])\n                            .chain(once(transition_probs[\u0026(GapY \u003e\u003e GapY)] + v[prev][GapY][j_]))\n                            .collect_vec(),\n                    );\n\n                MATCH_HOP_Y.iter().for_each(|\u0026(m, h)| {\n                    v[curr][h][j_] = (transition_probs[\u0026(m \u003e\u003e h)] + v[prev][m][j_])\n                        .ln_add_exp(transition_probs[\u0026(h \u003e\u003e h)] + v[prev][h][j_])\n                });\n\n                v[curr][GapX][j_] = emission_params.prob_emit_y(j)\n                    + LogProb::ln_sum_exp(\n                        \u0026MATCH_STATES\n                            .iter()\n                            .map(|\u0026s| transition_probs[\u0026(s \u003e\u003e GapX)] + v[curr][s][j_minus_one])\n                            .chain(once(\n                                transition_probs[\u0026(GapX \u003e\u003e GapX)] + v[curr][GapX][j_minus_one],\n                            ))\n                            .collect_vec(),\n                    );\n\n                MATCH_HOP_X.iter().for_each(|\u0026(m, h)| {\n                    v[curr][h][j_] = (transition_probs[\u0026(m \u003e\u003e h)] + v[curr][m][j_minus_one])\n                        .ln_add_exp(transition_probs[\u0026(h \u003e\u003e h)] + v[curr][h][j_minus_one])\n                });\n\n                // calculate minimal number of mismatches\n                if max_edit_dist.is_some() {\n                    min_edit_dist[curr][j_] = min3(\n                        if any_match {\n                            // a match, so nothing changes\n                            min_edit_dist_topleft\n                        } else {\n                            // one new mismatch\n                            min_edit_dist_topleft.saturating_add(1)\n                        },\n                        // gap or hop in y (no new mismatch)\n                        min_edit_dist_left.saturating_add(1),\n                        // gap or hop in x (no new mismatch)\n                        min_edit_dist_top.saturating_add(1),\n                    )\n                };\n\n                if free_end_gap_x {\n                    // Cache column probabilities or simply record the last probability.\n                    // We can put all of them in one array since we simply have to sum in the end.\n                    // This is also good for numerical stability.\n                    prob_cols.extend(MATCH_STATES.iter().map(|\u0026s| v[curr][s][len_y]));\n                    prob_cols.extend(HOP_Y_STATES.iter().map(|\u0026s| v[curr][s][len_y]));\n                    prob_cols.extend(HOP_X_STATES.iter().map(|\u0026s| v[curr][s][len_y]));\n                    prob_cols.push(v[curr][GapY][len_y]);\n                    // TODO check removing this (we don't want open gaps in x):\n                    prob_cols.push(v[curr][GapX][len_y]);\n                }\n            }\n            mem::swap(\u0026mut prev, \u0026mut curr);\n            for \u0026s in \u0026MATCH_STATES {\n                v[curr][s].reset(LogProb::zero());\n            }\n        }\n        let p = if free_end_gap_x {\n            LogProb::ln_sum_exp(\u0026prob_cols.iter().cloned().collect_vec())\n        } else {\n            LogProb::ln_sum_exp(\n                \u0026STATES\n                    .iter()\n                    .map(|\u0026state| v[prev][state][len_y])\n                    .collect_vec(),\n            )\n        };\n        // take the minimum with 1.0, because sum of paths can exceed probability 1.0\n        // especially in case of repeats\n        assert!(!p.is_nan());\n        if p \u003e LogProb::ln_one() {\n            LogProb::ln_one()\n        } else {\n            p\n        }\n    }\n}\n\n// explicitly defined groups of transitions between states\nconst MATCH_HOP_X: [(State, State); 4] = [\n    (MatchA, HopAX),\n    (MatchC, HopCX),\n    (MatchG, HopGX),\n    (MatchT, HopTX),\n];\nconst MATCH_HOP_Y: [(State, State); 4] = [\n    (MatchA, HopAY),\n    (MatchC, HopCY),\n    (MatchG, HopGY),\n    (MatchT, HopTY),\n];\nconst HOP_X_HOP_X: [(State, State); 4] = [\n    (HopAX, HopAX),\n    (HopCX, HopCX),\n    (HopGX, HopGX),\n    (HopTX, HopTX),\n];\nconst HOP_Y_HOP_Y: [(State, State); 4] = [\n    (HopAY, HopAY),\n    (HopCY, HopCY),\n    (HopGY, HopGY),\n    (HopTY, HopTY),\n];\nconst HOP_X_MATCH: [(State, State); 16] = [\n    (HopAX, MatchA),\n    (HopAX, MatchC),\n    (HopAX, MatchG),\n    (HopAX, MatchT),\n    (HopCX, MatchC),\n    (HopCX, MatchC),\n    (HopCX, MatchG),\n    (HopCX, MatchT),\n    (HopGX, MatchG),\n    (HopGX, MatchC),\n    (HopGX, MatchG),\n    (HopGX, MatchT),\n    (HopTX, MatchT),\n    (HopTX, MatchC),\n    (HopTX, MatchG),\n    (HopTX, MatchT),\n];\nconst HOP_Y_MATCH: [(State, State); 16] = [\n    (HopAY, MatchA),\n    (HopAY, MatchC),\n    (HopAY, MatchG),\n    (HopAY, MatchT),\n    (HopCY, MatchC),\n    (HopCY, MatchC),\n    (HopCY, MatchG),\n    (HopCY, MatchT),\n    (HopGY, MatchG),\n    (HopGY, MatchC),\n    (HopGY, MatchG),\n    (HopGY, MatchT),\n    (HopTY, MatchT),\n    (HopTY, MatchC),\n    (HopTY, MatchG),\n    (HopTY, MatchT),\n];\nconst MATCH_SAME_: [(State, State); 4] = [\n    (MatchA, MatchA),\n    (MatchC, MatchC),\n    (MatchG, MatchG),\n    (MatchT, MatchT),\n];\nconst MATCH_OTHER: [(State, State); 12] = [\n    (MatchA, MatchC),\n    (MatchA, MatchG),\n    (MatchA, MatchT),\n    (MatchC, MatchA),\n    (MatchC, MatchG),\n    (MatchC, MatchT),\n    (MatchG, MatchC),\n    (MatchG, MatchA),\n    (MatchG, MatchT),\n    (MatchT, MatchC),\n    (MatchT, MatchG),\n    (MatchT, MatchA),\n];\n\nfn build_transition_table\u003cG: GapParameters, H: HopParameters\u003e(\n    gap_params: \u0026G,\n    hop_params: \u0026H,\n) -\u003e HashMap\u003cusize, LogProb\u003e {\n    let mut transition_probs = HashMap::new();\n\n    let prob_hop_x = hop_params.prob_hop_x();\n    let prob_hop_y = hop_params.prob_hop_y();\n    let prob_hop_x_extend = hop_params.prob_hop_x_extend();\n    let prob_hop_y_extend = hop_params.prob_hop_y_extend();\n\n    let prob_gap_x = gap_params.prob_gap_x();\n    let prob_gap_y = gap_params.prob_gap_y();\n    let prob_gap_x_extend = gap_params.prob_gap_x_extend();\n    let prob_gap_y_extend = gap_params.prob_gap_y_extend();\n\n    MATCH_HOP_X.iter().for_each(|(a, b)| {\n        transition_probs.insert(*a \u003e\u003e *b, prob_hop_x);\n    });\n    MATCH_HOP_Y.iter().for_each(|(a, b)| {\n        transition_probs.insert(*a \u003e\u003e *b, prob_hop_y);\n    });\n    HOP_X_HOP_X.iter().for_each(|(a, b)| {\n        transition_probs.insert(*a \u003e\u003e *b, prob_hop_x_extend);\n    });\n    HOP_Y_HOP_Y.iter().for_each(|(a, b)| {\n        transition_probs.insert(*a \u003e\u003e *b, prob_hop_y_extend);\n    });\n    HOP_X_MATCH.iter().for_each(|(a, b)| {\n        transition_probs.insert(*a \u003e\u003e *b, prob_hop_x_extend.ln_one_minus_exp());\n    });\n    HOP_Y_MATCH.iter().for_each(|(a, b)| {\n        transition_probs.insert(*a \u003e\u003e *b, prob_hop_y_extend.ln_one_minus_exp());\n    });\n\n    let match_same =\n        LogProb::ln_sum_exp(\u0026[prob_gap_y, prob_gap_x, prob_hop_x, prob_hop_y]).ln_one_minus_exp();\n    let match_other =\n        LogProb::ln_sum_exp(\u0026[prob_gap_y, prob_gap_x, prob_hop_x, prob_hop_y]).ln_one_minus_exp();\n    MATCH_SAME_.iter().for_each(|(a, b)| {\n        transition_probs.insert(*a \u003e\u003e *b, match_same);\n    });\n    MATCH_OTHER.iter().for_each(|(a, b)| {\n        transition_probs.insert(*a \u003e\u003e *b, match_other);\n    });\n\n    MATCH_STATES.iter().for_each(|\u0026a| {\n        transition_probs.insert(a \u003e\u003e GapX, prob_gap_y);\n    });\n    MATCH_STATES.iter().for_each(|\u0026a| {\n        transition_probs.insert(a \u003e\u003e GapY, prob_gap_x);\n    });\n    MATCH_STATES.iter().for_each(|\u0026b| {\n        transition_probs.insert(GapX \u003e\u003e b, prob_gap_y_extend.ln_one_minus_exp());\n    });\n    MATCH_STATES.iter().for_each(|\u0026b| {\n        transition_probs.insert(GapY \u003e\u003e b, prob_gap_x_extend.ln_one_minus_exp());\n    });\n    transition_probs.insert(GapX \u003e\u003e GapX, prob_gap_y_extend);\n    transition_probs.insert(GapY \u003e\u003e GapY, prob_gap_x_extend);\n    transition_probs\n}\n\ntrait Reset\u003cT: Copy\u003e {\n    fn reset(\u0026mut self, value: T);\n}\n\nimpl\u003cT: Copy\u003e Reset\u003cT\u003e for [T] {\n    fn reset(\u0026mut self, value: T) {\n        for v in self {\n            *v = value;\n        }\n    }\n}\n\nfn min3\u003cT: Ord\u003e(a: T, b: T, c: T) -\u003e T {\n    cmp::min(a, cmp::min(b, c))\n}\n\n#[cfg(test)]\nmod tests {\n    use std::iter::repeat;\n\n    use crate::stats::pairhmm::homopolypairhmm::tests::AlignmentMode::{Global, Semiglobal};\n    use crate::stats::pairhmm::PairHMM;\n    use crate::stats::{LogProb, Prob};\n\n    use super::*;\n\n    // Single base insertion and deletion rates for R1 according to Schirmer et al.\n    // BMC Bioinformatics 2016, 10.1186/s12859-016-0976-y\n    static PROB_ILLUMINA_INS: Prob = Prob(2.8e-6);\n    static PROB_ILLUMINA_DEL: Prob = Prob(5.1e-6);\n    static PROB_ILLUMINA_SUBST: Prob = Prob(0.0021);\n\n    // log(0.0021)\n    const PROB_SUBSTITUTION: LogProb = LogProb(-6.165_817_934_252_76);\n    // log(2.8e-6)\n    const PROB_OPEN_GAP_Y: LogProb = LogProb(-12.785_891_140_783_116);\n    // log(5.1e-6)\n    const PROB_OPEN_GAP_X: LogProb = LogProb(-12.186_270_018_233_994);\n\n    const EMIT_MATCH: LogProb = LogProb(-0.0021022080918701985);\n    const EMIT_GAP_AND_Y: LogProb = LogProb(-0.0021022080918701985);\n    const EMIT_X_AND_GAP: LogProb = LogProb(-0.0021022080918701985);\n\n    const T_MATCH_TO_HOP_X: LogProb = LogProb(-11.512925464970229);\n    const T_MATCH_TO_HOP_Y: LogProb = LogProb(-11.512925464970229);\n    const T_HOP_X_TO_HOP_X: LogProb = LogProb(-2.3025850929940455);\n    const T_HOP_Y_TO_HOP_Y: LogProb = LogProb(-2.3025850929940455);\n\n    const T_MATCH_TO_MATCH: LogProb = LogProb(-7.900_031_205_113_962e-6);\n    const T_MATCH_TO_GAP_Y: LogProb = LogProb(-12.785_891_140_783_116);\n    const T_MATCH_TO_GAP_X: LogProb = LogProb(-12.186_270_018_233_994);\n    const T_GAP_TO_GAP: LogProb = LogProb(-9.210340371976182);\n\n    pub enum AlignmentMode {\n        Global,\n        Semiglobal,\n    }\n\n    impl StartEndGapParameters for AlignmentMode {\n        fn free_start_gap_x(\u0026self) -\u003e bool {\n            match self {\n                AlignmentMode::Semiglobal =\u003e true,\n                AlignmentMode::Global =\u003e false,\n            }\n        }\n\n        fn free_end_gap_x(\u0026self) -\u003e bool {\n            match self {\n                AlignmentMode::Semiglobal =\u003e true,\n                AlignmentMode::Global =\u003e false,\n            }\n        }\n    }\n\n    struct TestEmissionParams {\n        x: Vec\u003cu8\u003e,\n        y: Vec\u003cu8\u003e,\n    }\n\n    impl EmissionParameters for TestEmissionParams {\n        fn prob_emit_xy(\u0026self, i: usize, j: usize) -\u003e XYEmission {\n            if self.x[i] == self.y[j] {\n                XYEmission::Match(PROB_SUBSTITUTION.ln_one_minus_exp())\n            } else {\n                XYEmission::Mismatch(LogProb::from(PROB_ILLUMINA_SUBST / Prob(3.)))\n            }\n        }\n\n        fn prob_emit_x(\u0026self, _i: usize) -\u003e LogProb {\n            PROB_SUBSTITUTION.ln_one_minus_exp()\n        }\n\n        fn prob_emit_y(\u0026self, _j: usize) -\u003e LogProb {\n            PROB_SUBSTITUTION.ln_one_minus_exp()\n        }\n\n        fn len_x(\u0026self) -\u003e usize {\n            self.x.len()\n        }\n\n        fn len_y(\u0026self) -\u003e usize {\n            self.y.len()\n        }\n    }\n\n    impl Emission for TestEmissionParams {\n        fn emission_x(\u0026self, i: usize) -\u003e u8 {\n            self.x[i]\n        }\n\n        fn emission_y(\u0026self, j: usize) -\u003e u8 {\n            self.y[j]\n        }\n    }\n\n    struct TestSingleGapParams;\n\n    impl GapParameters for TestSingleGapParams {\n        fn prob_gap_x(\u0026self) -\u003e LogProb {\n            PROB_OPEN_GAP_Y\n        }\n\n        fn prob_gap_y(\u0026self) -\u003e LogProb {\n            PROB_OPEN_GAP_X\n        }\n\n        fn prob_gap_x_extend(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n\n        fn prob_gap_y_extend(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n    }\n\n    struct NoGapParams;\n\n    impl GapParameters for NoGapParams {\n        fn prob_gap_x(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n\n        fn prob_gap_y(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n\n        fn prob_gap_x_extend(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n\n        fn prob_gap_y_extend(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n    }\n\n    struct TestExtendGapParams;\n\n    impl GapParameters for TestExtendGapParams {\n        fn prob_gap_x(\u0026self) -\u003e LogProb {\n            LogProb::from(PROB_ILLUMINA_INS)\n        }\n\n        fn prob_gap_y(\u0026self) -\u003e LogProb {\n            LogProb::from(PROB_ILLUMINA_DEL)\n        }\n\n        fn prob_gap_x_extend(\u0026self) -\u003e LogProb {\n            T_GAP_TO_GAP\n        }\n\n        fn prob_gap_y_extend(\u0026self) -\u003e LogProb {\n            T_GAP_TO_GAP\n        }\n    }\n\n    struct TestNoHopParams;\n\n    impl HopParameters for TestNoHopParams {\n        fn prob_hop_x(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n\n        fn prob_hop_y(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n\n        fn prob_hop_x_extend(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n\n        fn prob_hop_y_extend(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n    }\n\n    struct TestHopParams;\n\n    impl HopParameters for TestHopParams {\n        fn prob_hop_x(\u0026self) -\u003e LogProb {\n            T_MATCH_TO_HOP_X\n        }\n\n        fn prob_hop_y(\u0026self) -\u003e LogProb {\n            T_MATCH_TO_HOP_Y\n        }\n\n        fn prob_hop_x_extend(\u0026self) -\u003e LogProb {\n            T_HOP_X_TO_HOP_X\n        }\n\n        fn prob_hop_y_extend(\u0026self) -\u003e LogProb {\n            T_HOP_Y_TO_HOP_Y\n        }\n    }\n\n    lazy_static! {\n        static ref SINGLE_GAPS_NO_HOPS_PHMM: HomopolyPairHMM =\n            HomopolyPairHMM::new(\u0026SINGLE_GAP_PARAMS, \u0026NO_HOP_PARAMS);\n        static ref EXTEND_GAPS_NO_HOPS_PHMM: HomopolyPairHMM =\n            HomopolyPairHMM::new(\u0026EXTEND_GAP_PARAMS, \u0026NO_HOP_PARAMS);\n        static ref NO_GAPS_WITH_HOPS_PHMM: HomopolyPairHMM =\n            HomopolyPairHMM::new(\u0026NO_GAP_PARAMS, \u0026TestHopParams);\n    }\n\n    #[test]\n    fn impossible_global_alignment() {\n        let x = b\"AAA\".to_vec();\n        let y = b\"A\".to_vec();\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n        assert_eq!(p, LogProb::zero());\n    }\n\n    #[test]\n    fn test_hompolymer_run_in_y() {\n        let pair_hmm = \u0026NO_GAPS_WITH_HOPS_PHMM;\n        for i in 1..5 {\n            let x = b\"ACGT\".to_vec();\n            let y = format!(\"AC{}GT\", repeat(\"C\").take(i).join(\"\"))\n                .as_bytes()\n                .to_vec();\n            let emission_params = TestEmissionParams { x, y };\n\n            let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n            let p_most_likely_path_with_hops = LogProb(\n                *EMIT_MATCH // A A\n                    + *T_MATCH_TO_MATCH\n                    + *EMIT_MATCH // C C\n                    + *T_MATCH_TO_HOP_X // C CC\n                    + *T_HOP_X_TO_HOP_X * ((i - 1) as f64)\n                    + (1. - 0.1f64).ln()\n                    + *EMIT_MATCH // G G\n                    + *T_MATCH_TO_MATCH\n                    + *EMIT_MATCH, // T T\n            );\n            assert!(*p \u003c= 0.0);\n            assert!(*p \u003e= *p_most_likely_path_with_hops);\n            assert!(*p \u003c *p_most_likely_path_with_hops + 1.);\n        }\n    }\n\n    #[test]\n    fn test_hompolymer_run_in_x() {\n        let pair_hmm = \u0026NO_GAPS_WITH_HOPS_PHMM;\n        for i in 1..5 {\n            let x = format!(\"AC{}GT\", repeat(\"C\").take(i).join(\"\"))\n                .as_bytes()\n                .to_vec();\n\n            let y = b\"ACGT\".to_vec();\n\n            let emission_params = TestEmissionParams { x, y };\n\n            let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n            let p_most_likely_path_with_hops = LogProb(\n                *EMIT_MATCH // A A\n                    + *T_MATCH_TO_MATCH\n                    + *EMIT_MATCH // C C\n                    + *T_MATCH_TO_HOP_Y // CC C\n                    + *T_HOP_Y_TO_HOP_Y * ((i - 1) as f64)\n                    + (1. - 0.1f64).ln()\n                    + *EMIT_MATCH // G G\n                    + *T_MATCH_TO_MATCH\n                    + *EMIT_MATCH, // T T\n            );\n            assert!(*p \u003c= 0.0);\n            assert!(*p \u003e= *p_most_likely_path_with_hops);\n            assert!(*p \u003c *p_most_likely_path_with_hops + 1.);\n        }\n    }\n\n    #[test]\n    fn test_interleave_gaps_x() {\n        let x = b\"AGAGAG\".to_vec();\n        let y = b\"ACGTACGTACGT\".to_vec();\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n\n        let n_matches = 6.;\n        let n_insertions = 6.;\n\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH_TO_MATCH * (n_matches - n_insertions)\n                + *EMIT_GAP_AND_Y * n_insertions\n                + *T_MATCH_TO_GAP_X * n_insertions\n                + *(PROB_OPEN_GAP_Y.ln_one_minus_exp()) * n_insertions,\n        );\n\n        let p_max = LogProb(*T_MATCH_TO_GAP_X * n_insertions);\n\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_interleave_gaps_y() {\n        let x = b\"ACGTACGTACGT\".to_vec();\n        let y = b\"AGAGAG\".to_vec();\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n\n        let n_matches = 6.;\n        let n_insertions = 6.;\n\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH_TO_MATCH * (n_matches - n_insertions)\n                + *EMIT_X_AND_GAP * n_insertions\n                + *T_MATCH_TO_GAP_Y * n_insertions\n                + *PROB_OPEN_GAP_X.ln_one_minus_exp() * n_insertions,\n        );\n\n        let p_max = LogProb(*T_MATCH_TO_GAP_Y * n_insertions);\n\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    static SINGLE_GAP_PARAMS: TestSingleGapParams = TestSingleGapParams;\n    static EXTEND_GAP_PARAMS: TestExtendGapParams = TestExtendGapParams;\n    static NO_GAP_PARAMS: NoGapParams = NoGapParams;\n    static NO_HOP_PARAMS: TestNoHopParams = TestNoHopParams;\n\n    #[test]\n    fn test_same() {\n        let x = b\"AGCTCGATCGATCGATC\".to_vec();\n        let y = b\"AGCTCGATCGATCGATC\".to_vec();\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n        let n = 17.;\n        let p_most_likely_path = LogProb(*EMIT_MATCH * n + *T_MATCH_TO_MATCH * (n - 1.));\n        let p_max = LogProb(*EMIT_MATCH * n);\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.001);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.001);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_gap_x() {\n        let x = b\"AGCTCGATCGATCGATC\".to_vec();\n        let y = b\"AGCTCGATCTGATCGATCT\".to_vec();\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n\n        let n_matches = 17.;\n        let n_insertions = 2.;\n\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH_TO_MATCH * (n_matches - n_insertions)\n                + *EMIT_GAP_AND_Y * n_insertions\n                + *T_MATCH_TO_GAP_X * n_insertions\n                + (1. - *PROB_ILLUMINA_INS).ln(),\n        );\n\n        let p_max = LogProb(*T_MATCH_TO_GAP_X * 2.);\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_gap_x_2() {\n        let x = b\"ACAGTA\".to_vec();\n        let y = b\"ACAGTCA\".to_vec();\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n\n        let n_matches = 6.;\n        let n_insertions = 1.;\n\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH_TO_MATCH * (n_matches - n_insertions)\n                + *EMIT_GAP_AND_Y * n_insertions\n                + *T_MATCH_TO_GAP_X * n_insertions\n                + (1. - *PROB_ILLUMINA_INS).ln(),\n        );\n\n        let p_max = LogProb(*T_MATCH_TO_GAP_X * n_insertions);\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_gap_y() {\n        let x = b\"AGCTCGATCTGATCGATCT\".to_vec();\n        let y = b\"AGCTCGATCGATCGATC\".to_vec();\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n\n        let n_matches = 17.;\n        let n_deletions = 2.;\n\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH_TO_MATCH * (n_matches - n_deletions)\n                + *EMIT_X_AND_GAP * n_deletions\n                + *T_MATCH_TO_GAP_Y * n_deletions\n                + (1. - *PROB_ILLUMINA_DEL).ln(),\n        );\n\n        let p_max = LogProb(*T_MATCH_TO_GAP_Y * 2.);\n\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_multigap_y() {\n        let x = b\"AGCTCGATCTGATCGATCT\".to_vec();\n        let y = b\"AGCTTCTGATCGATCT\".to_vec();\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026EXTEND_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n        let n_matches = 16.;\n        let n_consecutive_deletions = 3.;\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH_TO_MATCH * (n_matches - n_consecutive_deletions)\n                + *PROB_OPEN_GAP_Y\n                + *EMIT_X_AND_GAP * n_consecutive_deletions\n                + *T_GAP_TO_GAP * (n_consecutive_deletions - 1.)\n                + *T_GAP_TO_GAP.ln_one_minus_exp(),\n        );\n\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n    }\n\n    #[test]\n    fn test_mismatch() {\n        let x = b\"AGCTCGAGCGATCGATC\".to_vec();\n        let y = b\"TGCTCGATCGATCGATC\".to_vec();\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n\n        let n = 17.;\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * (n - 2.)\n                + *T_MATCH_TO_MATCH * (n - 1.)\n                + (*PROB_ILLUMINA_SUBST / 3.).ln() * 2.,\n        );\n        let p_max = LogProb((*PROB_ILLUMINA_SUBST / 3.).ln() * 2.);\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 1e-2);\n        assert_relative_eq!(*p, *p_max, epsilon = 1e-1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_banded() {\n        let x = b\"GATCACAGGTCTATCACCCTATTAACCACTCACGGGAGCTCTCCATGC\\\nATTTGGTATTTTCGTCTGGGGGGTATGCACGCGATAGCATTGCGAGACGCTGGAGCCGGAGCACCCTATGTCGCAGTAT\\\nCTGTCTTTGATTCCTGCCTCATCCTATTATTTATCGCACCTACGTTCAATATTACAGGCGAACATACTTACTAAAGTGT\"\n            .to_vec();\n\n        let y = b\"GGGTATGCACGCGATAGCATTGCGAGATGCTGGAGCTGGAGCACCCTATGTCGC\".to_vec();\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Semiglobal, None);\n\n        let p_banded = pair_hmm.prob_related(\u0026emission_params, \u0026Semiglobal, Some(2));\n        assert_relative_eq!(*p, *p_banded, epsilon = 1e-3);\n    }\n\n    #[test]\n    fn test_phmm_vs_phhmm() {\n        let x = b\"AGAGAGC\".to_vec();\n        let y = b\"ATACGTACGTC\".to_vec();\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hhmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p1 = pair_hhmm.prob_related(\u0026emission_params, \u0026Global, None);\n\n        struct TestSingleGapParamsPairHMM;\n        impl crate::stats::pairhmm::StartEndGapParameters for TestSingleGapParamsPairHMM {\n            fn free_start_gap_x(\u0026self) -\u003e bool {\n                false\n            }\n\n            fn free_end_gap_x(\u0026self) -\u003e bool {\n                false\n            }\n        }\n        impl crate::stats::pairhmm::GapParameters for TestSingleGapParamsPairHMM {\n            fn prob_gap_x(\u0026self) -\u003e LogProb {\n                LogProb::from(PROB_ILLUMINA_DEL)\n            }\n\n            fn prob_gap_y(\u0026self) -\u003e LogProb {\n                LogProb::from(PROB_ILLUMINA_INS)\n            }\n\n            fn prob_gap_x_extend(\u0026self) -\u003e LogProb {\n                LogProb::zero()\n            }\n\n            fn prob_gap_y_extend(\u0026self) -\u003e LogProb {\n                LogProb::zero()\n            }\n        }\n\n        fn prob_emit_x_or_y() -\u003e LogProb {\n            LogProb::from(Prob(1.0) - PROB_ILLUMINA_SUBST)\n        }\n\n        struct TestEmissionParamsPairHMM {\n            x: \u0026'static [u8],\n            y: \u0026'static [u8],\n        }\n\n        impl crate::stats::pairhmm::EmissionParameters for TestEmissionParamsPairHMM {\n            fn prob_emit_xy(\u0026self, i: usize, j: usize) -\u003e crate::stats::pairhmm::XYEmission {\n                if self.x[i] == self.y[j] {\n                    crate::stats::pairhmm::XYEmission::Match(LogProb::from(\n                        Prob(1.0) - PROB_ILLUMINA_SUBST,\n                    ))\n                } else {\n                    crate::stats::pairhmm::XYEmission::Mismatch(LogProb::from(\n                        PROB_ILLUMINA_SUBST / Prob(3.0),\n                    ))\n                }\n            }\n\n            fn prob_emit_x(\u0026self, _: usize) -\u003e LogProb {\n                prob_emit_x_or_y()\n            }\n\n            fn prob_emit_y(\u0026self, _: usize) -\u003e LogProb {\n                prob_emit_x_or_y()\n            }\n\n            fn len_x(\u0026self) -\u003e usize {\n                self.x.len()\n            }\n\n            fn len_y(\u0026self) -\u003e usize {\n                self.y.len()\n            }\n        }\n\n        let mut pair_hmm = PairHMM::new(\u0026TestSingleGapParamsPairHMM);\n\n        let x = b\"AGAGAGC\";\n        let y = b\"ATACGTACGTC\";\n        let p2 = pair_hmm.prob_related(\n            \u0026TestEmissionParamsPairHMM { x, y },\n            \u0026AlignmentMode::Global,\n            None,\n        );\n        assert_relative_eq!(*p1, *p2, epsilon = 1e-4)\n    }\n}\n","traces":[{"line":106,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[5619600],"length":1,"stats":{"Line":1},"fn_name":"space_bits"},{"line":140,"address":[5619608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[5619628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[5619683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[5619738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[5619793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[5619848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[5619920],"length":1,"stats":{"Line":1},"fn_name":"interleave_bits"},{"line":150,"address":[5619936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[4288768,4288640,4288704],"length":1,"stats":{"Line":3},"fn_name":"new\u003cbio::stats::pairhmm::homopolypairhmm::tests::NoGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestHopParams\u003e"},{"line":190,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":459,"address":[4307305,4309560,4305088,4305065,4305080,4307320,4307328,4309545,4302848],"length":1,"stats":{"Line":3},"fn_name":"build_transition_table\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestSingleGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":463,"address":[4305146,4307386,4302906],"length":1,"stats":{"Line":3},"fn_name":null},{"line":465,"address":[4305159,4307399,4302919],"length":1,"stats":{"Line":3},"fn_name":null},{"line":466,"address":[4307514,4305274,4303034,4307441,4305201,4302961],"length":1,"stats":{"Line":6},"fn_name":null},{"line":467,"address":[4305283,4307523,4303043],"length":1,"stats":{"Line":3},"fn_name":null},{"line":468,"address":[4305325,4307565,4303085],"length":1,"stats":{"Line":3},"fn_name":null},{"line":470,"address":[4303127,4307607,4305367],"length":1,"stats":{"Line":3},"fn_name":null},{"line":471,"address":[4307649,4305409,4303169],"length":1,"stats":{"Line":3},"fn_name":null},{"line":472,"address":[4307691,4303211,4305451],"length":1,"stats":{"Line":3},"fn_name":null},{"line":473,"address":[4303253,4305493,4307733],"length":1,"stats":{"Line":3},"fn_name":null},{"line":475,"address":[4309586,4309760,4309778,4307767,4309568,4309682,4309664,4303287,4305527],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::NoGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestHopParams\u003e"},{"line":476,"address":[4309702,4309798,4309606],"length":1,"stats":{"Line":3},"fn_name":null},{"line":478,"address":[4309856,4303399,4310066,4305639,4307879,4309874,4309952,4309970,4310048],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestSingleGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":479,"address":[4309894,4309990,4310086],"length":1,"stats":{"Line":3},"fn_name":null},{"line":481,"address":[4307991,4310258,4305751,4310354,4303511,4310144,4310336,4310240,4310162],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestExtendGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":482,"address":[4310278,4310374,4310182],"length":1,"stats":{"Line":3},"fn_name":null},{"line":484,"address":[4310642,4310450,4308103,4310528,4310624,4305863,4303623,4310546,4310432],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::NoGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestHopParams\u003e"},{"line":485,"address":[4310662,4310470,4310566],"length":1,"stats":{"Line":3},"fn_name":null},{"line":487,"address":[4303735,4310739,4310832,4310851,4310720,4305975,4310963,4308215,4310944],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestExtendGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":488,"address":[4310871,4310983,4310759],"length":1,"stats":{"Line":3},"fn_name":null},{"line":490,"address":[4308327,4303847,4311187,4311168,4311056,4311075,4311280,4306087,4311299],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestSingleGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":491,"address":[4311207,4311095,4311319],"length":1,"stats":{"Line":3},"fn_name":null},{"line":494,"address":[4303959,4306199,4308439],"length":1,"stats":{"Line":3},"fn_name":null},{"line":496,"address":[4306360,4304120,4308600],"length":1,"stats":{"Line":3},"fn_name":null},{"line":498,"address":[4311584,4308755,4311392,4311488,4311602,4311506,4304275,4306515,4311410],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::NoGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestHopParams\u003e"},{"line":499,"address":[4311622,4311526,4311430],"length":1,"stats":{"Line":3},"fn_name":null},{"line":501,"address":[4304375,4311794,4311776,4306615,4311698,4311872,4308855,4311680,4311890],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestSingleGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":502,"address":[4311718,4311814,4311910],"length":1,"stats":{"Line":3},"fn_name":null},{"line":505,"address":[4311968,4312160,4312064,4308955,4312085,4312181,4304475,4311989,4306715],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestExtendGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":506,"address":[4312093,4311997,4312189],"length":1,"stats":{"Line":3},"fn_name":null},{"line":508,"address":[4312469,4312373,4312256,4312352,4312277,4304575,4312448,4306815,4309055],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestExtendGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":509,"address":[4312381,4312477,4312285],"length":1,"stats":{"Line":3},"fn_name":null},{"line":511,"address":[4309155,4312563,4304675,4312675,4306915,4312544,4312768,4312787,4312656],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestSingleGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":512,"address":[4312683,4312795,4312571],"length":1,"stats":{"Line":3},"fn_name":null},{"line":514,"address":[4304775,4312899,4312880,4309255,4312992,4313011,4313123,4307015,4313104],"length":1,"stats":{"Line":9},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::NoGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestHopParams\u003e"},{"line":515,"address":[4312907,4313019,4313131],"length":1,"stats":{"Line":3},"fn_name":null},{"line":517,"address":[4309355,4304875,4307115],"length":1,"stats":{"Line":3},"fn_name":null},{"line":518,"address":[4304962,4307202,4309442],"length":1,"stats":{"Line":3},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":534,"address":[4313370,4313216],"length":1,"stats":{"Line":1},"fn_name":"min3\u003cusize\u003e"},{"line":535,"address":[4313384,4313382,4313269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":618,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":623,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":672,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":673,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":681,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":689,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":713,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":724,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":729,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":739,"address":[5000747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":741,"address":[5043483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":743,"address":[5032747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":747,"address":[8992144,8992718],"length":1,"stats":{"Line":3},"fn_name":"impossible_global_alignment"},{"line":748,"address":[8992151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":749,"address":[8992190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":750,"address":[8992218],"length":1,"stats":{"Line":1},"fn_name":null},{"line":752,"address":[8992333],"length":1,"stats":{"Line":1},"fn_name":null},{"line":753,"address":[8992348,8992409,8992502],"length":1,"stats":{"Line":3},"fn_name":null},{"line":754,"address":[8992511,8992656],"length":1,"stats":{"Line":1},"fn_name":null},{"line":758,"address":[8992752,8994922],"length":1,"stats":{"Line":3},"fn_name":"test_hompolymer_run_in_y"},{"line":759,"address":[8992759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":760,"address":[8994898,8992790,8992944],"length":1,"stats":{"Line":3},"fn_name":null},{"line":761,"address":[8992984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":762,"address":[8993018,8993139],"length":1,"stats":{"Line":2},"fn_name":null},{"line":765,"address":[8993616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":767,"address":[8993834,8993760,8993939],"length":1,"stats":{"Line":3},"fn_name":null},{"line":769,"address":[8994040,8994099,8994529,8994435,8994482,8993948,8994313,8994158,8994388],"length":1,"stats":{"Line":9},"fn_name":null},{"line":770,"address":[8993994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":771,"address":[8994053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":772,"address":[8994112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":773,"address":[8994171,8994344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":774,"address":[8994331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":775,"address":[8994398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":776,"address":[8994445],"length":1,"stats":{"Line":1},"fn_name":null},{"line":777,"address":[8994492],"length":1,"stats":{"Line":1},"fn_name":null},{"line":779,"address":[8994550,8994609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":780,"address":[8994727,8994647,8994594],"length":1,"stats":{"Line":2},"fn_name":null},{"line":781,"address":[8994712,8994849,8994765],"length":1,"stats":{"Line":2},"fn_name":null},{"line":786,"address":[8995515,8994960],"length":1,"stats":{"Line":3},"fn_name":"test_hompolymer_run_in_x"},{"line":787,"address":[8994967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":788,"address":[8995144,8997032,8994990],"length":1,"stats":{"Line":3},"fn_name":null},{"line":789,"address":[8995530,8995184],"length":1,"stats":{"Line":2},"fn_name":null},{"line":793,"address":[8995740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":795,"address":[8995812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":797,"address":[8996089,8995948],"length":1,"stats":{"Line":2},"fn_name":null},{"line":799,"address":[8996098,8996308,8996457,8996249,8996579,8996190,8996532,8996626,8996673],"length":1,"stats":{"Line":9},"fn_name":null},{"line":800,"address":[8996144],"length":1,"stats":{"Line":1},"fn_name":null},{"line":801,"address":[8996203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":802,"address":[8996262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":803,"address":[8996321,8996488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":804,"address":[8996475],"length":1,"stats":{"Line":1},"fn_name":null},{"line":805,"address":[8996542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":806,"address":[8996589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":807,"address":[8996636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":809,"address":[8996753,8996694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":810,"address":[8996738,8996791,8996871],"length":1,"stats":{"Line":2},"fn_name":null},{"line":811,"address":[8996856,8996991,8996909],"length":1,"stats":{"Line":2},"fn_name":null},{"line":816,"address":[9000484,8997056],"length":1,"stats":{"Line":3},"fn_name":"test_interleave_gaps_x"},{"line":817,"address":[8997070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":818,"address":[8997112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":820,"address":[8997143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":822,"address":[8997279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":823,"address":[8997466,8997294,8997361],"length":1,"stats":{"Line":3},"fn_name":null},{"line":825,"address":[8997485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":826,"address":[8997493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":829,"address":[8997683,8997501,8997867,8997612,8997754],"length":1,"stats":{"Line":5},"fn_name":null},{"line":830,"address":[8997559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":831,"address":[8997625],"length":1,"stats":{"Line":1},"fn_name":null},{"line":832,"address":[8997696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":833,"address":[8997767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":836,"address":[8997880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":838,"address":[8997946,8998014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":839,"address":[8998054,8998312,8997996],"length":1,"stats":{"Line":2},"fn_name":null},{"line":840,"address":[8999242,8998291,8999500],"length":1,"stats":{"Line":2},"fn_name":null},{"line":841,"address":[9000428,8999479,9000352],"length":1,"stats":{"Line":2},"fn_name":null},{"line":845,"address":[9000528,9003956],"length":1,"stats":{"Line":3},"fn_name":"test_interleave_gaps_y"},{"line":846,"address":[9000542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":847,"address":[9000584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":849,"address":[9000615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":851,"address":[9000751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":852,"address":[9000833,9000766,9000938],"length":1,"stats":{"Line":3},"fn_name":null},{"line":854,"address":[9000957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":855,"address":[9000965],"length":1,"stats":{"Line":1},"fn_name":null},{"line":858,"address":[9001339,9001155,9001084,9000973,9001226],"length":1,"stats":{"Line":5},"fn_name":null},{"line":859,"address":[9001031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":860,"address":[9001097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":861,"address":[9001168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":862,"address":[9001239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":865,"address":[9001352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":867,"address":[9001486,9001418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":868,"address":[9001526,9001468,9001784],"length":1,"stats":{"Line":2},"fn_name":null},{"line":869,"address":[9002972,9002714,9001763],"length":1,"stats":{"Line":2},"fn_name":null},{"line":870,"address":[9003900,9002951,9003824],"length":1,"stats":{"Line":2},"fn_name":null},{"line":879,"address":[9007162,9004000],"length":1,"stats":{"Line":3},"fn_name":"test_same"},{"line":880,"address":[9004014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":881,"address":[9004056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":882,"address":[9004087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":884,"address":[9004223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":885,"address":[9004410,9004238,9004305],"length":1,"stats":{"Line":3},"fn_name":null},{"line":886,"address":[9004429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":887,"address":[9004437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":888,"address":[9004566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":889,"address":[9004700,9004632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":890,"address":[9004740,9004682,9004998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":891,"address":[9005928,9006186,9004977],"length":1,"stats":{"Line":2},"fn_name":null},{"line":892,"address":[9007032,9006165,9007106],"length":1,"stats":{"Line":2},"fn_name":null},{"line":896,"address":[9007200,9010602],"length":1,"stats":{"Line":3},"fn_name":"test_gap_x"},{"line":897,"address":[9007214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":898,"address":[9007256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":899,"address":[9007287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":901,"address":[9007423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":902,"address":[9007438,9007505,9007610],"length":1,"stats":{"Line":3},"fn_name":null},{"line":904,"address":[9007629],"length":1,"stats":{"Line":1},"fn_name":null},{"line":905,"address":[9007647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":908,"address":[9007897,9007771,9007655,9007834,9007993],"length":1,"stats":{"Line":5},"fn_name":null},{"line":909,"address":[9007713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":910,"address":[9007784],"length":1,"stats":{"Line":1},"fn_name":null},{"line":911,"address":[9007847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":912,"address":[9007910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":915,"address":[9008006],"length":1,"stats":{"Line":1},"fn_name":null},{"line":916,"address":[9008064,9008132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":917,"address":[9008430,9008114,9008172],"length":1,"stats":{"Line":2},"fn_name":null},{"line":918,"address":[9009360,9009618,9008409],"length":1,"stats":{"Line":2},"fn_name":null},{"line":919,"address":[9009597,9010470,9010546],"length":1,"stats":{"Line":2},"fn_name":null},{"line":923,"address":[9014030,9010640],"length":1,"stats":{"Line":3},"fn_name":"test_gap_x_2"},{"line":924,"address":[9010654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":925,"address":[9010696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":926,"address":[9010727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":928,"address":[9010863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":929,"address":[9011050,9010878,9010945],"length":1,"stats":{"Line":3},"fn_name":null},{"line":931,"address":[9011069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":932,"address":[9011087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":935,"address":[9011270,9011095,9011425,9011329,9011211],"length":1,"stats":{"Line":5},"fn_name":null},{"line":936,"address":[9011153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":937,"address":[9011224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":938,"address":[9011283],"length":1,"stats":{"Line":1},"fn_name":null},{"line":939,"address":[9011342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":942,"address":[9011438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":943,"address":[9011560,9011492],"length":1,"stats":{"Line":1},"fn_name":null},{"line":944,"address":[9011858,9011542,9011600],"length":1,"stats":{"Line":2},"fn_name":null},{"line":945,"address":[9012788,9013046,9011837],"length":1,"stats":{"Line":2},"fn_name":null},{"line":946,"address":[9013025,9013974,9013898],"length":1,"stats":{"Line":2},"fn_name":null},{"line":950,"address":[9014064,9017466],"length":1,"stats":{"Line":3},"fn_name":"test_gap_y"},{"line":951,"address":[9014078],"length":1,"stats":{"Line":1},"fn_name":null},{"line":952,"address":[9014120],"length":1,"stats":{"Line":1},"fn_name":null},{"line":953,"address":[9014151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":955,"address":[9014287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":956,"address":[9014369,9014474,9014302],"length":1,"stats":{"Line":3},"fn_name":null},{"line":958,"address":[9014493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":959,"address":[9014511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":962,"address":[9014857,9014635,9014519,9014698,9014761],"length":1,"stats":{"Line":5},"fn_name":null},{"line":963,"address":[9014577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":964,"address":[9014648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":965,"address":[9014711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":966,"address":[9014774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":969,"address":[9014870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":971,"address":[9014928,9014996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":972,"address":[9014978,9015036,9015294],"length":1,"stats":{"Line":2},"fn_name":null},{"line":973,"address":[9016482,9016224,9015273],"length":1,"stats":{"Line":2},"fn_name":null},{"line":974,"address":[9017334,9016461,9017410],"length":1,"stats":{"Line":2},"fn_name":null},{"line":978,"address":[9019600,9017504],"length":1,"stats":{"Line":3},"fn_name":"test_multigap_y"},{"line":979,"address":[9017518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":980,"address":[9017560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":981,"address":[9017591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":983,"address":[9017727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":984,"address":[9017742,9017809,9017914],"length":1,"stats":{"Line":3},"fn_name":null},{"line":985,"address":[9017933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":986,"address":[9017951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":988,"address":[9018075,9018369,9017959,9018268,9018205,9018134],"length":1,"stats":{"Line":6},"fn_name":null},{"line":989,"address":[9018017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":990,"address":[9018088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":991,"address":[9018147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":992,"address":[9018218],"length":1,"stats":{"Line":1},"fn_name":null},{"line":993,"address":[9018281],"length":1,"stats":{"Line":1},"fn_name":null},{"line":996,"address":[9018390,9018458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":997,"address":[9018745,9018440,9018498],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1001,"address":[9019632,9022923],"length":1,"stats":{"Line":3},"fn_name":"test_mismatch"},{"line":1002,"address":[9019646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1003,"address":[9019688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1004,"address":[9019719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1006,"address":[9019855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1007,"address":[9019870,9019937,9020042],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1009,"address":[9020061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1011,"address":[9020185,9020285,9020069],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1012,"address":[9020127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1013,"address":[9020198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1015,"address":[9020298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1016,"address":[9020461,9020393],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1017,"address":[9020443,9020501,9020759],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1018,"address":[9020738,9021947,9021689],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1019,"address":[9022793,9021926,9022867],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1023,"address":[9024628,9022960],"length":1,"stats":{"Line":3},"fn_name":"test_banded"},{"line":1024,"address":[9022974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1029,"address":[9023016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1031,"address":[9023047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1033,"address":[9023183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1034,"address":[9023198,9023370,9023265],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1036,"address":[9023379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1037,"address":[9023509,9023782],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1041,"address":[9024672,9026458],"length":1,"stats":{"Line":3},"fn_name":"test_phmm_vs_phhmm"},{"line":1042,"address":[9024686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1043,"address":[9024728],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1044,"address":[9024759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1046,"address":[9024895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1047,"address":[9025082,9024910,9024977],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1051,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1052,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1055,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1056,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1060,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1061,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1064,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1065,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1068,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1069,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1072,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1073,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1077,"address":[9026688],"length":1,"stats":{"Line":1},"fn_name":"prob_emit_x_or_y"},{"line":1078,"address":[9026692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1087,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1088,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1089,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1090,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1093,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1094,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1099,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1107,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1112,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1116,"address":[9025091],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1118,"address":[9025113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1119,"address":[9025128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1120,"address":[9025195],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1121,"address":[9025143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1123,"address":[9025183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1125,"address":[9025589,9025342,9025276],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":434,"coverable":460},{"path":["/","home","todd","rust-bio","src","stats","pairhmm","mod.rs"],"content":"//! This module contains the implementation of a classic `PairHMM` as described in\n//! Durbin, R., Eddy, S., Krogh, A., \u0026 Mitchison, G. (1998). Biological Sequence Analysis.\n//! Current Topics in Genome Analysis 2008. http://doi.org/10.1017/CBO9780511790492.\n//! It also contains a modified variant `HomopolyPairHMM` with additional homopolymer states suited\n//! for dealing with homopolymer runs in sequencing as often encountered in Oxford Nanopore\n//! sequencing data.\n//!\n//! Traits defined in this module apply to both `PairHMM` and `HomopolyPairHMM`.\n//!\n//! # Examples\n//! ```\n//! use approx::assert_relative_eq;\n//! use bio::stats::pairhmm::{\n//!     EmissionParameters, GapParameters, PairHMM, StartEndGapParameters, XYEmission,\n//! };\n//! use bio::stats::{LogProb, Prob};\n//! use num_traits::Zero;\n//!\n//! // Two sequences for which we'd like to know if they are likely related.\n//! let x = b\"AAAA\";\n//! let y = b\"AAAT\";\n//!\n//! // For this example, we disallow gaps, so all probabilities are zero here.\n//! struct GapParams;\n//! impl GapParameters for GapParams {\n//!     fn prob_gap_x(\u0026self) -\u003e LogProb {\n//!         LogProb::zero()\n//!     }\n//!     fn prob_gap_y(\u0026self) -\u003e LogProb {\n//!         LogProb::zero()\n//!     }\n//!     fn prob_gap_x_extend(\u0026self) -\u003e LogProb {\n//!         LogProb::zero()\n//!     }\n//!     fn prob_gap_y_extend(\u0026self) -\u003e LogProb {\n//!         LogProb::zero()\n//!     }\n//! }\n//! let gap_params = GapParams;\n//!\n//! // The PairHMM instance stores the gap params, since these are constant.\n//! let mut pairhmm = PairHMM::new(\u0026gap_params);\n//!\n//! // However, emission parameters depend on the actual sequences\n//! struct EmissionParams {\n//!     x: \u0026'static [u8],\n//!     y: \u0026'static [u8],\n//! }\n//!\n//! const PROB_SUBSTITUTION: f64 = 0.1;\n//! const PROB_NO_SUBSTITUION: f64 = 1. - PROB_SUBSTITUTION;\n//! impl EmissionParameters for EmissionParams {\n//!     fn prob_emit_xy(\u0026self, i: usize, j: usize) -\u003e XYEmission {\n//!         if self.x[i] == self.y[j] {\n//!             // if two bases match, emit a Match!\n//!             XYEmission::Match(LogProb::from(Prob(PROB_NO_SUBSTITUION)))\n//!         } else {\n//!             // otherwise emit a Mismatch!\n//!             // Note that the probability here is `mismatch / 3`, since probabilities should sum\n//!             // to 1 and there are 3 possible mismatch configurations\n//!             XYEmission::Mismatch(LogProb::from(Prob(PROB_SUBSTITUTION / 3.)))\n//!         }\n//!     }\n//!\n//!     // In this example, emitting x[i] is as likely as not observing a mismatch.\n//!     // In more complex cases, this might e.g. depend on base qualities reported by the sequencer\n//!     fn prob_emit_x(\u0026self, i: usize) -\u003e LogProb {\n//!         LogProb::from(Prob(PROB_NO_SUBSTITUION))\n//!     }\n//!     fn prob_emit_y(\u0026self, j: usize) -\u003e LogProb {\n//!         LogProb::from(Prob(PROB_NO_SUBSTITUION))\n//!     }\n//!\n//!     fn len_x(\u0026self) -\u003e usize {\n//!         self.x.len()\n//!     }\n//!     fn len_y(\u0026self) -\u003e usize {\n//!         self.y.len()\n//!     }\n//! }\n//!\n//! // Since we want to do global alignment here, disallow free start and end gaps in x.\n//! struct GlobalAlignmentMode;\n//! impl StartEndGapParameters for GlobalAlignmentMode {\n//!     fn free_start_gap_x(\u0026self) -\u003e bool {\n//!         false\n//!     }\n//!     fn free_end_gap_x(\u0026self) -\u003e bool {\n//!         false\n//!     }\n//! }\n//!\n//! // Finally calculate the probability of relatedness between x and y!\n//! let prob_related = pairhmm.prob_related(\u0026EmissionParams { x, y }, \u0026GlobalAlignmentMode, None);\n//!\n//! // … and compare it to a rough estimation\n//! let prob_expected = LogProb::from(Prob(PROB_NO_SUBSTITUION.powi(3) * PROB_SUBSTITUTION / 3.));\n//! assert_relative_eq!(*prob_related, *prob_expected, epsilon = 1e-5);\n//! ```\npub use homopolypairhmm::{HomopolyPairHMM, HopParameters};\npub use pairhmm::PairHMM;\n\nuse crate::stats::LogProb;\n\nmod homopolypairhmm;\nmod pairhmm;\n\n// traits common to pairhmm implementations\n\n/// Trait for parametrization of `PairHMM` emission behavior.\npub trait EmissionParameters {\n    /// Emission probability for `(x[i], y[j])`.\n    /// Returns a tuple with probability and a boolean indicating whether emissions match\n    /// (e.g., are the same DNA alphabet letter).\n    fn prob_emit_xy(\u0026self, i: usize, j: usize) -\u003e XYEmission;\n\n    /// Emission probability for `(x[i], -)`.\n    fn prob_emit_x(\u0026self, i: usize) -\u003e LogProb;\n\n    /// Emission probability for `(-, y[j])`.\n    fn prob_emit_y(\u0026self, j: usize) -\u003e LogProb;\n\n    fn len_x(\u0026self) -\u003e usize;\n\n    fn len_y(\u0026self) -\u003e usize;\n}\n/// Trait needed for the `HomopolyPairHMM`, because its implementation details\n/// depend on the actual bases to distinguish between Match states.\npub trait Emission {\n    /// Base emitted at `i` in sequence `x`.\n    /// Should be one of b'A', b'C', b'G' or b'T'.\n    fn emission_x(\u0026self, i: usize) -\u003e u8;\n    /// Base emitted at `i` in sequence `y`.\n    /// Should be one of b'A', b'C', b'G' or b'T'.\n    fn emission_y(\u0026self, j: usize) -\u003e u8;\n}\n\n/// Trait for parametrization of `PairHMM` gap behavior.\npub trait GapParameters {\n    /// Probability to open gap in x.\n    fn prob_gap_x(\u0026self) -\u003e LogProb;\n\n    /// Probability to open gap in y.\n    fn prob_gap_y(\u0026self) -\u003e LogProb;\n\n    /// Probability to extend gap in x.\n    fn prob_gap_x_extend(\u0026self) -\u003e LogProb;\n\n    /// Probability to extend gap in y.\n    fn prob_gap_y_extend(\u0026self) -\u003e LogProb;\n}\n\n/// Trait for parametrization of `PairHMM` start and end gap behavior.\n/// This trait can be used to implement global and semiglobal alignments.\n///\n/// * global: methods return `false` and `LogProb::ln_zero()`.\n/// * semiglobal: methods return `true` and `LogProb::ln_one()`.\npub trait StartEndGapParameters {\n    /// Probability to start at `x[i]`. This can be left unchanged if you use `free_start_gap_x` and\n    /// `free_end_gap_x`.\n    #[inline]\n    #[allow(unused_variables)]\n    fn prob_start_gap_x(\u0026self, i: usize) -\u003e LogProb {\n        if self.free_start_gap_x() {\n            LogProb::ln_one()\n        } else {\n            // For global alignment, this has to return 0.0.\n            LogProb::ln_zero()\n        }\n    }\n\n    /// Allow free start gap in x.\n    fn free_start_gap_x(\u0026self) -\u003e bool;\n\n    /// Allow free end gap in x.\n    fn free_end_gap_x(\u0026self) -\u003e bool;\n}\n\n#[derive(Debug)]\npub enum XYEmission {\n    Match(LogProb),\n    Mismatch(LogProb),\n}\n\nimpl XYEmission {\n    pub fn prob(\u0026self) -\u003e LogProb {\n        match *self {\n            XYEmission::Match(p) =\u003e p,\n            XYEmission::Mismatch(p) =\u003e p,\n        }\n    }\n\n    pub fn is_match(\u0026self) -\u003e bool {\n        match *self {\n            XYEmission::Match(_) =\u003e true,\n            XYEmission::Mismatch(_) =\u003e false,\n        }\n    }\n}\n","traces":[{"line":163,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":12,"coverable":12},{"path":["/","home","todd","rust-bio","src","stats","pairhmm","pairhmm.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A pair Hidden Markov Model for calculating the probability that two sequences are related to\n//! each other. Depending on the used parameters, this can, e.g., be used to calculate the\n//! probability that a certain sequencing read comes from a given position in a reference genome.\n//!\n//! Time complexity: O(n * m) where `n = seq1.len()`, `m = seq2.len()` (or `m = min(seq2.len(), max_edit_dist)` with banding enabled).\n//! Memory complexity: O(m) where `m = seq2.len()`.\n//! Note that if the number of states weren't fixed in this implementation, we would have to include\n//! these in both time and memory complexity above as an additional factor.\n\nuse std::cmp;\nuse std::mem;\nuse std::usize;\n\npub use crate::stats::pairhmm::{\n    EmissionParameters, GapParameters, StartEndGapParameters, XYEmission,\n};\nuse crate::stats::LogProb;\n\n/// Fast approximation of sum over the three given proabilities. If the largest is sufficiently\n/// large compared to the others, we just return that instead of computing the full (expensive)\n/// sum.\n#[inline]\nfn ln_sum3_exp_approx(mut p0: LogProb, mut p1: LogProb, mut p2: LogProb) -\u003e LogProb {\n    if p1 \u003c p2 {\n        mem::swap(\u0026mut p1, \u0026mut p2);\n    }\n    if p1 \u003e p0 {\n        mem::swap(\u0026mut p1, \u0026mut p0);\n    }\n    if *(p0 - p1) \u003e 10.0 {\n        // if p0 is strong enough compared to second, just return the maximum\n        p0\n    } else {\n        // calculate accurate sum (slower)\n        LogProb::ln_sum_exp(\u0026[p0, p1, p2])\n    }\n}\n\n/// A pair Hidden Markov Model for comparing sequences x and y as described by\n/// Durbin, R., Eddy, S., Krogh, A., \u0026 Mitchison, G. (1998). Biological Sequence Analysis.\n/// Current Topics in Genome Analysis 2008. http://doi.org/10.1017/CBO9780511790492.\n#[derive(Debug, Clone)]\npub struct PairHMM {\n    fm: [Vec\u003cLogProb\u003e; 2],\n    fx: [Vec\u003cLogProb\u003e; 2],\n    fy: [Vec\u003cLogProb\u003e; 2],\n    min_edit_dist: [Vec\u003cusize\u003e; 2],\n    prob_cols: Vec\u003cLogProb\u003e,\n    gap_params: GapParamCache,\n}\n\n#[derive(Debug, Clone)]\nstruct GapParamCache {\n    prob_no_gap: LogProb,\n    prob_no_gap_x_extend: LogProb,\n    prob_no_gap_y_extend: LogProb,\n    prob_gap_x: LogProb,\n    prob_gap_y: LogProb,\n    prob_gap_x_extend: LogProb,\n    prob_gap_y_extend: LogProb,\n    do_gap_x_extend: bool,\n    do_gap_y_extend: bool,\n}\n\nimpl PairHMM {\n    pub fn new\u003cG\u003e(gap_params: \u0026G) -\u003e Self\n    where\n        G: GapParameters,\n    {\n        let gap_params = GapParamCache {\n            prob_no_gap: gap_params\n                .prob_gap_x()\n                .ln_add_exp(gap_params.prob_gap_y())\n                .ln_one_minus_exp(),\n            prob_no_gap_x_extend: gap_params.prob_gap_x_extend().ln_one_minus_exp(),\n            prob_no_gap_y_extend: gap_params.prob_gap_y_extend().ln_one_minus_exp(),\n            prob_gap_x: gap_params.prob_gap_x(),\n            prob_gap_y: gap_params.prob_gap_y(),\n            prob_gap_x_extend: gap_params.prob_gap_x_extend(),\n            prob_gap_y_extend: gap_params.prob_gap_y_extend(),\n            do_gap_y_extend: gap_params.prob_gap_y_extend() != LogProb::ln_zero(),\n            do_gap_x_extend: gap_params.prob_gap_x_extend() != LogProb::ln_zero(),\n        };\n        Self {\n            fm: [Vec::new(), Vec::new()],\n            fx: [Vec::new(), Vec::new()],\n            fy: [Vec::new(), Vec::new()],\n            min_edit_dist: [Vec::new(), Vec::new()],\n            prob_cols: Vec::new(),\n            gap_params,\n        }\n    }\n\n    /// Calculate the probability of sequence x being related to y via any alignment.\n    ///\n    /// # Arguments\n    ///\n    /// * `gap_params` - parameters for opening or extending gaps\n    /// * `emission_params` - parameters for emission\n    /// * `max_edit_dist` - maximum edit distance to consider; if not `None`, perform banded alignment\n    pub fn prob_related\u003cE, A\u003e(\n        \u0026mut self,\n        emission_params: \u0026E,\n        alignment_mode: \u0026A,\n        max_edit_dist: Option\u003cusize\u003e,\n    ) -\u003e LogProb\n    where\n        E: EmissionParameters,\n        A: StartEndGapParameters,\n    {\n        for k in 0..2 {\n            self.fm[k].clear();\n            self.fx[k].clear();\n            self.fy[k].clear();\n            self.min_edit_dist[k].clear();\n            self.prob_cols.clear();\n\n            self.fm[k].resize(emission_params.len_y() + 1, LogProb::ln_zero());\n            self.fx[k].resize(emission_params.len_y() + 1, LogProb::ln_zero());\n            self.fy[k].resize(emission_params.len_y() + 1, LogProb::ln_zero());\n            self.min_edit_dist[k].resize(emission_params.len_y() + 1, usize::MAX);\n\n            if alignment_mode.free_end_gap_x() {\n                let c = (emission_params.len_x() * 3).saturating_sub(self.prob_cols.capacity());\n                self.prob_cols.reserve_exact(c);\n            }\n        }\n\n        let mut prev = 0;\n        let mut curr = 1;\n        self.fm[prev][0] = LogProb::ln_one();\n\n        // iterate over x\n        for i in 0..emission_params.len_x() {\n            // allow alignment to start from offset in x (if prob_start_gap_x is set accordingly)\n            self.fm[prev][0] = self.fm[prev][0].ln_add_exp(alignment_mode.prob_start_gap_x(i));\n            if alignment_mode.free_start_gap_x() {\n                self.min_edit_dist[prev][0] = 0;\n            }\n\n            let prob_emit_x = emission_params.prob_emit_x(i);\n\n            // TODO: in the case of no gap extensions, we can reduce the number of columns of y that need to be looked at (by cone).\n            let (j_min, j_max) = (0, emission_params.len_y());\n\n            // iterate over y\n            for j in j_min..j_max {\n                let j_ = j + 1;\n                let j_minus_one = j_ - 1;\n\n                let min_edit_dist_topleft = self.min_edit_dist[prev][j_minus_one];\n                let min_edit_dist_top = self.min_edit_dist[curr][j_minus_one];\n                let min_edit_dist_left = self.min_edit_dist[prev][j_];\n\n                if let Some(max_edit_dist) = max_edit_dist {\n                    if cmp::min(\n                        min_edit_dist_topleft,\n                        cmp::min(min_edit_dist_top, min_edit_dist_left),\n                    ) \u003e max_edit_dist\n                    {\n                        // skip this cell if best edit dist is already larger than given maximum\n                        continue;\n                    }\n                }\n\n                let (prob_match_mismatch, prob_gap_x, prob_gap_y, min_edit_dist) = {\n                    let fm_curr = \u0026self.fm[curr];\n                    let fm_prev = \u0026self.fm[prev];\n                    let fx_prev = \u0026self.fx[prev];\n                    let fy_curr = \u0026self.fy[curr];\n                    let fy_prev = \u0026self.fy[prev];\n\n                    // match or mismatch\n                    let emit_xy = emission_params.prob_emit_xy(i, j);\n                    let prob_match_mismatch = emit_xy.prob()\n                        + ln_sum3_exp_approx(\n                            self.gap_params.prob_no_gap + fm_prev[j_minus_one],\n                            // coming from state X\n                            self.gap_params.prob_no_gap_x_extend + fx_prev[j_minus_one],\n                            // coming from state Y\n                            self.gap_params.prob_no_gap_y_extend + fy_prev[j_minus_one],\n                        );\n\n                    // gap in y\n                    let mut prob_gap_y = prob_emit_x\n                        + (\n                            // open gap\n                            self.gap_params.prob_gap_y + fm_prev[j_]\n                        );\n                    if self.gap_params.do_gap_y_extend {\n                        prob_gap_y = prob_gap_y.ln_add_exp(\n                            // extend gap\n                            self.gap_params.prob_gap_y_extend + fx_prev[j_],\n                        );\n                    }\n\n                    // gap in x\n                    let mut prob_gap_x = emission_params.prob_emit_y(j)\n                        + (\n                            // open gap\n                            self.gap_params.prob_gap_x + fm_curr[j_minus_one]\n                        );\n                    if self.gap_params.do_gap_x_extend {\n                        prob_gap_x = prob_gap_x.ln_add_exp(\n                            // extend gap\n                            self.gap_params.prob_gap_x_extend + fy_curr[j_minus_one],\n                        );\n                    }\n\n                    // calculate minimal number of mismatches\n                    let min_edit_dist = if max_edit_dist.is_some() {\n                        cmp::min(\n                            if emit_xy.is_match() {\n                                // a match, so nothing changes\n                                min_edit_dist_topleft\n                            } else {\n                                // one new mismatch\n                                min_edit_dist_topleft.saturating_add(1)\n                            },\n                            cmp::min(\n                                // gap in y (no new mismatch)\n                                min_edit_dist_left.saturating_add(1),\n                                // gap in x (no new mismatch)\n                                min_edit_dist_top.saturating_add(1),\n                            ),\n                        )\n                    } else {\n                        0\n                    };\n\n                    (prob_match_mismatch, prob_gap_x, prob_gap_y, min_edit_dist)\n                };\n\n                self.fm[curr][j_] = prob_match_mismatch;\n                self.fx[curr][j_] = prob_gap_y;\n                self.fy[curr][j_] = prob_gap_x;\n                if max_edit_dist.is_some() {\n                    self.min_edit_dist[curr][j_] = min_edit_dist;\n                }\n            }\n\n            if alignment_mode.free_end_gap_x() {\n                // Cache column probabilities or simply record the last probability.\n                // We can put all of them in one array since we simply have to sum in the end.\n                // This is also good for numerical stability.\n                self.prob_cols.push(*self.fm[curr].last().unwrap());\n                self.prob_cols.push(*self.fx[curr].last().unwrap());\n                // TODO check removing this (we don't want open gaps in x):\n                self.prob_cols.push(*self.fy[curr].last().unwrap());\n            }\n\n            // next column\n            mem::swap(\u0026mut curr, \u0026mut prev);\n            // reset next column to zeros\n            for v in \u0026mut self.fm[curr] {\n                *v = LogProb::ln_zero();\n            }\n        }\n\n        let p = if alignment_mode.free_end_gap_x() {\n            LogProb::ln_sum_exp(\u0026self.prob_cols)\n        } else {\n            LogProb::ln_sum_exp(\u0026[\n                *self.fm[prev].last().unwrap(),\n                *self.fx[prev].last().unwrap(),\n                *self.fy[prev].last().unwrap(),\n            ])\n        };\n        // take the minimum with 1.0, because sum of paths can exceed probability 1.0\n        // especially in case of repeats\n        assert!(!p.is_nan());\n        if p \u003e LogProb::ln_one() {\n            LogProb::ln_one()\n        } else {\n            p\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::stats::{LogProb, Prob};\n\n    use super::*;\n\n    // Single base insertion and deletion rates for R1 according to Schirmer et al.\n    // BMC Bioinformatics 2016, 10.1186/s12859-016-0976-y\n    static PROB_ILLUMINA_INS: Prob = Prob(2.8e-6);\n    static PROB_ILLUMINA_DEL: Prob = Prob(5.1e-6);\n    static PROB_ILLUMINA_SUBST: Prob = Prob(0.0021);\n\n    fn prob_emit_x_or_y() -\u003e LogProb {\n        LogProb::from(Prob(1.0) - PROB_ILLUMINA_SUBST)\n    }\n\n    struct TestEmissionParams {\n        x: \u0026'static [u8],\n        y: \u0026'static [u8],\n    }\n\n    impl EmissionParameters for TestEmissionParams {\n        fn prob_emit_xy(\u0026self, i: usize, j: usize) -\u003e XYEmission {\n            if self.x[i] == self.y[j] {\n                XYEmission::Match(LogProb::from(Prob(1.0) - PROB_ILLUMINA_SUBST))\n            } else {\n                XYEmission::Mismatch(LogProb::from(PROB_ILLUMINA_SUBST / Prob(3.0)))\n            }\n        }\n\n        fn prob_emit_x(\u0026self, _: usize) -\u003e LogProb {\n            prob_emit_x_or_y()\n        }\n\n        fn prob_emit_y(\u0026self, _: usize) -\u003e LogProb {\n            prob_emit_x_or_y()\n        }\n\n        fn len_x(\u0026self) -\u003e usize {\n            self.x.len()\n        }\n\n        fn len_y(\u0026self) -\u003e usize {\n            self.y.len()\n        }\n    }\n\n    struct TestSingleGapParams;\n\n    impl GapParameters for TestSingleGapParams {\n        fn prob_gap_x(\u0026self) -\u003e LogProb {\n            LogProb::from(PROB_ILLUMINA_INS)\n        }\n\n        fn prob_gap_y(\u0026self) -\u003e LogProb {\n            LogProb::from(PROB_ILLUMINA_DEL)\n        }\n\n        fn prob_gap_x_extend(\u0026self) -\u003e LogProb {\n            LogProb::ln_zero()\n        }\n\n        fn prob_gap_y_extend(\u0026self) -\u003e LogProb {\n            LogProb::ln_zero()\n        }\n    }\n\n    impl StartEndGapParameters for TestSingleGapParams {\n        fn free_start_gap_x(\u0026self) -\u003e bool {\n            false\n        }\n\n        fn free_end_gap_x(\u0026self) -\u003e bool {\n            false\n        }\n    }\n\n    pub enum AlignmentMode {\n        Global,\n        Semiglobal,\n    }\n\n    impl StartEndGapParameters for AlignmentMode {\n        fn free_start_gap_x(\u0026self) -\u003e bool {\n            match self {\n                AlignmentMode::Semiglobal =\u003e true,\n                AlignmentMode::Global =\u003e false,\n            }\n        }\n\n        fn free_end_gap_x(\u0026self) -\u003e bool {\n            match self {\n                AlignmentMode::Semiglobal =\u003e true,\n                AlignmentMode::Global =\u003e false,\n            }\n        }\n    }\n\n    const EMIT_MATCH: LogProb = LogProb(-0.0021022080918701985);\n    const EMIT_GAP_X: LogProb = LogProb(-0.0021022080918701985);\n    const EMIT_GAP_Y: LogProb = LogProb(-0.0021022080918701985);\n    const T_MATCH: LogProb = LogProb(-7.900_031_205_113_962e-6);\n    const T_GAP_X: LogProb = LogProb(-12.785891140783116);\n    const T_GAP_Y: LogProb = LogProb(-12.186270018233994);\n\n    #[test]\n    fn impossible_global_alignment() {\n        let x = b\"AAA\";\n        let y = b\"A\";\n        let emission_params = TestEmissionParams { x, y };\n\n        let mut pair_hmm = PairHMM::new(\u0026TestSingleGapParams);\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026AlignmentMode::Global, None);\n        assert_eq!(p, LogProb::ln_zero());\n    }\n\n    #[test]\n    fn test_interleave_gaps_y() {\n        let x = b\"ACGTACGTACGT\";\n        let y = b\"AGAGAG\";\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let mut pair_hmm = PairHMM::new(\u0026TestSingleGapParams);\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026AlignmentMode::Global, None);\n\n        let n_matches = 6.;\n        let n_insertions = 6.;\n\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH * (n_matches - n_insertions)\n                + *EMIT_GAP_Y * n_insertions\n                + *T_GAP_Y * n_insertions\n                + (1. - *PROB_ILLUMINA_DEL).ln() * n_insertions,\n        );\n\n        let p_max = LogProb(*T_GAP_Y * n_insertions);\n\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_interleave_gaps_x() {\n        let x = b\"AGAGAG\";\n        let y = b\"ACGTACGTACGT\";\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let mut pair_hmm = PairHMM::new(\u0026TestSingleGapParams);\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026AlignmentMode::Global, None);\n\n        let n_matches = 6.;\n        let n_insertions = 6.;\n\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH * (n_matches - n_insertions)\n                + *EMIT_GAP_X * n_insertions\n                + *T_GAP_X * n_insertions\n                + (1. - *PROB_ILLUMINA_INS).ln() * n_insertions,\n        );\n\n        let p_max = LogProb(*T_GAP_X * n_insertions);\n\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_same() {\n        let x = b\"AGCTCGATCGATCGATC\";\n        let y = b\"AGCTCGATCGATCGATC\";\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let mut pair_hmm = PairHMM::new(\u0026TestSingleGapParams);\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026AlignmentMode::Global, None);\n        let n = x.len() as f64;\n        let p_most_likely_path = LogProb(*EMIT_MATCH * n + *T_MATCH * (n - 1.));\n        let p_max = LogProb(*EMIT_MATCH * n);\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.001);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.001);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_gap_x() {\n        let x = b\"AGCTCGATCGATCGATC\";\n        let y = b\"AGCTCGATCTGATCGATCT\";\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let mut pair_hmm = PairHMM::new(\u0026TestSingleGapParams);\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026AlignmentMode::Global, None);\n\n        let n_matches = 17.;\n        let n_insertions = 2.;\n\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH * (n_matches - n_insertions)\n                + *EMIT_GAP_X * n_insertions\n                + *T_GAP_X * n_insertions\n                + (1. - *PROB_ILLUMINA_INS).ln(),\n        );\n\n        let p_max = LogProb(*T_GAP_X * 2.);\n\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_gap_y() {\n        let x = b\"AGCTCGATCTGATCGATCT\";\n        let y = b\"AGCTCGATCGATCGATC\";\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let mut pair_hmm = PairHMM::new(\u0026TestSingleGapParams);\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026AlignmentMode::Global, None);\n\n        let n_matches = 17.;\n        let n_deletions = 2.;\n\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH * (n_matches - n_deletions)\n                + *EMIT_GAP_Y * n_deletions\n                + *T_GAP_Y * n_deletions\n                + (1. - *PROB_ILLUMINA_DEL).ln(),\n        );\n\n        let p_max = LogProb(*T_GAP_Y * 2.);\n\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_mismatch() {\n        let x = b\"AGCTCGAGCGATCGATC\";\n        let y = b\"TGCTCGATCGATCGATC\";\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let mut pair_hmm = PairHMM::new(\u0026TestSingleGapParams);\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026AlignmentMode::Global, None);\n\n        let n = x.len() as f64;\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * (n - 2.) + *T_MATCH * (n - 1.) + (*PROB_ILLUMINA_SUBST / 3.).ln() * 2.,\n        );\n        let p_max = LogProb((*PROB_ILLUMINA_SUBST / 3.).ln() * 2.);\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 1e-4);\n        assert_relative_eq!(*p, *p_max, epsilon = 1e-1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_banded() {\n        let x = b\"GATCACAGGTCTATCACCCTATTAACCACTCACGGGAGCTCTCCATGC\\\nATTTGGTATTTTCGTCTGGGGGGTATGCACGCGATAGCATTGCGAGACGCTGGAGCCGGAGCACCCTATGTCGCAGTAT\\\nCTGTCTTTGATTCCTGCCTCATCCTATTATTTATCGCACCTACGTTCAATATTACAGGCGAACATACTTACTAAAGTGT\";\n\n        let y = b\"GGGTATGCACGCGATAGCATTGCGAGATGCTGGAGCTGGAGCACCCTATGTCGC\";\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let mut pair_hmm = PairHMM::new(\u0026TestSingleGapParams);\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026AlignmentMode::Semiglobal, None);\n\n        let p_banded = pair_hmm.prob_related(\u0026emission_params, \u0026AlignmentMode::Semiglobal, Some(2));\n\n        assert_relative_eq!(*p, *p_banded, epsilon = 1e-7);\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[4952649,4951209,4952016,4950576],"length":1,"stats":{"Line":2},"fn_name":"new\u003cbio::stats::pairhmm::homopolypairhmm::tests::test_phmm_vs_phhmm::TestSingleGapParamsPairHMM\u003e"},{"line":76,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":297,"address":[4925632],"length":1,"stats":{"Line":3},"fn_name":"prob_emit_x_or_y"},{"line":298,"address":[4925636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":391,"address":[4926957,4926560],"length":1,"stats":{"Line":3},"fn_name":"impossible_global_alignment"},{"line":392,"address":[4926567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[4926582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[4926597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":396,"address":[4926639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":397,"address":[4926656],"length":1,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[4926729,4926785,4926911],"length":1,"stats":{"Line":2},"fn_name":null},{"line":402,"address":[4926992,4930216],"length":1,"stats":{"Line":3},"fn_name":"test_interleave_gaps_y"},{"line":403,"address":[4927006],"length":1,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[4927021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":406,"address":[4927036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":408,"address":[4927090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":409,"address":[4927110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":411,"address":[4927205],"length":1,"stats":{"Line":1},"fn_name":null},{"line":412,"address":[4927213],"length":1,"stats":{"Line":1},"fn_name":null},{"line":415,"address":[4927443,4927372,4927622,4927514,4927221,4927294],"length":1,"stats":{"Line":6},"fn_name":null},{"line":416,"address":[4927319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":417,"address":[4927385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[4927456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":419,"address":[4927527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[4927635],"length":1,"stats":{"Line":1},"fn_name":null},{"line":424,"address":[4927701,4927769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[4927751,4927809,4928067],"length":1,"stats":{"Line":2},"fn_name":null},{"line":426,"address":[4929255,4928046,4928997],"length":1,"stats":{"Line":2},"fn_name":null},{"line":427,"address":[4929234,4930183,4930107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":431,"address":[4933480,4930256],"length":1,"stats":{"Line":3},"fn_name":"test_interleave_gaps_x"},{"line":432,"address":[4930270],"length":1,"stats":{"Line":1},"fn_name":null},{"line":433,"address":[4930285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[4930300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":437,"address":[4930354],"length":1,"stats":{"Line":1},"fn_name":null},{"line":438,"address":[4930374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":440,"address":[4930469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":441,"address":[4930477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":444,"address":[4930707,4930778,4930886,4930485,4930558,4930636],"length":1,"stats":{"Line":6},"fn_name":null},{"line":445,"address":[4930583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[4930649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[4930720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":448,"address":[4930791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":451,"address":[4930899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":453,"address":[4930965,4931033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":454,"address":[4931073,4931331,4931015],"length":1,"stats":{"Line":2},"fn_name":null},{"line":455,"address":[4931310,4932519,4932261],"length":1,"stats":{"Line":2},"fn_name":null},{"line":456,"address":[4933447,4932498,4933371],"length":1,"stats":{"Line":2},"fn_name":null},{"line":460,"address":[4936587,4933520],"length":1,"stats":{"Line":3},"fn_name":"test_same"},{"line":461,"address":[4933534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":462,"address":[4933549],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[4933564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":466,"address":[4933618],"length":1,"stats":{"Line":1},"fn_name":null},{"line":467,"address":[4933638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":468,"address":[4933723,4933805],"length":1,"stats":{"Line":2},"fn_name":null},{"line":469,"address":[4933862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[4934005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[4934140,4934072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[4934438,4934180,4934122],"length":1,"stats":{"Line":2},"fn_name":null},{"line":473,"address":[4935368,4934417,4935626],"length":1,"stats":{"Line":2},"fn_name":null},{"line":474,"address":[4935605,4936554,4936478],"length":1,"stats":{"Line":2},"fn_name":null},{"line":478,"address":[4939827,4936624],"length":1,"stats":{"Line":3},"fn_name":"test_gap_x"},{"line":479,"address":[4936638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[4936653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":482,"address":[4936668],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[4936722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[4936742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[4936837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[4936855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":491,"address":[4937082,4937241,4937145,4936863,4936936,4937019],"length":1,"stats":{"Line":6},"fn_name":null},{"line":492,"address":[4936961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":493,"address":[4937032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":494,"address":[4937095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":495,"address":[4937158],"length":1,"stats":{"Line":1},"fn_name":null},{"line":498,"address":[4937254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[4937380,4937312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":501,"address":[4937420,4937362,4937678],"length":1,"stats":{"Line":2},"fn_name":null},{"line":502,"address":[4938608,4937657,4938866],"length":1,"stats":{"Line":2},"fn_name":null},{"line":503,"address":[4939794,4939718,4938845],"length":1,"stats":{"Line":2},"fn_name":null},{"line":507,"address":[4939872,4943075],"length":1,"stats":{"Line":3},"fn_name":"test_gap_y"},{"line":508,"address":[4939886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[4939901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[4939916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[4939970],"length":1,"stats":{"Line":1},"fn_name":null},{"line":514,"address":[4939990],"length":1,"stats":{"Line":1},"fn_name":null},{"line":516,"address":[4940085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[4940103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[4940111,4940184,4940330,4940489,4940393,4940267],"length":1,"stats":{"Line":6},"fn_name":null},{"line":521,"address":[4940209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[4940280],"length":1,"stats":{"Line":1},"fn_name":null},{"line":523,"address":[4940343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[4940406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":527,"address":[4940502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":529,"address":[4940628,4940560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":530,"address":[4940610,4940668,4940926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[4941856,4940905,4942114],"length":1,"stats":{"Line":2},"fn_name":null},{"line":532,"address":[4943042,4942966,4942093],"length":1,"stats":{"Line":2},"fn_name":null},{"line":536,"address":[4946327,4943120],"length":1,"stats":{"Line":3},"fn_name":"test_mismatch"},{"line":537,"address":[4943134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[4943149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":540,"address":[4943164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":542,"address":[4943218],"length":1,"stats":{"Line":1},"fn_name":null},{"line":543,"address":[4943238],"length":1,"stats":{"Line":1},"fn_name":null},{"line":545,"address":[4943323,4943405],"length":1,"stats":{"Line":2},"fn_name":null},{"line":547,"address":[4943462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":549,"address":[4943717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":550,"address":[4943880,4943812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":551,"address":[4943920,4944178,4943862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":552,"address":[4944157,4945108,4945366],"length":1,"stats":{"Line":2},"fn_name":null},{"line":553,"address":[4946218,4945345,4946294],"length":1,"stats":{"Line":2},"fn_name":null},{"line":557,"address":[4947812,4946368],"length":1,"stats":{"Line":3},"fn_name":"test_banded"},{"line":558,"address":[4946382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":562,"address":[4946397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":564,"address":[4946412],"length":1,"stats":{"Line":1},"fn_name":null},{"line":566,"address":[4946466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":567,"address":[4946486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":569,"address":[4946571,4946699],"length":1,"stats":{"Line":2},"fn_name":null},{"line":571,"address":[4946716,4946989],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":246,"coverable":260},{"path":["/","home","todd","rust-bio","src","stats","probs","cdf.rs"],"content":"// Copyright 2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Support for discrete probability distributions in terms of cumulative distribution\n//! functions (CDF).\n//!\n//! # Examples\n//!\n//! Example usage of all CDF functions:\n//! ```\n//! use approx::assert_relative_eq;\n//! use bio::stats::probs::cdf::{Entry, CDF};\n//! use bio::stats::probs::{LogProb, Prob};\n//! use ordered_float::NotNan;\n//! use std::ops::Range;\n//! // pmf1 is an example PMF with `LogProb(0.0)` at `0`, with `LogProb(0.1)`\n//! // at `{1, 2, ..., 8}` and LogProb(0.2) at `10`\n//! let mut pmf1 = vec![Entry::new(0, LogProb((0.0 as f64).ln()))];\n//! for i in 1..=8 {\n//!     pmf1.push(Entry::new(i, LogProb((0.1 as f64).ln())));\n//! }\n//! pmf1.push(Entry::new(10, LogProb((0.2 as f64).ln())));\n//!\n//! // create the cumulative distribution function from the probability mass function\n//! let cdf = CDF::from_pmf(pmf1.clone());\n//! assert_relative_eq!(*cdf.get(\u00260).unwrap(), (0.0 as f64).ln(), epsilon = 0.0);\n//! assert_relative_eq!(\n//!     *cdf.get(\u00263).unwrap(),\n//!     (0.3 as f64).ln(),\n//!     epsilon = 0.0000000001\n//! );\n//!\n//! // get back the original probability mass value at 7\n//! assert_relative_eq!(\n//!     *cdf.get_pmf(\u00267).unwrap(),\n//!     (0.1 as f64).ln(),\n//!     epsilon = 0.00001\n//! );\n//!\n//! // Check that cdf sums up to 1.0\n//! assert_relative_eq!(\n//!     f64::from(cdf.total_prob()),\n//!     (1.0 as f64).ln(),\n//!     epsilon = 0.0\n//! );\n//!\n//! // copy a CDF via its iter() function\n//! let mut cdf_copy = CDF::from_cdf(cdf.iter().cloned());\n//! assert_eq!(cdf.len(), cdf_copy.len());\n//!\n//! // get the maximum a posteriori probability estimate\n//! assert_eq!(cdf_copy.map().unwrap(), \u002610);\n//!\n//! // get the 50% credible interval\n//! assert_eq!(cdf_copy.credible_interval(0.5).unwrap(), \u00262..\u00268);\n//!\n//! // cdf_vec is an example Entry vector with `LogProb(0.0)` at `ordered_float::NotNan`\n//! // values `{0.0, 1.0, 2.0}` and increasing by `LogProb(0.2)` at each to `{3.0, 4.0, ..., 7.0}`\n//! let mut cdf_vec = Vec::new();\n//! for i in 0..=2 {\n//!     cdf_vec.push(Entry::new(\n//!         NotNan::new(i as f64).unwrap(),\n//!         LogProb::ln_zero(),\n//!     ))\n//! }\n//! for i in 3..=7 {\n//!     cdf_vec.push(Entry::new(\n//!         NotNan::new(i as f64).unwrap(),\n//!         LogProb(((i - 2) as f64 * 0.2f64).ln()),\n//!     ));\n//! }\n//!\n//! // create cdf from vector of `Entry`s\n//! let mut cdf_from_vec = CDF::from_cdf(cdf_vec.into_iter());\n//!\n//! assert_relative_eq!(\n//!     *cdf_from_vec.get(\u0026NotNan::new(2.0).unwrap()).unwrap(),\n//!     LogProb::ln_zero(),\n//!     epsilon = 0.0\n//! );\n//! assert_relative_eq!(\n//!     *cdf_from_vec.get(\u0026NotNan::new(4.0).unwrap()).unwrap(),\n//!     LogProb((0.4 as f64).ln()),\n//!     epsilon = 0.0\n//! );\n//!\n//! // get the number of `Entry`s in cdf_from_vec\n//! assert_eq!(cdf_from_vec.len(), 8);\n//!\n//! // remove three zero values at `{0.0, 1.0, 2.0}` with `CDF::reduce()`\n//! cdf_from_vec = CDF::reduce(cdf_from_vec);\n//! assert_eq!(cdf_from_vec.len(), 5);\n//! ```\n\nuse std::f64;\nuse std::iter;\nuse std::ops::Range;\nuse std::slice;\n\nuse itertools::Itertools;\nuse ordered_float::OrderedFloat;\n\nuse crate::stats::LogProb;\n\n/// An `Entry` associates a `LogProb` with a value on an ordered axis. It can for example be\n/// used to set up probability mass functions or cumulative distribution functions ([CDF](struct.CDF)).\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Entry\u003cT: Ord\u003e {\n    /// A `value` on the ordered axis, which has to have the Trait [`std::cmp::Ord`](https://doc.rust-lang.org/std/cmp/trait.Ord.html) implemented.\n    pub value: T,\n    /// A probability at that `value` / point x on the x-axis.\n    pub prob: LogProb,\n}\n\nimpl\u003cT: Ord\u003e Entry\u003cT\u003e {\n    /// Create a new `Entry` for `prob` at `value`.\n    ///\n    /// `value` needs to have the Trait [`std::cmp::Ord`](https://doc.rust-lang.org/std/cmp/trait.Ord.html)\n    /// implemented. As `f64` only has PartialOrd, use something like the [`ordered_float` crate](https://docs.rs/ordered-float/1.0.2/ordered_float/)\n    /// if you want to use floating point numbers.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::stats::probs::cdf::Entry;\n    /// use bio::stats::LogProb;\n    /// let entry = Entry::new(5, LogProb(0.6));\n    /// assert_eq!(entry.value, 5);\n    /// assert_eq!(entry.prob, LogProb(0.6));\n    /// ```\n    pub fn new(value: T, prob: LogProb) -\u003e Self {\n        Entry { value, prob }\n    }\n}\n\n/// Implementation of a cumulative distribution function as a vector of `Entry`s.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CDF\u003cT: Ord\u003e {\n    inner: Vec\u003cEntry\u003cT\u003e\u003e,\n}\n\nimpl\u003cT: Ord\u003e CDF\u003cT\u003e {\n    /// Create CDF from a vector representing a probability mass function (PMF).\n    /// The PMF may contain duplicate values the probabilities of which are summed\n    /// during generation of the CDF.\n    ///\n    /// Runtime complexity: O(n log n), where n is the number of `entries`.\n    ///\n    /// # Arguments\n    ///\n    /// * `entries` - The PMF as a vector of `Entry` objects (values with an associated `LogProb`).\n    pub fn from_pmf(mut entries: Vec\u003cEntry\u003cT\u003e\u003e) -\u003e Self {\n        entries.sort_by(|a, b| a.value.cmp(\u0026b.value));\n        let mut inner: Vec\u003cEntry\u003cT\u003e\u003e = Vec::new();\n        for mut e in entries {\n            let p = inner\n                .last()\n                .map_or(LogProb::ln_zero(), |e| e.prob)\n                .ln_add_exp(e.prob);\n            if !inner.is_empty() \u0026\u0026 inner.last().unwrap().value == e.value {\n                inner.last_mut().unwrap().prob = p;\n            } else {\n                e.prob = p;\n                inner.push(e);\n            }\n        }\n        let mut cdf = CDF { inner };\n\n        // cap at prob=1.0 if there are slightly exceeding values due to numerical issues.\n        for e in \u0026mut cdf.inner {\n            e.prob = e.prob.cap_numerical_overshoot(0.00001);\n        }\n\n        cdf\n    }\n\n    /// Create CDF from iterator. This can be used to replace the values of a CDF.\n    ///\n    /// Runtime complexity: O(n), where n is the number of `entries`.\n    ///\n    /// # Arguments\n    ///\n    /// * `entries` - An iterator over `Entry\u003cT\u003e` values, where T requires\n    pub fn from_cdf\u003cI: Iterator\u003cItem = Entry\u003cT\u003e\u003e\u003e(entries: I) -\u003e Self {\n        CDF {\n            inner: entries.collect_vec(),\n        }\n    }\n\n    /// Reduce CDF by omitting values with zero probability.\n    ///\n    /// Runtime complexity: O(n), where n is the number of `value`s with `prob` of zero.\n    pub fn reduce(self) -\u003e Self {\n        let mut inner = Vec::new();\n        let mut last = LogProb::ln_zero();\n        for e in self.inner {\n            if last != e.prob {\n                last = e.prob;\n                inner.push(e);\n            }\n        }\n        CDF { inner }\n    }\n\n    /// Downsample CDF to n entries. Panics if n \u003c= 1 and returns identity if n is greater\n    /// than the number of entries.\n    ///\n    /// Runtime complexity: O(m), where m is the original number of `Entry`s in `CDF`.\n    ///\n    /// # Arguments\n    ///\n    /// * `n` - Number of entries after downsampling.\n    pub fn sample(mut self, n: usize) -\u003e Self {\n        assert!(n \u003e 1);\n        if self.inner.len() \u003c= n {\n            self\n        } else {\n            let s = self.inner.len() / (n - 1);\n            let last = self.inner.pop().unwrap();\n            let mut inner = self.inner.into_iter().step_by(s).collect_vec();\n            inner.push(last);\n            CDF { inner }\n        }\n    }\n\n    /// Provide an iterator for the CDF.\n    pub fn iter(\u0026self) -\u003e slice::Iter\u003c'_, Entry\u003cT\u003e\u003e {\n        self.inner.iter()\n    }\n\n    /// Provide a mutable iterator over entries.\n    ///\n    /// This does not check for consistency. In other words, you\n    /// should not change the order of the entries, nor the probabilities!\n    pub fn iter_mut(\u0026mut self) -\u003e slice::IterMut\u003c'_, Entry\u003cT\u003e\u003e {\n        self.inner.iter_mut()\n    }\n\n    /// Provide an iterator over the PMF corresponding to this CDF.\n    pub fn iter_pmf(\u0026self) -\u003e CDFPMFIter\u003c'_, T\u003e {\n        fn cdf_to_pmf\u003c'a, G: Ord\u003e(\n            last_prob: \u0026mut LogProb,\n            e: \u0026'a Entry\u003cG\u003e,\n        ) -\u003e Option\u003cEntry\u003c\u0026'a G\u003e\u003e {\n            let prob = e.prob.ln_sub_exp(*last_prob);\n            *last_prob = e.prob;\n            Some(Entry::new(\u0026e.value, prob))\n        }\n        self.inner.iter().scan(LogProb::ln_zero(), cdf_to_pmf)\n    }\n\n    /// Get cumulative probability for a given value.\n    ///\n    /// If the value is not present, return the probability of the previous value.\n    /// Time complexity: O(log n), where n is the number of `Entry`s in `CDF`.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - A value at which you're interested in the cumulative probability.\n    pub fn get(\u0026self, value: \u0026T) -\u003e Option\u003cLogProb\u003e {\n        if self.inner.is_empty() {\n            None\n        } else {\n            Some(match self.inner.binary_search_by(|e| e.value.cmp(value)) {\n                Ok(i) =\u003e self.inner[i].prob,\n                Err(i) =\u003e {\n                    if i \u003e 0 {\n                        self.inner[i - 1].prob\n                    } else {\n                        LogProb::ln_zero()\n                    }\n                }\n            })\n        }\n    }\n\n    /// Get probability (i.e. probability mass) for a given `value`.\n    ///\n    /// Time complexity: O(log n), where n is the number of `Entry`s in `CDF`.\n    pub fn get_pmf(\u0026self, value: \u0026T) -\u003e Option\u003cLogProb\u003e {\n        if self.inner.is_empty() {\n            None\n        } else {\n            Some(match self.inner.binary_search_by(|e| e.value.cmp(value)) {\n                Ok(i) =\u003e {\n                    if i \u003e 0 {\n                        self.inner[i].prob.ln_sub_exp(self.inner[i - 1].prob)\n                    } else {\n                        self.inner[0].prob\n                    }\n                }\n                Err(i) =\u003e {\n                    if i \u003e 0 {\n                        self.inner[i - 1].prob\n                    } else {\n                        LogProb::ln_zero()\n                    }\n                }\n            })\n        }\n    }\n\n    /// Return total probability of the `CDF`.\n    ///\n    /// Time complexity: O(1).\n    pub fn total_prob(\u0026self) -\u003e LogProb {\n        self.inner.last().map_or(LogProb::ln_zero(), |e| e.prob)\n    }\n\n    /// Return maximum a posteriori probability estimate (MAP).\n    ///\n    /// Time complexity: O(n), where n is the number of `Entry`s in `CDF`.\n    pub fn map(\u0026self) -\u003e Option\u003c\u0026T\u003e {\n        if let Some(mut max) = self.iter_pmf().next() {\n            for e in self.iter_pmf() {\n                if e.prob \u003e= max.prob {\n                    max = e;\n                }\n            }\n            Some(max.value)\n        } else {\n            None\n        }\n    }\n\n    /// Return w%-credible interval. The width w is a float between 0 and 1. Panics otherwise.\n    /// E.g. provide `width=0.95` for the 95% credible interval.\n    ///\n    /// Runtime complexity: O(log n), where n is the number of `Entry`s in `CDF`.\n    ///\n    /// # Arguments\n    ///\n    /// * `width` - wanted width of the credible interval as a fraction of 1.\n    pub fn credible_interval(\u0026self, width: f64) -\u003e Option\u003cRange\u003c\u0026T\u003e\u003e {\n        assert!((0.0..=1.0).contains(\u0026width));\n\n        if self.inner.is_empty() {\n            return None;\n        }\n\n        let margin = 1.0 - width;\n        let p_lower = OrderedFloat((margin / 2.0).ln());\n        let p_upper = OrderedFloat((1.0 - margin / 2.0).ln());\n        let lower = self\n            .inner\n            .binary_search_by(|e| OrderedFloat(*e.prob).cmp(\u0026p_lower))\n            .unwrap_or_else(|i| if i \u003e 0 { i - 1 } else { 0 });\n        let mut upper = self\n            .inner\n            .binary_search_by(|e| OrderedFloat(*e.prob).cmp(\u0026p_upper))\n            .unwrap_or_else(|i| i);\n        if upper == self.inner.len() {\n            upper -= 1;\n        }\n\n        Some(\u0026self.inner[lower].value..\u0026self.inner[upper].value)\n    }\n\n    /// Number of `Entry`s in the `CDF`.\n    ///\n    /// Time complexity: O(1)\n    pub fn len(\u0026self) -\u003e usize {\n        self.inner.len()\n    }\n\n    /// Returns `true` if a CDF is empty, false otherwise.\n    ///\n    /// Time complexity: O(1)\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.inner.is_empty()\n    }\n}\n\nimpl\u003cT: Clone + Ord\u003e CDF\u003cT\u003e\nwhere\n    f64: From\u003cT\u003e,\n{\n    /// Calculate expected value.\n    ///\n    /// Runtime complexity: O(n), where n is the number of `Entry`s in `CDF`.\n    pub fn expected_value(\u0026self) -\u003e f64 {\n        self.iter_pmf()\n            .map(|e| f64::from(e.value.clone()) * e.prob.exp())\n            .fold(0.0f64, |s, e| s + e)\n    }\n\n    /// Calculate variance.\n    ///\n    /// Runtime complexity: O(n), where n is the number of `Entry`s in `CDF`.\n    pub fn variance(\u0026self) -\u003e f64 {\n        let ev = self.expected_value();\n        self.iter_pmf()\n            .map(|e| (f64::from(e.value.clone()) - ev).powi(2) * e.prob.exp())\n            .fold(0.0, |s, e| s + e)\n    }\n\n    /// Calculate standard deviation.\n    ///\n    /// Runtime complexity: O(n), where n is the number of `Entry`s in `CDF`.\n    pub fn standard_deviation(\u0026self) -\u003e f64 {\n        self.variance().sqrt()\n    }\n}\n\npub type CDFPMFIter\u003c'a, T\u003e = iter::Scan\u003c\n    slice::Iter\u003c'a, Entry\u003cT\u003e\u003e,\n    LogProb,\n    fn(\u0026mut LogProb, \u0026'a Entry\u003cT\u003e) -\u003e Option\u003cEntry\u003c\u0026'a T\u003e\u003e,\n\u003e;\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::stats::LogProb;\n    use ordered_float::NotNan;\n\n    #[test]\n    fn test_cdf() {\n        let mut pmf = vec![Entry::new(NotNan::new(0.0).unwrap(), LogProb(0.1f64.ln()))];\n        for i in 0..9 {\n            pmf.push(Entry::new(\n                NotNan::new(i as f64).unwrap(),\n                LogProb(0.1f64.ln()),\n            ));\n        }\n        println!(\"{:?}\", pmf);\n\n        let cdf = CDF::from_pmf(pmf.clone());\n        println!(\"{:?}\", cdf);\n        for e in pmf.iter().skip(2) {\n            assert_relative_eq!(*e.prob, *cdf.get_pmf(\u0026e.value).unwrap(), epsilon = 0.000003);\n        }\n        assert_relative_eq!(*cdf.total_prob(), 1.0f64.ln());\n        assert_relative_eq!(\n            *cdf.get(\u0026NotNan::new(1.0).unwrap()).unwrap(),\n            0.3f64.ln(),\n            epsilon = 0.00000001\n        );\n        {\n            let ci = cdf.credible_interval(0.95).unwrap();\n            assert_relative_eq!(**ci.start, 0.0);\n            assert_relative_eq!(**ci.end, 8.0);\n        }\n\n        {\n            for e in cdf.iter_pmf() {\n                assert_relative_eq!(\n                    e.prob.exp(),\n                    if **e.value == 0.0 { 0.2 } else { 0.1 },\n                    epsilon = 0.0001\n                );\n            }\n        }\n\n        assert_relative_eq!(cdf.sample(5).total_prob().exp(), 1.0);\n    }\n}\n","traces":[{"line":133,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[5251789,5251488],"length":1,"stats":{"Line":3},"fn_name":"test_cdf"},{"line":421,"address":[5251508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[5252307,5251804,5252090,5251936],"length":1,"stats":{"Line":4},"fn_name":null},{"line":423,"address":[5252240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":424,"address":[5252118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[5252197],"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[5252328,5252027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":430,"address":[5252420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":431,"address":[5252640,5252466],"length":1,"stats":{"Line":2},"fn_name":null},{"line":432,"address":[5252942,5253342,5252667],"length":1,"stats":{"Line":3},"fn_name":null},{"line":433,"address":[5252982,5253347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[5254277,5252923,5254552],"length":1,"stats":{"Line":2},"fn_name":null},{"line":436,"address":[5255558,5255809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":437,"address":[5255340,5254522],"length":1,"stats":{"Line":2},"fn_name":null},{"line":438,"address":[5255516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[5256747,5255777],"length":1,"stats":{"Line":2},"fn_name":null},{"line":443,"address":[5257032,5256826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":444,"address":[5257988,5257011,5257811],"length":1,"stats":{"Line":2},"fn_name":null},{"line":448,"address":[5259449,5258775,5259011,5257978],"length":1,"stats":{"Line":4},"fn_name":null},{"line":449,"address":[5259246,5259454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[5259087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":451,"address":[5259151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[5260384,5258940,5260730],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":77,"coverable":129},{"path":["/","home","todd","rust-bio","src","stats","probs","errors.rs"],"content":"// Copyright 2019 Johannes Köster, University of Duisburg-Essen.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Error definitions for the `probs` module.\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum Error {\n    #[error(\"probabilty {} not in interval [0,1]\", prob)]\n    InvalidProb { prob: f64 },\n}\npub type Result\u003cT, E = Error\u003e = std::result::Result\u003cT, E\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","stats","probs","mod.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Handling log-probabilities. Log probabilities are an important tool to deal with probabilities\n//! in a numerically stable way, in particular when having probabilities close to zero.\n\npub mod cdf;\npub mod errors;\n\nuse std::f64;\nuse std::iter;\nuse std::mem;\nuse std::ops::{Add, AddAssign, Div, Mul, Sub, SubAssign};\n\nuse itertools::Itertools;\nuse itertools_num::linspace;\nuse num_traits::{Float, Zero};\nuse ordered_float::NotNan;\n\nuse crate::utils::FastExp;\n\npub use self::errors::{Error, Result};\n\n/// A factor to convert log-probabilities to PHRED-scale (phred = p * `LOG_TO_PHRED_FACTOR`).\nconst LOG_TO_PHRED_FACTOR: f64 = -4.342_944_819_032_517_5; // -10 * 1 / ln(10)\n\n/// A factor to convert PHRED-scale to log-probabilities (p = phred * `PHRED_TO_LOG_FACTOR`).\nconst PHRED_TO_LOG_FACTOR: f64 = -0.230_258_509_299_404_56; // 1 / (-10 * log10(e))\n\n/// Calculate log(1 - p) with p given in log space without loss of precision as described in\n/// http://cran.r-project.org/web/packages/Rmpfr/vignettes/log1mexp-note.pdf.\nfn ln_1m_exp(p: f64) -\u003e f64 {\n    assert!(p \u003c= 0.0);\n    if p \u003c -0.693 {\n        (-p.fastexp()).ln_1p()\n    } else {\n        (-p.exp_m1()).ln()\n    }\n}\n\ncustom_derive! {\n    /// A newtype for probabilities.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// #[macro_use]\n    /// extern crate approx;\n    /// # extern crate bio;\n    /// # fn main() {\n    /// use bio::stats::Prob;\n    ///\n    /// let p = Prob(0.5);\n    /// let q = Prob(0.2);\n    ///\n    /// assert_relative_eq!(*(p + q), *Prob(0.7));\n    /// # }\n    /// ```\n    #[derive(\n        NewtypeFrom,\n        NewtypeDeref,\n        NewtypeAdd(*),\n        NewtypeSub(*),\n        NewtypeMul(*),\n        NewtypeDiv(*),\n        PartialEq,\n        PartialOrd,\n        Copy,\n        Clone,\n        Debug,\n        Default\n    )]\n    #[derive(Serialize, Deserialize)]\n    pub struct Prob(pub f64);\n}\n\nimpl Prob {\n    pub fn checked(p: f64) -\u003e Result\u003cSelf\u003e {\n        if (0.0..=1.0).contains(\u0026p) {\n            Ok(Prob(p))\n        } else {\n            Err(Error::InvalidProb { prob: p })\n        }\n    }\n}\n\ncustom_derive! {\n    /// A newtype for log-scale probabilities.\n    /// For performance reasons, we use an approximation of the exp method\n    /// implemented in `bio::utils::FastExp`. This can lead to slight\n    /// errors, but should not matter given that most of the probability differences\n    /// are reflected within the integer part of the log probability.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// #[macro_use]\n    /// extern crate approx;\n    /// # extern crate bio;\n    /// # fn main() {\n    /// use bio::stats::{LogProb, Prob};\n    ///\n    /// // convert from probability\n    /// let p = LogProb::from(Prob(0.5));\n    /// // convert manually\n    /// let q = LogProb(0.2f64.ln());\n    /// // obtain zero probability in log-space\n    /// let o = LogProb::ln_one();\n    ///\n    /// assert_relative_eq!(*Prob::from(p.ln_add_exp(q) + o), *Prob(0.7), epsilon=0.000001);\n    /// # }\n    /// ```\n    #[derive(\n        NewtypeFrom,\n        NewtypeDeref,\n        NewtypeAdd(*),\n        NewtypeSub(*),\n        PartialEq,\n        PartialOrd,\n        Copy,\n        Clone,\n        Debug\n    )]\n    #[derive(Serialize, Deserialize)]\n    pub struct LogProb(pub f64);\n}\n\ncustom_derive! {\n    /// A newtype for PHRED-scale probabilities.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// #[macro_use]\n    /// extern crate approx;\n    /// # extern crate bio;\n    /// # fn main() {\n    /// use bio::stats::{PHREDProb, Prob};\n    ///\n    /// let p = PHREDProb::from(Prob(0.5));\n    ///\n    /// assert_relative_eq!(*Prob::from(p), *Prob(0.5));\n    /// # }\n    /// ```\n    #[derive(\n        NewtypeFrom,\n        NewtypeDeref,\n        NewtypeAdd(*),\n        NewtypeSub(*),\n        PartialEq,\n        PartialOrd,\n        Copy,\n        Clone,\n        Debug\n    )]\n    #[derive(Serialize, Deserialize)]\n    pub struct PHREDProb(pub f64);\n}\n\n/// Iterator returned by scans over logprobs.\npub type ScanIter\u003cI\u003e = iter::Scan\u003c\n    \u003cI as IntoIterator\u003e::IntoIter,\n    LogProb,\n    fn(\u0026mut LogProb, LogProb) -\u003e Option\u003cLogProb\u003e,\n\u003e;\n\nstatic LOGPROB_LN_ZERO: LogProb = LogProb(f64::NEG_INFINITY);\nstatic LOGPROB_LN_ONE: LogProb = LogProb(0.0);\n\nimpl LogProb {\n    pub fn is_valid(\u0026self) -\u003e bool {\n        !self.is_nan() \u0026\u0026 **self \u003c= 0.0\n    }\n\n    /// Log-space representation of Pr=0\n    #[inline]\n    pub fn ln_zero() -\u003e LogProb {\n        LOGPROB_LN_ZERO\n    }\n\n    /// Log-space representation of Pr=1\n    #[inline]\n    pub fn ln_one() -\u003e LogProb {\n        LOGPROB_LN_ONE\n    }\n\n    /// sums of LogProbs, e.g. with `ln_sum_exp()` can end up\n    /// slightly above the maximum of `LogProb \u003c= 0` due to\n    /// numerical imprecisions -- this function can rescue such\n    /// values before panics due to asserts in other functions\n    /// handling LogProbs, e.g. `ln_1m_exp`\n    pub fn cap_numerical_overshoot(\u0026self, epsilon: f64) -\u003e LogProb {\n        if *self \u003c= LogProb::ln_one() {\n            *self\n        } else {\n            let capped = **self - epsilon;\n            if capped \u003c= 0.0 {\n                LogProb::ln_one()\n            } else {\n                panic!(\n                    \"Cannot correct LogProb {:?} -- not within given epsilon of 0.0 ({})\",\n                    **self, epsilon\n                );\n            }\n        }\n    }\n\n    /// Numerically stable calculation of 1 - p in log-space.\n    pub fn ln_one_minus_exp(\u0026self) -\u003e LogProb {\n        LogProb(ln_1m_exp(**self))\n    }\n\n    /// Numerically stable sum of probabilities in log-space.\n    pub fn ln_sum_exp(probs: \u0026[LogProb]) -\u003e LogProb {\n        if probs.is_empty() {\n            Self::ln_zero()\n        } else {\n            let mut pmax = probs[0];\n            let mut imax = 0;\n            for (i, \u0026p) in probs.iter().enumerate().skip(1) {\n                if p \u003e pmax {\n                    pmax = p;\n                    imax = i;\n                }\n            }\n            if pmax == Self::ln_zero() {\n                Self::ln_zero()\n            } else if *pmax == f64::INFINITY {\n                LogProb(f64::INFINITY)\n            } else {\n                pmax + LogProb(\n                    (probs\n                        .iter()\n                        .enumerate()\n                        .filter_map(|(i, p)| {\n                            if i == imax || *p == Self::ln_zero() {\n                                None\n                            } else {\n                                Some((p - pmax).fastexp())\n                            }\n                        })\n                        .sum::\u003cf64\u003e())\n                    .ln_1p(),\n                )\n            }\n        }\n    }\n\n    /// Numerically stable addition of probabilities in log-space.\n    pub fn ln_add_exp(self, other: LogProb) -\u003e LogProb {\n        if other == Self::ln_zero() {\n            // do nothing\n            self\n        } else {\n            let (mut p0, mut p1) = (self, other);\n            if p1 \u003e p0 {\n                mem::swap(\u0026mut p0, \u0026mut p1);\n            }\n            if p0 == Self::ln_zero() {\n                Self::ln_zero()\n            } else if *p0 == f64::INFINITY {\n                LogProb(f64::INFINITY)\n            } else {\n                p0 + LogProb((p1 - p0).fastexp().ln_1p())\n            }\n        }\n    }\n\n    /// Numerically stable subtraction of probabilities in log-space.\n    pub fn ln_sub_exp(self, other: LogProb) -\u003e LogProb {\n        if other == Self::ln_zero() {\n            self\n        } else {\n            let (p0, p1) = (self, other);\n            assert!(\n                p0 \u003e= p1,\n                \"Subtraction would lead to negative probability, which is undefined in log space.\"\n            );\n            if *p1 == f64::NEG_INFINITY {\n                p0\n            } else if relative_eq!(*p0, *p1) || p0 == Self::ln_zero() {\n                // the first case leads to zero,\n                // in the second case p0 and p1 are -inf, which is fine\n                Self::ln_zero()\n            } else if *p0 == f64::INFINITY {\n                LogProb(f64::INFINITY)\n            } else {\n                p0 + (p1 - p0).ln_one_minus_exp()\n            }\n        }\n    }\n\n    /// Calculate the cumulative sum of the given probabilities in a numerically stable way (Durbin 1998).\n    pub fn ln_cumsum_exp\u003cI: IntoIterator\u003cItem = LogProb\u003e\u003e(probs: I) -\u003e ScanIter\u003cI\u003e {\n        probs\n            .into_iter()\n            .scan(Self::ln_zero(), Self::scan_ln_add_exp)\n    }\n\n    /// Integrate numerically stable over given log-space density in the interval [a, b]. Uses the trapezoidal rule with n grid points.\n    pub fn ln_trapezoidal_integrate_exp\u003cT, D\u003e(mut density: D, a: T, b: T, n: usize) -\u003e LogProb\n    where\n        T: Copy + Add\u003cOutput = T\u003e + Sub\u003cOutput = T\u003e + Div\u003cOutput = T\u003e + Mul\u003cOutput = T\u003e + Float,\n        D: FnMut(usize, T) -\u003e LogProb,\n        f64: From\u003cT\u003e,\n    {\n        let mut probs = linspace(a, b, n)\n            .enumerate()\n            .dropping(1)\n            .dropping_back(1)\n            .map(|(i, v)| LogProb(*density(i, v) + 2.0f64.ln()))\n            .collect_vec();\n        probs.push(density(0, a));\n        probs.push(density(n, b));\n        let width = f64::from(b - a);\n\n        LogProb(*Self::ln_sum_exp(\u0026probs) + width.ln() - (2.0 * (n - 1) as f64).ln())\n    }\n\n    /// Integrate numerically stable over given log-space density in the interval [a, b]. Uses Simpson's rule with n (odd) grid points.\n    pub fn ln_simpsons_integrate_exp\u003cT, D\u003e(mut density: D, a: T, b: T, n: usize) -\u003e LogProb\n    where\n        T: Copy + Add\u003cOutput = T\u003e + Sub\u003cOutput = T\u003e + Div\u003cOutput = T\u003e + Mul\u003cOutput = T\u003e + Float,\n        D: FnMut(usize, T) -\u003e LogProb,\n        f64: From\u003cT\u003e,\n    {\n        assert_eq!(n % 2, 1, \"n must be odd\");\n        let mut probs = linspace(a, b, n)\n            .enumerate()\n            .dropping(1)\n            .dropping_back(1)\n            .map(|(i, v)| {\n                let weight = (2 + (i % 2) * 2) as f64;\n                LogProb(*density(i, v) + weight.ln()) // factors alter between 2 and 4\n            })\n            .collect_vec();\n        probs.push(density(0, a));\n        probs.push(density(n, b));\n        let width = f64::from(b - a);\n\n        LogProb(*Self::ln_sum_exp(\u0026probs) + width.ln() - ((n - 1) as f64).ln() - 3.0f64.ln())\n    }\n\n    /// Integrate numerically stable over given log-space density and grid points. Uses the trapezoidal rule.\n    pub fn ln_trapezoidal_integrate_grid_exp\u003cT, D\u003e(mut density: D, grid: \u0026[T]) -\u003e LogProb\n    where\n        T: Copy + Add\u003cOutput = T\u003e + Sub\u003cOutput = T\u003e + Div\u003cOutput = T\u003e + Mul\u003cOutput = T\u003e + Float,\n        D: FnMut(usize, T) -\u003e LogProb,\n        f64: From\u003cT\u003e,\n    {\n        let probs = grid\n            .iter()\n            .enumerate()\n            .dropping(1)\n            .map(|(i, v)| {\n                LogProb(\n                    *(density(i - 1, grid[i - 1]).ln_add_exp(density(i, *v))) - 2.0f64.ln()\n                        + f64::from(*v - grid[i - 1]).ln(),\n                )\n            })\n            .collect_vec();\n        LogProb::ln_sum_exp(\u0026probs)\n    }\n\n    fn scan_ln_add_exp(s: \u0026mut LogProb, p: LogProb) -\u003e Option\u003cLogProb\u003e {\n        *s = s.ln_add_exp(p);\n        Some(*s)\n    }\n}\n\nimpl\u003c'a\u003e iter::Sum\u003c\u0026'a LogProb\u003e for LogProb {\n    fn sum\u003cI: Iterator\u003cItem = \u0026'a LogProb\u003e\u003e(iter: I) -\u003e Self {\n        iter.fold(LogProb(0.0), |a, b| a + *b)\n    }\n}\n\nimpl\u003c'a\u003e iter::Sum\u003cLogProb\u003e for LogProb {\n    fn sum\u003cI: Iterator\u003cItem = LogProb\u003e\u003e(iter: I) -\u003e Self {\n        iter.fold(LogProb(0.0), |a, b| a + b)\n    }\n}\n\nimpl AddAssign for LogProb {\n    fn add_assign(\u0026mut self, other: LogProb) {\n        *self = *self + other;\n    }\n}\n\nimpl SubAssign for LogProb {\n    fn sub_assign(\u0026mut self, other: LogProb) {\n        *self = *self - other;\n    }\n}\n\nimpl From\u003cNotNan\u003cf64\u003e\u003e for LogProb {\n    fn from(p: NotNan\u003cf64\u003e) -\u003e LogProb {\n        LogProb(*p)\n    }\n}\n\nimpl From\u003cLogProb\u003e for NotNan\u003cf64\u003e {\n    fn from(p: LogProb) -\u003e NotNan\u003cf64\u003e {\n        NotNan::from(*p)\n    }\n}\n\nimpl From\u003cLogProb\u003e for Prob {\n    fn from(p: LogProb) -\u003e Prob {\n        Prob(p.fastexp())\n    }\n}\n\nimpl From\u003cPHREDProb\u003e for Prob {\n    fn from(p: PHREDProb) -\u003e Prob {\n        Prob(10.0f64.powf(-*p / 10.0))\n    }\n}\n\nimpl From\u003cProb\u003e for LogProb {\n    fn from(p: Prob) -\u003e LogProb {\n        LogProb(p.ln())\n    }\n}\n\nimpl From\u003cPHREDProb\u003e for LogProb {\n    fn from(p: PHREDProb) -\u003e LogProb {\n        LogProb(*p * PHRED_TO_LOG_FACTOR)\n    }\n}\n\nimpl From\u003cProb\u003e for PHREDProb {\n    fn from(p: Prob) -\u003e PHREDProb {\n        PHREDProb(-10.0 * p.log10())\n    }\n}\n\nimpl From\u003cLogProb\u003e for PHREDProb {\n    fn from(p: LogProb) -\u003e PHREDProb {\n        PHREDProb(*p * LOG_TO_PHRED_FACTOR)\n    }\n}\n\nimpl Default for LogProb {\n    fn default() -\u003e LogProb {\n        LogProb::ln_zero()\n    }\n}\n\nimpl Default for PHREDProb {\n    fn default() -\u003e PHREDProb {\n        PHREDProb::from(Prob(0.0))\n    }\n}\n\nimpl Zero for Prob {\n    fn zero() -\u003e Self {\n        Prob(0.0)\n    }\n\n    fn is_zero(\u0026self) -\u003e bool {\n        **self == 0.0\n    }\n}\n\nimpl Zero for LogProb {\n    fn zero() -\u003e Self {\n        LogProb::ln_zero()\n    }\n\n    fn is_zero(\u0026self) -\u003e bool {\n        self.is_infinite() \u0026\u0026 self.signum() \u003c 0.0\n    }\n}\n\nimpl Zero for PHREDProb {\n    fn zero() -\u003e Self {\n        PHREDProb::from(Prob(0.0))\n    }\n\n    fn is_zero(\u0026self) -\u003e bool {\n        *self == Self::zero()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use itertools::Itertools;\n\n    #[test]\n    fn test_sum() {\n        let probs = [LogProb::ln_zero(), LogProb::ln_one(), LogProb::ln_zero()];\n        assert_eq!(LogProb::ln_sum_exp(\u0026probs), LogProb::ln_one());\n    }\n\n    #[test]\n    fn test_empty_sum() {\n        assert_eq!(LogProb::ln_sum_exp(\u0026[]), LogProb::ln_zero());\n    }\n\n    #[test]\n    fn test_cumsum() {\n        let probs = vec![\n            LogProb::ln_zero(),\n            LogProb(0.01f64.ln()),\n            LogProb(0.001f64.ln()),\n        ];\n        let cumsum = LogProb::ln_cumsum_exp(probs).collect_vec();\n\n        assert_relative_eq!(*cumsum[0], *LogProb::ln_zero());\n        assert_relative_eq!(*cumsum[1], 0.01f64.ln());\n        assert_relative_eq!(*cumsum[2], 0.011f64.ln(), epsilon = 0.000001);\n    }\n\n    #[test]\n    fn test_sub() {\n        assert_eq!(\n            LogProb::ln_one().ln_sub_exp(LogProb::ln_one()),\n            LogProb::ln_zero()\n        );\n        assert_relative_eq!(\n            *LogProb::ln_one().ln_sub_exp(LogProb(0.5f64.ln())),\n            *LogProb(0.5f64.ln()),\n            epsilon = 0.0000000001\n        );\n        assert_relative_eq!(\n            *LogProb(-1.6094379124341).ln_sub_exp(LogProb::ln_zero()),\n            *LogProb(-1.6094379124341)\n        );\n    }\n\n    #[test]\n    fn test_one_minus() {\n        assert_eq!(LogProb::ln_zero().ln_one_minus_exp(), LogProb::ln_one());\n        assert_eq!(LogProb::ln_one().ln_one_minus_exp(), LogProb::ln_zero());\n    }\n\n    #[test]\n    fn test_trapezoidal_integrate() {\n        let density = |_, _| LogProb(0.1f64.ln());\n        let prob = LogProb::ln_trapezoidal_integrate_exp(density, 0.0, 10.0, 5);\n        assert_relative_eq!(*prob, *LogProb::ln_one(), epsilon = 0.0000001);\n    }\n\n    #[test]\n    fn test_trapezoidal_integrate_grid() {\n        let grid: Vec\u003c_\u003e = linspace(0.0, 10.0, 5).collect();\n        let density = |_, _| LogProb(0.1f64.ln());\n        let prob = LogProb::ln_trapezoidal_integrate_grid_exp(density, \u0026grid);\n        assert_relative_eq!(*prob, *LogProb::ln_one(), epsilon = 0.0000001);\n    }\n\n    #[test]\n    fn test_simpsons_integrate() {\n        let density = |_, _| LogProb(0.1f64.ln());\n        let prob = LogProb::ln_simpsons_integrate_exp(density, 0.0, 10.0, 5);\n        assert_relative_eq!(*prob, *LogProb::ln_one(), epsilon = 0.0000001);\n    }\n\n    #[test]\n    fn test_cap_numerical_overshoot() {\n        let under_top = LogProb(-0.00000005);\n        assert_eq!(under_top, under_top.cap_numerical_overshoot(0.0000001));\n        let over_top = LogProb(0.00000005);\n        assert_eq!(\n            LogProb::ln_one(),\n            over_top.cap_numerical_overshoot(0.0000001)\n        );\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_cap_numerical_overshoot_panic() {\n        let over_top = LogProb(0.00000005);\n        over_top.cap_numerical_overshoot(0.00000001);\n    }\n\n    #[test]\n    fn test_sum_one_zero() {\n        assert_eq!(\n            LogProb::ln_one().ln_add_exp(LogProb::ln_zero()),\n            LogProb::ln_one()\n        );\n    }\n\n    #[test]\n    fn test_zero() {\n        assert!(LogProb::zero().is_zero());\n        assert!(Prob::zero().is_zero());\n        assert!(PHREDProb::zero().is_zero());\n    }\n}\n","traces":[{"line":34,"address":[4777840],"length":1,"stats":{"Line":1},"fn_name":"ln_1m_exp"},{"line":35,"address":[4777850,4777886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4777868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4777935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[4778045,4778009,4777916],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[4782475,4782448],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":76,"address":[4782029,4782093,4782334,4782404,4782158,4782291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[4778048],"length":1,"stats":{"Line":0},"fn_name":"checked"},{"line":81,"address":[4778058,4778123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[4778125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[4778090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[4784011,4783984],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":127,"address":[4783613,4783677,4783875,4783918,4783742],"length":1,"stats":{"Line":5},"fn_name":null},{"line":158,"address":[4785008,4785035],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":159,"address":[4784942,4784899,4784701,4784637,4784766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[4778176],"length":1,"stats":{"Line":0},"fn_name":"is_valid"},{"line":174,"address":[4778190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[4778288],"length":1,"stats":{"Line":1},"fn_name":"ln_zero"},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[4778304],"length":1,"stats":{"Line":1},"fn_name":"ln_one"},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[4778320],"length":1,"stats":{"Line":1},"fn_name":"cap_numerical_overshoot"},{"line":195,"address":[4778346],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[4778410],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[4778439,4778392],"length":1,"stats":{"Line":3},"fn_name":null},{"line":199,"address":[4778458],"length":1,"stats":{"Line":2},"fn_name":null},{"line":200,"address":[4778485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[4778503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[4778472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[4778736],"length":1,"stats":{"Line":1},"fn_name":"ln_one_minus_exp"},{"line":212,"address":[4778745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[4778800],"length":1,"stats":{"Line":1},"fn_name":"ln_sum_exp"},{"line":217,"address":[4778833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[4778872],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[4778955,4778858,4778907],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[4778920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[4778932,4778987,4779191,4779334],"length":1,"stats":{"Line":4},"fn_name":null},{"line":223,"address":[4779265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[4779308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[4779326],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[4779172,4779339],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[4779395],"length":1,"stats":{"Line":4},"fn_name":null},{"line":230,"address":[4779495,4779374,4779416],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[4779481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[4779643,4779448],"length":1,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[4779510,4779556,4779463],"length":1,"stats":{"Line":3},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[4779524],"length":1,"stats":{"Line":3},"fn_name":null},{"line":238,"address":[4839544,4839367,4839542],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[4839465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[4839443,4839490],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[4779680],"length":1,"stats":{"Line":1},"fn_name":"ln_add_exp"},{"line":253,"address":[4779708],"length":1,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[4779824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[4779754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[4779796,4779872,4779848],"length":1,"stats":{"Line":3},"fn_name":null},{"line":259,"address":[4779856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[4779874],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[4779932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[4779914,4779950,4780027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[4780013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[4779972,4780032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":272,"address":[4780144],"length":1,"stats":{"Line":1},"fn_name":"ln_sub_exp"},{"line":273,"address":[4780172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[4780306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[4780218],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[4780357,4780330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[4780275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[4780336,4780446,4780392],"length":1,"stats":{"Line":2},"fn_name":null},{"line":282,"address":[4780434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[4780414,4780451],"length":1,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[4780619],"length":1,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[4780640,4780720,4780601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[4780706],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[4780662,4780725],"length":1,"stats":{"Line":2},"fn_name":null},{"line":296,"address":[4839552,4839708],"length":1,"stats":{"Line":2},"fn_name":"ln_cumsum_exp\u003ccore::iter::adapters::map::Map\u003calloc::vec::into_iter::IntoIter\u003cusize, alloc::alloc::Global\u003e, closure-1\u003e\u003e"},{"line":297,"address":[4839569,4839634],"length":1,"stats":{"Line":4},"fn_name":null},{"line":299,"address":[4839662,4839733,4839720,4839610],"length":1,"stats":{"Line":2},"fn_name":null},{"line":303,"address":[5883904,5884737],"length":1,"stats":{"Line":1},"fn_name":"ln_trapezoidal_integrate_exp\u003cf64,closure-0\u003e"},{"line":309,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":323,"address":[5884944,5886095],"length":1,"stats":{"Line":1},"fn_name":"ln_simpsons_integrate_exp\u003cf64,closure-0\u003e"},{"line":329,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[5886411,5886343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[5886496,5886815],"length":1,"stats":{"Line":1},"fn_name":"ln_trapezoidal_integrate_grid_exp\u003cf64,closure-0\u003e"},{"line":353,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[4780784],"length":1,"stats":{"Line":1},"fn_name":"scan_ln_add_exp"},{"line":368,"address":[4780807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":369,"address":[4780838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[4780880],"length":1,"stats":{"Line":0},"fn_name":"add_assign"},{"line":387,"address":[4780903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[4780944],"length":1,"stats":{"Line":0},"fn_name":"sub_assign"},{"line":393,"address":[4780967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[4781008],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":399,"address":[4781018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[4983680],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":405,"address":[4983690],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[4781072],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":411,"address":[4781082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":416,"address":[4781152],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":417,"address":[4781162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[4781264],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":423,"address":[4781274],"length":1,"stats":{"Line":2},"fn_name":null},{"line":428,"address":[4781344],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":429,"address":[4781354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[4781408],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":435,"address":[4781418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":440,"address":[4781504],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":441,"address":[4781514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[4781568],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":447,"address":[4781569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[4781600],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":453,"address":[4781604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[4781648],"length":1,"stats":{"Line":1},"fn_name":"zero"},{"line":462,"address":[4781664],"length":1,"stats":{"Line":1},"fn_name":"is_zero"},{"line":463,"address":[4781673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":468,"address":[4781728],"length":1,"stats":{"Line":1},"fn_name":"zero"},{"line":469,"address":[4781729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[4781760],"length":1,"stats":{"Line":1},"fn_name":"is_zero"},{"line":473,"address":[4781774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[4781904],"length":1,"stats":{"Line":1},"fn_name":"zero"},{"line":479,"address":[4781908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":482,"address":[4781952],"length":1,"stats":{"Line":1},"fn_name":"is_zero"},{"line":483,"address":[4781966],"length":1,"stats":{"Line":1},"fn_name":null},{"line":493,"address":[5850752],"length":1,"stats":{"Line":3},"fn_name":"test_sum"},{"line":494,"address":[5850759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":495,"address":[5850828,5850953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":499,"address":[5850992],"length":1,"stats":{"Line":3},"fn_name":"test_empty_sum"},{"line":500,"address":[5851122,5850999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":504,"address":[5851168,5851417],"length":1,"stats":{"Line":3},"fn_name":"test_cumsum"},{"line":505,"address":[5851256,5851365,5851192],"length":1,"stats":{"Line":2},"fn_name":null},{"line":506,"address":[5851208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":507,"address":[5851297,5851232],"length":1,"stats":{"Line":2},"fn_name":null},{"line":508,"address":[5851314],"length":1,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[5851432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[5851886,5851522,5851625],"length":1,"stats":{"Line":2},"fn_name":null},{"line":513,"address":[5852925,5852664,5851845],"length":1,"stats":{"Line":2},"fn_name":null},{"line":514,"address":[5853704,5853993,5852884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":518,"address":[5854848],"length":1,"stats":{"Line":3},"fn_name":"test_sub"},{"line":519,"address":[5855071,5854934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[5854860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[5854920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":523,"address":[5855285,5855502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[5855039,5855115],"length":1,"stats":{"Line":2},"fn_name":null},{"line":525,"address":[5855208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":528,"address":[5856288,5856421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":529,"address":[5855466,5856208],"length":1,"stats":{"Line":2},"fn_name":null},{"line":530,"address":[5856252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[5856928],"length":1,"stats":{"Line":3},"fn_name":"test_one_minus"},{"line":536,"address":[5857074,5856935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[5857048,5857109,5857256],"length":1,"stats":{"Line":2},"fn_name":null},{"line":541,"address":[5857312],"length":1,"stats":{"Line":3},"fn_name":"test_trapezoidal_integrate"},{"line":542,"address":[9089024,9089044],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":543,"address":[5857324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":544,"address":[5857620,5857354],"length":1,"stats":{"Line":1},"fn_name":null},{"line":548,"address":[5859583,5858240],"length":1,"stats":{"Line":3},"fn_name":"test_trapezoidal_integrate_grid"},{"line":549,"address":[5858254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":550,"address":[9089120,9089140],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":551,"address":[5858304,5858427],"length":1,"stats":{"Line":2},"fn_name":null},{"line":552,"address":[5858444,5858752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":556,"address":[5859616],"length":1,"stats":{"Line":3},"fn_name":"test_simpsons_integrate"},{"line":557,"address":[9089236,9089216],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":558,"address":[5859628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":559,"address":[5859658,5859924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":563,"address":[5860544],"length":1,"stats":{"Line":3},"fn_name":"test_cap_numerical_overshoot"},{"line":564,"address":[5860551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[5860565,5860707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":566,"address":[5860664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":567,"address":[5860881,5860772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":568,"address":[5860681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":569,"address":[5860742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":575,"address":[5860928],"length":1,"stats":{"Line":3},"fn_name":"test_cap_numerical_overshoot_panic"},{"line":576,"address":[5860929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[5860942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[5860960],"length":1,"stats":{"Line":3},"fn_name":"test_sum_one_zero"},{"line":582,"address":[5861023,5861116],"length":1,"stats":{"Line":1},"fn_name":null},{"line":583,"address":[5860967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":584,"address":[5861012],"length":1,"stats":{"Line":1},"fn_name":null},{"line":589,"address":[5861152],"length":1,"stats":{"Line":3},"fn_name":"test_zero"},{"line":590,"address":[5861204,5861156],"length":1,"stats":{"Line":1},"fn_name":null},{"line":591,"address":[5861271,5861191,5861234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":592,"address":[5861360,5861301,5861330,5861258],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":162,"coverable":205},{"path":["/","home","todd","rust-bio","src","utils","fastexp.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! This module provides a trait adding a fast approximation of the exponential function to f64.\n//! This can be very useful if the exact value is not too important, for example when working with\n//! `bio::stats::LogProb`.\n\nuse num_traits::Float;\nuse std::f64;\nuse std::ops;\n\nconst COEFF_0: f64 = 1.0;\nconst COEFF_1: f64 = 4.831_794_110;\nconst COEFF_2: f64 = 0.143_440_676;\nconst COEFF_3: f64 = 0.019_890_581;\nconst COEFF_4: f64 = 0.006_935_931;\n#[allow(clippy::approx_constant)]\nconst ONEBYLOG2: f64 = 1.442_695_041;\nconst OFFSET_F64: i64 = 1023;\nconst FRACTION_F64: u32 = 52;\nconst MIN_VAL: f64 = -500.0;\n\n/// This trait adds a fast approximation of exp to float types.\npub trait FastExp\u003cV: Float + ops::MulAssign\u003e {\n    fn fastexp(\u0026self) -\u003e V;\n}\n\nimpl FastExp\u003cf64\u003e for f64 {\n    /// Fast approximation of exp() as shown by Kopczynski 2017:\n    /// https://eldorado.tu-dortmund.de/bitstream/2003/36203/1/Dissertation_Kopczynski.pdf\n    fn fastexp(\u0026self) -\u003e f64 {\n        if *self \u003e MIN_VAL {\n            let mut x = ONEBYLOG2 * self;\n\n            let mut bits = x as i64;\n\n            x -= bits as f64;\n            let mut f2 = x;\n            let mut x_tmp = x;\n\n            bits += OFFSET_F64;\n            bits \u003c\u003c= FRACTION_F64;\n\n            f2 *= COEFF_4;\n            x_tmp += COEFF_1;\n            f2 += COEFF_3;\n            x_tmp *= x;\n            f2 *= x;\n            f2 += COEFF_2;\n            f2 *= x_tmp;\n            f2 += COEFF_0;\n\n            f64::from_bits(bits as u64) * f2\n        } else {\n            0.0\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_fastexp() {\n        let x = 1e-15_f64.ln();\n        assert_relative_eq!(x.fastexp(), 1e-15);\n        let x = 1e-8_f64.ln();\n        assert_relative_eq!(x.fastexp(), 1e-8, epsilon = 0.00000000000002);\n        let x = 0.5_f64.ln();\n        assert_relative_eq!(x.fastexp(), 0.5, epsilon = 0.01);\n        let x = -159.000_000_023_278_6_f64;\n        assert_relative_eq!(x.fastexp(), (-159.000_000_023_278_6).exp());\n    }\n}\n","traces":[{"line":33,"address":[6280368],"length":1,"stats":{"Line":1},"fn_name":"fastexp"},{"line":34,"address":[6280382,6280409],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[6280419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[6280438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[6280490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[6280513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[4865357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4865369,4865418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[4865453,4865402],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4865458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[4865478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4865498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4865518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4865536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[4865554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4865574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[4865592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[4865612],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[4865232],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[4501296],"length":1,"stats":{"Line":3},"fn_name":"test_fastexp"},{"line":68,"address":[4501308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[4501526,4501330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[4501499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[4502115,4502360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[4502333],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[4503319,4503057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[4503275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[4504193,4503292,4504016],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":28,"coverable":28},{"path":["/","home","todd","rust-bio","src","utils","interval","errors.rs"],"content":"// Copyright 2019 Johannes Köster, University of Duisburg-Essen.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Error definitions for the `interval` module.\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum Error {\n    #[error(\"an Interval must have a Range with a positive width\")]\n    InvalidRange,\n}\npub type Result\u003cT, E = Error\u003e = std::result::Result\u003cT, E\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","utils","interval","mod.rs"],"content":"//! This module defines a newtype `Interval` for `std::ops::Range`, which will panic if `end` \u003c `start`.\n//!\n//! # Examples\n//! Create a new `Interval` given a `Range`.\n//! ```\n//! use bio::utils::Interval;\n//! assert_eq!(Interval::new(3..6).unwrap(), (3..6).into());\n//! ```\n//!\n//! Building an `Interval` from a `Range` with start \u003e end should panic.\n//! ```should_panic\n//! use bio::utils::Interval;\n//! Interval::from(7..1);\n//! ```\n//!\n//! If you want to handle invalid ranges properly, use the `new` constructor\n//! ```\n//! use bio::utils::Interval;\n//! match Interval::new(7..1) {\n//!     Ok(interval) =\u003e println!(\"{:?}\", interval),\n//!     Err(error) =\u003e eprintln!(\"interval start \u003e end\"),\n//! }\n//! ```\n\npub mod errors;\n\nuse std::ops::{Deref, Range};\n\npub use self::errors::{Error, Result};\n\n/// An `Interval` wraps the `std::ops::Range` from the stdlib and is defined by a start and end field\n/// where end should be \u003e= start.\n#[derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]\npub struct Interval\u003cN: Ord + Clone\u003e(Range\u003cN\u003e);\n\nimpl\u003cN: Ord + Clone\u003e Interval\u003cN\u003e {\n    /// Construct a new `Interval` from the given Range.\n    /// Will return `Err` if end \u003c start.\n    pub fn new(r: Range\u003cN\u003e) -\u003e Result\u003cInterval\u003cN\u003e\u003e {\n        if r.end \u003e= r.start {\n            Ok(Interval(r))\n        } else {\n            Err(Error::InvalidRange)\n        }\n    }\n}\n\n/// Convert a `Range` into an `Interval`. This conversion will panic if the `Range` has end \u003c start\nimpl\u003cN: Ord + Clone\u003e From\u003cRange\u003cN\u003e\u003e for Interval\u003cN\u003e {\n    fn from(r: Range\u003cN\u003e) -\u003e Self {\n        match Interval::new(r) {\n            Ok(interval) =\u003e interval,\n            Err(Error::InvalidRange) =\u003e panic!(\"Cannot convert negative width range to interval\"),\n        }\n    }\n}\n\n/// Convert a reference to a `Range` to an interval by cloning. This conversion will panic if the\n/// `Range` has end \u003c start\nimpl\u003c'a, N: Ord + Clone\u003e From\u003c\u0026'a Range\u003cN\u003e\u003e for Interval\u003cN\u003e {\n    fn from(r: \u0026Range\u003cN\u003e) -\u003e Self {\n        match Interval::new(r.clone()) {\n            Ok(interval) =\u003e interval,\n            Err(Error::InvalidRange) =\u003e panic!(\"Cannot convert negative width range to interval\"),\n        }\n    }\n}\n\n/// Use the `Deref` operator to get a reference to `Range` wrapped by the `Interval` newtype.\nimpl\u003cN: Ord + Clone\u003e Deref for Interval\u003cN\u003e {\n    type Target = Range\u003cN\u003e;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Interval;\n\n    #[test]\n    #[should_panic]\n    fn negative_width_range() {\n        let _ = Interval::from(10..5);\n    }\n\n    #[test]\n    fn range_interval_conversions() {\n        assert_eq!(Interval::new(1..10).unwrap(), (1..10).into());\n        assert_eq!(Interval::from(1..10), Interval::new(1..10).unwrap());\n        //deref access\n        let r = Interval::new(1..10).unwrap();\n        assert_eq!(*r, (1..10));\n        assert_eq!(r.start, 1);\n        assert_eq!(r.end, 10);\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[9185024,9185029],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":85,"address":[9384305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[9185056,9185061],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":90,"address":[9384689,9384343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[9385057,9384622,9384733],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[9385101,9384957],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[9385144,9385281],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[9385251,9385330,9385437],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[9385587,9385407,9385490],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":21,"coverable":23},{"path":["/","home","todd","rust-bio","src","utils","mod.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Common utilities.\n\nmod fastexp;\npub use self::fastexp::FastExp;\n\nmod text;\npub use self::text::{trim_newline, Text, TextSlice};\n\nmod interval;\npub use self::interval::Interval;\n\n/// In place implementation of scan over a slice.\npub fn scan\u003cT: Copy, F: Fn(T, T) -\u003e T\u003e(a: \u0026mut [T], op: F) {\n    let mut s = a[0];\n    for v in a.iter_mut().skip(1) {\n        s = op(s, *v);\n        *v = s;\n    }\n}\n\n// Inplace implementation of prescan over a slice.\npub fn prescan\u003cT: Copy, F: Fn(T, T) -\u003e T\u003e(a: \u0026mut [T], neutral: T, op: F) {\n    let mut s = neutral;\n    for v in a.iter_mut() {\n        let t = *v;\n        *v = s;\n        s = op(s, t);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_scan() {\n        let mut a = vec![1, 0, 0, 1];\n        scan(\u0026mut a[..], |a, b| a + b);\n        assert_eq!(a, vec![1, 1, 1, 2]);\n    }\n\n    #[test]\n    fn test_prescan() {\n        let mut a = vec![1, 0, 0, 1];\n        prescan(\u0026mut a[..], 0, |a, b| a + b);\n        assert_eq!(a, vec![0, 1, 1, 1]);\n    }\n}\n","traces":[{"line":18,"address":[5635200,5635600],"length":1,"stats":{"Line":1},"fn_name":"scan\u003ci32,closure-0\u003e"},{"line":19,"address":[5635233,5635295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[5635487,5635364,5635595,5635263],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[5635524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[5635589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[5223472,5223779,5224115,5223808],"length":1,"stats":{"Line":8},"fn_name":"prescan\u003cusize,closure-0\u003e"},{"line":28,"address":[5223833,5223497],"length":1,"stats":{"Line":8},"fn_name":null},{"line":29,"address":[5223603,5223838,5223502,5223939,5223671,5223774,5224007,5224110],"length":1,"stats":{"Line":32},"fn_name":null},{"line":30,"address":[5223700,5224036],"length":1,"stats":{"Line":8},"fn_name":null},{"line":31,"address":[5223711,5224047],"length":1,"stats":{"Line":8},"fn_name":null},{"line":32,"address":[5224055,5223719],"length":1,"stats":{"Line":8},"fn_name":null},{"line":41,"address":[5580634,5580224],"length":1,"stats":{"Line":3},"fn_name":"test_scan"},{"line":42,"address":[5580231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[5580291],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[5580395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[5581084,5580672],"length":1,"stats":{"Line":3},"fn_name":"test_prescan"},{"line":49,"address":[5580679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[5580739],"length":1,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[5580845],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":19,"coverable":19},{"path":["/","home","todd","rust-bio","src","utils","text.rs"],"content":"/// Type alias for an owned text, i.e. ``Vec\u003cu8\u003e``.\npub type Text = Vec\u003cu8\u003e;\n/// Type alias for a text slice, i.e. ``\u0026[u8]``.\npub type TextSlice\u003c'a\u003e = \u0026'a [u8];\n\n/// Remove a trailing newline from the given string in place.\npub fn trim_newline(s: \u0026mut String) {\n    if s.ends_with('\\n') {\n        s.pop();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::Deref;\n\n    /// This function demonstrates the use of the IntoSequenceIterator alias, which takes both\n    /// slices and iterators.\n    fn print_sequence\u003cItem: Deref\u003cTarget = u8\u003e, T: IntoIterator\u003cItem = Item\u003e\u003e(sequence: T) {\n        for c in sequence {\n            println!(\"{}\", *c);\n        }\n    }\n\n    #[test]\n    fn test_print_sequence() {\n        let s = b\"ACGT\";\n        // use iterator\n        print_sequence(s.iter().step_by(1));\n        // use slice\n        print_sequence(\u0026s[..]);\n        // use vec\n        print_sequence(\u0026vec![b'A', b'C']);\n        // keep ownership\n        println!(\"{:?}\", s);\n    }\n\n    #[test]\n    fn test_trim_newline_from_string() {\n        let mut s = String::from(\"AGCT\\n\");\n        trim_newline(\u0026mut s);\n        assert_eq!(s, String::from(\"AGCT\"));\n    }\n}\n","traces":[{"line":7,"address":[9465312],"length":1,"stats":{"Line":1},"fn_name":"trim_newline"},{"line":8,"address":[9465326,9465388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[9465383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[5622170,5623140,5622689,5622720,5622208,5621744],"length":1,"stats":{"Line":3},"fn_name":"print_sequence\u003c\u0026u8,\u0026[u8]\u003e"},{"line":21,"address":[5622874,5621921,5622735,5621767,5622215,5622889,5623131,5622161,5621906,5622425,5622680,5622410],"length":1,"stats":{"Line":9},"fn_name":null},{"line":22,"address":[5622481,5622594,5621968,5622081,5623051,5622936],"length":1,"stats":{"Line":6},"fn_name":null},{"line":27,"address":[5623173,5623168],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":28,"address":[9522967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[9522979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[9523040],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[9523082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[9523197],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[5623205,5623200],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":41,"address":[9523351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[9523378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[9523385,9523452],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":16,"coverable":16},{"path":["/","home","todd","rust-bio","tests","data_structures","mod.rs"],"content":"mod rank_select;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","tests","data_structures","rank_select.rs"],"content":"use proptest::prelude::*;\nuse std::collections::HashMap;\nuse std::hash::Hash;\n\n// Naive Rank datastructure.\n//\n// Each index in the `ranks` vector is the index in the sequence.\n// At each of the indexes the overall rank of all values seen up to\n// that point is stored in a HashMap.\n#[derive(Default)]\nstruct Rank\u003cT: Hash + Eq + Clone\u003e {\n    ranks: Vec\u003cHashMap\u003cT, usize\u003e\u003e,\n    len: usize,\n}\n\n// Naive Select data structure.\n//\n// All values in the sequence are keys in the HashMap.\n// Each value has an associated vector where the indexes are the ranks\n// and the value at each index is the index in the sequence at which the\n// rank occured.\n#[derive(Default)]\nstruct Select\u003cT: Hash + Eq + Clone\u003e {\n    select: HashMap\u003cT, Vec\u003cusize\u003e\u003e,\n    len: usize,\n}\n\nimpl\u003cT: Hash + Eq + Clone\u003e Select\u003cT\u003e {\n    fn push(\u0026mut self, val: T) {\n        self.select\n            .entry(val)\n            .or_insert_with(Vec::new)\n            .push(self.len);\n        self.len += 1;\n    }\n\n    fn select(\u0026self, rank: usize, val: \u0026T) -\u003e Option\u003cu64\u003e {\n        if rank \u003e 0 {\n            if let Some(ranks) = self.select.get(val) {\n                if let Some(idx) = ranks.get(rank - 1) {\n                    return Some(*idx as u64);\n                }\n            }\n        }\n        return None;\n    }\n}\n\nimpl\u003cT: Hash + Eq + Clone\u003e Rank\u003cT\u003e {\n    fn push(\u0026mut self, val: T) {\n        if let Some(prev) = self.ranks.last() {\n            let mut nxt: HashMap\u003c_, _\u003e = prev.clone();\n            *nxt.entry(val).or_insert(0) += 1;\n            self.ranks.push(nxt.clone());\n        } else {\n            let mut nxt = HashMap::new();\n            nxt.insert(val, 1);\n            self.ranks.push(nxt);\n        }\n        self.len += 1;\n    }\n\n    fn get_rank(\u0026self, idx: usize, val: T) -\u003e Option\u003cu64\u003e {\n        if idx \u003c self.len {\n            let rank = self\n                .ranks\n                .get(idx)\n                .map(|x| *x.get(\u0026val).unwrap_or(\u00260))\n                .unwrap_or(0);\n            Some(rank as u64)\n        } else {\n            None\n        }\n    }\n}\n\nproptest! {\n    #[test]\n    fn rank_same_as_naive(input: Vec\u003cbool\u003e, k in 1usize..1000usize) {\n        use bio::data_structures::rank_select::RankSelect;\n        use bv::BitVec;\n        let mut bv = BitVec::new();\n        let mut naive = Rank::default();\n        for \u0026i in \u0026input {\n            naive.push(i);\n            bv.push(i)\n        }\n        let rs = RankSelect::new(bv, k);\n        for idx in 0..=input.len() {\n            assert_eq!(naive.get_rank(idx, false), rs.rank_0(idx as u64));\n            assert_eq!(naive.get_rank(idx, true), rs.rank_1(idx as u64));\n        }\n    }\n\n    #[test]\n    fn select_same_as_naive(input: Vec\u003cbool\u003e, k in 1usize..1000usize) {\n        use bio::data_structures::rank_select::RankSelect;\n        use bv::BitVec;\n        let mut bv = BitVec::new();\n        let mut naive = Select::default();\n        for \u0026i in \u0026input {\n            naive.push(i);\n            bv.push(i)\n        }\n        let rs = RankSelect::new(bv, k);\n        for idx in 0..=input.len() {\n            assert_eq!(naive.select(idx, \u0026false), rs.select_0(idx as u64));\n            assert_eq!(naive.select(idx, \u0026true), rs.select_1(idx as u64));\n        }\n    }\n}\n","traces":[{"line":29,"address":[4266384],"length":1,"stats":{"Line":1},"fn_name":"push\u003cbool\u003e"},{"line":30,"address":[4266457,4266412],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[4266453],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[4266535,4266468,4266505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4266544],"length":1,"stats":{"Line":1},"fn_name":"select\u003cbool\u003e"},{"line":38,"address":[4266578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[4266802,4266596,4266657],"length":1,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[4266678,4266639],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[4266783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4266659],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4267570,4266832],"length":1,"stats":{"Line":1},"fn_name":"push\u003cbool\u003e"},{"line":51,"address":[4266868,4266986,4267230],"length":1,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[4267032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[4267391,4267288,4267452],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[4267445,4267496],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[4267050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[4267061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[4267114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4267255,4267540,4267528],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[4267834,4267600],"length":1,"stats":{"Line":1},"fn_name":"get_rank\u003cbool\u003e"},{"line":64,"address":[4267650,4267635,4267832],"length":1,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[4267746,4267660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[4267872,4267741,4267899],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}\u003cbool\u003e"},{"line":70,"address":[4267818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[4267641],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4294959,4296255],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[4268482],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[4268510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[4268517],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[4268727,4268959,4268672,4268589,4268873],"length":1,"stats":{"Line":5},"fn_name":null},{"line":85,"address":[4268913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[4268938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[4268806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[4269064,4268964,4269253,4269806],"length":1,"stats":{"Line":4},"fn_name":null},{"line":90,"address":[4269567,4269300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[4269628,4269534,4269821],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[4296725],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[4270270],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[4270277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[4270432,4270487,4270349,4270633,4270719],"length":1,"stats":{"Line":5},"fn_name":null},{"line":102,"address":[4270673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[4270698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4270566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[4271573,4270824,4271013,4270724],"length":1,"stats":{"Line":4},"fn_name":null},{"line":107,"address":[4271334,4271050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4271286,4271588,4271395],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":46,"coverable":50},{"path":["/","home","todd","rust-bio","tests","mod.rs"],"content":"mod data_structures;\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","todd","rust-bio","benches","approximate_matching.rs"],"content":"#![feature(test)]\n\nextern crate test;\n\nuse test::Bencher;\n\nuse bio::alignment::Alignment;\nuse bio::pattern_matching::myers::{long, Myers};\nuse bio::pattern_matching::ukkonen::*;\n\nstatic TEXT: \u0026'static [u8] = b\"GATCACAGGTCTATCACCCTATTAACCACTCACGGGAGCTCTCCATGC\\\nATTTGGTATTTTCGTCTGGGGGGTATGCACGCGATAGCATTGCGAGACGCTGGAGCCGGAGCACCCTATGTCGCAGTAT\\\nCTGTCTTTGATTCCTGCCTCATCCTATTATTTATCGCACCTACGTTCAATATTACAGGCGAACATACTTACTAAAGTGT\\\nGTTAATTAATTAATGCTTGTAGGACATAATAATAACAATTGAATGTCTGCACAGCCACTTTCCACACAGACATCATAAC\\\nAAAAAATTTCCACCAAACCCCCCCTCCCCCGCTTCTGGCCACAGCACTTAAACACATCTCTGCCAAACCCCAAAAACAA\\\nAGAACCCTAACACCAGCCTAACCAGATTTCAAATTTTATCTTTTGGCGGTATGCACTTTTAACAGTCACCCCCCAACTA\\\nACACATTATTTTCCCCTCCCACTCCCATACTACTAATCTCATCAATACAACCCCCGCCCATCCTACCCAGCACACACAC\\\nACCGCTGCTAACCCCATACCCCGAACCAACCAAACCCCAAAGACACCCCCCACAGTTTATGTAGCTTACCTCCTCAAAG\\\nCAATACACTGAAAATGTTTAGACGGGCTCACATCACCCCATAAACAAATAGGTTTGGTCCTAGCCTTTCTATTAGCTCT\\\nTAGTAAGATTACACATGCAAGCATCCCCGTTCCAGTGAGTTCACCCTCTAAATCACCACGATCAAAAGGAACAAGCATC\\\nAAGCACGCAGCAATGCAGCTCAAAACGCTTAGCCTAGCCACACCCCCACGGGAAACAGCAGTGATTAACCTTTAGCAAT\\\nAAACGAAAGTTTAACTAAGCTATACTAACCCCAGGGTTGGTCAATTTCGTGCCAGCCACCGCGGTCACACGATTAACCC\\\nAAGTCAATAGAAGCCGGCGTAAAGAGTGTTTTAGATCACCCCCTCCCCAATAAAGCTAAAACTCACCTGAGTTGTAAAA\\\nAACTCCAGTTGACACAAAATAGACTACGAAAGTGGCTTTAACATATCTGAACACACAATAGCTAAGACCCAAACTGGGA\\\nTTAGATACCCCACTATGCTTAGCCCTAAACCTCAACAGTTAAATCAACAAAACTGCTCGCCAGAACACTACGAGCCACA\\\nGCTTAAAACTCAAAGGACCTGGCGGTGCTTCATATCCCTCTAGAGGAGCCTGTTCTGTAATCGATAAACCCCGATCAAC\\\nCTCACCACCTCTTGCTCAGCCTATATACCGCCATCTTCAGCAAACCCTGATGAAGGCTACAAAGTAAGCGCAAGTACCC\\\nACGTAAAGACGTTAGGTCAAGGTGTAGCCCATGAGGTGGCAAGAAATGGGCTACATTTTCTACCCCAGAAAACTACGAT\\\nAGCCCTTATGAAACTTAAGGGTCGAAGGTGGATTTAGCAGTAAACTAAGAGTAGAGTGCTTAGTTGAACAGGGCCCTGA\\\nAGCGCGTACACACCGCCCGTCACCCTCCTCAAGTATACTTCAAAGGACATTTAACTAAAACCCCTACGCATTTATATAG\\\nAGGAGACAAGTCGTAACATGGTAAGTGTACTGGAAAGTGCACTTGGACGAACCAGAGTGTAGCTTAACACAAAGCACCC\\\nAACTTACACTTAGGAGATTTCAACTTAACTTGACCGCTCTGAGCTAAACCTAGCCCCAAACCCACTCCACCTTACTACC\\\nAGACAACCTTAGCCAAACCATTTACCCAAATAAAGTATAGGCGATAGAAATTGAAACCTGGCGCAATAGATATAGTACC\\\nGCAAGGGAAAGATGAAAAATTATAACCAAGCATAATATAGCAAGGACTAACCCCTATACCTTCTGCATAATGAATTAAC\\\nTAGAAATAACTTTGCAAGGAGAGCCAAAGCTAAGACCCCCGAAACCAGACGAGCTACCTAAGAACAGCTAAAAGAGCAC\\\nACCCGTCTATGTAGCAAAATAGTGGGAAGATTTATAGGTAGAGGCGACAAACCTACCGAGCCTGGTGATAGCTGGTTGT\\\nCCAAGATAGAATCTTAGTTCAACTTTAAATTTGCCCACAGAACCCTCTAAATCCCCTTGTAAATTTAACTGTTAGTCCA\\\nAAGAGGAACAGCTCTTTGGACACTAGGAAAAAACCTTGTAGAGAGAGTAAAAAATTTAACACCCATAGTAGGCCTAAAA\\\nGCAGCCACCAATTAAGAAAGCGTTCAAGCTCAACACCCACTACCTAAAAAATCCCAAACATATAACTGAACTCCTCACA\\\nCCCAATTGGACCAATCTATCACCCTATAGAAGAACTAATGTTAGTATAAGTAACATGAAAACATTCTCCTCCGCATAAG\\\nCCTGCGTCAGATTAAAACACTGAACTGACAATTAACAGCCCAATATCTACAATCAACCAACAAGTCATTATTACCCTCA\\\nCTGTCAACCCAACACAGGCATGCTCATAAGGAAAGGTTAAAAAAAGTAAAAGGAACTCGGCAAATCTTACCCCGCCTGT\\\nTTACCAAAAACATCACCTCTAGCATCACCAGTATTAGAGGCACCGCCTGCCCAGTGACACATGTTTAACGGCCGCGGTA\\\nCCCTAACCGTGCAAAGGTAGCATAATCACTTGTTCCTTAAATAGGGACCTGTATGAATGGCTCCACGAGGGTTCAGCTG\\\nTCTCTTACTTTTAACCAGTGAAATTGACCTGCCCGTGAAGAGGCGGGCATAACACAGCAAGACGAGAAGACCCTATGGA\\\nGCTTTAATTTATTAATGCAAACAGTACCTAACAAACCCACAGGTCCTAAACTACCAAACCTGCATTAAAAATTTCGGTT\\\nGGGGCGACCTCGGAGCAGAACCCAACCTCCGAGCAGTACATGCTAAGACTTCACCAGTCAAAGCGAACTACTATACTCA\\\nATTGATCCAATAACTTGACCAACGGAACAAGTTACCCTAGGGATAACAGCGCAATCCTATTCTAGAGTCCATATCAACA\\\nATAGGGTTTACGACCTCGATGTTGGATCAGGACATCCCGATGGTGCAGCCGCTATTAAAGGTTCGTTTGTTCAACGATT\\\nAAAGTCCTACGTGATCTGAGTTCAGACCGGAGTAATCCAGGTCGGTTTCTATCTACNTTCAAATTCCTCCCTGTACGAA\\\nAGGACAAGAGAAATAAGGCCTACTTCACAAAGCGCCTTCCCCCGTAAATGATATCATCTCAACTTAGTATTATACCCAC\\\nACCCACCCAAGAACAGGGTTTGTTAAGATGGCAGAGCCCGGTAATCGCATAAAACTTAAAACTTTACAGTCAGAGGTTC\\\nAATTCCTCTTCTTAACAACATACCCATGGCCAACCTCCTACTCCTCATTGTACCCATTCTAATCGCAATGGCATTCCTA\\\nATGCTTACCGAACGAAAAATTCTAGGCTATATACAACTACGCAAAGGCCCCAACGTTGTAGGCCCCTACGGGCTACTAC\\\nAACCCTTCGCTGACGCCATAAAACTCTTCACCAAAGAGCCCCTAAAACCCGCCACATCTACCATCACCCTCTACATCAC\\\nCGCCCCGACCTTAGCTCTCACCATCGCTCTTCTACTATGAACCCCCCTCCCCATACCCAACCCCCTGGTCAACCTCAAC\\\nCTAGGCCTCCTATTTATTCTAGCCACCTCTAGCCTAGCCGTTTACTCAATCCTCTGATCAGGGTGAGCATCAAACTCAA\\\nACTACGCCCTGATCGGCGCACTGCGAGCAGTAGCCCAAACAATCTCATATGAAGTCACCCTAGCCATCATTCTACTATC\\\nAACATTACTAATAAGTGGCTCCTTTAACCTCTCCACCCTTATCACAACACAAGAACACCTCTGATTACTCCTGCCATCA\\\nTGACCCTTGGCCATAATATGATTTATCTCCACACTAGCAGAGACCAACCGAACCCCCTTCGACCTTGCCGAAGGGGAGT\\\nCCGAACTAGTCTCAGGCTTCAACATCGAATACGCCGCAGGCCCCTTCGCCCTATTCTTCATAGCCGAATACACAAACAT\\\nTATTATAATAAACACCCTCACCACTACAATCTTCCTAGGAACAACATATGACGCACTCTCCCCTGAACTCTACACAACA\\\nTATTTTGTCACCAAGACCCTACTTCTAACCTCCCTGTTCTTATGAATTCGAACAGCATACCCCCGATTCCGCTACGACC\\\nAACTCATACACCTCCTATGAAAAAACTTCCTACCACTCACCCTAGCATTACTTATATGATATGTCTCCATACCCATTAC\\\nAATCTCCAGCATTCCCCCTCAAACCTAAGAAATATGTCTGATAAAAGAGTTACTTTGATAGAGTAAATAATAGGAGCTT\\\nAAACCCCCTTATTTCTAGGACTATGAGAATCGAACCCATCCCTGAGAATCCAAAATTCTCCGTGCCACCTATCACACCC\\\nCATCCTAAAGTAAGGTCAGCTAAATAAGCTATCGGGCCCATACCCCGAAAATGTTGGTTATACCCTTCCCGTACTAATT\\\nAATCCCCTGGCCCAACCCGTCATCTACTCTACCATCTTTGCAGGCACACTCATCACAGCGCTAAGCTCGCACTGATTTT\\\nTTACCTGAGTAGGCCTAGAAATAAACATGCTAGCTTTTATTCCAGTTCTAACCAAAAAAATAAACCCTCGTTCCACAGA\\\nAGCTGCCATCAAGTATTTCCTCACGCAAGCAACCGCATCCATAATCCTTCTAATAGCTATCCTCTTCAACAATATACTC\\\nTCCGGACAATGAACCATAACCAATACTACCAATCAATACTCATCATTAATAATCATAATAGCTATAGCAATAAAACTAG\\\nGAATAGCCCCCTTTCACTTCTGAGTCCCAGAGGTTACCCAAGGCACCCCTCTGACATCCGGCCTGCTTCTTCTCACATG\\\nACAAAAACTAGCCCCCATCTCAATCATATACCAAATCTCTCCCTCACTAAACGTAAGCCTTCTCCTCACTCTCTCAATC\\\nTTATCCATCATAGCAGGCAGTTGAGGTGGATTAAACCAAACCCAGCTACGCAAAATCTTAGCATACTCCTCAATTACCC\\\nACATAGGATGAATAATAGCAGTTCTACCGTACAACCCTAACATAACCATTCTTAATTTAACTATTTATATTATCCTAAC\\\nTACTACCGCATTCCTACTACTCAACTTAAACTCCAGCACCACGACCCTACTACTATCTCGCACCTGAAACAAGCTAACA\\\nTGACTAACACCCTTAATTCCATCCACCCTCCTCTCCCTAGGAGGCCTGCCCCCGCTAACCGGCTTTTTGCCCAAATGGG\\\nCCATTATCGAAGAATTCACAAAAAACAATAGCCTCATCATCCCCACCATCATAGCCACCATCACCCTCCTTAACCTCTA\\\nCTTCTACCTACGCCTAATCTACTCCACCTCAATCACACTACTCCCCATATCTAACAACGTAAAAATAAAATGACAGTTT\\\nGAACATACAAAACCCACCCCATTCCTCCCCACACTCATCGCCCTTACCACGCTACTCCTACCTATCTCCCCTTTTATAC\\\nTAATAATCTTATAGAAATTTAGGTTAAATACAGACCAAGAGCCTTCAAAGCCCTCAGTAAGTTGCAATACTTAATTTCT\\\nGTAACAGCTAAGGACTGCAAAACCCCACTCTGCATCAACTGAACGCAAATCAGCCACTTTAATTAAGCTAAGCCCTTAC\\\nTAGACCAATGGGACTTAAACCCACAAACACTTAGTTAACAGCTAAGCACCCTAATCAACTGGCTTCAATCTACTTCTCC\\\nCGCCGCCGGGAAAAAAGGCGGGAGAAGCCCCGGCAGGTTTGAAGCTGCTTCTTCGAATTTGCAATTCAATATGAAAATC\\\nACCTCGGAGCTGGTAAAAAGAGGCCTAACCCCTGTCTTTAGATTTACAGTCCAATGCTTCACTCAGCCATTTTACCTCA\\\nCCCCCACTGATGTTCGCCGACCGTTGACTATTCTCTACAAACCACAAAGACATTGGAACACTATACCTATTATTCGGCG\\\nCATGAGCTGGAGTCCTAGGCACAGCTCTAAGCCTCCTTATTCGAGCCGAGCTGGGCCAGCCAGGCAACCTTCTAGGTAA\\\nCGACCACATCTACAACGTTATCGTCACAGCCCATGCATTTGTAATAATCTTCTTCATAGTAATACCCATCATAATCGGA\\\nGGCTTTGGCAACTGACTAGTTCCCCTAATAATCGGTGCCCCCGATATGGCGTTTCCCCGCATAAACAACATAAGCTTCT\\\nGACTCTTACCTCCCTCTCTCCTACTCCTGCTCGCATCTGCTATAGTGGAGGCCGGAGCAGGAACAGGTTGAACAGTCTA\\\nCCCTCCCTTAGCAGGGAACTACTCCCACCCTGGAGCCTCCGTAGACCTAACCATCTTCTCCTTACACCTAGCAGGTGTC\\\nTCCTCTATCTTAGGGGCCATCAATTTCATCACAACAATTATCAATATAAAACCCCCTGCCATAACCCAATACCAAACGC\\\nCCCTCTTCGTCTGATCCGTCCTAATCACAGCAGTCCTACTTCTCCTATCTCTCCCAGTCCTAGCTGCTGGCATCACTAT\\\nACTACTAACAGACCGCAACCTCAACACCACCTTCTTCGACCCCGCCGGAGGAGGAGACCCCATTCTATACCAACACCTA\\\nTTCTGATTTTTCGGTCACCCTGAAGTTTATATTCTTATCCTACCAGGCTTCGGAATAATCTCCCATATTGTAACTTACT\\\nACTCCGGAAAAAAAGAACCATTTGGATACATAGGTATGGTCTGAGCTATGATATCAATTGGCTTCCTAGGGTTTATCGT\\\nGTGAGCACACCATATATTTACAGTAGGAATAGACGTAGACACACGAGCATATTTCACCTCCGCTACCATAATCATCGCT\\\nATCCCCACCGGCGTCAAAGTATTTAGCTGACTCGCCACACTCCACGGAAGCAATATGAAATGATCTGCTGCAGTGCTCT\\\nGAGCCCTAGGATTCATCTTTCTTTTCACCGTAGGTGGCCTGACTGGCATTGTATTAGCAAACTCATCACTAGACATCGT\\\nACTACACGACACGTACTACGTTGTAGCCCACTTCCACTATGTCCTATCAATAGGAGCTGTATTTGCCATCATAGGAGGC\\\nTTCATTCACTGATTTCCCCTATTCTCAGGCTACACCCTAGACCAAACCTACGCCAAAATCCATTTCACTATCATATTCA\\\nTCGGCGTAAATCTAACTTTCTTCCCACAACACTTTCTCGGCCTATCCGGAATGCCCCGACGTTACTCGGACTACCCCGA\\\nTGCATACACCACATGAAACATCCTATCATCTGTAGGCTCATTCATTTCTCTAACAGCAGTAATATTAATAATTTTCATG\\\nATTTGAGAAGCCTTCGCTTCGAAGCGAAAAGTCCTAATAGTAGAAGAACCCTCCATAAACCTGGAGTGACTATATGGAT\\\nGCCCCCCACCCTACCACACATTCGAAGAACCCGTATACATAAAATCTAGACAAAAAAGGAAGGAATCGAACCCCCCAAA\\\nGCTGGTTTCAAGCCAACCCCATGGCCTCCATGACTTTTTCAAAAAGGTATTAGAAAAACCATTTCATAACTTTGTCAAA\\\nGTTAAATTATAGGCTAAATCCTATATATCTTAATGGCACATGCAGCGCAAGTAGGTCTACAAGACGCTACTTCCCCTAT\\\nCATAGAAGAGCTTATCACCTTTCATGATCACGCCCTCATAATCATTTTCCTTATCTGCTTCCTAGTCCTGTATGCCCTT\\\nTTCCTAACACTCACAACAAAACTAACTAATACTAACATCTCAGACGCTCAGGAAATAGAAACCGTCTGAACTATCCTGC\\\nCCGCCATCATCCTAGTCCTCATCGCCCTCCCATCCCTACGCATCCTTTACATAACAGACGAGGTCAACGATCCCTCCCT\\\nTACCATCAAATCAATTGGCCACCAATGGTACTGAACCTACGAGTACACCGACTACGGCGGACTAATCTTCAACTCCTAC\\\nATACTTCCCCCATTATTCCTAGAACCAGGCGACCTGCGACTCCTTGACGTTGACAATCGAGTAGTACTCCCGATTGAAG\\\nCCCCCATTCGTATAATAATTACATCACAAGACGTCTTGCACTCATGAGCTGTCCCCACATTAGGCTTAAAAACAGATGC\\\nAATTCCCGGACGTCTAAACCAAACCACTTTCACCGCTACACGACCGGGGGTATACTACGGTCAATGCTCTGAAATCTGT\\\nGGAGCAAACCACAGTTTCATGCCCATCGTCCTAGAATTAATTCCCCTAAAAATCTTTGAAATAGGGCCCGTATTTACCC\\\nTATAGCACCCCCTCTACCCCCTCTAGAGCCCACTGTAAAGCTAACTTAGCATTAACCTTTTAAGTTAAAGATTAAGAGA\\\nACCAACACCTCTTTACAGTGAAATGCCCCAACTAAATACTACCGTATGGCCCACCATAATTACCCCCATACTCCTTACA\\\nCTATTCCTCATCACCCAACTAAAAATATTAAACACAAACTACCACCTACCTCCCTCACCAAAGCCCATAAAAATAAAAA\\\nATTATAACAAACCCTGAGAACCAAAATGAACGAAAATCTGTTCGCTTCATTCATTGCCCCCACAATCCTAGGCCTACCC\\\nGCCGCAGTACTGATCATTCTATTTCCCCCTCTATTGATCCCCACCTCCAAATATCTCATCAACAACCGACTAATCACCA\\\nCCCAACAATGACTAATCAAACTAACCTCAAAACAAATGATAACCATACACAACACTAAAGGACGAACCTGATCTCTTAT\\\nACTAGTATCCTTAATCATTTTTATTGCCACAACTAACCTCCTCGGACTCCTGCCTCACTCATTTACACCAACCACCCAA\\\nCTATCTATAAACCTAGCCATGGCCATCCCCTTATGAGCGGGCACAGTGATTATAGGCTTTCGCTCTAAGATTAAAAATG\\\nCCCTAGCCCACTTCTTACCACAAGGCACACCTACACCCCTTATCCCCATACTAGTTATTATCGAAACCATCAGCCTACT\\\nCATTCAACCAATAGCCCTGGCCGTACGCCTAACCGCTAACATTACTGCAGGCCACCTACTCATGCACCTAATTGGAAGC\\\nGCCACCCTAGCAATATCAACCATTAACCTTCCCTCTACACTTATCATCTTCACAATTCTAATTCTACTGACTATCCTAG\\\nAAATCGCTGTCGCCTTAATCCAAGCCTACGTTTTCACACTTCTAGTAAGCCTCTACCTGCACGACAACACATAATGACC\\\nCACCAATCACATGCCTATCATATAGTAAAACCCAGCCCATGACCCCTAACAGGGGCCCTCTCAGCCCTCCTAATGACCT\\\nCCGGCCTAGCCATGTGATTTCACTTCCACTCCATAACGCTCCTCATACTAGGCCTACTAACCAACACACTAACCATATA\\\nCCAATGATGGCGCGATGTAACACGAGAAAGCACATACCAAGGCCACCACACACCACCTGTCCAAAAAGGCCTTCGATAC\\\nGGGATAATCCTATTTATTACCTCAGAAGTTTTTTTCTTCGCAGGATTTTTCTGAGCCTTTTACCACTCCAGCCTAGCCC\\\nCTACCCCCCAATTAGGAGGGCACTGGCCCCCAACAGGCATCACCCCGCTAAATCCCCTAGAAGTCCCACTCCTAAACAC\\\nATCCGTATTACTCGCATCAGGAGTATCAATCACCTGAGCTCACCATAGTCTAATAGAAAACAACCGAAACCAAATAATT\\\nCAAGCACTGCTTATTACAATTTTACTGGGTCTCTATTTTACCCTCCTACAAGCCTCAGAGTACTTCGAGTCTCCCTTCA\\\nCCATTTCCGACGGCATCTACGGCTCAACATTTTTTGTAGCCACAGGCTTCCACGGACTTCACGTCATTATTGGCTCAAC\\\nTTTCCTCACTATCTGCTTCATCCGCCAACTAATATTTCACTTTACATCCAAACATCACTTTGGCTTCGAAGCCGCCGCC\\\nTGATACTGGCATTTTGTAGATGTGGTTTGACTATTTCTGTATGTCTCCATCTATTGATGAGGGTCTTACTCTTTTAGTA\\\nTAAATAGTACCGTTAACTTCCAATTAACTAGTTTTGACAACATTCAAAAAAGAGTAATAAACTTCGCCTTAATTTTAAT\\\nAATCAACACCCTCCTAGCCTTACTACTAATAATTATTACATTTTGACTACCACAACTCAACGGCTACATAGAAAAATCC\\\nACCCCTTACGAGTGCGGCTTCGACCCTATATCCCCCGCCCGCGTCCCTTTCTCCATAAAATTCTTCTTAGTAGCTATTA\\\nCCTTCTTATTATTTGATCTAGAAATTGCCCTCCTTTTACCCCTACCATGAGCCCTACAAACAACTAACCTGCCACTAAT\\\nAGTTATGTCATCCCTCTTATTAATCATCATCCTAGCCCTAAGTCTGGCCTATGAGTGACTACAAAAAGGATTAGACTGA\\\nACCGAATTGGTATATAGTTTAAACAAAACGAATGATTTCGACTCATTAAATTATGATAATCATATTTACCAAATGCCCC\\\nTCATTTACATAAATATTATACTAGCATTTACCATCTCACTTCTAGGAATACTAGTATATCGCTCACACCTCATATCCTC\\\nCCTACTATGCCTAGAAGGAATAATACTATCGCTGTTCATTATAGCTACTCTCATAACCCTCAACACCCACTCCCTCTTA\\\nGCCAATATTGTGCCTATTGCCATACTAGTCTTTGCCGCCTGCGAAGCAGCGGTGGGCCTAGCCCTACTAGTCTCAATCT\\\nCCAACACATATGGCCTAGACTACGTACATAACCTAAACCTACTCCAATGCTAAAACTAATCGTCCCAACAATTATATTA\\\nCTACCACTGACATGACTTTCCAAAAAACACATAATTTGAATCAACACAACCACCCACAGCCTAATTATTAGCATCATCC\\\nCTCTACTATTTTTTAACCAAATCAACAACAACCTATTTAGCTGTTCCCCAACCTTTTCCTCCGACCCCCTAACAACCCC\\\nCCTCCTAATACTAACTACCTGACTCCTACCCCTCACAATCATGGCAAGCCAACGCCACTTATCCAGTGAACCACTATCA\\\nCGAAAAAAACTCTACCTCTCTATACTAATCTCCCTACAAATCTCCTTAATTATAACATTCACAGCCACAGAACTAATCA\\\nTATTTTATATCTTCTTCGAAACCACACTTATCCCCACCTTGGCTATCATCACCCGATGAGGCAACCAGCCAGAACGCCT\\\nGAACGCAGGCACATACTTCCTATTCTACACCCTAGTAGGCTCCCTTCCCCTACTCATCGCACTAATTTACACTCACAAC\\\nACCCTAGGCTCACTAAACATTCTACTACTCACTCTCACTGCCCAAGAACTATCAAACTCCTGAGCCAACAACTTAATAT\\\nGACTAGCTTACACAATAGCTTTTATAGTAAAGATACCTCTTTACGGACTCCACTTATGACTCCCTAAAGCCCATGTCGA\\\nAGCCCCCATCGCTGGGTCAATAGTACTTGCCGCAGTACTCTTAAAACTAGGCGGCTATGGTATAATACGCCTCACACTC\\\nATTCTCAACCCCCTGACAAAACACATAGCCTACCCCTTCCTTGTACTATCCCTATGAGGCATAATTATAACAAGCTCCA\\\nTCTGCCTACGACAAACAGACCTAAAATCGCTCATTGCATACTCTTCAATCAGCCACATAGCCCTCGTAGTAACAGCCAT\\\nTCTCATCCAAACCCCCTGAAGCTTCACCGGCGCAGTCATTCTCATAATCGCCCACGGGCTTACATCCTCATTACTATTC\\\nTGCCTAGCAAACTCAAACTACGAACGCACTCACAGTCGCATCATAATCCTCTCTCAAGGACTTCAAACTCTACTCCCAC\\\nTAATAGCTTTTTGATGACTTCTAGCAAGCCTCGCTAACCTCGCCTTACCCCCCACTATTAACCTACTGGGAGAACTCTC\\\nTGTGCTAGTAACCACGTTCTCCTGATCAAATATCACTCTCCTACTTACAGGACTCAACATACTAGTCACAGCCCTATAC\\\nTCCCTCTACATATTTACCACAACACAATGGGGCTCACTCACCCACCACATTAACAACATAAAACCCTCATTCACACGAG\\\nAAAACACCCTCATGTTCATACACCTATCCCCCATTCTCCTCCTATCCCTCAACCCCGACATCATTACCGGGTTTTCCTC\\\nTTGTAAATATAGTTTAACCAAAACATCAGATTGTGAATCTGACAACAGAGGCTTACGACCCCTTATTTACCGAGAAAGC\\\nTCACAAGAACTGCTAACTCATGCCCCCATGTCTAACAACATGGCTTTCTCAACTTTTAAAGGATAACAGCTATCCATTG\\\nGTCTTAGGCCCCAAAAATTTTGGTGCAACTCCAAATAAAAGTAATAACCATGCACACTACTATAACCACCCTAACCCTG\\\nACTTCCCTAATTCCCCCCATCCTTACCACCCTCGTTAACCCTAACAAAAAAAACTCATACCCCCATTATGTAAAATCCA\\\nTTGTCGCATCCACCTTTATTATCAGTCTCTTCCCCACAACAATATTCATGTGCCTAGACCAAGAAGTTATTATCTCGAA\\\nCTGACACTGAGCCACAACCCAAACAACCCAGCTCTCCCTAAGCTTCAAACTAGACTACTTCTCCATAATATTCATCCCT\\\nGTAGCATTGTTCGTTACATGGTCCATCATAGAATTCTCACTGTGATATATAAACTCAGACCCAAACATTAATCAGTTCT\\\nTCAAATATCTACTCATCTTCCTAATTACCATACTAATCTTAGTTACCGCTAACAACCTATTCCAACTGTTCATCGGCTG\\\nAGAGGGCGTAGGAATTATATCCTTCTTGCTCATCAGTTGATGATACGCCCGAGCAGATGCCAACACAGCAGCCATTCAA\\\nGCAATCCTATACAACCGTATCGGCGATATCGGTTTCATCCTCGCCTTAGCATGATTTATCCTACACTCCAACTCATGAG\\\nACCCACAACAAATAGCCCTTCTAAACGCTAATCCAAGCCTCACCCCACTACTAGGCCTCCTCCTAGCAGCAGCAGGCAA\\\nATCAGCCCAATTAGGTCTCCACCCCTGACTCCCCTCAGCCATAGAAGGCCCCACCCCAGTCTCAGCCCTACTCCACTCA\\\nAGCACTATAGTTGTAGCAGGAATCTTCTTACTCATCCGCTTCCACCCCCTAGCAGAAAATAGCCCACTAATCCAAACTC\\\nTAACACTATGCTTAGGCGCTATCACCACTCTGTTCGCAGCAGTCTGCGCCCTTACACAAAATGACATCAAAAAAATCGT\\\nAGCCTTCTCCACTTCAAGTCAACTAGGACTCATAATAGTTACAATCGGCATCAACCAACCACACCTAGCATTCCTGCAC\\\nATCTGTACCCACGCCTTCTTCAAAGCCATACTATTTATGTGCTCCGGGTCCATCATCCACAACCTTAACAATGAACAAG\\\nATATTCGAAAAATAGGAGGACTACTCAAAACCATACCTCTCACTTCAACCTCCCTCACCATTGGCAGCCTAGCATTAGC\\\nAGGAATACCTTTCCTCACAGGTTTCTACTCCAAAGACCACATCATCGAAACCGCAAACATATCATACACAAACGCCTGA\\\nGCCCTATCTATTACTCTCATCGCTACCTCCCTGACAAGCGCCTATAGCACTCGAATAATTCTTCTCACCCTAACAGGTC\\\nAACCTCGCTTCCCCACCCTTACTAACATTAACGAAAATAACCCCACCCTACTAAACCCCATTAAACGCCTGGCAGCCGG\\\nAAGCCTATTCGCAGGATTTCTCATTACTAACAACATTTCCCCCGCATCCCCCTTCCAAACAACAATCCCCCTCTACCTA\\\nAAACTCACAGCCCTCGCTGTCACTTTCCTAGGACTTCTAACAGCCCTAGACCTCAACTACCTAACCAACAAACTTAAAA\\\nTAAAATCCCCACTATGCACATTTTATTTCTCCAACATACTCGGATTCTACCCTAGCATCACACACCGCACAATCCCCTA\\\nTCTAGGCCTTCTTACGAGCCAAAACCTGCCCCTACTCCTCCTAGACCTAACCTGACTAGAAAAGCTATTACCTAAAACA\\\nATTTCACAGCACCAAATCTCCACCTCCATCATCACCTCAACCCAAAAAGGCATAATTAAACTTTACTTCCTCTCTTTCT\\\nTCTTCCCACTCATCCTAACCCTACTCCTAATCACATAACCTATTCCCCCGAGCAATCTCAATTACAATATATACACCAA\\\nCAAACAATGTTCAACCAGTAACTACTACTAATCAACGCCCATAATCATACAAAGCCCCCGCACCAATAGGATCCTCCCG\\\nAATCAACCCTGACCCCTCTCCTTCATAAATTATTCAGCTTCCTACACTATTAAAGTTTACCACAACCACCACCCCATCA\\\nTACTCTTTCACCCACAGCACCAATCCTACCTCCATCGCTAACCCCACTAAAACACTCACCAAGACCTCAACCCCTGACC\\\nCCCATGCCTCAGGATACTCCTCAATAGCCATCGCTGTAGTATATCCAAAGACAACCATCATTCCCCCTAAATAAATTAA\\\nAAAAACTATTAAACCCATATAACCTCCCCCAAAATTCAGAATAATAACACACCCGACCACACCGCTAACAATCAATACT\\\nAAACCCCCATAAATAGGAGAAGGCTTAGAAGAAAACCCCACAAACCCCATTACTAAACCCACACTCAACAGAAACAAAG\\\nCATACATCATTATTCTCGCACGGACTACAACCACGACCAATGATATGAAAAACCATCGTTGTATTTCAACTACAAGAAC\\\nACCAATGACCCCAATACGCAAAACTAACCCCCTAATAAAATTAATTAACCACTCATTCATCGACCTCCCCACCCCATCC\\\nAACATCTCCGCATGATGAAACTTCGGCTCACTCCTTGGCGCCTGCCTGATCCTCCAAATCACCACAGGACTATTCCTAG\\\nCCATGCACTACTCACCAGACGCCTCAACCGCCTTTTCATCAATCGCCCACATCACTCGAGACGTAAATTATGGCTGAAT\\\nCATCCGCTACCTTCACGCCAATGGCGCCTCAATATTCTTTATCTGCCTCTTCCTACACATCGGGCGAGGCCTATATTAC\\\nGGATCATTTCTCTACTCAGAAACCTGAAACATCGGCATTATCCTCCTGCTTGCAACTATAGCAACAGCCTTCATAGGCT\\\nATGTCCTCCCGTGAGGCCAAATATCATTCTGAGGGGCCACAGTAATTACAAACTTACTATCCGCCATCCCATACATTGG\\\nGACAGACCTAGTTCAATGAATCTGAGGAGGCTACTCAGTAGACAGTCCCACCCTCACACGATTCTTTACCTTTCACTTC\\\nATCTTGCCCTTCATTATTGCAGCCCTAGCAACACTCCACCTCCTATTCTTGCACGAAACGGGATCAAACAACCCCCTAG\\\nGAATCACCTCCCATTCCGATAAAATCACCTTCCACCCTTACTACACAATCAAAGACGCCCTCGGCTTACTTCTCTTCCT\\\nTCTCTCCTTAATGACATTAACACTATTCTCACCAGACCTCCTAGGCGACCCAGACAATTATACCCTAGCCAACCCCTTA\\\nAACACCCCTCCCCACATCAAGCCCGAATGATATTTCCTATTCGCCTACACAATTCTCCGATCCGTCCCTAACAAACTAG\\\nGAGGCGTCCTTGCCCTATTACTATCCATCCTCATCCTAGCAATAATCCCCATCCTCCATATATCCAAACAACAAAGCAT\\\nAATATTTCGCCCACTAAGCCAATCACTTTATTGACTCCTAGCCGCAGACCTCCTCATTCTAACCTGAATCGGAGGACAA\\\nCCAGTAAGCTACCCTTTTACCATCATTGGACAAGTAGCATCCGTACTATACTTCACAACAATCCTAATCCTAATACCAA\\\nCTATCTCCCTAATTGAAAACAAAATACTCAAATGGGCCTGTCCTTGTAGTATAAACTAATACACCAGTCTTGTAAACCG\\\nGAGATGAAAACCTTTTTCCAAGGACAAATCAGAGAAAAAGTCTTTAACTCCACCATTAGCACCCAAAGCTAAGATTCTA\\\nATTTAAACTATTCTCTGTTCTTTCATGGGGAAGCAGATTTGGGTACCACCCAAGTATTGACTCACCCATCAACAACCGC\\\nTATGTATTTCGTACATTACTGCCAGCCACCATGAATATTGTACGGTACCATAAATACTTGACCACCTGTAGTACATAAA\\\nAACCCAATCCACATCAAAACCCCCTCCCCATGCTTACAAGCAAGTACAGCAATCAACCCTCAACTATCACACATCAACT\\\nGCAACTCCAAAGCCACCCCTCACCCACTAGGATACCAACAAACCTACCCACCCTTAACAGTACATAGTACATAAAGCCA\\\nTTTACCGTACATAGCACATTACAGTCAAATCCCTTCTCGTCCCCATGGATGACCCCCCTCAGATAGGGGTCCCTTGACC\\\nACCATCCTCCGTGAAATCAATATCCCGCACAAGAGTGCTACTCTCCTCGCTCCGGGCCCATAACACTTGGGGGTAGCTA\\\nAAGTGAACTGTATCCGACATCTGGTTCCTACTTCAGGGTCATAAAGCCTAAATAGCCCACACGTTCCCCTTAAATAAGA\\\nCATCACGATG\";\n\n// Pattern has same length as in pattern_matching.rs, but 2 differences to best match.\n// With k = 5 there are 14 hits, with k = 6, there are 78 hits (most are overlapping)\nstatic PATTERN: \u0026'static [u8] = b\"GCGCGTCCACACCGCTCG\";\n\nstatic K: u8 = 6;\n// used with assertions to ensure correct code and to prevent over-optimization\nstatic N_HITS: usize = 78; // at given K\n\n#[bench]\nfn ukkonen(b: \u0026mut Bencher) {\n    let mut ukkonen = Ukkonen::with_capacity(PATTERN.len(), unit_cost);\n    b.iter(|| {\n        let mut n = 0;\n        for _ in ukkonen.find_all_end(PATTERN, TEXT, K as usize) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn pairwise_align(b: \u0026mut Bencher) {\n    use bio::alignment::pairwise;\n\n    let s = pairwise::Scoring::new(-1, -1, |a, b| if a == b { 1 } else { -1 });\n    let mut aligner = pairwise::Aligner::with_scoring(s);\n\n    b.iter(|| {\n        let _ = aligner.semiglobal(PATTERN, TEXT);\n    });\n}\n\n#[bench]\nfn myers_end_32(b: \u0026mut Bencher) {\n    let myers: Myers\u003cu32\u003e = Myers::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        for _ in myers.find_all_end(TEXT, K) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_end_64(b: \u0026mut Bencher) {\n    let myers = Myers::\u003cu64\u003e::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        for _ in myers.find_all_end(TEXT, K) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_end_long_64(b: \u0026mut Bencher) {\n    let myers = long::Myers::\u003cu64\u003e::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        for _ in myers.find_all_end(TEXT, K as usize) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_end_long_8(b: \u0026mut Bencher) {\n    let myers = long::Myers::\u003cu8\u003e::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        for _ in myers.find_all_end(TEXT, K as usize) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[cfg(has_u128)]\n#[bench]\nfn myers_end_128(b: \u0026mut Bencher) {\n    let myers = Myers::\u003cu128\u003e::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        for _ in myers.find_all_end(TEXT, K) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[cfg(has_u128)]\n#[bench]\nfn myers_end_long_128(b: \u0026mut Bencher) {\n    let myers = long::Myers::\u003cu128\u003e::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        for _ in myers.find_all_end(TEXT, K as usize) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_pos_64(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu64\u003e::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        let matches = myers.find_all(TEXT, K);\n        for _ in matches {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[cfg(has_u128)]\n#[bench]\nfn myers_pos_128(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu128\u003e::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        let matches = myers.find_all(TEXT, K);\n        for _ in matches {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_path_reverse_64(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu64\u003e::new(PATTERN);\n    let mut ops = vec![];\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all(TEXT, K);\n        while let Some(_) = matches.next_path_reverse(\u0026mut ops) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_path_64(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu64\u003e::new(PATTERN);\n    let mut ops = vec![];\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all(TEXT, K);\n        while let Some(_) = matches.next_path(\u0026mut ops) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_path_long_64(b: \u0026mut Bencher) {\n    let mut myers = long::Myers::\u003cu64\u003e::new(PATTERN);\n    let mut ops = vec![];\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all(TEXT, K as usize);\n        while let Some(_) = matches.next_path(\u0026mut ops) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_path_long_8(b: \u0026mut Bencher) {\n    let mut myers = long::Myers::\u003cu8\u003e::new(PATTERN);\n    let mut ops = vec![];\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all(TEXT, K as usize);\n        while let Some(_) = matches.next_path(\u0026mut ops) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[cfg(has_u128)]\n#[bench]\nfn myers_path_long_128(b: \u0026mut Bencher) {\n    let mut myers = long::Myers::\u003cu128\u003e::new(PATTERN);\n    let mut ops = vec![];\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all(TEXT, K as usize);\n        while let Some(_) = matches.next_path(\u0026mut ops) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_alignment_64(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu64\u003e::new(PATTERN);\n    let mut aln = Alignment::default();\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all(TEXT, K);\n        while matches.next_alignment(\u0026mut aln) {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n// Allocates a new Alignment instance in each loop\n#[bench]\nfn myers_alignment_alloc_64(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu64\u003e::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all(TEXT, K);\n        loop {\n            let mut aln = Alignment::default();\n            if !matches.next_alignment(\u0026mut aln) {\n                break;\n            }\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n// test impact of storing traceback information\n#[bench]\nfn myers_no_alignment_64(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu64\u003e::new(PATTERN);\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all(TEXT, K);\n        while let Some(_) = matches.next_end() {\n            n += 1;\n        }\n        assert_eq!(n, N_HITS);\n    });\n}\n\n// test impact of storing traceback information\n#[bench]\nfn myers_no_alignment_lazy_64(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu64\u003e::new(PATTERN);\n    b.iter(|| {\n        let n = myers.find_all_lazy(TEXT, K).count();\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_lazy_best_alignment_64(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu64\u003e::new(PATTERN);\n    let mut aln = Alignment::default();\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all_lazy(TEXT, K);\n        let mut best_dist = u8::max_value();\n        let mut best_end = 0;\n        for (end, dist) in matches.by_ref() {\n            if dist \u003c best_dist {\n                best_dist = dist;\n                best_end = end;\n            }\n            n += 1;\n        }\n        matches.alignment_at(best_end, \u0026mut aln);\n        assert_eq!(n, N_HITS);\n    });\n}\n\n#[bench]\nfn myers_lazy_best_alignment_iter_min_64(b: \u0026mut Bencher) {\n    let mut myers = Myers::\u003cu64\u003e::new(PATTERN);\n    let mut aln = Alignment::default();\n    b.iter(|| {\n        let mut n = 0;\n        let mut matches = myers.find_all_lazy(TEXT, K);\n        let (best_end, _) = matches\n            .by_ref()\n            .inspect(|_| n += 1)\n            .min_by_key(|\u0026(_, dist)| dist)\n            .unwrap();\n        matches.alignment_at(best_end, \u0026mut aln);\n        assert_eq!(n, N_HITS);\n    });\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","benches","distance.rs"],"content":"#![feature(test)]\n\nextern crate test;\n\nuse test::{black_box, Bencher};\n\nuse bio::alignment::distance::*;\n\nuse std::u32;\n\n// 5,000 random nucleotides, GC content = .55\nstatic STR_1: \u0026'static [u8] = b\"ATCTAACTATTCCCTGTGCCTTATGGGGGCCTGCGCTATCTGCCTGT\\\nCGAACCATAGGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCGGGGCCTAAGACCACGAGCGTCTGGCG\\\nTCTTGGCTAACCCCCCTACATGCTGTTATAGACAATCAGTGGAAACCCGGTGCCAGGGGGTGGAGTGACCTTAAGTCAG\\\nGGACGATATTAATCGGAAGGAGTATTCAACGCAATGAAGCCGCAGGGTTGGCGTGGGAATGGTGCTTCTGTCCAAGCAG\\\nGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTGCACTTTGCAACGATTTCGGAGTCCGGAGACTCGCTG\\\nTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTACGCCCAAGAACGTAGCAAGGTGACTCAAACAAGGTA\\\nCATCTTGCCCGCGTTTCACACGAATCAAGTTGGAGGTTATGGAGCATAGTAACACGTGGGCGGCCAGTGGTCGGTTGCT\\\nACACCCCTGCCGCAACGTTGAAGGTCCCGGATTAGACTGGCTGGACCCATGCCGTGACACCCGTCACACTCCATTACCG\\\nTCTGCGGGTCACGGCTTGTTGTGGACTGGATTGCCATTCTCTCAGTGTATTACGCAGGCCGGCGCGCGGGTCCCATGTA\\\nAACCTGTCATAGCTTACCTGACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCCACGCACCTGGTCGGTCCTCGTTTGCT\\\nTTTTAGGACCGGATGAACTACAGAGCGCTGCAAGAATCTCTACCTGCTTTACAAAGCGCTGGGTCCTACTCCAGCGGGA\\\nTGTTTTATCTAAACACGATGAGAGGAGTATTCGTCAGGCCACATGGCTTTCTTGTCCTGGTCGGATCCATCGTTGGCGC\\\nCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTGCATGCCAGATCGGCAGACAGATAGCGGATCCAGTAT\\\nATCCCTGGAAGCTATAGACGCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTCCGAACCCAGCTCTACTTTAGTGGCCA\\\nCGGGTTCTGGTCCCCCCGGGCCGCGGAACCGATTAGGGCCATGTACAACAATACTTATTAGTCACCTTTCAGACACGAT\\\nCTCCCTGCTCAGTGGTATATGGTTCCTGCTATAATTAGCCACCCTCATAAGTTGCACTACTTCTGCGACCCAAGTGCAC\\\nCCTTACCACGAAGACAGGATTGTCCGATCCCATACTGCGGCCTTGGCAGGGGGTTCGCAAGTCCCACCCCAAACGATGC\\\nTGAAGGCTCAGGTTACACAGGCACAAGTGCTATATACGCGAGTTCCCGCTCTTAACCTGGACCGAATGCGGGATCATGC\\\nATCGTACCACTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGATACATAGTTCAATCAAGAATACCTTGTATTATTGTA\\\nCACCTACCGGTCACCAGCCAACAATGTGCGGACGGCGTTGCGACTTGCTGGGCCTGATCTCACCGCCCTAGATACCGCA\\\nCACTGGGCAATACGAGGTAAAGCCAGTCACCCAGTGTCGATCAACAGCTGACGTAACGGTAAGAGGCTCACAAAATCGC\\\nACCGCCGGCGTCCCCTGGGTATTTTACGTCAGCATCGGGTGGACTGGCATGAATCTTTACTCCCAGGCGGAAACGGGTG\\\nCGTGGACAAGCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGGTGTCTCGTATCCCTCTTGGAGATCGAGGAAATGTTT\\\nCACGACCAAGGGAAAGGTCGCCCTACGAAATAGATTTGCGCTACTGTCCGCATAAGGAGTCCGGTGTAGCGAAGGATGA\\\nAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAAGCAGGCACGGAAAGACACGGTCTAGC\\\nAGACCGTCTATCGGCTAGGTCAAATAGGGTGCTTTGATATCAGCATGTCCAGCCTTAGAATTCAGTTCAGCGCGCTGGT\\\nCTGGGTCGAGATAAAATCACCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTGGCTAATCCTGGTACATCTTGTAATCA\\\nATGTTCAGAAGAAAATCTGTGTTAGAGGGACGAGTCACCACGTACCAATAGCGACAACGATCGGTCGGACTATTCATCG\\\nTGGTGGTGACGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAGGATATAATGCTGAGGCGCTGCCCCAA\\\nCCGTTCAGCGTGGGGTTTGCTACAACTTCCGAGTGCTACGTGTGCGAGACCATGTTATGTATGCACAAGGCCGACAATA\\\nGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCACAGTAGATCCTCCCCGCGCATCCTATTTATTAAGTT\\\nAATTCTATAGCAATACGATCACATGCGGATGGGCAGTGGCCGGTAGTCACACGCCTACCGCGGTGCTCAATGACCGGGA\\\nCTAGAGAGGCGAAGATTATGGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGAGCGTCATTGCGAGTAGTCGATTGCTT\\\nTCCCAATCTCCGAGCGATTTAGCGTGACAGCCCCAGGGAACCCACAAAATGCGATCGCAGTCCACCCGATCGTACACAG\\\nAAAGGAGGGTCCCCATACGCCGACGCACCTGTTCGCACGTCGTATGCATAAACGAGCCGCACGAACCAGAGAGCATAAA\\\nGAGGACCTCTAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGCCGGGATGCCTTACCTAGACGCAATGACGGACGTATT\\\nCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAAGCCGCCTTTCCAAAGTGAGTCCTTCG\\\nTCTGTGACTAACTGTGCCAGATCGTCTTGCAAACTCCCGATCCAGTTTAACTCACCAAACTATAGCCGTACAGACCCAA\\\nATCTTAAGTCATATCACGCGACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGTTTTGGTCCGCCCGAGCGGTGCAGCCG\\\nATTAGGACCATCTAATGCACTTGTTACAAGACTTCTTTTAAACACTTTCTTCCTGCCCAGTGGCGGATGATAATGGTTG\\\nTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAATGTGCCGTCTCCACCAACACAGGGCTGTCCGGTCGT\\\nATAATAGGACTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGGACTCGCGATGTACATGCTCTGGTTCA\\\nATACATACGTGACCCGGCAGTTATCCTGCATCGGAACGTCAATCGTGCATCGGGCCAGCGTAATCGTGTCATCTGGGAG\\\nGCGGCCGTAGGATAAATAATTCAATAAAGATGTCGTTTTGCTAGTATACGCCTAGGCGTCACCCGCCATCTCTGTGCAG\\\nGTGGGCCGACGAGACACTGCCCCTGATTTCTCCGCTACTAATAGCACACACGGGGCAATACCAGCACAAGCCAGTCTCG\\\nCGGGAACGCTCGTCAGCATACGAAAGAGCTTGAGGCACGCCAATTCGCACTGTCGGGGTCGCTTGGGTGTTTTGCACTA\\\nCCGTCAGGTACGCTAGTATGCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGGTCAAAAGTGCGGCATTCGTATTTGCT\\\nCCCCGTGCTTGCTCTCACGAACTTGACCTGGAGATCAAGGAGATGCTTCTTGTGGAACCGGACAGCGCATCAACGCAAC\\\nGGATCTACGTTACAGCGTGCATAGCGAGAACGGAGTTGCCGACGACGAAAGCGACACTGGGATCTGTCCGTCGTCATTC\\\nGCGGAAAGCATCCGCTCACGAGGCGGACACTGATTGACACGGTTTTGCAGAAGGTTAGGGGAATAGGTCAAATTGAGTG\\\nGCTTAAAAACGCTATGTCTGGGATTAAAGTGTAGTAAACTGCGGTCAACGGAGACGGTTTTAAGACAGGAGTTCGCAAA\\\nACCAGGCGGGGTCGCCACGACGGCTATTCCTGGTGGTTTAGGCGTACAATGTCCTGAAGAATATTTAAGAAAGAAGCAC\\\nCCCTCGTCGCCTAGAATTACCTACCGCGGTCGACCATACCTTCGATTGTCGCGCCCACCCTCCCATTAGTCGGCAGAGG\\\nTGGTTGTGTTGCGATAGCCCAGCATGATATCCTAAGGCGTTACGCCGATGGATATCCCACGGAATTGCCATAGGCGCTG\\\nAACGCTACACGGACGATACGAACTTATGTATGGAGCGGGTCATCGAAAGGTCATACCCTTGTAGTTAACATGTAGCCCG\\\nGCCCTATTAGTACAGCAGTGCCTTGAGCGGCATTCTCATTATTAAGTTTTCTCTACAGCCAAACGACCAAGTGCACTTC\\\nCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCAGCTCTGTAATAGGGACTAAAAGAGTGATGATAATCATGAGTGCCGC\\\nGTTATGGTGGTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCGAGTTCCGTCCGGTTAAGCGTGACACT\\\nCCCAGTGTACCCGCAAACCGTGATGGCTGTGCTTGGGGTCAATCGCATGTAGGATGGTCTCCAGACACCGGGGCACCAG\\\nTTTTCACGCCCAAAGCATAAACGACGAGCAGTCATGAGAGTCTTAGAACTGGACGTGCCGTTTCTCTGCGAACAACACC\\\nTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTCCTATCACATTTGCCTCGACGACTGCCGCCTTCGCTG\\\nTTTCCCTAGACACTCAACAGTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGTCAGTGGCTGCGCCAAAACGTCTTCGG\\\nATCCCCTTGTCCAATCAAACTGACCGAATTCTTTCATTTAAGACCCTAATATGACATCATTAGTGACTAAATGCCACTC\\\nCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAACGA\";\n// 5,000 random nucleotides, GC content = .45\nstatic STR_2: \u0026'static [u8] = b\"CTAAAGTGGCGAAATTTATGGTGTGTGACCCGTTATGCTCCATTTCG\\\nGTCAGTGGGTCATTGCTAGTAGTCGATTGCATTGTCATTCTCCGAGTGATTTAGCGTGACAGCCGCAGGGAACCCATAA\\\nAATGTAATCGTAGTCCATCTGATCGTACTTAGAAATGAAGGTCCCCTTTTACCCACGCACCTGTTTACTCGTCGTTTGC\\\nTTTTAAGAACCGCACGAACCACAGAGCATAAAGAGAACCTCTAGTTCCTTTACAAAGTACTGGTTCCCTTTTCAGCAAG\\\nATGCCTTATCTAAATGCAATGACAGACGTATTCCTCAGGCCACATCGCTTCCTACTTTCGCTGGGATCCATCATTGGCA\\\nGCTGAAACCGCCATTCCATAGTGAGTCCTTCGTCTGTGTCTTTCTGTGCCAAATCGTCTAGCAAATTGCTGATCCAGTT\\\nTATCTCACGAAATTATAGTCATACAGACCGAAATTTTAAATCAAATCACGCGACTAGGCTCAGCTTTATTTTAGTGGTC\\\nATGGGTTTTGGTCCGCCCGAGCGGTGCAACCGATTAGGACCATGTAAAACATTTGTTACAAGTCTTCTTTTAAATACAA\\\nTCTTCCTGCTCAGTAGCGCATGATTATCGTTGTTGCTAGCCAGTGTGGTAAGTAACAGCACCACTGCGAGCCTAATGTG\\\nCCCTTTCCACGAACACAAGGCTATCCGATCCTATATTAGGATTCCGCAATGGGGTTAGCAAATCGCACCCTAAACGATA\\\nTTGAAGACTTGCGATGTACATGCTTTGGTACAATACATACGTGTTCCAGTTGTTATCCTGTATCGGAACTTCAATTATG\\\nCATCGCACCAGCATATTCATGTCATCTAGGAAGAGCGCGTAGGATAAATAATTCAATTAAGATGTCGTTATGCTAGTAT\\\nACGTCTACCCGTCACCGGCCATCTGTGTGCAGATGGGGCGACGAGTTATTGACCCTGATTTCTCCACTTCTAATACCAC\\\nACACTGGGCAATACGAGCTCAAGCTAGTCTCGCAGTAACGCTCATCAGCTAACGAAAGAGTTAAAGGCTCGCTAATTCG\\\nCACTGTCAGGGTCTCTTGGGTGTTTTGCACTAGCGTCAGGTAGGCTAGTATGTGTTTTTCCTTCCAGAGGTATGTGGCT\\\nGCGTGGTCAAATGTGCAGCATACGTATTTGCTCGACGTGTTTAGTCTCTCATACTTCTCCTGGAGATCAAGGAAATGTT\\\nTCTTGTCCAAGTGGACAACGGTTCTACGGAATGGATCTACGTTACTGCCTGCATAAAGAAAACGGAGTTGCTAAGGACG\\\nAAAGCGACTTTAGGTTCTAACTGTTGACTTTGGCGGAAAAGTTTCATTCAGGAAGCAGACACTGATTGACACGGTTTAG\\\nCAGAACGTTTGAGGATTAGGTTAAATTGAGTGGTTTAATATTGGTATGTCTGGGATTAAAATATAGTATAGTGTGTTAA\\\nTCGGAGACGAATTAAAGACACGAGTTCCCAAAATCAAGCGGGCTCATTACAACGGTTAATCCTGGTAGTTTACGTGAAC\\\nAATGTTCTGAAGAAAATTTATGAAAAAAGGACCCGTCATCGCCTACAATTACCTACAACGGTCGACCATACCTTCGATT\\\nATCGTGGCCACTCTCGGATTACACGGCAGAGGTGGTTGTGTTCCGATAGGCCAGTATATTATTCTAAGGCGTTACCCTA\\\nATCATTTTTCATCGGATTTGCTATAGCCCTTGAACGCTACATGCACGAAACCAAATTATGTATACACTGGGTCATCAAT\\\nAGGATATAGTCTTGTAGTTAACATGTAGCCCGGCCGTATTAGTACAGTAGAGCCTTCATTGACATTCTGTTTATTAAAT\\\nTATTTCTACAGCAAAACGATCATATGCAAATCCACAGTGCGCGATAGAGATACATTCACTCGGCTGCTCTGTAATAGGG\\\nACTAAAAAAGTGATGATTATCATGAGTGCCCCGTTATGGTCGTGTTCGATCAGAGCGCTCTTACGAGCAGTCGTATACT\\\nTTCTCGAATTCCGTGCAGTTAAGCGTGACAGTCCCAGTGAACCCACAAAACGTGATGGCAGTCCATGCAATCATACGCA\\\nAGAAGGATGGTCTCCAGACACCGGCGCACCAGTTTTCACGCCGAAAGCATAAACGAGGAGCACAAATGAAAGTGTTTGA\\\nACTGGACCTGTAGTTTCTCTACGAAAAATACCTTGAGCTGTTGCGTTGTTGCGCTGCCTAGATGCAGTGTTGCACATAT\\\nCACTTTTGCTTCAACGACTGCTGCTTTCGCTGTAACCCTAGACAGACAACAATAAGCGCTTTTTGTAGGCAAGAGCTCC\\\nGCCTATGACTAACTGCGCCAAAACATCTTCCAATCCCCTTATCCAATTTAATTCATCGAATTCTTACAATTTAGACCCT\\\nAATATCACATCATTAGACATTAATTGCCTCTGCCAAAATTCTGTCTACAAATGTTTTAGTTCGCTCCAGTAAAGTTGTT\\\nAATAACGACTACTAAATCCGCATGTTACGGGATTTCTTATTAATTCTTTTTTCGTAAGGAACAGCGGATCTTAATGGAT\\\nGGCGCCAGGTGGTATGGAAGCTAATAGCGCGGGTGAGAGGGTAATTAGCCGTCTTCACCAACACAACGCTATCGGGTCA\\\nTACTATAAGATTCCACAATGCGACTACTTATAAGATGTCTTAACGGTATCCGCAACTTGTGATGTGCCTACTATGCTTA\\\nAATGCATATCTCGCTCAGTAACTTTCCAATATGAGAGCATCAATTGTAGATCGGGCCGAGATAATCATGTCGTCACGGA\\\nACTTATTGTAAGAGTAATAATTTAAAAGAGATGTCAGTTTGCTGGTTCACGTAAAGGTTCCTCACACTACCTCTAAATA\\\nAGTGAGCGGTCGTGACATTATCCCTGATTTTCTCACTACTATTAGTACTCACGACACAATTCTACCACAGCCTTGTTTC\\\nGCCAGAATGCCAGTCAGCATAAAGAAGAGCTCAAGGCAGGTCAACTCGCATTGTGAGAGTTACATGAACGTTCGGCACT\\\nACCGACACGAACCTCAGTTAGCGTACATCCTACCAGAGGTCTGTGGCCCCGTGGTCAAAAGTGCGGATTTCGTATTTGC\\\nTGCTCGTCAGTACTTTCAGAATCATGACCTGCACGGTAAAAAGACGCTTATTATGGAGTTCGACATGGCAATAACGCGA\\\nCGAATCTACGTCATGACGAGAATAGTATAAACAAAACTGCTGACGGCAGAAGCGTCAAAGAAGTCTGTAAATTGTTATT\\\nCGCGAAAAACATCCGTCTCCGTGGGGGATAATCACCGACGCCATTTTATAGAAGCCTAGGGGAACAGATTGGTTTAATT\\\nAGCTTAAGAAAGTAAATTCTGGGATTATACTGTAGTAATCACTAATTTACGGTGAGGGTTTTATGGCGGATTTTTACAA\\\nATTCAAACCAGGTGATTTCAACAAATTTTGTTGACGATTTAGGCGCACTATCCCCTAAACTACAAATTAAAAAATAGCG\\\nTTCCTTGACGGCTAGAATTACTTACCGGCCTTCACCATACCTTCGATATTCGCGCCCACTCTCCCATTAATCCGTACAA\\\nGTGGATGTAATGCGATTGTCCGCTAAGATATTCTAACGTGTAACGTAGATAAGTATTTTACAGAGTTGCCGTACGCGTT\\\nGAACACTTCACAGATGATAGGAATTTGCGTATAGAGCGTGTTATTGAGGAGTTATACACCCGTAGACTACAATGGGCCC\\\nAACTCAATCAGAACTCGAGTGCCTTGAATAACATACTCATCACTAAACATTCTCAACAATCAATCGAGCAAGTCCATTA\\\nTCAACGAGTGTGTTGCAGTTTTATTCTCTTGCCAGCATTGTAATAGGCACTAAAAGAATGATGATAGTCATGAGTACTG\\\nAGCTAAGACGGCGTCGATGCATAGCGGACTTTCGGTCAATCACAATTCCTCACGAGACTCGTCCTGTTGAGCGTATCAC\\\nTCTCAATGTACAAGCAACCCAAGAAGGCTGTGCCTGGACTCAACTGGATGCAGGATGAACTCCAGACACGGGGTCACTA\\\nCTCTTCATACATAAAGCAAGAACGTCGAACAGTCATGAAAGTCTTAGTACCGCACGTACCATCTTACTGTGAATATTGC\\\nTTGAAGCTGTACCGTTATTGGGGGGCAAAGATGAAGTTCTCTTCTTTTCATAATTGTACTGACGACAGTCGTGTTCTCG\\\nGTTTCTTCAAAGGTTAAAGAATAAAGGCTTATTGTAGGCAGAGGAACGCCCTTTTAGTGGCTGGCGTTAAGTATCTTCG\\\nGACCCCCTTGTCTATCCAGATTAATCGAATTCTCTCATTTAGGACCTTAGTAAGTCATCATTGGTATTTGAATGCGACC\\\nTTGAAGAAACCGCTTAAAAATGTCAATGGTTGATCCACTAAACTTCATTTAATTAACTCCTAAATCAGCGCGATAGGCT\\\nATTAGAGGTTTAATTTTGTATAGCAAGGTACTTCCGATCTTAATGAATGGCCGGAAAAGGTACGGACGCGATATGCGAG\\\nGGTGAAAGGGCAAATAGACAGGTTCGTCTTTGTCACGCTAGGAGGCAATTCTATAAGAATGCATATTGCATCGATACAT\\\nAAAATGTCTCGATCGCATGCGCAATTTGTGAAGTGTCTATTATCCCTAAGCCCATTTCCCGCATAATAACCCCTGATTG\\\nTATCCGCATTTGATGCTACCCAGGTTGAGTTAGCGTCGAGCTCGCGGAACTTATTGCATGAGTAGAGTTGAGTAAGAGC\\\nTGTTAGATGGCTCGCTGAACTAATAGTTGTCCACAGAACGTCAAGATTAGAAAACGGTTGTAGCATTATCGGAGGTTCT\\\nCTAACTACTATCAATACCCGTGTCTTGACTCTGCTGCGGCTACCTATCGCCTGAAAACCAGTTGGTGTTAAGGGATGCT\\\nCTGTCCAGGACGCCACATGTAGTGAAACTTACATGTTCGTTGGGTTCACCCGACT\";\n// 5,000 random nucleotides, GC content = .0\nstatic STR_3: \u0026'static [u8] = b\"AATTTAAAATAAAATTATTTTAAAAAATAAATTTTTATTATTTTTTT\\\nTATAAATAATTTAATATATTAAAAATATAAAATTAATTTTTTTAATAATTATAAATTAAAAATTTAAAATATTATTTAA\\\nAATATAAATTTAATAATATATATTTTAATTATTTAATTATTTTTTATATTTTATAAAAATTTATATTATTTATTTATTA\\\nAATTATAAAATTTATATTAATATATAAATTTAAATTAAAATAAAATTTTTAAAATTTAAAATTATAAATATTTAATATT\\\nTTAATTAATTTTTATATATATTATTATAAATAATTAATAAAAATTTTATATTAAAAAATAAAATAATTTTAAATTAAAA\\\nATAATATTAATTAAAAAAAATATTTAATATAATAAAATTATAAAATTAATATAAAAATAATATTTTTATTTAAATAAAT\\\nAAAAATATAATATTATAATTATTTTTTAAATATATAAAATATATTTTATAATAATTTTTAAATTTAAAAATTTATTATT\\\nTTTAAAATTTATATTTAAAAATAAATATTAAATTAAATTTATATTTAAAAATATAATAAAATAATTTAAATAAAATATA\\\nTTTTATTTATATTTTATATAAATTAAATTAAAAATTATAAAATATAATAATATATAAATAATTAATAATTAATTATTAT\\\nATATTTATTATAATATTAAAAATTTTAAATTAAATTAATAAAATTTATATTATAATATTTATTATATTTTATTATTATT\\\nTATAAATTATAATTTATTATAAATTAAATTATTATTTTTTTAATATATTATAAAAATTAATATATAAATTTTATATAAA\\\nTTAATTATAATTTATTTAATTTTATTTAAAAATATAATTTTATTTTTATTTATATATTTAATTAATTTTTATTTATTTT\\\nTTAAAATTAAATAAATTATAAAATATTATAAAAATTTTTATTTATTTTATAAAATATTAAATTTTTTTTTAATAAAATA\\\nTTTTATTTAAATATAATAAAAAAAATATTTTTTAAATTATATAATTTTTTTATTTTATTTAAATTTATTATTAATAATT\\\nAATATTTTTATTTTATAATAAATTTTTTATTTAAATTATTATATATTAAATTAATTAATAAATAATAAATTTAATATAT\\\nTTTTAAAAATTATAAATATATAAATTAAAATTTTAAATAAAATTATATATTTAAATTTAATTTTATTTTAATAATTATA\\\nAATTTTAATTTTTTTAAATTATATAATTAATTAAAATTATATAAAATAATATTTATAAATTATTTTTTAAATATAATTT\\\nTTTTATTTAATAATATATAATTTTTATTATAATTAATTATTTTTATAAATAATATTATTTTTATAATTTAAATATATTT\\\nTTTTTATAAATATAAAATTATTTAATTTTATATTATAATTTTAATAAAAAATTTATAAATTTTATTTTAAATAATATTA\\\nAAAATTTAAATTATATAAATATAAATATTATATATATAAATTTTTATTTTTAATTTAAATTAAAAATATAATTATATAT\\\nTATATTATTATATTTATATTATTTAAAATAAATATATAAAATATATAATTTAATTAAAAATATTTTATATTATTATATA\\\nTTTATTAATTATTAATTAATAATATATAAATAATATTATAATTTATTAAATTTAATTTTATTATTTTAAATATTATATA\\\nTTAAATAATATAAAATAAAATTAATTATTTAATAATAATTATTAATTAATATAATAATAAAAAATTTATTAAATTATAT\\\nTATTAATATTTTTTAAATATTTTATATTAATATTAAATAAATTAATATAAATTTTTATTTTTAAAAAAAAATAAATATA\\\nTAAATAAATAAATAATAAATAAAAATTTTTAATATATTTAATATTTTATATTTTTTTTAAAAATTAAAAAAATATTTTA\\\nTAATTAAAAAAAAAATTATTTTATAAAATAAATTTATATTATTATTTATATAAAAAATTTAATATAATAAAAAATAAAA\\\nATAATTTTAAATAATAATTATTAATTTTAATAATAAAATATTATTTAAAAAATAAATATAAAAAAATATAATTTAATAA\\\nATTATTTAATAATTAAATTAAATAAAATATTTTAATATTAATATATTTAATTTTAAAATTTAATTTAATATATTAATTT\\\nAAATTAAAATAAAATTATTAATATTTAAAATTAAATAAATTTATTATATTAATTAATTTTAATATATTTTATAAATAAT\\\nATTTAAAAAAAAATTTATATTAAAAAAATAAATTATTATATATTAATAATAATAATAATTAATTATATTATTTATTATT\\\nATAATAATATTTAAATTATATAAAAAAAATATTTATATTTTAATAAATTAAAATATAATTTTAAAATATTATTTTAATT\\\nATTTAATATAAAATTTATTATAATTTTTAAATATTATATATATAAAATTATATTATATATATATAAAATTAATAATAAA\\\nATATAATTTTAAAATTAATATATAATATAATTATATAAATATAATAAATTTTTTTTATATATTTTATTTATTAAATTAA\\\nTTTTATAATAATATAATTATATATAAATAAATAATAATTAATAAATATATATTTATTTTATTATTTAATAATTAAAATT\\\nAAAAAAATAAAAATTATAATATATAATTTATTATATTTAAATTTAATTAAAATATTATTATAAATAATTAATTATTTTT\\\nTTAATTTTTAAATAATTAAATATAATAATTTTAAAAAATTTATAAAATATAATTATAATTTATTTAATTATATATAAAA\\\nAAAAAAATTTTTATATATTAATATATTAATTTATATATTATATATATAAATAAATTATATAAATTAAAAAATATAAAAA\\\nAAATTTTTAATTTTTTTATAAAAAATAAATTTATTTATTATTAAAATATTTTATTTAAATATAATAATAAATATATTTT\\\nTTTTATTTTAATAATTTTTATTTTTATTAAAATTTAAAATTAATAATTAAAATTATTTTTTTAAAATAAATTTTTTATT\\\nTATAATTAATTATATTAAATTATTTTATAAATTTTTAATTTAATTTAATTTATTAAATTATAATTATATAAATTTTAAT\\\nTTTATATTATATTATATAATTAATTTTTATTTAATTTTTATATTTAAAAATTTTAATTTATTTAAATAATATTATTAAT\\\nTAAAATTATTAAATATATTTATTATAAAATTTTTTTTAAATATTTTTTTTTTAAATAATAATAAATATTAATAAATATT\\\nATTAATTAATATAAAAATTAATAATATTAATAAAAATTTAATATATTATTTTTATTAATATAAAATTATTTAATTATAT\\\nAATAAAATTTTATAATAAAATTAATAAAAAATAATTTAAATAATATTAAAAATTTATAATATATATATTTTAATTTAAT\\\nATATATATAATTTAATAATTATTTTATATTAAAATATTAATTATATATTAAATTAATATAATTATATTATTTTAAAAAT\\\nAATTATAAAATAAATAATTTAATAAAAATATTATTTTATTAATATATATTTAAATATTATATATTATTTTTATATAAAT\\\nAAATTAATAAAATATTATTTTTAATTTTTTTATTATTAATAATATTTATAAAATAATATTAATATAAATTAATTTTATA\\\nAAAATATTTATTAATATATAAAAAAATTTAAAATATATTAATTTATATTATTAAAATTATTTAAATATTTTATATTATT\\\nATTAAATATATTAATATATATTTTTTTTATTAAAAATTTATAATTATATAATTAAAAATATAATTTTTATATTTATTTT\\\nTTATATTTATTTTTATAAATTTAATTTAAATATTAAAAAAATATTTTTTATAAAATTTAATAATATAATAATATAATAA\\\nATTTATATTATAATATATATAATAAAAATAAAATTATTAATAATAAAAATAATATTAAAATTTATTTATTATTATTTAT\\\nAAAAAATATTTATTTTTAAAATAAATATTAATTAATATAATTTTATAAAAAATTAAAAAAATAAATTAAATTAAATAAT\\\nTTAAAAATATTAAATTTAAAATTATAATATAATAATTTATAATTAATAAAAATAATTTTAAAATAAATATTTATAAAAT\\\nTAAATAAAATTATTTTAATAATTATTATTAATAATTTAAATATATAATATTTTAAAAAATAATTAAAAAAAAAATATTT\\\nTTTATTATTTAAAATTATTTATTATAATTTATTATATTTTTAATTATTATATTTATTTTTTTATTAATTAATAAAAATA\\\nATTATATTATAATAATTTAATATAATATTTTAAAATATTATATTAATAAATATTTTATAAAATTATTATAAATATTAAA\\\nTATTATATAAATAATATAAATTTATATATAAAATAAATTATTAAAAAATTATATTTTTATAATTAATATTTAATTTAAT\\\nTTTATTAATATAATAATATTTTAAATAATATTTTTATTATTAAATTTTTTTTATAATTAAATAATTAAATATATTTTTA\\\nAAAAATATAATAAAAATTTATTTATTTATTAATATTATAATAAAAATTAAAAAAATAATAATAATTATAAATATTATAT\\\nTAAAATAATATTAAAATAAAATAATTTTATAATTAATTATATTTTTTTTTAAATTTTATTTAATTAAATATAATATTTT\\\nTAATATATTTATAAATTATAATAATTATATTTAAAATTAATTATATATAAAATAATTTTTAAATATTAAAATATTAATT\\\nTTTATATTTAAAATATAAATAATAAATAATTATAAAAATTTTAATATTAAATATATTATTTTTTTATAAATAATATTTT\\\nAAATTATATTATTATTATATTATTTAAATATAATATTATTTTTATTATATTTATTTTAATAATTATTATTTTTATAATT\\\nTTTTTAAATATTTAATAATAAATATTTTTTATAAATAAAAATATTTTTTATTAAT\";\n// 5,000 random nucleotides, GC content = 1.\nstatic STR_4: \u0026'static [u8] = b\"GGGGGGGGGGCGCGCGGCCCCCCGCCGGGGCGCCCCCGCGCGCGGCG\\\nCGGCCGCGCGCCCCGCGGGGGCGGCGGGCGCGCCGGGCGCCCCGCGGGCGGCGGGGGCCCGGGCGGGGGGCGCGCGGCC\\\nGGGGGCCGGCGCGGGCGCGGGCCGCGGCGGCGCCGGCCCGGCCGCGGCCCGCGCGCCCCGGGCGGCGCGCCCGCCCCGG\\\nCCGGCCCCCGGCGGCCCGCGGGGCGGCCCGGCCGCCGGCGGCCGCCCGGCGGCCCCGGCCCCCCGCCGGCGCCGCGGCG\\\nGCCCCCGGGGGGCCGGCCGCGCCCGCCGGCGCGGGGGCGGCGCGGCGCCGGCGGGCGGCGGGCCCCCGGCCGGCCGCGG\\\nCCCCCCGGGGGGCGGGCCCCGCGGCGCGCGCCGCCCCGCGCGCGCGGGCGGCCCGGGCGGGCCCGGCCCGGGCCCGGCC\\\nGGCCCCCGCGCGGGCCCGGGGCCGGGGGCGGCGGCCCCCCGGGCGCGGGGCGGGGGCGCCGGGCGGCCGGGGGGCCCGC\\\nGGCGCCCCGGGCGCCGGCCCGCCCGGGCCGCCGCCCGGGGCCGCGCCGCCCCGGGGGGGGGGCGCCGGGGGCCCCCCCC\\\nCCCGGCGGCCGGGCCCGCGGGGGCCGCGGGGCCGGCCCCCCCGGCGGCCGGGGGGCGGGGGCCCGCCGCGCGGGCCGGG\\\nGCGCCCGCCCGGCGGCCCGCGCCCCGGGCGCCCGGCCCCCCCCGCCGCCCCGGGCGGGCCCGCCCCCCCCGCCCGCCGG\\\nCCCGCGGGGCCCGCGCCGGCGCGCGGGCGCGGCCCGGGGGGGGGCGCCCGGGGCCGGGGGCGGCCGGCGCCCCGCGCCC\\\nCGCCCGGCCCCCCCGCGCGCCGCCGCGGCGGGCCGGCGGGGGCCCGGCGCCGGGCGGCGGGGCGCCCCCGGCCCCGGCG\\\nGGGGGCCGGGGGGGGCGCGCGCGCGGCGCGGGGGGGCCGGGGGGCCGGCGGGGGGGCCCCCCCCCCGCCCGCCGGGGGG\\\nCGGGCGCGGGGCGGCGGCCGCCGCGCCGGCGCGCGGGGCGCGCCCGGCGGCCGCCCGGGGCGCCGGGCGCCCGCCGCCC\\\nCCGGGGCCGCCCCCCGGGCGCGGGCGCCGGGCCGGGCCCGCGCCCGGGGCCGCCGCGGGCGGGCCCGGGCCGGGCGCGC\\\nCGCGCCCGCCGCGCGGGCGGGGCCGGCCGGGGGCCGCCGGGCGCGCCGCCGCGCGGGCGGCCGCCGGCGGGCCGCCGGG\\\nCCCGGGGGGCGGCGCCGGCGCCCCCGGGGGGCCCCGGCCGGGCGCGGGCCGCGGCGCCCGCGCCGCCCCGCGGCCGCCC\\\nGCGGCCCGGGGCCCGGCCCGCGCCGGGCCGCCGCCCCCCCGGGGCGCCGCGCGGGGCGGCGCGCGCGCCCCGCGCGGGC\\\nCCGCCGCGGCCCGCCCGGGGCCGGCCGGGGGCGCGGCCGGGCCCCGGCCCGCGCGCCCGGCCGGCCCGCGCCCGGCCCC\\\nCGGGGCCCGGCGGCCCCCGGGGCGCCGCGGGGCCCGCGGCCCGCCCCGCCGGGCGCCGGGCCCCGCCCCGGCGGGGCCC\\\nCCCGCCCGGGGGCGCCGGGGGGGGCGCCCGCCGGGCCGCGCGGCCCCCGCGCCCCGGCCGGGGGGGCCGCCGGCGCCCG\\\nGCCCCCGGGCCCCGCGGCGGGCCCCGCGCGCGGGCCGCCGCGCGCGGGGCCGGCGGGCCGGCGGGGGGCGCGGGGCGCC\\\nCCCGGGCGCGGCGGGCGGGCGGCCCGGCGCCCCGGGCGCGGCCGCGCGCCCGGGCCCGGCCCCGCCCCGGGGGCCCCGG\\\nGCCCCGGCGCCCGCGGGCCGCGGGGCCGGCCGGGGGGGCGCGCGGCGGCGCCCGCCGGCCGCCCCCGGGCCGCGGCCCC\\\nCCGCCCCGCCGGGGCCCGGCCCCCGCCGCGGCCGGCCCCCCCCGCGGGCCGCGCCGCCCCGGCGCCCCGGCCGCGCCCC\\\nCGCCGCGGGGGCGGGCCCGCCCGCCCCCGCGCCCCGGCGCCGGCGGGGGGCCCGCGCGCCCCGCGCGGGGCGCCGCCGG\\\nGGCCCCGGGCCCCCGGGCGGCGGGGGCCCCGGGCGCGGGCCCCCGCCCGCGGCCCGGCCCGGGCGCGGGCCCCCGCGCC\\\nGCCCCGCCGGGCCCGCCCCGCGCGGGGCGGGCGCGGGGCGCGCCCGGCCCGGCCCCCGGCGCCCCGCGCCGCCGCGCGC\\\nCCGCCGGCCGCCGGCCGGCGGCGCGGGGGCGGCGCCGCGGCCCCCGGGGCCCGGCCCGGCCGGCCCGGGCGCGGCGCCG\\\nCGGGCGGCGCGGGGCGGCGGCGGGCGCCCGGCGCCGGGCGGCGCCCGGCCCGGCGGCGGGGGGGCCGCGCGGCGCGCCC\\\nGGCCGCGCGCCCGGGGCGCGCCCGGGCGGCGCCGGGCGGGCCGGGGCGGGCCCCCGCGCCGGCCCGGGGGCGGGCGCGC\\\nGGGCCGGCCGGGGGCGGGCGGGGGGCCCCGGCCCGCCCGGCGCCCCGCGGCGCCCCCGGGGGCGGGCGGGGCGCCCCGC\\\nGGCCCGGGGCGGGGCCGCCCCGCGGGGCGGGCCCGCGCCGCCCCCCCCGCGGGCGGCCCGGCGCGCCGGGGGGGCGGGG\\\nCCGGCCCGGGCGGCGGCCGCGGGCCGGGGGGGCGGGGCGCCGCCCGGGGGGCGGGCCCGGCGGCGCGCGGCCCGGCCGC\\\nCCGCCCGCCGCCCGGGCCGCGCGGGGGCCCCCGGCGCCCGCGCGCCCGGCCCCGGGGCCCGCCCCGGCGCGCGGGCCCG\\\nGGCCGGGGCGGGGCCGCCGGCGCCCGGGGCCGGGGGGGCCCGGCGCCCCGGCCGGCCCCGGCGCGCGCCGCCGCGGGCG\\\nGCCGGCGGGGGGCCCGCGCCGGGGGGGCGGGCCGCCGCGCGCCGGGGGCGGCGCCGGCCGGCGGGGGCGCCCGGCGCGG\\\nCGGGGGCGCCGGGCCCGCGCGGGGGCGGCGCCCCCGCCCCGGCGGGCCGGGGCGCGGCGCCGGGGCCGCCCCCCGGGCG\\\nCCCGGGGCGGGGCCCGCCGCGGCCCCCGGGCCCGGCGCGCCCGCGCCCGCGGCGCGCGCGCCCGGGGGCGGGGGCCGGG\\\nCCCGGCCCGCGCCCCGGCGCGCGGCGCGGCGGCGCGGGCGCGGCGGGCCCCGCCCGCGCCCCCCGCGCGCCGGGCCGGC\\\nCCCCGCGGGGCGCGGCGGCGCGCGGGCGGCCGGCGGCCGGCCGCCGCGCGCCCGCCGCGGCGCCGGGCGGCCCGGGCCG\\\nGGGCGGCGGGGCCCGCGGCGCGCGGCCCGCCGCGCCCCGCCCCGGCCGGCGGGCCGCGGCCGGCCGCCGGCCGCGCCGC\\\nCGCCCCCCGGGCGCCCCGGCGCGGCGGCCGCGGGGGGCCCGCGGGGCGCGGCCGCGGCCCGCCCGGCCGCGCCCGGGGG\\\nCGGGGGCCCGCCCCCGCCCGCGCGCCCGCCCGCCCGCCGCCCGCCCCCGGGGGCCGGGCGGGCCGCGGGGCGCGGGGGG\\\nGGCCCCCGGCCCCCCCGCGGGGCGCCGGCCCCCCCCCCGGCGGGGCGCCCCGCCCGGGCGCGGCGGCGGGCGCGCCCCC\\\nCGGGCCGCGCCGCCCCCCGCCCCCGCCGGGGCCCGCCGCCGGCGGCCGGGGCCGCCGCCCCGCGGCGGGCCCCCCGCCC\\\nGCGCCCCCCCGCGCCGGGCCGCCCGGCGGGCGGCCGGCCCGGCCCGCCCCGCGGGGCCGCGGCCGCGCGGGCCGGGGCC\\\nCCGGGCCGGGCCGCGCGGCCGGGCCCGGCCCCGCCCCGGCGGCCGCGGGCCCCGGCCCGCCCGGGCGGCGCGGCCGGCC\\\nGGGGCCGCGCGGGGCGCCGGCCGCGGGCCCCCCCCCGGGCGCGGCCCCCCCGCCCGGCGGCGCGCGGCCGCCGCCGCCG\\\nCCGGCCGGCCCGGCGGGCGGCGCCGCCGCCGCGGGCCCGGCGCGCCCCCCCCGCGGGCGCGGGGCCGCCCGGCCCCGCG\\\nCCGCGGCCCCGCGGCGGGGCCGGCGGGCCGCGCCCCGGGCGGCGCCGGGGGCCCGCGGCGCGCGCGCCCCGGCGCGGCG\\\nCGCGCGCGCCCCGGCCGCCGCCCCGCGCCGGGGGCCCGGCCGCGCGCCGCGCCGGCGCGCCCGCGCCGCCCGGGGGGGG\\\nCGCGCGGGGCGGGCGGCCCGGCCGGGGCGCCGCCGCGCCGGCGCGCGCCCGCCCGCCGCCGGCCGCCGGCGCGCGGGCG\\\nGCGCCGCGGGCCGCCGGCCCCGGCCCCCCCGCCCCCGGCGCCGCGCGCCGGGCGGCGCGGGCCCGGGCCGGCCCCGCGG\\\nCGGCGCCCGCCGGCCGGCGGGGGGGCCGGGGGCCCGCCGGGCCGCGCCGCCGGGGCCCCCCGGGCGCCCCGCGCCGGCG\\\nCCGGGCGGGCCGGCGCGCGCCCCCCCCCCCGGGGGCGCGCGGCCGCGCGGGCGGGCGCGCGGCGCGCGCGCCCGCCCGG\\\nCGCGCCCGGCCCCCCGCGCCCCCCCCGGGGGCCGGGGGGGCGCCCCGCGCCCGGGCGGGCGGCGGCCCCGCGGGGCGGG\\\nCCCGCGCCGCCGCCCGCGCGGGGGGGCCGGGGCCGCCGGGGGCGGGGGCGGCCCCGGGCCCCGGCCGCCGGCCCCGGCG\\\nGGGGGGCCCCGCCCGGGGGGCGGGCGCCGGCCGGCGCGGCCCGGCGGGGCGCCCGGGGGCCGGGCCGGGCCGGGCGGCC\\\nCGGCGCCGGCGCGCCCGGGCCCGGGGCCCGGCGCGGCGCGCCGGCCGGGGGCGGGCCGGGGGCGCGGGCCCCCGGGGCC\\\nGGGCGGGCCCGCCGCGCCGGCCGGCCCCGGCGGGCCGCGCGGGCGGCGCCCCGGGGGGGGCCCGCGGGGGGGGGGCGGG\\\nCCGCCGCCCGCCGCCGCCGGCGGCGGCCGGCCGCGCCCCCCGCCGCCGCGGCCGCGCCCGGGCCGCGCGGCGGGGGCGG\\\nCCGCGCCCCGGCGGGCCGGCGCGCCGCCCCGGGGCGCCGCCCCGGCCGCCCGCCGCCGGGCCCGCCGCGGCCCCCGGGC\\\nGCCGCGCGCGCGGGGCCGGGCCGCGCGCGCGCCGGGCCGCCGGCGGGGCGCGGCC\";\n\n#[bench]\nfn bench_hamming_dist_equal_str_1000iter(b: \u0026mut Bencher) {\n    b.iter(|| {\n        for _ in 0..1000 {\n            black_box(hamming(STR_1, STR_1));\n        }\n    });\n}\n\n#[bench]\nfn bench_hamming_dist_diverse_str_1000iter(b: \u0026mut Bencher) {\n    b.iter(|| {\n        for _ in 0..1000 {\n            black_box(hamming(STR_1, STR_2));\n        }\n    });\n}\n\n#[bench]\nfn bench_levenshtein_dist_equal_str(b: \u0026mut Bencher) {\n    b.iter(|| levenshtein(STR_1, STR_1));\n}\n\n#[bench]\nfn bench_levenshtein_dist_diverse_str(b: \u0026mut Bencher) {\n    b.iter(|| levenshtein(STR_1, STR_2));\n}\n\n#[bench]\nfn bench_levenshtein_dist_worst_str(b: \u0026mut Bencher) {\n    b.iter(|| levenshtein(STR_3, STR_4));\n}\n\n// SIMD-accelerated edit distance routines below\n\n#[bench]\nfn bench_simd_hamming_dist_equal_str_1000iter(b: \u0026mut Bencher) {\n    b.iter(|| {\n        for _ in 0..1000 {\n            black_box(simd::hamming(STR_1, STR_1));\n        }\n    });\n}\n\n#[bench]\nfn bench_simd_hamming_dist_diverse_str_1000iter(b: \u0026mut Bencher) {\n    b.iter(|| {\n        for _ in 0..1000 {\n            black_box(simd::hamming(STR_1, STR_2));\n        }\n    });\n}\n\n#[bench]\nfn bench_simd_levenshtein_dist_equal_str(b: \u0026mut Bencher) {\n    b.iter(|| simd::levenshtein(STR_1, STR_1));\n}\n\n#[bench]\nfn bench_simd_levenshtein_dist_diverse_str(b: \u0026mut Bencher) {\n    b.iter(|| simd::levenshtein(STR_1, STR_2));\n}\n\n#[bench]\nfn bench_simd_levenshtein_dist_worst_str(b: \u0026mut Bencher) {\n    b.iter(|| simd::levenshtein(STR_3, STR_4));\n}\n\n#[bench]\nfn bench_simd_bounded_levenshtein_dist_equal_str(b: \u0026mut Bencher) {\n    b.iter(|| simd::bounded_levenshtein(STR_1, STR_1, u32::MAX));\n}\n\n#[bench]\nfn bench_simd_bounded_levenshtein_dist_diverse_str(b: \u0026mut Bencher) {\n    b.iter(|| simd::bounded_levenshtein(STR_1, STR_2, u32::MAX));\n}\n\n#[bench]\nfn bench_simd_bounded_levenshtein_dist_worst_str(b: \u0026mut Bencher) {\n    b.iter(|| simd::bounded_levenshtein(STR_3, STR_4, u32::MAX));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","benches","fmindex.rs"],"content":"#![feature(test)]\n\nextern crate test;\n\nuse bio::alphabets;\nuse bio::data_structures::bwt::{bwt, less, Occ};\nuse bio::data_structures::fmindex::{FMIndex, FMIndexable};\nuse bio::data_structures::suffix_array::suffix_array;\nuse test::Bencher;\n\n#[bench]\nfn search_index_seeds(b: \u0026mut Bencher) {\n    let alphabet = alphabets::dna::iupac_alphabet();\n    let sa = suffix_array(STR_1);\n    let bwt = bwt(STR_1, \u0026sa);\n    let less = less(\u0026bwt, \u0026alphabet);\n    let occ = Occ::new(\u0026bwt, 128, \u0026alphabet);\n    let fmindex = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n\n    b.iter(|| {\n        let sequence = b\"TCCAAAACAATAACGGAGGTGTCCAAAGGTCAGCTCAGCGTGTGGTTTCT\";\n        let seed_length = 20;\n\n        let seeds =\n            (0..(sequence.len() + 1 - seed_length)).map(|i| (i, \u0026sequence[i..i + seed_length]));\n\n        let mut loc_temp = Vec::new();\n        for (offset, seed) in seeds {\n            let interval = fmindex.backward_search(seed.iter());\n\n            loc_temp.extend((interval.lower..interval.upper).map(|i| (sa[i], offset)));\n        }\n    });\n}\n\nstatic STR_1: \u0026'static [u8] = b\"ATCTAACTATTCCCTGTGCCTTATGGGGGCCTGCGCTATCTGCCTGT\\\nCGAACCATAGGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCGGGGCCTAAGACCACGAGCGTCTGGCG\\\nTCTTGGCTAACCCCCCTACATGCTGTTATAGACAATCAGTGGAAACCCGGTGCCAGGGGGTGGAGTGACCTTAAGTCAG\\\nGGACGATATTAATCGGAAGGAGTATTCAACGCAATGAAGCCGCAGGGTTGGCGTGGGAATGGTGCTTCTGTCCAAGCAG\\\nGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTGCACTTTGCAACGATTTCGGAGTCCGGAGACTCGCTG\\\nTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTACGCCCAAGAACGTAGCAAGGTGACTCAAACAAGGTA\\\nCATCTTGCCCGCGTTTCACACGAATCAAGTTGGAGGTTATGGAGCATAGTAACACGTGGGCGGCCAGTGGTCGGTTGCT\\\nACACCCCTGCCGCAACGTTGAAGGTCCCGGATTAGACTGGCTGGACCCATGCCGTGACACCCGTCACACTCCATTACCG\\\nTCTGCGGGTCACGGCTTGTTGTGGACTGGATTGCCATTCTCTCAGTGTATTACGCAGGCCGGCGCGCGGGTCCCATGTA\\\nAACCTGTCATAGCTTACCTGACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCCACGCACCTGGTCGGTCCTCGTTTGCT\\\nTTTTAGGACCGGATGAACTACAGAGCGCTGCAAGAATCTCTACCTGCTTTACAAAGCGCTGGGTCCTACTCCAGCGGGA\\\nTGTTTTATCTAAACACGATGAGAGGAGTATTCGTCAGGCCACATGGCTTTCTTGTCCTGGTCGGATCCATCGTTGGCGC\\\nCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTGCATGCCAGATCGGCAGACAGATAGCGGATCCAGTAT\\\nATCCCTGGAAGCTATAGACGCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTCCGAACCCAGCTCTACTTTAGTGGCCA\\\nCGGGTTCTGGTCCCCCCGGGCCGCGGAACCGATTAGGGCCATGTACAACAATACTTATTAGTCACCTTTCAGACACGAT\\\nCTCCCTGCTCAGTGGTATATGGTTCCTGCTATAATTAGCCACCCTCATAAGTTGCACTACTTCTGCGACCCAAGTGCAC\\\nCCTTACCACGAAGACAGGATTGTCCGATCCCATACTGCGGCCTTGGCAGGGGGTTCGCAAGTCCCACCCCAAACGATGC\\\nTGAAGGCTCAGGTTACACAGGCACAAGTGCTATATACGCGAGTTCCCGCTCTTAACCTGGACCGAATGCGGGATCATGC\\\nATCGTACCACTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGATACATAGTTCAATCAAGAATACCTTGTATTATTGTA\\\nCACCTACCGGTCACCAGCCAACAATGTGCGGACGGCGTTGCGACTTGCTGGGCCTGATCTCACCGCCCTAGATACCGCA\\\nCACTGGGCAATACGAGGTAAAGCCAGTCACCCAGTGTCGATCAACAGCTGACGTAACGGTAAGAGGCTCACAAAATCGC\\\nACCGCCGGCGTCCCCTGGGTATTTTACGTCAGCATCGGGTGGACTGGCATGAATCTTTACTCCCAGGCGGAAACGGGTG\\\nCGTGGACAAGCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGGTGTCTCGTATCCCTCTTGGAGATCGAGGAAATGTTT\\\nCACGACCAAGGGAAAGGTCGCCCTACGAAATAGATTTGCGCTACTGTCCGCATAAGGAGTCCGGTGTAGCGAAGGATGA\\\nAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAAGCAGGCACGGAAAGACACGGTCTAGC\\\nAGACCGTCTATCGGCTAGGTCAAATAGGGTGCTTTGATATCAGCATGTCCAGCCTTAGAATTCAGTTCAGCGCGCTGGT\\\nCTGGGTCGAGATAAAATCACCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTGGCTAATCCTGGTACATCTTGTAATCA\\\nATGTTCAGAAGAAAATCTGTGTTAGAGGGACGAGTCACCACGTACCAATAGCGACAACGATCGGTCGGACTATTCATCG\\\nTGGTGGTGACGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAGGATATAATGCTGAGGCGCTGCCCCAA\\\nCCGTTCAGCGTGGGGTTTGCTACAACTTCCGAGTGCTACGTGTGCGAGACCATGTTATGTATGCACAAGGCCGACAATA\\\nGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCACAGTAGATCCTCCCCGCGCATCCTATTTATTAAGTT\\\nAATTCTATAGCAATACGATCACATGCGGATGGGCAGTGGCCGGTAGTCACACGCCTACCGCGGTGCTCAATGACCGGGA\\\nCTAGAGAGGCGAAGATTATGGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGAGCGTCATTGCGAGTAGTCGATTGCTT\\\nTCCCAATCTCCGAGCGATTTAGCGTGACAGCCCCAGGGAACCCACAAAATGCGATCGCAGTCCACCCGATCGTACACAG\\\nAAAGGAGGGTCCCCATACGCCGACGCACCTGTTCGCACGTCGTATGCATAAACGAGCCGCACGAACCAGAGAGCATAAA\\\nGAGGACCTCTAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGCCGGGATGCCTTACCTAGACGCAATGACGGACGTATT\\\nCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAAGCCGCCTTTCCAAAGTGAGTCCTTCG\\\nTCTGTGACTAACTGTGCCAGATCGTCTTGCAAACTCCCGATCCAGTTTAACTCACCAAACTATAGCCGTACAGACCCAA\\\nATCTTAAGTCATATCACGCGACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGTTTTGGTCCGCCCGAGCGGTGCAGCCG\\\nATTAGGACCATCTAATGCACTTGTTACAAGACTTCTTTTAAACACTTTCTTCCTGCCCAGTGGCGGATGATAATGGTTG\\\nTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAATGTGCCGTCTCCACCAACACAGGGCTGTCCGGTCGT\\\nATAATAGGACTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGGACTCGCGATGTACATGCTCTGGTTCA\\\nATACATACGTGACCCGGCAGTTATCCTGCATCGGAACGTCAATCGTGCATCGGGCCAGCGTAATCGTGTCATCTGGGAG\\\nGCGGCCGTAGGATAAATAATTCAATAAAGATGTCGTTTTGCTAGTATACGCCTAGGCGTCACCCGCCATCTCTGTGCAG\\\nGTGGGCCGACGAGACACTGCCCCTGATTTCTCCGCTACTAATAGCACACACGGGGCAATACCAGCACAAGCCAGTCTCG\\\nCGGGAACGCTCGTCAGCATACGAAAGAGCTTGAGGCACGCCAATTCGCACTGTCGGGGTCGCTTGGGTGTTTTGCACTA\\\nCCGTCAGGTACGCTAGTATGCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGGTCAAAAGTGCGGCATTCGTATTTGCT\\\nCCCCGTGCTTGCTCTCACGAACTTGACCTGGAGATCAAGGAGATGCTTCTTGTGGAACCGGACAGCGCATCAACGCAAC\\\nGGATCTACGTTACAGCGTGCATAGCGAGAACGGAGTTGCCGACGACGAAAGCGACACTGGGATCTGTCCGTCGTCATTC\\\nGCGGAAAGCATCCGCTCACGAGGCGGACACTGATTGACACGGTTTTGCAGAAGGTTAGGGGAATAGGTCAAATTGAGTG\\\nGCTTAAAAACGCTATGTCTGGGATTAAAGTGTAGTAAACTGCGGTCAACGGAGACGGTTTTAAGACAGGAGTTCGCAAA\\\nACCAGGCGGGGTCGCCACGACGGCTATTCCTGGTGGTTTAGGCGTACAATGTCCTGAAGAATATTTAAGAAAGAAGCAC\\\nCCCTCGTCGCCTAGAATTACCTACCGCGGTCGACCATACCTTCGATTGTCGCGCCCACCCTCCCATTAGTCGGCAGAGG\\\nTGGTTGTGTTGCGATAGCCCAGCATGATATCCTAAGGCGTTACGCCGATGGATATCCCACGGAATTGCCATAGGCGCTG\\\nAACGCTACACGGACGATACGAACTTATGTATGGAGCGGGTCATCGAAAGGTCATACCCTTGTAGTTAACATGTAGCCCG\\\nGCCCTATTAGTACAGCAGTGCCTTGAGCGGCATTCTCATTATTAAGTTTTCTCTACAGCCAAACGACCAAGTGCACTTC\\\nCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCAGCTCTGTAATAGGGACTAAAAGAGTGATGATAATCATGAGTGCCGC\\\nGTTATGGTGGTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCGAGTTCCGTCCGGTTAAGCGTGACACT\\\nCCCAGTGTACCCGCAAACCGTGATGGCTGTGCTTGGGGTCAATCGCATGTAGGATGGTCTCCAGACACCGGGGCACCAG\\\nTTTTCACGCCCAAAGCATAAACGACGAGCAGTCATGAGAGTCTTAGAACTGGACGTGCCGTTTCTCTGCGAACAACACC\\\nTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTCCTATCACATTTGCCTCGACGACTGCCGCCTTCGCTG\\\nTTTCCCTAGACACTCAACAGTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGTCAGTGGCTGCGCCAAAACGTCTTCGG\\\nATCCCCTTGTCCAATCAAACTGACCGAATTCTTTCATTTAAGACCCTAATATGACATCATTAGTGACTAAATGCCACTC\\\nCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAACGAATCTAACTATTCCCTGTGCCTTAT\\\nGGGGGCCTGCGCTATCTGCCTGTCGAACCATAGGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCGGGG\\\nCCTAAGACCACGAGCGTCTGGCGTCTTGGCTAACCCCCCTACATGCTGTTATAGACAATCAGTGGAAACCCGGTGCCAG\\\nGGGGTGGAGTGACCTTAAGTCAGGGACGATATTAATCGGAAGGAGTATTCAACGCAATGAAGCCGCAGGGTTGGCGTGG\\\nGAATGGTGCTTCTGTCCAAGCAGGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTGCACTTTGCAACGA\\\nTTTCGGAGTCCGGAGACTCGCTGTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTACGCCCAAGAACGT\\\nAGCAAGGTGACTCAAACAAGGTACATCTTGCCCGCGTTTCACACGAATCAAGTTGGAGGTTATGGAGCATAGTAACACG\\\nTGGGCGGCCAGTGGTCGGTTGCTACACCCCTGCCGCAACGTTGAAGGTCCCGGATTAGACTGGCTGGACCCATGCCGTG\\\nACACCCGTCACACTCCATTACCGTCTGCGGGTCACGGCTTGTTGTGGACTGGATTGCCATTCTCTCAGTGTATTACGCA\\\nGGCCGGCGCGCGGGTCCCATGTAAACCTGTCATAGCTTACCTGACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCCACG\\\nCACCTGGTCGGTCCTCGTTTGCTTTTTAGGACCGGATGAACTACAGAGCGCTGCAAGAATCTCTACCTGCTTTACAAAG\\\nCGCTGGGTCCTACTCCAGCGGGATGTTTTATCTAAACACGATGAGAGGAGTATTCGTCAGGCCACATGGCTTTCTTGTC\\\nCTGGTCGGATCCATCGTTGGCGCCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTGCATGCCAGATCGG\\\nCAGACAGATAGCGGATCCAGTATATCCCTGGAAGCTATAGACGCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTCCGA\\\nACCCAGCTCTACTTTAGTGGCCACGGGTTCTGGTCCCCCCGGGCCGCGGAACCGATTAGGGCCATGTACAACAATACTT\\\nATTAGTCACCTTTCAGACACGATCTCCCTGCTCAGTGGTATATGGTTCCTGCTATAATTAGCCACCCTCATAAGTTGCA\\\nCTACTTCTGCGACCCAAGTGCACCCTTACCACGAAGACAGGATTGTCCGATCCCATACTGCGGCCTTGGCAGGGGGTTC\\\nGCAAGTCCCACCCCAAACGATGCTGAAGGCTCAGGTTACACAGGCACAAGTGCTATATACGCGAGTTCCCGCTCTTAAC\\\nCTGGACCGAATGCGGGATCATGCATCGTACCACTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGATACATAGTTCAAT\\\nCAAGAATACCTTGTATTATTGTACACCTACCGGTCACCAGCCAACAATGTGCGGACGGCGTTGCGACTTGCTGGGCCTG\\\nATCTCACCGCCCTAGATACCGCACACTGGGCAATACGAGGTAAAGCCAGTCACCCAGTGTCGATCAACAGCTGACGTAA\\\nCGGTAAGAGGCTCACAAAATCGCACCGCCGGCGTCCCCTGGGTATTTTACGTCAGCATCGGGTGGACTGGCATGAATCT\\\nTTACTCCCAGGCGGAAACGGGTGCGTGGACAAGCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGGTGTCTCGTATCCC\\\nTCTTGGAGATCGAGGAAATGTTTCACGACCAAGGGAAAGGTCGCCCTACGAAATAGATTTGCGCTACTGTCCGCATAAG\\\nGAGTCCGGTGTAGCGAAGGATGAAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAAGCA\\\nGGCACGGAAAGACACGGTCTAGCAGACCGTCTATCGGCTAGGTCAAATAGGGTGCTTTGATATCAGCATGTCCAGCCTT\\\nAGAATTCAGTTCAGCGCGCTGGTCTGGGTCGAGATAAAATCACCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTGGCT\\\nAATCCTGGTACATCTTGTAATCAATGTTCAGAAGAAAATCTGTGTTAGAGGGACGAGTCACCACGTACCAATAGCGACA\\\nACGATCGGTCGGACTATTCATCGTGGTGGTGACGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAGGAT\\\nATAATGCTGAGGCGCTGCCCCAACCGTTCAGCGTGGGGTTTGCTACAACTTCCGAGTGCTACGTGTGCGAGACCATGTT\\\nATGTATGCACAAGGCCGACAATAGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCACAGTAGATCCTCC\\\nCCGCGCATCCTATTTATTAAGTTAATTCTATAGCAATACGATCACATGCGGATGGGCAGTGGCCGGTAGTCACACGCCT\\\nACCGCGGTGCTCAATGACCGGGACTAGAGAGGCGAAGATTATGGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGAGCG\\\nTCATTGCGAGTAGTCGATTGCTTTCCCAATCTCCGAGCGATTTAGCGTGACAGCCCCAGGGAACCCACAAAATGCGATC\\\nGCAGTCCACCCGATCGTACACAGAAAGGAGGGTCCCCATACGCCGACGCACCTGTTCGCACGTCGTATGCATAAACGAG\\\nCCGCACGAACCAGAGAGCATAAAGAGGACCTCTAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGCCGGGATGCCTTAC\\\nCTAGACGCAATGACGGACGTATTCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAAGCC\\\nGCCTTTCCAAAGTGAGTCCTTCGTCTGTGACTAACTGTGCCAGATCGTCTTGCAAACTCCCGATCCAGTTTAACTCACC\\\nAAACTATAGCCGTACAGACCCAAATCTTAAGTCATATCACGCGACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGTTTT\\\nGGTCCGCCCGAGCGGTGCAGCCGATTAGGACCATCTAATGCACTTGTTACAAGACTTCTTTTAAACACTTTCTTCCTGC\\\nCCAGTGGCGGATGATAATGGTTGTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAATGTGCCGTCTCCA\\\nCCAACACAGGGCTGTCCGGTCGTATAATAGGACTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGGACT\\\nCGCGATGTACATGCTCTGGTTCAATACATACGTGACCCGGCAGTTATCCTGCATCGGAACGTCAATCGTGCATCGGGCC\\\nAGCGTAATCGTGTCATCTGGGAGGCGGCCGTAGGATAAATAATTCAATAAAGATGTCGTTTTGCTAGTATACGCCTAGG\\\nCGTCACCCGCCATCTCTGTGCAGGTGGGCCGACGAGACACTGCCCCTGATTTCTCCGCTACTAATAGCACACACGGGGC\\\nAATACCAGCACAAGCCAGTCTCGCGGGAACGCTCGTCAGCATACGAAAGAGCTTGAGGCACGCCAATTCGCACTGTCGG\\\nGGTCGCTTGGGTGTTTTGCACTACCGTCAGGTACGCTAGTATGCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGGTCA\\\nAAAGTGCGGCATTCGTATTTGCTCCCCGTGCTTGCTCTCACGAACTTGACCTGGAGATCAAGGAGATGCTTCTTGTGGA\\\nACCGGACAGCGCATCAACGCAACGGATCTACGTTACAGCGTGCATAGCGAGAACGGAGTTGCCGACGACGAAAGCGACA\\\nCTGGGATCTGTCCGTCGTCATTCGCGGAAAGCATCCGCTCACGAGGCGGACACTGATTGACACGGTTTTGCAGAAGGTT\\\nAGGGGAATAGGTCAAATTGAGTGGCTTAAAAACGCTATGTCTGGGATTAAAGTGTAGTAAACTGCGGTCAACGGAGACG\\\nGTTTTAAGACAGGAGTTCGCAAAACCAGGCGGGGTCGCCACGACGGCTATTCCTGGTGGTTTAGGCGTACAATGTCCTG\\\nAAGAATATTTAAGAAAGAAGCACCCCTCGTCGCCTAGAATTACCTACCGCGGTCGACCATACCTTCGATTGTCGCGCCC\\\nACCCTCCCATTAGTCGGCAGAGGTGGTTGTGTTGCGATAGCCCAGCATGATATCCTAAGGCGTTACGCCGATGGATATC\\\nCCACGGAATTGCCATAGGCGCTGAACGCTACACGGACGATACGAACTTATGTATGGAGCGGGTCATCGAAAGGTCATAC\\\nCCTTGTAGTTAACATGTAGCCCGGCCCTATTAGTACAGCAGTGCCTTGAGCGGCATTCTCATTATTAAGTTTTCTCTAC\\\nAGCCAAACGACCAAGTGCACTTCCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCAGCTCTGTAATAGGGACTAAAAGA\\\nGTGATGATAATCATGAGTGCCGCGTTATGGTGGTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCGAGT\\\nTCCGTCCGGTTAAGCGTGACACTCCCAGTGTACCCGCAAACCGTGATGGCTGTGCTTGGGGTCAATCGCATGTAGGATG\\\nGTCTCCAGACACCGGGGCACCAGTTTTCACGCCCAAAGCATAAACGACGAGCAGTCATGAGAGTCTTAGAACTGGACGT\\\nGCCGTTTCTCTGCGAACAACACCTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTCCTATCACATTTGC\\\nCTCGACGACTGCCGCCTTCGCTGTTTCCCTAGACACTCAACAGTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGTCAG\\\nTGGCTGCGCCAAAACGTCTTCGGATCCCCTTGTCCAATCAAACTGACCGAATTCTTTCATTTAAGACCCTAATATGACA\\\nTCATTAGTGACTAAATGCCACTCCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAACGAA\\\nTCTAACTATTCCCTGTGCCTTATGGGGGCCTGCGCTATCTGCCTGTCGAACCATAGGACTCGCGCCAGCGCGCAGGCTT\\\nGGATCGAGGTGAAATCTCCGGGGCCTAAGACCACGAGCGTCTGGCGTCTTGGCTAACCCCCCTACATGCTGTTATAGAC\\\nAATCAGTGGAAACCCGGTGCCAGGGGGTGGAGTGACCTTAAGTCAGGGACGATATTAATCGGAAGGAGTATTCAACGCA\\\nATGAAGCCGCAGGGTTGGCGTGGGAATGGTGCTTCTGTCCAAGCAGGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGC\\\nGTACAGGGTGCACTTTGCAACGATTTCGGAGTCCGGAGACTCGCTGTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGA\\\nACCAGGCTTACGCCCAAGAACGTAGCAAGGTGACTCAAACAAGGTACATCTTGCCCGCGTTTCACACGAATCAAGTTGG\\\nAGGTTATGGAGCATAGTAACACGTGGGCGGCCAGTGGTCGGTTGCTACACCCCTGCCGCAACGTTGAAGGTCCCGGATT\\\nAGACTGGCTGGACCCATGCCGTGACACCCGTCACACTCCATTACCGTCTGCGGGTCACGGCTTGTTGTGGACTGGATTG\\\nCCATTCTCTCAGTGTATTACGCAGGCCGGCGCGCGGGTCCCATGTAAACCTGTCATAGCTTACCTGACTCTACTTGGAA\\\nGTGTGGCTAGGCCTTTGCCCACGCACCTGGTCGGTCCTCGTTTGCTTTTTAGGACCGGATGAACTACAGAGCGCTGCAA\\\nGAATCTCTACCTGCTTTACAAAGCGCTGGGTCCTACTCCAGCGGGATGTTTTATCTAAACACGATGAGAGGAGTATTCG\\\nTCAGGCCACATGGCTTTCTTGTCCTGGTCGGATCCATCGTTGGCGCCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTC\\\nCGAGCCATTGCATGCCAGATCGGCAGACAGATAGCGGATCCAGTATATCCCTGGAAGCTATAGACGCACAGGTTGGAAT\\\nCCTAAGCGAAGTCGCGCGTCCGAACCCAGCTCTACTTTAGTGGCCACGGGTTCTGGTCCCCCCGGGCCGCGGAACCGAT\\\nTAGGGCCATGTACAACAATACTTATTAGTCACCTTTCAGACACGATCTCCCTGCTCAGTGGTATATGGTTCCTGCTATA\\\nATTAGCCACCCTCATAAGTTGCACTACTTCTGCGACCCAAGTGCACCCTTACCACGAAGACAGGATTGTCCGATCCCAT\\\nACTGCGGCCTTGGCAGGGGGTTCGCAAGTCCCACCCCAAACGATGCTGAAGGCTCAGGTTACACAGGCACAAGTGCTAT\\\nATACGCGAGTTCCCGCTCTTAACCTGGACCGAATGCGGGATCATGCATCGTACCACTGTGTTCGTGTCATCTAGGACGG\\\nGCGCAAAGGATACATAGTTCAATCAAGAATACCTTGTATTATTGTACACCTACCGGTCACCAGCCAACAATGTGCGGAC\\\nGGCGTTGCGACTTGCTGGGCCTGATCTCACCGCCCTAGATACCGCACACTGGGCAATACGAGGTAAAGCCAGTCACCCA\\\nGTGTCGATCAACAGCTGACGTAACGGTAAGAGGCTCACAAAATCGCACCGCCGGCGTCCCCTGGGTATTTTACGTCAGC\\\nATCGGGTGGACTGGCATGAATCTTTACTCCCAGGCGGAAACGGGTGCGTGGACAAGCGAGCAGCAAACGAAAATTCCTG\\\nGCCTGCTTGGTGTCTCGTATCCCTCTTGGAGATCGAGGAAATGTTTCACGACCAAGGGAAAGGTCGCCCTACGAAATAG\\\nATTTGCGCTACTGTCCGCATAAGGAGTCCGGTGTAGCGAAGGATGAAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGC\\\nGGTAAGGTATCACTCAGGAAGCAGGCACGGAAAGACACGGTCTAGCAGACCGTCTATCGGCTAGGTCAAATAGGGTGCT\\\nTTGATATCAGCATGTCCAGCCTTAGAATTCAGTTCAGCGCGCTGGTCTGGGTCGAGATAAAATCACCAGTACCCAAGAC\\\nCAGGCGGGCTCGCCGCGTTGGCTAATCCTGGTACATCTTGTAATCAATGTTCAGAAGAAAATCTGTGTTAGAGGGACGA\\\nGTCACCACGTACCAATAGCGACAACGATCGGTCGGACTATTCATCGTGGTGGTGACGCTCGGATTACGCGGGAAAGGTG\\\nCTTGTGTCCCGACAGGCTAGGATATAATGCTGAGGCGCTGCCCCAACCGTTCAGCGTGGGGTTTGCTACAACTTCCGAG\\\nTGCTACGTGTGCGAGACCATGTTATGTATGCACAAGGCCGACAATAGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGT\\\nCGCACAAGCACAGTAGATCCTCCCCGCGCATCCTATTTATTAAGTTAATTCTATAGCAATACGATCACATGCGGATGGG\\\nCAGTGGCCGGTAGTCACACGCCTACCGCGGTGCTCAATGACCGGGACTAGAGAGGCGAAGATTATGGCGTGTGACCCGT\\\nTATGCTCGAGTTCGGTCAGAGCGTCATTGCGAGTAGTCGATTGCTTTCCCAATCTCCGAGCGATTTAGCGTGACAGCCC\\\nCAGGGAACCCACAAAATGCGATCGCAGTCCACCCGATCGTACACAGAAAGGAGGGTCCCCATACGCCGACGCACCTGTT\\\nCGCACGTCGTATGCATAAACGAGCCGCACGAACCAGAGAGCATAAAGAGGACCTCTAGCTCCTTTACAAAGTACAGGTT\\\nCGCCTGCCGCCGGGATGCCTTACCTAGACGCAATGACGGACGTATTCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGG\\\nATCCAAGATTGGCGGCCGAAGCCGCCTTTCCAAAGTGAGTCCTTCGTCTGTGACTAACTGTGCCAGATCGTCTTGCAAA\\\nCTCCCGATCCAGTTTAACTCACCAAACTATAGCCGTACAGACCCAAATCTTAAGTCATATCACGCGACTAGCCTCTGCT\\\nCAATTTCTGTGCTCAAGGGTTTTGGTCCGCCCGAGCGGTGCAGCCGATTAGGACCATCTAATGCACTTGTTACAAGACT\\\nTCTTTTAAACACTTTCTTCCTGCCCAGTGGCGGATGATAATGGTTGTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGT\\\nGCGAGCCTAATGTGCCGTCTCCACCAACACAGGGCTGTCCGGTCGTATAATAGGACTCCGCAATGGGGTTAGCAAGTGG\\\nCAGCCTAAACGATGTCGGGGACTCGCGATGTACATGCTCTGGTTCAATACATACGTGACCCGGCAGTTATCCTGCATCG\\\nGAACGTCAATCGTGCATCGGGCCAGCGTAATCGTGTCATCTGGGAGGCGGCCGTAGGATAAATAATTCAATAAAGATGT\\\nCGTTTTGCTAGTATACGCCTAGGCGTCACCCGCCATCTCTGTGCAGGTGGGCCGACGAGACACTGCCCCTGATTTCTCC\\\nGCTACTAATAGCACACACGGGGCAATACCAGCACAAGCCAGTCTCGCGGGAACGCTCGTCAGCATACGAAAGAGCTTGA\\\nGGCACGCCAATTCGCACTGTCGGGGTCGCTTGGGTGTTTTGCACTACCGTCAGGTACGCTAGTATGCGTCCTTCCTTCC\\\nAGGGGTATGTGGCTGCGTGGTCAAAAGTGCGGCATTCGTATTTGCTCCCCGTGCTTGCTCTCACGAACTTGACCTGGAG\\\nATCAAGGAGATGCTTCTTGTGGAACCGGACAGCGCATCAACGCAACGGATCTACGTTACAGCGTGCATAGCGAGAACGG\\\nAGTTGCCGACGACGAAAGCGACACTGGGATCTGTCCGTCGTCATTCGCGGAAAGCATCCGCTCACGAGGCGGACACTGA\\\nTTGACACGGTTTTGCAGAAGGTTAGGGGAATAGGTCAAATTGAGTGGCTTAAAAACGCTATGTCTGGGATTAAAGTGTA\\\nGTAAACTGCGGTCAACGGAGACGGTTTTAAGACAGGAGTTCGCAAAACCAGGCGGGGTCGCCACGACGGCTATTCCTGG\\\nTGGTTTAGGCGTACAATGTCCTGAAGAATATTTAAGAAAGAAGCACCCCTCGTCGCCTAGAATTACCTACCGCGGTCGA\\\nCCATACCTTCGATTGTCGCGCCCACCCTCCCATTAGTCGGCAGAGGTGGTTGTGTTGCGATAGCCCAGCATGATATCCT\\\nAAGGCGTTACGCCGATGGATATCCCACGGAATTGCCATAGGCGCTGAACGCTACACGGACGATACGAACTTATGTATGG\\\nAGCGGGTCATCGAAAGGTCATACCCTTGTAGTTAACATGTAGCCCGGCCCTATTAGTACAGCAGTGCCTTGAGCGGCAT\\\nTCTCATTATTAAGTTTTCTCTACAGCCAAACGACCAAGTGCACTTCCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCA\\\nGCTCTGTAATAGGGACTAAAAGAGTGATGATAATCATGAGTGCCGCGTTATGGTGGTGTCGGAACAGAGCGGTCTTACG\\\nGCCAGTCGTATCCCTTCTCGAGTTCCGTCCGGTTAAGCGTGACACTCCCAGTGTACCCGCAAACCGTGATGGCTGTGCT\\\nTGGGGTCAATCGCATGTAGGATGGTCTCCAGACACCGGGGCACCAGTTTTCACGCCCAAAGCATAAACGACGAGCAGTC\\\nATGAGAGTCTTAGAACTGGACGTGCCGTTTCTCTGCGAACAACACCTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGC\\\nAGTGCCGCTCCTATCACATTTGCCTCGACGACTGCCGCCTTCGCTGTTTCCCTAGACACTCAACAGTAAGCGCCTTTTG\\\nTAGGCAGGGGCACCCCCTGTCAGTGGCTGCGCCAAAACGTCTTCGGATCCCCTTGTCCAATCAAACTGACCGAATTCTT\\\nTCATTTAAGACCCTAATATGACATCATTAGTGACTAAATGCCACTCCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCC\\\nCCACTAAAGTTGTCTAAAACGAATCTAACTATTCCCTGTGCCTTATGGGGGCCTGCGCTATCTGCCTGTCGAACCATAG\\\nGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCGGGGCCTAAGACCACGAGCGTCTGGCGTCTTGGCTAA\\\nCCCCCCTACATGCTGTTATAGACAATCAGTGGAAACCCGGTGCCAGGGGGTGGAGTGACCTTAAGTCAGGGACGATATT\\\nAATCGGAAGGAGTATTCAACGCAATGAAGCCGCAGGGTTGGCGTGGGAATGGTGCTTCTGTCCAAGCAGGTAAGGGCAT\\\nGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTGCACTTTGCAACGATTTCGGAGTCCGGAGACTCGCTGTTTTCGAAAT\\\nTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTACGCCCAAGAACGTAGCAAGGTGACTCAAACAAGGTACATCTTGCCC\\\nGCGTTTCACACGAATCAAGTTGGAGGTTATGGAGCATAGTAACACGTGGGCGGCCAGTGGTCGGTTGCTACACCCCTGC\\\nCGCAACGTTGAAGGTCCCGGATTAGACTGGCTGGACCCATGCCGTGACACCCGTCACACTCCATTACCGTCTGCGGGTC\\\nACGGCTTGTTGTGGACTGGATTGCCATTCTCTCAGTGTATTACGCAGGCCGGCGCGCGGGTCCCATGTAAACCTGTCAT\\\nAGCTTACCTGACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCCACGCACCTGGTCGGTCCTCGTTTGCTTTTTAGGACC\\\nGGATGAACTACAGAGCGCTGCAAGAATCTCTACCTGCTTTACAAAGCGCTGGGTCCTACTCCAGCGGGATGTTTTATCT\\\nAAACACGATGAGAGGAGTATTCGTCAGGCCACATGGCTTTCTTGTCCTGGTCGGATCCATCGTTGGCGCCCGACCCCCC\\\nCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTGCATGCCAGATCGGCAGACAGATAGCGGATCCAGTATATCCCTGGAA\\\nGCTATAGACGCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTCCGAACCCAGCTCTACTTTAGTGGCCACGGGTTCTGG\\\nTCCCCCCGGGCCGCGGAACCGATTAGGGCCATGTACAACAATACTTATTAGTCACCTTTCAGACACGATCTCCCTGCTC\\\nAGTGGTATATGGTTCCTGCTATAATTAGCCACCCTCATAAGTTGCACTACTTCTGCGACCCAAGTGCACCCTTACCACG\\\nAAGACAGGATTGTCCGATCCCATACTGCGGCCTTGGCAGGGGGTTCGCAAGTCCCACCCCAAACGATGCTGAAGGCTCA\\\nGGTTACACAGGCACAAGTGCTATATACGCGAGTTCCCGCTCTTAACCTGGACCGAATGCGGGATCATGCATCGTACCAC\\\nTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGATACATAGTTCAATCAAGAATACCTTGTATTATTGTACACCTACCGG\\\nTCACCAGCCAACAATGTGCGGACGGCGTTGCGACTTGCTGGGCCTGATCTCACCGCCCTAGATACCGCACACTGGGCAA\\\nTACGAGGTAAAGCCAGTCACCCAGTGTCGATCAACAGCTGACGTAACGGTAAGAGGCTCACAAAATCGCACCGCCGGCG\\\nTCCCCTGGGTATTTTACGTCAGCATCGGGTGGACTGGCATGAATCTTTACTCCCAGGCGGAAACGGGTGCGTGGACAAG\\\nCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGGTGTCTCGTATCCCTCTTGGAGATCGAGGAAATGTTTCACGACCAAG\\\nGGAAAGGTCGCCCTACGAAATAGATTTGCGCTACTGTCCGCATAAGGAGTCCGGTGTAGCGAAGGATGAAGGCGACCCT\\\nAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAAGCAGGCACGGAAAGACACGGTCTAGCAGACCGTCTA\\\nTCGGCTAGGTCAAATAGGGTGCTTTGATATCAGCATGTCCAGCCTTAGAATTCAGTTCAGCGCGCTGGTCTGGGTCGAG\\\nATAAAATCACCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTGGCTAATCCTGGTACATCTTGTAATCAATGTTCAGAA\\\nGAAAATCTGTGTTAGAGGGACGAGTCACCACGTACCAATAGCGACAACGATCGGTCGGACTATTCATCGTGGTGGTGAC\\\nGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAGGATATAATGCTGAGGCGCTGCCCCAACCGTTCAGCG\\\nTGGGGTTTGCTACAACTTCCGAGTGCTACGTGTGCGAGACCATGTTATGTATGCACAAGGCCGACAATAGGACGTAGCC\\\nTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCACAGTAGATCCTCCCCGCGCATCCTATTTATTAAGTTAATTCTATAG\\\nCAATACGATCACATGCGGATGGGCAGTGGCCGGTAGTCACACGCCTACCGCGGTGCTCAATGACCGGGACTAGAGAGGC\\\nGAAGATTATGGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGAGCGTCATTGCGAGTAGTCGATTGCTTTCCCAATCTC\\\nCGAGCGATTTAGCGTGACAGCCCCAGGGAACCCACAAAATGCGATCGCAGTCCACCCGATCGTACACAGAAAGGAGGGT\\\nCCCCATACGCCGACGCACCTGTTCGCACGTCGTATGCATAAACGAGCCGCACGAACCAGAGAGCATAAAGAGGACCTCT\\\nAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGCCGGGATGCCTTACCTAGACGCAATGACGGACGTATTCCTCTGGCCT\\\nCAACGGTTCCTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAAGCCGCCTTTCCAAAGTGAGTCCTTCGTCTGTGACTA\\\nACTGTGCCAGATCGTCTTGCAAACTCCCGATCCAGTTTAACTCACCAAACTATAGCCGTACAGACCCAAATCTTAAGTC\\\nATATCACGCGACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGTTTTGGTCCGCCCGAGCGGTGCAGCCGATTAGGACCA\\\nTCTAATGCACTTGTTACAAGACTTCTTTTAAACACTTTCTTCCTGCCCAGTGGCGGATGATAATGGTTGTTGCCAGCCG\\\nGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAATGTGCCGTCTCCACCAACACAGGGCTGTCCGGTCGTATAATAGGAC\\\nTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGGACTCGCGATGTACATGCTCTGGTTCAATACATACGT\\\nGACCCGGCAGTTATCCTGCATCGGAACGTCAATCGTGCATCGGGCCAGCGTAATCGTGTCATCTGGGAGGCGGCCGTAG\\\nGATAAATAATTCAATAAAGATGTCGTTTTGCTAGTATACGCCTAGGCGTCACCCGCCATCTCTGTGCAGGTGGGCCGAC\\\nGAGACACTGCCCCTGATTTCTCCGCTACTAATAGCACACACGGGGCAATACCAGCACAAGCCAGTCTCGCGGGAACGCT\\\nCGTCAGCATACGAAAGAGCTTGAGGCACGCCAATTCGCACTGTCGGGGTCGCTTGGGTGTTTTGCACTACCGTCAGGTA\\\nCGCTAGTATGCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGGTCAAAAGTGCGGCATTCGTATTTGCTCCCCGTGCTT\\\nGCTCTCACGAACTTGACCTGGAGATCAAGGAGATGCTTCTTGTGGAACCGGACAGCGCATCAACGCAACGGATCTACGT\\\nTACAGCGTGCATAGCGAGAACGGAGTTGCCGACGACGAAAGCGACACTGGGATCTGTCCGTCGTCATTCGCGGAAAGCA\\\nTCCGCTCACGAGGCGGACACTGATTGACACGGTTTTGCAGAAGGTTAGGGGAATAGGTCAAATTGAGTGGCTTAAAAAC\\\nGCTATGTCTGGGATTAAAGTGTAGTAAACTGCGGTCAACGGAGACGGTTTTAAGACAGGAGTTCGCAAAACCAGGCGGG\\\nGTCGCCACGACGGCTATTCCTGGTGGTTTAGGCGTACAATGTCCTGAAGAATATTTAAGAAAGAAGCACCCCTCGTCGC\\\nCTAGAATTACCTACCGCGGTCGACCATACCTTCGATTGTCGCGCCCACCCTCCCATTAGTCGGCAGAGGTGGTTGTGTT\\\nGCGATAGCCCAGCATGATATCCTAAGGCGTTACGCCGATGGATATCCCACGGAATTGCCATAGGCGCTGAACGCTACAC\\\nGGACGATACGAACTTATGTATGGAGCGGGTCATCGAAAGGTCATACCCTTGTAGTTAACATGTAGCCCGGCCCTATTAG\\\nTACAGCAGTGCCTTGAGCGGCATTCTCATTATTAAGTTTTCTCTACAGCCAAACGACCAAGTGCACTTCCGCGGAGCGC\\\nGGTGGAGACTCGTCCACCCGGCAGCTCTGTAATAGGGACTAAAAGAGTGATGATAATCATGAGTGCCGCGTTATGGTGG\\\nTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCGAGTTCCGTCCGGTTAAGCGTGACACTCCCAGTGTAC\\\nCCGCAAACCGTGATGGCTGTGCTTGGGGTCAATCGCATGTAGGATGGTCTCCAGACACCGGGGCACCAGTTTTCACGCC\\\nCAAAGCATAAACGACGAGCAGTCATGAGAGTCTTAGAACTGGACGTGCCGTTTCTCTGCGAACAACACCTCGAGCTGTA\\\nCCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTCCTATCACATTTGCCTCGACGACTGCCGCCTTCGCTGTTTCCCTAGA\\\nCACTCAACAGTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGTCAGTGGCTGCGCCAAAACGTCTTCGGATCCCCTTGT\\\nCCAATCAAACTGACCGAATTCTTTCATTTAAGACCCTAATATGACATCATTAGTGACTAAATGCCACTCCCAAAATTCT\\\nGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAACGAATCTAACTATTCCCTGTGCCTTATGGGGGCCTGC\\\nGCTATCTGCCTGTCGAACCATAGGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCGGGGCCTAAGACCA\\\nCGAGCGTCTGGCGTCTTGGCTAACCCCCCTACATGCTGTTATAGACAATCAGTGGAAACCCGGTGCCAGGGGGTGGAGT\\\nGACCTTAAGTCAGGGACGATATTAATCGGAAGGAGTATTCAACGCAATGAAGCCGCAGGGTTGGCGTGGGAATGGTGCT\\\nTCTGTCCAAGCAGGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTGCACTTTGCAACGATTTCGGAGTC\\\nCGGAGACTCGCTGTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTACGCCCAAGAACGTAGCAAGGTGA\\\nCTCAAACAAGGTACATCTTGCCCGCGTTTCACACGAATCAAGTTGGAGGTTATGGAGCATAGTAACACGTGGGCGGCCA\\\nGTGGTCGGTTGCTACACCCCTGCCGCAACGTTGAAGGTCCCGGATTAGACTGGCTGGACCCATGCCGTGACACCCGTCA\\\nCACTCCATTACCGTCTGCGGGTCACGGCTTGTTGTGGACTGGATTGCCATTCTCTCAGTGTATTACGCAGGCCGGCGCG\\\nCGGGTCCCATGTAAACCTGTCATAGCTTACCTGACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCCACGCACCTGGTCG\\\nGTCCTCGTTTGCTTTTTAGGACCGGATGAACTACAGAGCGCTGCAAGAATCTCTACCTGCTTTACAAAGCGCTGGGTCC\\\nTACTCCAGCGGGATGTTTTATCTAAACACGATGAGAGGAGTATTCGTCAGGCCACATGGCTTTCTTGTCCTGGTCGGAT\\\nCCATCGTTGGCGCCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTGCATGCCAGATCGGCAGACAGATA\\\nGCGGATCCAGTATATCCCTGGAAGCTATAGACGCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTCCGAACCCAGCTCT\\\nACTTTAGTGGCCACGGGTTCTGGTCCCCCCGGGCCGCGGAACCGATTAGGGCCATGTACAACAATACTTATTAGTCACC\\\nTTTCAGACACGATCTCCCTGCTCAGTGGTATATGGTTCCTGCTATAATTAGCCACCCTCATAAGTTGCACTACTTCTGC\\\nGACCCAAGTGCACCCTTACCACGAAGACAGGATTGTCCGATCCCATACTGCGGCCTTGGCAGGGGGTTCGCAAGTCCCA\\\nCCCCAAACGATGCTGAAGGCTCAGGTTACACAGGCACAAGTGCTATATACGCGAGTTCCCGCTCTTAACCTGGACCGAA\\\nTGCGGGATCATGCATCGTACCACTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGATACATAGTTCAATCAAGAATACC\\\nTTGTATTATTGTACACCTACCGGTCACCAGCCAACAATGTGCGGACGGCGTTGCGACTTGCTGGGCCTGATCTCACCGC\\\nCCTAGATACCGCACACTGGGCAATACGAGGTAAAGCCAGTCACCCAGTGTCGATCAACAGCTGACGTAACGGTAAGAGG\\\nCTCACAAAATCGCACCGCCGGCGTCCCCTGGGTATTTTACGTCAGCATCGGGTGGACTGGCATGAATCTTTACTCCCAG\\\nGCGGAAACGGGTGCGTGGACAAGCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGGTGTCTCGTATCCCTCTTGGAGAT\\\nCGAGGAAATGTTTCACGACCAAGGGAAAGGTCGCCCTACGAAATAGATTTGCGCTACTGTCCGCATAAGGAGTCCGGTG\\\nTAGCGAAGGATGAAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAAGCAGGCACGGAAA\\\nGACACGGTCTAGCAGACCGTCTATCGGCTAGGTCAAATAGGGTGCTTTGATATCAGCATGTCCAGCCTTAGAATTCAGT\\\nTCAGCGCGCTGGTCTGGGTCGAGATAAAATCACCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTGGCTAATCCTGGTA\\\nCATCTTGTAATCAATGTTCAGAAGAAAATCTGTGTTAGAGGGACGAGTCACCACGTACCAATAGCGACAACGATCGGTC\\\nGGACTATTCATCGTGGTGGTGACGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAGGATATAATGCTGA\\\nGGCGCTGCCCCAACCGTTCAGCGTGGGGTTTGCTACAACTTCCGAGTGCTACGTGTGCGAGACCATGTTATGTATGCAC\\\nAAGGCCGACAATAGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCACAGTAGATCCTCCCCGCGCATCC\\\nTATTTATTAAGTTAATTCTATAGCAATACGATCACATGCGGATGGGCAGTGGCCGGTAGTCACACGCCTACCGCGGTGC\\\nTCAATGACCGGGACTAGAGAGGCGAAGATTATGGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGAGCGTCATTGCGAG\\\nTAGTCGATTGCTTTCCCAATCTCCGAGCGATTTAGCGTGACAGCCCCAGGGAACCCACAAAATGCGATCGCAGTCCACC\\\nCGATCGTACACAGAAAGGAGGGTCCCCATACGCCGACGCACCTGTTCGCACGTCGTATGCATAAACGAGCCGCACGAAC\\\nCAGAGAGCATAAAGAGGACCTCTAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGCCGGGATGCCTTACCTAGACGCAA\\\nTGACGGACGTATTCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAAGCCGCCTTTCCAA\\\nAGTGAGTCCTTCGTCTGTGACTAACTGTGCCAGATCGTCTTGCAAACTCCCGATCCAGTTTAACTCACCAAACTATAGC\\\nCGTACAGACCCAAATCTTAAGTCATATCACGCGACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGTTTTGGTCCGCCCG\\\nAGCGGTGCAGCCGATTAGGACCATCTAATGCACTTGTTACAAGACTTCTTTTAAACACTTTCTTCCTGCCCAGTGGCGG\\\nATGATAATGGTTGTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAATGTGCCGTCTCCACCAACACAGG\\\nGCTGTCCGGTCGTATAATAGGACTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGGACTCGCGATGTAC\\\nATGCTCTGGTTCAATACATACGTGACCCGGCAGTTATCCTGCATCGGAACGTCAATCGTGCATCGGGCCAGCGTAATCG\\\nTGTCATCTGGGAGGCGGCCGTAGGATAAATAATTCAATAAAGATGTCGTTTTGCTAGTATACGCCTAGGCGTCACCCGC\\\nCATCTCTGTGCAGGTGGGCCGACGAGACACTGCCCCTGATTTCTCCGCTACTAATAGCACACACGGGGCAATACCAGCA\\\nCAAGCCAGTCTCGCGGGAACGCTCGTCAGCATACGAAAGAGCTTGAGGCACGCCAATTCGCACTGTCGGGGTCGCTTGG\\\nGTGTTTTGCACTACCGTCAGGTACGCTAGTATGCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGGTCAAAAGTGCGGC\\\nATTCGTATTTGCTCCCCGTGCTTGCTCTCACGAACTTGACCTGGAGATCAAGGAGATGCTTCTTGTGGAACCGGACAGC\\\nGCATCAACGCAACGGATCTACGTTACAGCGTGCATAGCGAGAACGGAGTTGCCGACGACGAAAGCGACACTGGGATCTG\\\nTCCGTCGTCATTCGCGGAAAGCATCCGCTCACGAGGCGGACACTGATTGACACGGTTTTGCAGAAGGTTAGGGGAATAG\\\nGTCAAATTGAGTGGCTTAAAAACGCTATGTCTGGGATTAAAGTGTAGTAAACTGCGGTCAACGGAGACGGTTTTAAGAC\\\nAGGAGTTCGCAAAACCAGGCGGGGTCGCCACGACGGCTATTCCTGGTGGTTTAGGCGTACAATGTCCTGAAGAATATTT\\\nAAGAAAGAAGCACCCCTCGTCGCCTAGAATTACCTACCGCGGTCGACCATACCTTCGATTGTCGCGCCCACCCTCCCAT\\\nTAGTCGGCAGAGGTGGTTGTGTTGCGATAGCCCAGCATGATATCCTAAGGCGTTACGCCGATGGATATCCCACGGAATT\\\nGCCATAGGCGCTGAACGCTACACGGACGATACGAACTTATGTATGGAGCGGGTCATCGAAAGGTCATACCCTTGTAGTT\\\nAACATGTAGCCCGGCCCTATTAGTACAGCAGTGCCTTGAGCGGCATTCTCATTATTAAGTTTTCTCTACAGCCAAACGA\\\nCCAAGTGCACTTCCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCAGCTCTGTAATAGGGACTAAAAGAGTGATGATAA\\\nTCATGAGTGCCGCGTTATGGTGGTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCGAGTTCCGTCCGGT\\\nTAAGCGTGACACTCCCAGTGTACCCGCAAACCGTGATGGCTGTGCTTGGGGTCAATCGCATGTAGGATGGTCTCCAGAC\\\nACCGGGGCACCAGTTTTCACGCCCAAAGCATAAACGACGAGCAGTCATGAGAGTCTTAGAACTGGACGTGCCGTTTCTC\\\nTGCGAACAACACCTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTCCTATCACATTTGCCTCGACGACT\\\nGCCGCCTTCGCTGTTTCCCTAGACACTCAACAGTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGTCAGTGGCTGCGCC\\\nAAAACGTCTTCGGATCCCCTTGTCCAATCAAACTGACCGAATTCTTTCATTTAAGACCCTAATATGACATCATTAGTGA\\\nCTAAATGCCACTCCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAACGAATCTAACTATT\\\nCCCTGTGCCTTATGGGGGCCTGCGCTATCTGCCTGTCGAACCATAGGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGT\\\nGAAATCTCCGGGGCCTAAGACCACGAGCGTCTGGCGTCTTGGCTAACCCCCCTACATGCTGTTATAGACAATCAGTGGA\\\nAACCCGGTGCCAGGGGGTGGAGTGACCTTAAGTCAGGGACGATATTAATCGGAAGGAGTATTCAACGCAATGAAGCCGC\\\nAGGGTTGGCGTGGGAATGGTGCTTCTGTCCAAGCAGGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTG\\\nCACTTTGCAACGATTTCGGAGTCCGGAGACTCGCTGTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTA\\\nCGCCCAAGAACGTAGCAAGGTGACTCAAACAAGGTACATCTTGCCCGCGTTTCACACGAATCAAGTTGGAGGTTATGGA\\\nGCATAGTAACACGTGGGCGGCCAGTGGTCGGTTGCTACACCCCTGCCGCAACGTTGAAGGTCCCGGATTAGACTGGCTG\\\nGACCCATGCCGTGACACCCGTCACACTCCATTACCGTCTGCGGGTCACGGCTTGTTGTGGACTGGATTGCCATTCTCTC\\\nAGTGTATTACGCAGGCCGGCGCGCGGGTCCCATGTAAACCTGTCATAGCTTACCTGACTCTACTTGGAAGTGTGGCTAG\\\nGCCTTTGCCCACGCACCTGGTCGGTCCTCGTTTGCTTTTTAGGACCGGATGAACTACAGAGCGCTGCAAGAATCTCTAC\\\nCTGCTTTACAAAGCGCTGGGTCCTACTCCAGCGGGATGTTTTATCTAAACACGATGAGAGGAGTATTCGTCAGGCCACA\\\nTGGCTTTCTTGTCCTGGTCGGATCCATCGTTGGCGCCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTG\\\nCATGCCAGATCGGCAGACAGATAGCGGATCCAGTATATCCCTGGAAGCTATAGACGCACAGGTTGGAATCCTAAGCGAA\\\nGTCGCGCGTCCGAACCCAGCTCTACTTTAGTGGCCACGGGTTCTGGTCCCCCCGGGCCGCGGAACCGATTAGGGCCATG\\\nTACAACAATACTTATTAGTCACCTTTCAGACACGATCTCCCTGCTCAGTGGTATATGGTTCCTGCTATAATTAGCCACC\\\nCTCATAAGTTGCACTACTTCTGCGACCCAAGTGCACCCTTACCACGAAGACAGGATTGTCCGATCCCATACTGCGGCCT\\\nTGGCAGGGGGTTCGCAAGTCCCACCCCAAACGATGCTGAAGGCTCAGGTTACACAGGCACAAGTGCTATATACGCGAGT\\\nTCCCGCTCTTAACCTGGACCGAATGCGGGATCATGCATCGTACCACTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGA\\\nTACATAGTTCAATCAAGAATACCTTGTATTATTGTACACCTACCGGTCACCAGCCAACAATGTGCGGACGGCGTTGCGA\\\nCTTGCTGGGCCTGATCTCACCGCCCTAGATACCGCACACTGGGCAATACGAGGTAAAGCCAGTCACCCAGTGTCGATCA\\\nACAGCTGACGTAACGGTAAGAGGCTCACAAAATCGCACCGCCGGCGTCCCCTGGGTATTTTACGTCAGCATCGGGTGGA\\\nCTGGCATGAATCTTTACTCCCAGGCGGAAACGGGTGCGTGGACAAGCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGG\\\nTGTCTCGTATCCCTCTTGGAGATCGAGGAAATGTTTCACGACCAAGGGAAAGGTCGCCCTACGAAATAGATTTGCGCTA\\\nCTGTCCGCATAAGGAGTCCGGTGTAGCGAAGGATGAAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTAT\\\nCACTCAGGAAGCAGGCACGGAAAGACACGGTCTAGCAGACCGTCTATCGGCTAGGTCAAATAGGGTGCTTTGATATCAG\\\nCATGTCCAGCCTTAGAATTCAGTTCAGCGCGCTGGTCTGGGTCGAGATAAAATCACCAGTACCCAAGACCAGGCGGGCT\\\nCGCCGCGTTGGCTAATCCTGGTACATCTTGTAATCAATGTTCAGAAGAAAATCTGTGTTAGAGGGACGAGTCACCACGT\\\nACCAATAGCGACAACGATCGGTCGGACTATTCATCGTGGTGGTGACGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCC\\\nGACAGGCTAGGATATAATGCTGAGGCGCTGCCCCAACCGTTCAGCGTGGGGTTTGCTACAACTTCCGAGTGCTACGTGT\\\nGCGAGACCATGTTATGTATGCACAAGGCCGACAATAGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCA\\\nCAGTAGATCCTCCCCGCGCATCCTATTTATTAAGTTAATTCTATAGCAATACGATCACATGCGGATGGGCAGTGGCCGG\\\nTAGTCACACGCCTACCGCGGTGCTCAATGACCGGGACTAGAGAGGCGAAGATTATGGCGTGTGACCCGTTATGCTCGAG\\\nTTCGGTCAGAGCGTCATTGCGAGTAGTCGATTGCTTTCCCAATCTCCGAGCGATTTAGCGTGACAGCCCCAGGGAACCC\\\nACAAAATGCGATCGCAGTCCACCCGATCGTACACAGAAAGGAGGGTCCCCATACGCCGACGCACCTGTTCGCACGTCGT\\\nATGCATAAACGAGCCGCACGAACCAGAGAGCATAAAGAGGACCTCTAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGC\\\nCGGGATGCCTTACCTAGACGCAATGACGGACGTATTCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGGATCCAAGATT\\\nGGCGGCCGAAGCCGCCTTTCCAAAGTGAGTCCTTCGTCTGTGACTAACTGTGCCAGATCGTCTTGCAAACTCCCGATCC\\\nAGTTTAACTCACCAAACTATAGCCGTACAGACCCAAATCTTAAGTCATATCACGCGACTAGCCTCTGCTCAATTTCTGT\\\nGCTCAAGGGTTTTGGTCCGCCCGAGCGGTGCAGCCGATTAGGACCATCTAATGCACTTGTTACAAGACTTCTTTTAAAC\\\nACTTTCTTCCTGCCCAGTGGCGGATGATAATGGTTGTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAA\\\nTGTGCCGTCTCCACCAACACAGGGCTGTCCGGTCGTATAATAGGACTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAAC\\\nGATGTCGGGGACTCGCGATGTACATGCTCTGGTTCAATACATACGTGACCCGGCAGTTATCCTGCATCGGAACGTCAAT\\\nCGTGCATCGGGCCAGCGTAATCGTGTCATCTGGGAGGCGGCCGTAGGATAAATAATTCAATAAAGATGTCGTTTTGCTA\\\nGTATACGCCTAGGCGTCACCCGCCATCTCTGTGCAGGTGGGCCGACGAGACACTGCCCCTGATTTCTCCGCTACTAATA\\\nGCACACACGGGGCAATACCAGCACAAGCCAGTCTCGCGGGAACGCTCGTCAGCATACGAAAGAGCTTGAGGCACGCCAA\\\nTTCGCACTGTCGGGGTCGCTTGGGTGTTTTGCACTACCGTCAGGTACGCTAGTATGCGTCCTTCCTTCCAGGGGTATGT\\\nGGCTGCGTGGTCAAAAGTGCGGCATTCGTATTTGCTCCCCGTGCTTGCTCTCACGAACTTGACCTGGAGATCAAGGAGA\\\nTGCTTCTTGTGGAACCGGACAGCGCATCAACGCAACGGATCTACGTTACAGCGTGCATAGCGAGAACGGAGTTGCCGAC\\\nGACGAAAGCGACACTGGGATCTGTCCGTCGTCATTCGCGGAAAGCATCCGCTCACGAGGCGGACACTGATTGACACGGT\\\nTTTGCAGAAGGTTAGGGGAATAGGTCAAATTGAGTGGCTTAAAAACGCTATGTCTGGGATTAAAGTGTAGTAAACTGCG\\\nGTCAACGGAGACGGTTTTAAGACAGGAGTTCGCAAAACCAGGCGGGGTCGCCACGACGGCTATTCCTGGTGGTTTAGGC\\\nGTACAATGTCCTGAAGAATATTTAAGAAAGAAGCACCCCTCGTCGCCTAGAATTACCTACCGCGGTCGACCATACCTTC\\\nGATTGTCGCGCCCACCCTCCCATTAGTCGGCAGAGGTGGTTGTGTTGCGATAGCCCAGCATGATATCCTAAGGCGTTAC\\\nGCCGATGGATATCCCACGGAATTGCCATAGGCGCTGAACGCTACACGGACGATACGAACTTATGTATGGAGCGGGTCAT\\\nCGAAAGGTCATACCCTTGTAGTTAACATGTAGCCCGGCCCTATTAGTACAGCAGTGCCTTGAGCGGCATTCTCATTATT\\\nAAGTTTTCTCTACAGCCAAACGACCAAGTGCACTTCCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCAGCTCTGTAAT\\\nAGGGACTAAAAGAGTGATGATAATCATGAGTGCCGCGTTATGGTGGTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTA\\\nTCCCTTCTCGAGTTCCGTCCGGTTAAGCGTGACACTCCCAGTGTACCCGCAAACCGTGATGGCTGTGCTTGGGGTCAAT\\\nCGCATGTAGGATGGTCTCCAGACACCGGGGCACCAGTTTTCACGCCCAAAGCATAAACGACGAGCAGTCATGAGAGTCT\\\nTAGAACTGGACGTGCCGTTTCTCTGCGAACAACACCTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTC\\\nCTATCACATTTGCCTCGACGACTGCCGCCTTCGCTGTTTCCCTAGACACTCAACAGTAAGCGCCTTTTGTAGGCAGGGG\\\nCACCCCCTGTCAGTGGCTGCGCCAAAACGTCTTCGGATCCCCTTGTCCAATCAAACTGACCGAATTCTTTCATTTAAGA\\\nCCCTAATATGACATCATTAGTGACTAAATGCCACTCCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGT\\\nTGTCTAAAACGAATCTAACTATTCCCTGTGCCTTATGGGGGCCTGCGCTATCTGCCTGTCGAACCATAGGACTCGCGCC\\\nAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCGGGGCCTAAGACCACGAGCGTCTGGCGTCTTGGCTAACCCCCCTACA\\\nTGCTGTTATAGACAATCAGTGGAAACCCGGTGCCAGGGGGTGGAGTGACCTTAAGTCAGGGACGATATTAATCGGAAGG\\\nAGTATTCAACGCAATGAAGCCGCAGGGTTGGCGTGGGAATGGTGCTTCTGTCCAAGCAGGTAAGGGCATGAGGCCGCAA\\\nCCGTCCCCCAAGCGTACAGGGTGCACTTTGCAACGATTTCGGAGTCCGGAGACTCGCTGTTTTCGAAATTTGCGCTCAA\\\nGGGCGGGTATTGAACCAGGCTTACGCCCAAGAACGTAGCAAGGTGACTCAAACAAGGTACATCTTGCCCGCGTTTCACA\\\nCGAATCAAGTTGGAGGTTATGGAGCATAGTAACACGTGGGCGGCCAGTGGTCGGTTGCTACACCCCTGCCGCAACGTTG\\\nAAGGTCCCGGATTAGACTGGCTGGACCCATGCCGTGACACCCGTCACACTCCATTACCGTCTGCGGGTCACGGCTTGTT\\\nGTGGACTGGATTGCCATTCTCTCAGTGTATTACGCAGGCCGGCGCGCGGGTCCCATGTAAACCTGTCATAGCTTACCTG\\\nACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCCACGCACCTGGTCGGTCCTCGTTTGCTTTTTAGGACCGGATGAACTA\\\nCAGAGCGCTGCAAGAATCTCTACCTGCTTTACAAAGCGCTGGGTCCTACTCCAGCGGGATGTTTTATCTAAACACGATG\\\nAGAGGAGTATTCGTCAGGCCACATGGCTTTCTTGTCCTGGTCGGATCCATCGTTGGCGCCCGACCCCCCCACTCCGTAG\\\nTGAGTTCTTCGTCCGAGCCATTGCATGCCAGATCGGCAGACAGATAGCGGATCCAGTATATCCCTGGAAGCTATAGACG\\\nCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTCCGAACCCAGCTCTACTTTAGTGGCCACGGGTTCTGGTCCCCCCGGG\\\nCCGCGGAACCGATTAGGGCCATGTACAACAATACTTATTAGTCACCTTTCAGACACGATCTCCCTGCTCAGTGGTATAT\\\nGGTTCCTGCTATAATTAGCCACCCTCATAAGTTGCACTACTTCTGCGACCCAAGTGCACCCTTACCACGAAGACAGGAT\\\nTGTCCGATCCCATACTGCGGCCTTGGCAGGGGGTTCGCAAGTCCCACCCCAAACGATGCTGAAGGCTCAGGTTACACAG\\\nGCACAAGTGCTATATACGCGAGTTCCCGCTCTTAACCTGGACCGAATGCGGGATCATGCATCGTACCACTGTGTTCGTG\\\nTCATCTAGGACGGGCGCAAAGGATACATAGTTCAATCAAGAATACCTTGTATTATTGTACACCTACCGGTCACCAGCCA\\\nACAATGTGCGGACGGCGTTGCGACTTGCTGGGCCTGATCTCACCGCCCTAGATACCGCACACTGGGCAATACGAGGTAA\\\nAGCCAGTCACCCAGTGTCGATCAACAGCTGACGTAACGGTAAGAGGCTCACAAAATCGCACCGCCGGCGTCCCCTGGGT\\\nATTTTACGTCAGCATCGGGTGGACTGGCATGAATCTTTACTCCCAGGCGGAAACGGGTGCGTGGACAAGCGAGCAGCAA\\\nACGAAAATTCCTGGCCTGCTTGGTGTCTCGTATCCCTCTTGGAGATCGAGGAAATGTTTCACGACCAAGGGAAAGGTCG\\\nCCCTACGAAATAGATTTGCGCTACTGTCCGCATAAGGAGTCCGGTGTAGCGAAGGATGAAGGCGACCCTAGGTAGCAAC\\\nCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAAGCAGGCACGGAAAGACACGGTCTAGCAGACCGTCTATCGGCTAGGT\\\nCAAATAGGGTGCTTTGATATCAGCATGTCCAGCCTTAGAATTCAGTTCAGCGCGCTGGTCTGGGTCGAGATAAAATCAC\\\nCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTGGCTAATCCTGGTACATCTTGTAATCAATGTTCAGAAGAAAATCTGT\\\nGTTAGAGGGACGAGTCACCACGTACCAATAGCGACAACGATCGGTCGGACTATTCATCGTGGTGGTGACGCTCGGATTA\\\nCGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAGGATATAATGCTGAGGCGCTGCCCCAACCGTTCAGCGTGGGGTTTGC\\\nTACAACTTCCGAGTGCTACGTGTGCGAGACCATGTTATGTATGCACAAGGCCGACAATAGGACGTAGCCTTCGAGTTAG\\\nTACGTAGCGTGGTCGCACAAGCACAGTAGATCCTCCCCGCGCATCCTATTTATTAAGTTAATTCTATAGCAATACGATC\\\nACATGCGGATGGGCAGTGGCCGGTAGTCACACGCCTACCGCGGTGCTCAATGACCGGGACTAGAGAGGCGAAGATTATG\\\nGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGAGCGTCATTGCGAGTAGTCGATTGCTTTCCCAATCTCCGAGCGATTT\\\nAGCGTGACAGCCCCAGGGAACCCACAAAATGCGATCGCAGTCCACCCGATCGTACACAGAAAGGAGGGTCCCCATACGC\\\nCGACGCACCTGTTCGCACGTCGTATGCATAAACGAGCCGCACGAACCAGAGAGCATAAAGAGGACCTCTAGCTCCTTTA\\\nCAAAGTACAGGTTCGCCTGCCGCCGGGATGCCTTACCTAGACGCAATGACGGACGTATTCCTCTGGCCTCAACGGTTCC\\\nTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAAGCCGCCTTTCCAAAGTGAGTCCTTCGTCTGTGACTAACTGTGCCAG\\\nATCGTCTTGCAAACTCCCGATCCAGTTTAACTCACCAAACTATAGCCGTACAGACCCAAATCTTAAGTCATATCACGCG\\\nACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGTTTTGGTCCGCCCGAGCGGTGCAGCCGATTAGGACCATCTAATGCAC\\\nTTGTTACAAGACTTCTTTTAAACACTTTCTTCCTGCCCAGTGGCGGATGATAATGGTTGTTGCCAGCCGGCGTGGAAGG\\\nTAACAGCACCGGTGCGAGCCTAATGTGCCGTCTCCACCAACACAGGGCTGTCCGGTCGTATAATAGGACTCCGCAATGG\\\nGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGGACTCGCGATGTACATGCTCTGGTTCAATACATACGTGACCCGGCAG\\\nTTATCCTGCATCGGAACGTCAATCGTGCATCGGGCCAGCGTAATCGTGTCATCTGGGAGGCGGCCGTAGGATAAATAAT\\\nTCAATAAAGATGTCGTTTTGCTAGTATACGCCTAGGCGTCACCCGCCATCTCTGTGCAGGTGGGCCGACGAGACACTGC\\\nCCCTGATTTCTCCGCTACTAATAGCACACACGGGGCAATACCAGCACAAGCCAGTCTCGCGGGAACGCTCGTCAGCATA\\\nCGAAAGAGCTTGAGGCACGCCAATTCGCACTGTCGGGGTCGCTTGGGTGTTTTGCACTACCGTCAGGTACGCTAGTATG\\\nCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGGTCAAAAGTGCGGCATTCGTATTTGCTCCCCGTGCTTGCTCTCACGA\\\nACTTGACCTGGAGATCAAGGAGATGCTTCTTGTGGAACCGGACAGCGCATCAACGCAACGGATCTACGTTACAGCGTGC\\\nATAGCGAGAACGGAGTTGCCGACGACGAAAGCGACACTGGGATCTGTCCGTCGTCATTCGCGGAAAGCATCCGCTCACG\\\nAGGCGGACACTGATTGACACGGTTTTGCAGAAGGTTAGGGGAATAGGTCAAATTGAGTGGCTTAAAAACGCTATGTCTG\\\nGGATTAAAGTGTAGTAAACTGCGGTCAACGGAGACGGTTTTAAGACAGGAGTTCGCAAAACCAGGCGGGGTCGCCACGA\\\nCGGCTATTCCTGGTGGTTTAGGCGTACAATGTCCTGAAGAATATTTAAGAAAGAAGCACCCCTCGTCGCCTAGAATTAC\\\nCTACCGCGGTCGACCATACCTTCGATTGTCGCGCCCACCCTCCCATTAGTCGGCAGAGGTGGTTGTGTTGCGATAGCCC\\\nAGCATGATATCCTAAGGCGTTACGCCGATGGATATCCCACGGAATTGCCATAGGCGCTGAACGCTACACGGACGATACG\\\nAACTTATGTATGGAGCGGGTCATCGAAAGGTCATACCCTTGTAGTTAACATGTAGCCCGGCCCTATTAGTACAGCAGTG\\\nCCTTGAGCGGCATTCTCATTATTAAGTTTTCTCTACAGCCAAACGACCAAGTGCACTTCCGCGGAGCGCGGTGGAGACT\\\nCGTCCACCCGGCAGCTCTGTAATAGGGACTAAAAGAGTGATGATAATCATGAGTGCCGCGTTATGGTGGTGTCGGAACA\\\nGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCGAGTTCCGTCCGGTTAAGCGTGACACTCCCAGTGTACCCGCAAACCG\\\nTGATGGCTGTGCTTGGGGTCAATCGCATGTAGGATGGTCTCCAGACACCGGGGCACCAGTTTTCACGCCCAAAGCATAA\\\nACGACGAGCAGTCATGAGAGTCTTAGAACTGGACGTGCCGTTTCTCTGCGAACAACACCTCGAGCTGTACCGTTGTTGC\\\nGCTGCCTAGATGCAGTGCCGCTCCTATCACATTTGCCTCGACGACTGCCGCCTTCGCTGTTTCCCTAGACACTCAACAG\\\nTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGTCAGTGGCTGCGCCAAAACGTCTTCGGATCCCCTTGTCCAATCAAAC\\\nTGACCGAATTCTTTCATTTAAGACCCTAATATGACATCATTAGTGACTAAATGCCACTCCCAAAATTCTGCCCAGAAGC\\\nGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAACGAATCTAACTATTCCCTGTGCCTTATGGGGGCCTGCGCTATCTGCC\\\nTGTCGAACCATAGGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCGGGGCCTAAGACCACGAGCGTCTG\\\nGCGTCTTGGCTAACCCCCCTACATGCTGTTATAGACAATCAGTGGAAACCCGGTGCCAGGGGGTGGAGTGACCTTAAGT\\\nCAGGGACGATATTAATCGGAAGGAGTATTCAACGCAATGAAGCCGCAGGGTTGGCGTGGGAATGGTGCTTCTGTCCAAG\\\nCAGGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTGCACTTTGCAACGATTTCGGAGTCCGGAGACTCG\\\nCTGTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTACGCCCAAGAACGTAGCAAGGTGACTCAAACAAG\\\nGTACATCTTGCCCGCGTTTCACACGAATCAAGTTGGAGGTTATGGAGCATAGTAACACGTGGGCGGCCAGTGGTCGGTT\\\nGCTACACCCCTGCCGCAACGTTGAAGGTCCCGGATTAGACTGGCTGGACCCATGCCGTGACACCCGTCACACTCCATTA\\\nCCGTCTGCGGGTCACGGCTTGTTGTGGACTGGATTGCCATTCTCTCAGTGTATTACGCAGGCCGGCGCGCGGGTCCCAT\\\nGTAAACCTGTCATAGCTTACCTGACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCCACGCACCTGGTCGGTCCTCGTTT\\\nGCTTTTTAGGACCGGATGAACTACAGAGCGCTGCAAGAATCTCTACCTGCTTTACAAAGCGCTGGGTCCTACTCCAGCG\\\nGGATGTTTTATCTAAACACGATGAGAGGAGTATTCGTCAGGCCACATGGCTTTCTTGTCCTGGTCGGATCCATCGTTGG\\\nCGCCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTGCATGCCAGATCGGCAGACAGATAGCGGATCCAG\\\nTATATCCCTGGAAGCTATAGACGCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTCCGAACCCAGCTCTACTTTAGTGG\\\nCCACGGGTTCTGGTCCCCCCGGGCCGCGGAACCGATTAGGGCCATGTACAACAATACTTATTAGTCACCTTTCAGACAC\\\nGATCTCCCTGCTCAGTGGTATATGGTTCCTGCTATAATTAGCCACCCTCATAAGTTGCACTACTTCTGCGACCCAAGTG\\\nCACCCTTACCACGAAGACAGGATTGTCCGATCCCATACTGCGGCCTTGGCAGGGGGTTCGCAAGTCCCACCCCAAACGA\\\nTGCTGAAGGCTCAGGTTACACAGGCACAAGTGCTATATACGCGAGTTCCCGCTCTTAACCTGGACCGAATGCGGGATCA\\\nTGCATCGTACCACTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGATACATAGTTCAATCAAGAATACCTTGTATTATT\\\nGTACACCTACCGGTCACCAGCCAACAATGTGCGGACGGCGTTGCGACTTGCTGGGCCTGATCTCACCGCCCTAGATACC\\\nGCACACTGGGCAATACGAGGTAAAGCCAGTCACCCAGTGTCGATCAACAGCTGACGTAACGGTAAGAGGCTCACAAAAT\\\nCGCACCGCCGGCGTCCCCTGGGTATTTTACGTCAGCATCGGGTGGACTGGCATGAATCTTTACTCCCAGGCGGAAACGG\\\nGTGCGTGGACAAGCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGGTGTCTCGTATCCCTCTTGGAGATCGAGGAAATG\\\nTTTCACGACCAAGGGAAAGGTCGCCCTACGAAATAGATTTGCGCTACTGTCCGCATAAGGAGTCCGGTGTAGCGAAGGA\\\nTGAAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAAGCAGGCACGGAAAGACACGGTCT\\\nAGCAGACCGTCTATCGGCTAGGTCAAATAGGGTGCTTTGATATCAGCATGTCCAGCCTTAGAATTCAGTTCAGCGCGCT\\\nGGTCTGGGTCGAGATAAAATCACCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTGGCTAATCCTGGTACATCTTGTAA\\\nTCAATGTTCAGAAGAAAATCTGTGTTAGAGGGACGAGTCACCACGTACCAATAGCGACAACGATCGGTCGGACTATTCA\\\nTCGTGGTGGTGACGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAGGATATAATGCTGAGGCGCTGCCC\\\nCAACCGTTCAGCGTGGGGTTTGCTACAACTTCCGAGTGCTACGTGTGCGAGACCATGTTATGTATGCACAAGGCCGACA\\\nATAGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCACAGTAGATCCTCCCCGCGCATCCTATTTATTAA\\\nGTTAATTCTATAGCAATACGATCACATGCGGATGGGCAGTGGCCGGTAGTCACACGCCTACCGCGGTGCTCAATGACCG\\\nGGACTAGAGAGGCGAAGATTATGGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGAGCGTCATTGCGAGTAGTCGATTG\\\nCTTTCCCAATCTCCGAGCGATTTAGCGTGACAGCCCCAGGGAACCCACAAAATGCGATCGCAGTCCACCCGATCGTACA\\\nCAGAAAGGAGGGTCCCCATACGCCGACGCACCTGTTCGCACGTCGTATGCATAAACGAGCCGCACGAACCAGAGAGCAT\\\nAAAGAGGACCTCTAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGCCGGGATGCCTTACCTAGACGCAATGACGGACGT\\\nATTCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAAGCCGCCTTTCCAAAGTGAGTCCT\\\nTCGTCTGTGACTAACTGTGCCAGATCGTCTTGCAAACTCCCGATCCAGTTTAACTCACCAAACTATAGCCGTACAGACC\\\nCAAATCTTAAGTCATATCACGCGACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGTTTTGGTCCGCCCGAGCGGTGCAG\\\nCCGATTAGGACCATCTAATGCACTTGTTACAAGACTTCTTTTAAACACTTTCTTCCTGCCCAGTGGCGGATGATAATGG\\\nTTGTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAATGTGCCGTCTCCACCAACACAGGGCTGTCCGGT\\\nCGTATAATAGGACTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGGACTCGCGATGTACATGCTCTGGT\\\nTCAATACATACGTGACCCGGCAGTTATCCTGCATCGGAACGTCAATCGTGCATCGGGCCAGCGTAATCGTGTCATCTGG\\\nGAGGCGGCCGTAGGATAAATAATTCAATAAAGATGTCGTTTTGCTAGTATACGCCTAGGCGTCACCCGCCATCTCTGTG\\\nCAGGTGGGCCGACGAGACACTGCCCCTGATTTCTCCGCTACTAATAGCACACACGGGGCAATACCAGCACAAGCCAGTC\\\nTCGCGGGAACGCTCGTCAGCATACGAAAGAGCTTGAGGCACGCCAATTCGCACTGTCGGGGTCGCTTGGGTGTTTTGCA\\\nCTACCGTCAGGTACGCTAGTATGCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGGTCAAAAGTGCGGCATTCGTATTT\\\nGCTCCCCGTGCTTGCTCTCACGAACTTGACCTGGAGATCAAGGAGATGCTTCTTGTGGAACCGGACAGCGCATCAACGC\\\nAACGGATCTACGTTACAGCGTGCATAGCGAGAACGGAGTTGCCGACGACGAAAGCGACACTGGGATCTGTCCGTCGTCA\\\nTTCGCGGAAAGCATCCGCTCACGAGGCGGACACTGATTGACACGGTTTTGCAGAAGGTTAGGGGAATAGGTCAAATTGA\\\nGTGGCTTAAAAACGCTATGTCTGGGATTAAAGTGTAGTAAACTGCGGTCAACGGAGACGGTTTTAAGACAGGAGTTCGC\\\nAAAACCAGGCGGGGTCGCCACGACGGCTATTCCTGGTGGTTTAGGCGTACAATGTCCTGAAGAATATTTAAGAAAGAAG\\\nCACCCCTCGTCGCCTAGAATTACCTACCGCGGTCGACCATACCTTCGATTGTCGCGCCCACCCTCCCATTAGTCGGCAG\\\nAGGTGGTTGTGTTGCGATAGCCCAGCATGATATCCTAAGGCGTTACGCCGATGGATATCCCACGGAATTGCCATAGGCG\\\nCTGAACGCTACACGGACGATACGAACTTATGTATGGAGCGGGTCATCGAAAGGTCATACCCTTGTAGTTAACATGTAGC\\\nCCGGCCCTATTAGTACAGCAGTGCCTTGAGCGGCATTCTCATTATTAAGTTTTCTCTACAGCCAAACGACCAAGTGCAC\\\nTTCCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCAGCTCTGTAATAGGGACTAAAAGAGTGATGATAATCATGAGTGC\\\nCGCGTTATGGTGGTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCGAGTTCCGTCCGGTTAAGCGTGAC\\\nACTCCCAGTGTACCCGCAAACCGTGATGGCTGTGCTTGGGGTCAATCGCATGTAGGATGGTCTCCAGACACCGGGGCAC\\\nCAGTTTTCACGCCCAAAGCATAAACGACGAGCAGTCATGAGAGTCTTAGAACTGGACGTGCCGTTTCTCTGCGAACAAC\\\nACCTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTCCTATCACATTTGCCTCGACGACTGCCGCCTTCG\\\nCTGTTTCCCTAGACACTCAACAGTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGTCAGTGGCTGCGCCAAAACGTCTT\\\nCGGATCCCCTTGTCCAATCAAACTGACCGAATTCTTTCATTTAAGACCCTAATATGACATCATTAGTGACTAAATGCCA\\\nCTCCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAACGAATCTAACTATTCCCTGTGCCT\\\nTATGGGGGCCTGCGCTATCTGCCTGTCGAACCATAGGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCG\\\nGGGCCTAAGACCACGAGCGTCTGGCGTCTTGGCTAACCCCCCTACATGCTGTTATAGACAATCAGTGGAAACCCGGTGC\\\nCAGGGGGTGGAGTGACCTTAAGTCAGGGACGATATTAATCGGAAGGAGTATTCAACGCAATGAAGCCGCAGGGTTGGCG\\\nTGGGAATGGTGCTTCTGTCCAAGCAGGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTGCACTTTGCAA\\\nCGATTTCGGAGTCCGGAGACTCGCTGTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTACGCCCAAGAA\\\nCGTAGCAAGGTGACTCAAACAAGGTACATCTTGCCCGCGTTTCACACGAATCAAGTTGGAGGTTATGGAGCATAGTAAC\\\nACGTGGGCGGCCAGTGGTCGGTTGCTACACCCCTGCCGCAACGTTGAAGGTCCCGGATTAGACTGGCTGGACCCATGCC\\\nGTGACACCCGTCACACTCCATTACCGTCTGCGGGTCACGGCTTGTTGTGGACTGGATTGCCATTCTCTCAGTGTATTAC\\\nGCAGGCCGGCGCGCGGGTCCCATGTAAACCTGTCATAGCTTACCTGACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCC\\\nACGCACCTGGTCGGTCCTCGTTTGCTTTTTAGGACCGGATGAACTACAGAGCGCTGCAAGAATCTCTACCTGCTTTACA\\\nAAGCGCTGGGTCCTACTCCAGCGGGATGTTTTATCTAAACACGATGAGAGGAGTATTCGTCAGGCCACATGGCTTTCTT\\\nGTCCTGGTCGGATCCATCGTTGGCGCCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTGCATGCCAGAT\\\nCGGCAGACAGATAGCGGATCCAGTATATCCCTGGAAGCTATAGACGCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTC\\\nCGAACCCAGCTCTACTTTAGTGGCCACGGGTTCTGGTCCCCCCGGGCCGCGGAACCGATTAGGGCCATGTACAACAATA\\\nCTTATTAGTCACCTTTCAGACACGATCTCCCTGCTCAGTGGTATATGGTTCCTGCTATAATTAGCCACCCTCATAAGTT\\\nGCACTACTTCTGCGACCCAAGTGCACCCTTACCACGAAGACAGGATTGTCCGATCCCATACTGCGGCCTTGGCAGGGGG\\\nTTCGCAAGTCCCACCCCAAACGATGCTGAAGGCTCAGGTTACACAGGCACAAGTGCTATATACGCGAGTTCCCGCTCTT\\\nAACCTGGACCGAATGCGGGATCATGCATCGTACCACTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGATACATAGTTC\\\nAATCAAGAATACCTTGTATTATTGTACACCTACCGGTCACCAGCCAACAATGTGCGGACGGCGTTGCGACTTGCTGGGC\\\nCTGATCTCACCGCCCTAGATACCGCACACTGGGCAATACGAGGTAAAGCCAGTCACCCAGTGTCGATCAACAGCTGACG\\\nTAACGGTAAGAGGCTCACAAAATCGCACCGCCGGCGTCCCCTGGGTATTTTACGTCAGCATCGGGTGGACTGGCATGAA\\\nTCTTTACTCCCAGGCGGAAACGGGTGCGTGGACAAGCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGGTGTCTCGTAT\\\nCCCTCTTGGAGATCGAGGAAATGTTTCACGACCAAGGGAAAGGTCGCCCTACGAAATAGATTTGCGCTACTGTCCGCAT\\\nAAGGAGTCCGGTGTAGCGAAGGATGAAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAA\\\nGCAGGCACGGAAAGACACGGTCTAGCAGACCGTCTATCGGCTAGGTCAAATAGGGTGCTTTGATATCAGCATGTCCAGC\\\nCTTAGAATTCAGTTCAGCGCGCTGGTCTGGGTCGAGATAAAATCACCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTG\\\nGCTAATCCTGGTACATCTTGTAATCAATGTTCAGAAGAAAATCTGTGTTAGAGGGACGAGTCACCACGTACCAATAGCG\\\nACAACGATCGGTCGGACTATTCATCGTGGTGGTGACGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAG\\\nGATATAATGCTGAGGCGCTGCCCCAACCGTTCAGCGTGGGGTTTGCTACAACTTCCGAGTGCTACGTGTGCGAGACCAT\\\nGTTATGTATGCACAAGGCCGACAATAGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCACAGTAGATCC\\\nTCCCCGCGCATCCTATTTATTAAGTTAATTCTATAGCAATACGATCACATGCGGATGGGCAGTGGCCGGTAGTCACACG\\\nCCTACCGCGGTGCTCAATGACCGGGACTAGAGAGGCGAAGATTATGGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGA\\\nGCGTCATTGCGAGTAGTCGATTGCTTTCCCAATCTCCGAGCGATTTAGCGTGACAGCCCCAGGGAACCCACAAAATGCG\\\nATCGCAGTCCACCCGATCGTACACAGAAAGGAGGGTCCCCATACGCCGACGCACCTGTTCGCACGTCGTATGCATAAAC\\\nGAGCCGCACGAACCAGAGAGCATAAAGAGGACCTCTAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGCCGGGATGCCT\\\nTACCTAGACGCAATGACGGACGTATTCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAA\\\nGCCGCCTTTCCAAAGTGAGTCCTTCGTCTGTGACTAACTGTGCCAGATCGTCTTGCAAACTCCCGATCCAGTTTAACTC\\\nACCAAACTATAGCCGTACAGACCCAAATCTTAAGTCATATCACGCGACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGT\\\nTTTGGTCCGCCCGAGCGGTGCAGCCGATTAGGACCATCTAATGCACTTGTTACAAGACTTCTTTTAAACACTTTCTTCC\\\nTGCCCAGTGGCGGATGATAATGGTTGTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAATGTGCCGTCT\\\nCCACCAACACAGGGCTGTCCGGTCGTATAATAGGACTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGG\\\nACTCGCGATGTACATGCTCTGGTTCAATACATACGTGACCCGGCAGTTATCCTGCATCGGAACGTCAATCGTGCATCGG\\\nGCCAGCGTAATCGTGTCATCTGGGAGGCGGCCGTAGGATAAATAATTCAATAAAGATGTCGTTTTGCTAGTATACGCCT\\\nAGGCGTCACCCGCCATCTCTGTGCAGGTGGGCCGACGAGACACTGCCCCTGATTTCTCCGCTACTAATAGCACACACGG\\\nGGCAATACCAGCACAAGCCAGTCTCGCGGGAACGCTCGTCAGCATACGAAAGAGCTTGAGGCACGCCAATTCGCACTGT\\\nCGGGGTCGCTTGGGTGTTTTGCACTACCGTCAGGTACGCTAGTATGCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGG\\\nTCAAAAGTGCGGCATTCGTATTTGCTCCCCGTGCTTGCTCTCACGAACTTGACCTGGAGATCAAGGAGATGCTTCTTGT\\\nGGAACCGGACAGCGCATCAACGCAACGGATCTACGTTACAGCGTGCATAGCGAGAACGGAGTTGCCGACGACGAAAGCG\\\nACACTGGGATCTGTCCGTCGTCATTCGCGGAAAGCATCCGCTCACGAGGCGGACACTGATTGACACGGTTTTGCAGAAG\\\nGTTAGGGGAATAGGTCAAATTGAGTGGCTTAAAAACGCTATGTCTGGGATTAAAGTGTAGTAAACTGCGGTCAACGGAG\\\nACGGTTTTAAGACAGGAGTTCGCAAAACCAGGCGGGGTCGCCACGACGGCTATTCCTGGTGGTTTAGGCGTACAATGTC\\\nCTGAAGAATATTTAAGAAAGAAGCACCCCTCGTCGCCTAGAATTACCTACCGCGGTCGACCATACCTTCGATTGTCGCG\\\nCCCACCCTCCCATTAGTCGGCAGAGGTGGTTGTGTTGCGATAGCCCAGCATGATATCCTAAGGCGTTACGCCGATGGAT\\\nATCCCACGGAATTGCCATAGGCGCTGAACGCTACACGGACGATACGAACTTATGTATGGAGCGGGTCATCGAAAGGTCA\\\nTACCCTTGTAGTTAACATGTAGCCCGGCCCTATTAGTACAGCAGTGCCTTGAGCGGCATTCTCATTATTAAGTTTTCTC\\\nTACAGCCAAACGACCAAGTGCACTTCCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCAGCTCTGTAATAGGGACTAAA\\\nAGAGTGATGATAATCATGAGTGCCGCGTTATGGTGGTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCG\\\nAGTTCCGTCCGGTTAAGCGTGACACTCCCAGTGTACCCGCAAACCGTGATGGCTGTGCTTGGGGTCAATCGCATGTAGG\\\nATGGTCTCCAGACACCGGGGCACCAGTTTTCACGCCCAAAGCATAAACGACGAGCAGTCATGAGAGTCTTAGAACTGGA\\\nCGTGCCGTTTCTCTGCGAACAACACCTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTCCTATCACATT\\\nTGCCTCGACGACTGCCGCCTTCGCTGTTTCCCTAGACACTCAACAGTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGT\\\nCAGTGGCTGCGCCAAAACGTCTTCGGATCCCCTTGTCCAATCAAACTGACCGAATTCTTTCATTTAAGACCCTAATATG\\\nACATCATTAGTGACTAAATGCCACTCCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAAC\\\nGA\";\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","benches","interval_tree.rs"],"content":"#![feature(test)]\n\nextern crate test;\n\nuse test::Bencher;\n\nuse bio::data_structures::interval_tree::*;\nuse bio::utils::Interval;\nuse std::cmp::{max, min};\nuse std::ops::Range;\n\n#[bench]\nfn bench_interval_few_large_queries(b: \u0026mut Bencher) {\n    // insert 100_000 intervals of size 10\n    // do 1000 queries, each resulting in 1000 matches\n    b.iter(|| test_insert_query(10, \u0026(100_000..200_000), 1000, 105_000..106_000));\n}\n\n#[bench]\nfn bench_interval_many_small_queries(b: \u0026mut Bencher) {\n    // insert 100_000 intervals of size 10\n    // do 100_000 queries, each resulting in at most 10 matches\n    b.iter(|| test_insert_query(10, \u0026(100_000..200_000), 10, 99_995..199_995));\n}\n\nfn test_insert_query(\n    insert_size: i64,\n    insert_bounds: \u0026Range\u003ci64\u003e,\n    query_size: i64,\n    query_bounds: Range\u003ci64\u003e,\n) {\n    let mut tree: IntervalTree\u003ci64, Range\u003ci64\u003e\u003e = IntervalTree::new();\n\n    for i in insert_bounds.clone() {\n        tree.insert(i..i + insert_size, i..i + insert_size);\n    }\n    for i in query_bounds {\n        let lower_bound = i;\n        let upper_bound = i + query_size;\n        let smallest_start = max(lower_bound - insert_size + 1, insert_bounds.start);\n        let largest_start = min(upper_bound, insert_bounds.end);\n        let mut expected_intersections = vec![];\n        for j in smallest_start..largest_start {\n            expected_intersections.push(j..j + insert_size);\n        }\n        assert_intersections(\u0026tree, lower_bound..upper_bound, \u0026expected_intersections);\n    }\n}\n\nfn assert_intersections(\n    tree: \u0026IntervalTree\u003ci64, Range\u003ci64\u003e\u003e,\n    target: Range\u003ci64\u003e,\n    expected_results: \u0026[Range\u003ci64\u003e],\n) {\n    let mut actual_entries: Vec\u003c_\u003e = tree.find(target).collect();\n    actual_entries.sort_by(|x1, x2| x1.data().start.cmp(\u0026x2.data().start));\n    let mut expected_entries: Vec\u003c_\u003e = expected_results\n        .iter()\n        .map(|x| (x.clone(), Interval::from(x.clone())))\n        .collect();\n    expected_entries.sort_by(|x1, x2| x1.0.start.cmp(\u0026x2.0.start));\n    assert_eq!(actual_entries.len(), expected_entries.len());\n    for (actual, expected) in actual_entries.iter().zip(expected_entries.iter()) {\n        assert_eq!(actual.interval(), \u0026expected.1);\n        assert_eq!(actual.data(), \u0026expected.0);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","benches","orf.rs"],"content":"#![feature(test)]\n\nextern crate test;\n\nuse test::Bencher;\n\nuse bio::seq_analysis::gc::*;\nuse bio::seq_analysis::orf::Finder;\n\n// 5,000 random nucleotides, GC content = .55\nstatic STR_1: \u0026'static [u8] = b\"ATCTAACTATTCCCTGTGCCTTATGGGGGCCTGCGCTATCTGCCTGT\\\nCGAACCATAGGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCGGGGCCTAAGACCACGAGCGTCTGGCG\\\nTCTTGGCTAACCCCCCTACATGCTGTTATAGACAATCAGTGGAAACCCGGTGCCAGGGGGTGGAGTGACCTTAAGTCAG\\\nGGACGATATTAATCGGAAGGAGTATTCAACGCAATGAAGCCGCAGGGTTGGCGTGGGAATGGTGCTTCTGTCCAAGCAG\\\nGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTGCACTTTGCAACGATTTCGGAGTCCGGAGACTCGCTG\\\nTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTACGCCCAAGAACGTAGCAAGGTGACTCAAACAAGGTA\\\nCATCTTGCCCGCGTTTCACACGAATCAAGTTGGAGGTTATGGAGCATAGTAACACGTGGGCGGCCAGTGGTCGGTTGCT\\\nACACCCCTGCCGCAACGTTGAAGGTCCCGGATTAGACTGGCTGGACCCATGCCGTGACACCCGTCACACTCCATTACCG\\\nTCTGCGGGTCACGGCTTGTTGTGGACTGGATTGCCATTCTCTCAGTGTATTACGCAGGCCGGCGCGCGGGTCCCATGTA\\\nAACCTGTCATAGCTTACCTGACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCCACGCACCTGGTCGGTCCTCGTTTGCT\\\nTTTTAGGACCGGATGAACTACAGAGCGCTGCAAGAATCTCTACCTGCTTTACAAAGCGCTGGGTCCTACTCCAGCGGGA\\\nTGTTTTATCTAAACACGATGAGAGGAGTATTCGTCAGGCCACATGGCTTTCTTGTCCTGGTCGGATCCATCGTTGGCGC\\\nCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTGCATGCCAGATCGGCAGACAGATAGCGGATCCAGTAT\\\nATCCCTGGAAGCTATAGACGCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTCCGAACCCAGCTCTACTTTAGTGGCCA\\\nCGGGTTCTGGTCCCCCCGGGCCGCGGAACCGATTAGGGCCATGTACAACAATACTTATTAGTCACCTTTCAGACACGAT\\\nCTCCCTGCTCAGTGGTATATGGTTCCTGCTATAATTAGCCACCCTCATAAGTTGCACTACTTCTGCGACCCAAGTGCAC\\\nCCTTACCACGAAGACAGGATTGTCCGATCCCATACTGCGGCCTTGGCAGGGGGTTCGCAAGTCCCACCCCAAACGATGC\\\nTGAAGGCTCAGGTTACACAGGCACAAGTGCTATATACGCGAGTTCCCGCTCTTAACCTGGACCGAATGCGGGATCATGC\\\nATCGTACCACTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGATACATAGTTCAATCAAGAATACCTTGTATTATTGTA\\\nCACCTACCGGTCACCAGCCAACAATGTGCGGACGGCGTTGCGACTTGCTGGGCCTGATCTCACCGCCCTAGATACCGCA\\\nCACTGGGCAATACGAGGTAAAGCCAGTCACCCAGTGTCGATCAACAGCTGACGTAACGGTAAGAGGCTCACAAAATCGC\\\nACCGCCGGCGTCCCCTGGGTATTTTACGTCAGCATCGGGTGGACTGGCATGAATCTTTACTCCCAGGCGGAAACGGGTG\\\nCGTGGACAAGCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGGTGTCTCGTATCCCTCTTGGAGATCGAGGAAATGTTT\\\nCACGACCAAGGGAAAGGTCGCCCTACGAAATAGATTTGCGCTACTGTCCGCATAAGGAGTCCGGTGTAGCGAAGGATGA\\\nAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAAGCAGGCACGGAAAGACACGGTCTAGC\\\nAGACCGTCTATCGGCTAGGTCAAATAGGGTGCTTTGATATCAGCATGTCCAGCCTTAGAATTCAGTTCAGCGCGCTGGT\\\nCTGGGTCGAGATAAAATCACCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTGGCTAATCCTGGTACATCTTGTAATCA\\\nATGTTCAGAAGAAAATCTGTGTTAGAGGGACGAGTCACCACGTACCAATAGCGACAACGATCGGTCGGACTATTCATCG\\\nTGGTGGTGACGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAGGATATAATGCTGAGGCGCTGCCCCAA\\\nCCGTTCAGCGTGGGGTTTGCTACAACTTCCGAGTGCTACGTGTGCGAGACCATGTTATGTATGCACAAGGCCGACAATA\\\nGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCACAGTAGATCCTCCCCGCGCATCCTATTTATTAAGTT\\\nAATTCTATAGCAATACGATCACATGCGGATGGGCAGTGGCCGGTAGTCACACGCCTACCGCGGTGCTCAATGACCGGGA\\\nCTAGAGAGGCGAAGATTATGGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGAGCGTCATTGCGAGTAGTCGATTGCTT\\\nTCCCAATCTCCGAGCGATTTAGCGTGACAGCCCCAGGGAACCCACAAAATGCGATCGCAGTCCACCCGATCGTACACAG\\\nAAAGGAGGGTCCCCATACGCCGACGCACCTGTTCGCACGTCGTATGCATAAACGAGCCGCACGAACCAGAGAGCATAAA\\\nGAGGACCTCTAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGCCGGGATGCCTTACCTAGACGCAATGACGGACGTATT\\\nCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAAGCCGCCTTTCCAAAGTGAGTCCTTCG\\\nTCTGTGACTAACTGTGCCAGATCGTCTTGCAAACTCCCGATCCAGTTTAACTCACCAAACTATAGCCGTACAGACCCAA\\\nATCTTAAGTCATATCACGCGACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGTTTTGGTCCGCCCGAGCGGTGCAGCCG\\\nATTAGGACCATCTAATGCACTTGTTACAAGACTTCTTTTAAACACTTTCTTCCTGCCCAGTGGCGGATGATAATGGTTG\\\nTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAATGTGCCGTCTCCACCAACACAGGGCTGTCCGGTCGT\\\nATAATAGGACTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGGACTCGCGATGTACATGCTCTGGTTCA\\\nATACATACGTGACCCGGCAGTTATCCTGCATCGGAACGTCAATCGTGCATCGGGCCAGCGTAATCGTGTCATCTGGGAG\\\nGCGGCCGTAGGATAAATAATTCAATAAAGATGTCGTTTTGCTAGTATACGCCTAGGCGTCACCCGCCATCTCTGTGCAG\\\nGTGGGCCGACGAGACACTGCCCCTGATTTCTCCGCTACTAATAGCACACACGGGGCAATACCAGCACAAGCCAGTCTCG\\\nCGGGAACGCTCGTCAGCATACGAAAGAGCTTGAGGCACGCCAATTCGCACTGTCGGGGTCGCTTGGGTGTTTTGCACTA\\\nCCGTCAGGTACGCTAGTATGCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGGTCAAAAGTGCGGCATTCGTATTTGCT\\\nCCCCGTGCTTGCTCTCACGAACTTGACCTGGAGATCAAGGAGATGCTTCTTGTGGAACCGGACAGCGCATCAACGCAAC\\\nGGATCTACGTTACAGCGTGCATAGCGAGAACGGAGTTGCCGACGACGAAAGCGACACTGGGATCTGTCCGTCGTCATTC\\\nGCGGAAAGCATCCGCTCACGAGGCGGACACTGATTGACACGGTTTTGCAGAAGGTTAGGGGAATAGGTCAAATTGAGTG\\\nGCTTAAAAACGCTATGTCTGGGATTAAAGTGTAGTAAACTGCGGTCAACGGAGACGGTTTTAAGACAGGAGTTCGCAAA\\\nACCAGGCGGGGTCGCCACGACGGCTATTCCTGGTGGTTTAGGCGTACAATGTCCTGAAGAATATTTAAGAAAGAAGCAC\\\nCCCTCGTCGCCTAGAATTACCTACCGCGGTCGACCATACCTTCGATTGTCGCGCCCACCCTCCCATTAGTCGGCAGAGG\\\nTGGTTGTGTTGCGATAGCCCAGCATGATATCCTAAGGCGTTACGCCGATGGATATCCCACGGAATTGCCATAGGCGCTG\\\nAACGCTACACGGACGATACGAACTTATGTATGGAGCGGGTCATCGAAAGGTCATACCCTTGTAGTTAACATGTAGCCCG\\\nGCCCTATTAGTACAGCAGTGCCTTGAGCGGCATTCTCATTATTAAGTTTTCTCTACAGCCAAACGACCAAGTGCACTTC\\\nCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCAGCTCTGTAATAGGGACTAAAAGAGTGATGATAATCATGAGTGCCGC\\\nGTTATGGTGGTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCGAGTTCCGTCCGGTTAAGCGTGACACT\\\nCCCAGTGTACCCGCAAACCGTGATGGCTGTGCTTGGGGTCAATCGCATGTAGGATGGTCTCCAGACACCGGGGCACCAG\\\nTTTTCACGCCCAAAGCATAAACGACGAGCAGTCATGAGAGTCTTAGAACTGGACGTGCCGTTTCTCTGCGAACAACACC\\\nTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTCCTATCACATTTGCCTCGACGACTGCCGCCTTCGCTG\\\nTTTCCCTAGACACTCAACAGTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGTCAGTGGCTGCGCCAAAACGTCTTCGG\\\nATCCCCTTGTCCAATCAAACTGACCGAATTCTTTCATTTAAGACCCTAATATGACATCATTAGTGACTAAATGCCACTC\\\nCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAACGA\";\n\n#[bench]\nfn bench_orf(b: \u0026mut Bencher) {\n    let start_codons = vec![b\"ATG\"];\n    let stop_codons = vec![b\"TGA\", b\"TAG\", b\"TAA\"];\n    let finder = Finder::new(start_codons, stop_codons, 100usize);\n    b.iter(|| finder.find_all(STR_1).count());\n}\n\n#[bench]\nfn bench_gc(b: \u0026mut Bencher) {\n    b.iter(|| gc_content(STR_1));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","benches","pairhmm.rs"],"content":"#![feature(test)]\n\nextern crate test;\n\nuse bio::stats::pairhmm::*;\nuse bio::stats::{LogProb, Prob};\nuse test::Bencher;\n\nstatic TEXT: \u0026'static [u8] = b\"GATCACAGGTCTATCACCCTATTAACCACTCACGGGAGCTCTCCATGC\\\nATTTGGTATTTTCGTCTGGGGGGTATGCACGCGATAGCATTGCGAGACGCTGGAGCCGGAGCACCCTATGTCGCAGTAT\\\nCTGTCTTTGATTCCTGCCTCATCCTATTATTTATCGCACCTACGTTCAATATTACAGGCGAACATACTTACTAAAGTGT\";\n\nstatic PATTERN: \u0026'static [u8] = b\"GGGTATGCACGCGATAGCATTGCGAGACGCTGGAGCCGGAGCACCCTATGTCGC\";\n\n// Single base insertion and deletion rates for R1 according to Schirmer et al.\n// BMC Bioinformatics 2016, 10.1186/s12859-016-0976-y\nstatic PROB_ILLUMINA_INS: Prob = Prob(2.8e-6);\nstatic PROB_ILLUMINA_DEL: Prob = Prob(5.1e-6);\nstatic PROB_ILLUMINA_SUBST: Prob = Prob(0.0021);\n\nfn prob_emit_x_or_y() -\u003e LogProb {\n    LogProb::from(Prob(1.0) - PROB_ILLUMINA_SUBST)\n}\n\npub struct TestEmissionParams {\n    x: \u0026'static [u8],\n    y: \u0026'static [u8],\n}\n\nimpl EmissionParameters for TestEmissionParams {\n    fn prob_emit_xy(\u0026self, i: usize, j: usize) -\u003e XYEmission {\n        if self.x[i] == self.y[j] {\n            XYEmission::Match(LogProb::from(Prob(1.0) - PROB_ILLUMINA_SUBST))\n        } else {\n            XYEmission::Mismatch(LogProb::from(PROB_ILLUMINA_SUBST / Prob(3.0)))\n        }\n    }\n\n    fn prob_emit_x(\u0026self, _: usize) -\u003e LogProb {\n        prob_emit_x_or_y()\n    }\n\n    fn prob_emit_y(\u0026self, _: usize) -\u003e LogProb {\n        prob_emit_x_or_y()\n    }\n\n    fn len_x(\u0026self) -\u003e usize {\n        self.x.len()\n    }\n\n    fn len_y(\u0026self) -\u003e usize {\n        self.y.len()\n    }\n}\n\npub struct SemiglobalGapParams;\n\nimpl GapParameters for SemiglobalGapParams {\n    fn prob_gap_x(\u0026self) -\u003e LogProb {\n        LogProb::from(PROB_ILLUMINA_INS)\n    }\n\n    fn prob_gap_y(\u0026self) -\u003e LogProb {\n        LogProb::from(PROB_ILLUMINA_DEL)\n    }\n\n    fn prob_gap_x_extend(\u0026self) -\u003e LogProb {\n        LogProb::ln_zero()\n    }\n\n    fn prob_gap_y_extend(\u0026self) -\u003e LogProb {\n        LogProb::ln_zero()\n    }\n}\n\npub struct SemiglobalAlignment;\n\nimpl StartEndGapParameters for SemiglobalAlignment {\n    fn free_start_gap_x(\u0026self) -\u003e bool {\n        true\n    }\n\n    fn free_end_gap_x(\u0026self) -\u003e bool {\n        true\n    }\n}\n\n#[bench]\nfn pairhmm_semiglobal(b: \u0026mut Bencher) {\n    let emission_params = TestEmissionParams {\n        x: TEXT,\n        y: PATTERN,\n    };\n    let gap_params = SemiglobalGapParams;\n\n    let mut pair_hmm = PairHMM::new(\u0026gap_params);\n    pair_hmm.prob_related(\u0026emission_params, \u0026SemiglobalAlignment, Some(4));\n\n    b.iter(|| {\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026SemiglobalAlignment, Some(4));\n        assert!(*p \u003c= 0.0);\n    });\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","home","todd","rust-bio","benches","pairwise.rs"],"content":"#![feature(test)]\n\nextern crate test;\n\nuse bio::alignment::pairwise::*;\nuse test::Bencher;\n\n// 5,000 random nucleotides, GC content = .55\nstatic STR_1: \u0026'static [u8] = b\"ATCTAACTATTCCCTGTGCCTTATGGGGGCCTGCGCTATCTGCCTGT\\\nCGAACCATAGGACTCGCGCCAGCGCGCAGGCTTGGATCGAGGTGAAATCTCCGGGGCCTAAGACCACGAGCGTCTGGCG\\\nTCTTGGCTAACCCCCCTACATGCTGTTATAGACAATCAGTGGAAACCCGGTGCCAGGGGGTGGAGTGACCTTAAGTCAG\\\nGGACGATATTAATCGGAAGGAGTATTCAACGCAATGAAGCCGCAGGGTTGGCGTGGGAATGGTGCTTCTGTCCAAGCAG\\\nGTAAGGGCATGAGGCCGCAACCGTCCCCCAAGCGTACAGGGTGCACTTTGCAACGATTTCGGAGTCCGGAGACTCGCTG\\\nTTTTCGAAATTTGCGCTCAAGGGCGGGTATTGAACCAGGCTTACGCCCAAGAACGTAGCAAGGTGACTCAAACAAGGTA\\\nCATCTTGCCCGCGTTTCACACGAATCAAGTTGGAGGTTATGGAGCATAGTAACACGTGGGCGGCCAGTGGTCGGTTGCT\\\nACACCCCTGCCGCAACGTTGAAGGTCCCGGATTAGACTGGCTGGACCCATGCCGTGACACCCGTCACACTCCATTACCG\\\nTCTGCGGGTCACGGCTTGTTGTGGACTGGATTGCCATTCTCTCAGTGTATTACGCAGGCCGGCGCGCGGGTCCCATGTA\\\nAACCTGTCATAGCTTACCTGACTCTACTTGGAAGTGTGGCTAGGCCTTTGCCCACGCACCTGGTCGGTCCTCGTTTGCT\\\nTTTTAGGACCGGATGAACTACAGAGCGCTGCAAGAATCTCTACCTGCTTTACAAAGCGCTGGGTCCTACTCCAGCGGGA\\\nTGTTTTATCTAAACACGATGAGAGGAGTATTCGTCAGGCCACATGGCTTTCTTGTCCTGGTCGGATCCATCGTTGGCGC\\\nCCGACCCCCCCACTCCGTAGTGAGTTCTTCGTCCGAGCCATTGCATGCCAGATCGGCAGACAGATAGCGGATCCAGTAT\\\nATCCCTGGAAGCTATAGACGCACAGGTTGGAATCCTAAGCGAAGTCGCGCGTCCGAACCCAGCTCTACTTTAGTGGCCA\\\nCGGGTTCTGGTCCCCCCGGGCCGCGGAACCGATTAGGGCCATGTACAACAATACTTATTAGTCACCTTTCAGACACGAT\\\nCTCCCTGCTCAGTGGTATATGGTTCCTGCTATAATTAGCCACCCTCATAAGTTGCACTACTTCTGCGACCCAAGTGCAC\\\nCCTTACCACGAAGACAGGATTGTCCGATCCCATACTGCGGCCTTGGCAGGGGGTTCGCAAGTCCCACCCCAAACGATGC\\\nTGAAGGCTCAGGTTACACAGGCACAAGTGCTATATACGCGAGTTCCCGCTCTTAACCTGGACCGAATGCGGGATCATGC\\\nATCGTACCACTGTGTTCGTGTCATCTAGGACGGGCGCAAAGGATACATAGTTCAATCAAGAATACCTTGTATTATTGTA\\\nCACCTACCGGTCACCAGCCAACAATGTGCGGACGGCGTTGCGACTTGCTGGGCCTGATCTCACCGCCCTAGATACCGCA\\\nCACTGGGCAATACGAGGTAAAGCCAGTCACCCAGTGTCGATCAACAGCTGACGTAACGGTAAGAGGCTCACAAAATCGC\\\nACCGCCGGCGTCCCCTGGGTATTTTACGTCAGCATCGGGTGGACTGGCATGAATCTTTACTCCCAGGCGGAAACGGGTG\\\nCGTGGACAAGCGAGCAGCAAACGAAAATTCCTGGCCTGCTTGGTGTCTCGTATCCCTCTTGGAGATCGAGGAAATGTTT\\\nCACGACCAAGGGAAAGGTCGCCCTACGAAATAGATTTGCGCTACTGTCCGCATAAGGAGTCCGGTGTAGCGAAGGATGA\\\nAGGCGACCCTAGGTAGCAACCGCCGGCTTCGGCGGTAAGGTATCACTCAGGAAGCAGGCACGGAAAGACACGGTCTAGC\\\nAGACCGTCTATCGGCTAGGTCAAATAGGGTGCTTTGATATCAGCATGTCCAGCCTTAGAATTCAGTTCAGCGCGCTGGT\\\nCTGGGTCGAGATAAAATCACCAGTACCCAAGACCAGGCGGGCTCGCCGCGTTGGCTAATCCTGGTACATCTTGTAATCA\\\nATGTTCAGAAGAAAATCTGTGTTAGAGGGACGAGTCACCACGTACCAATAGCGACAACGATCGGTCGGACTATTCATCG\\\nTGGTGGTGACGCTCGGATTACGCGGGAAAGGTGCTTGTGTCCCGACAGGCTAGGATATAATGCTGAGGCGCTGCCCCAA\\\nCCGTTCAGCGTGGGGTTTGCTACAACTTCCGAGTGCTACGTGTGCGAGACCATGTTATGTATGCACAAGGCCGACAATA\\\nGGACGTAGCCTTCGAGTTAGTACGTAGCGTGGTCGCACAAGCACAGTAGATCCTCCCCGCGCATCCTATTTATTAAGTT\\\nAATTCTATAGCAATACGATCACATGCGGATGGGCAGTGGCCGGTAGTCACACGCCTACCGCGGTGCTCAATGACCGGGA\\\nCTAGAGAGGCGAAGATTATGGCGTGTGACCCGTTATGCTCGAGTTCGGTCAGAGCGTCATTGCGAGTAGTCGATTGCTT\\\nTCCCAATCTCCGAGCGATTTAGCGTGACAGCCCCAGGGAACCCACAAAATGCGATCGCAGTCCACCCGATCGTACACAG\\\nAAAGGAGGGTCCCCATACGCCGACGCACCTGTTCGCACGTCGTATGCATAAACGAGCCGCACGAACCAGAGAGCATAAA\\\nGAGGACCTCTAGCTCCTTTACAAAGTACAGGTTCGCCTGCCGCCGGGATGCCTTACCTAGACGCAATGACGGACGTATT\\\nCCTCTGGCCTCAACGGTTCCTGCTTCCGCTGGGATCCAAGATTGGCGGCCGAAGCCGCCTTTCCAAAGTGAGTCCTTCG\\\nTCTGTGACTAACTGTGCCAGATCGTCTTGCAAACTCCCGATCCAGTTTAACTCACCAAACTATAGCCGTACAGACCCAA\\\nATCTTAAGTCATATCACGCGACTAGCCTCTGCTCAATTTCTGTGCTCAAGGGTTTTGGTCCGCCCGAGCGGTGCAGCCG\\\nATTAGGACCATCTAATGCACTTGTTACAAGACTTCTTTTAAACACTTTCTTCCTGCCCAGTGGCGGATGATAATGGTTG\\\nTTGCCAGCCGGCGTGGAAGGTAACAGCACCGGTGCGAGCCTAATGTGCCGTCTCCACCAACACAGGGCTGTCCGGTCGT\\\nATAATAGGACTCCGCAATGGGGTTAGCAAGTGGCAGCCTAAACGATGTCGGGGACTCGCGATGTACATGCTCTGGTTCA\\\nATACATACGTGACCCGGCAGTTATCCTGCATCGGAACGTCAATCGTGCATCGGGCCAGCGTAATCGTGTCATCTGGGAG\\\nGCGGCCGTAGGATAAATAATTCAATAAAGATGTCGTTTTGCTAGTATACGCCTAGGCGTCACCCGCCATCTCTGTGCAG\\\nGTGGGCCGACGAGACACTGCCCCTGATTTCTCCGCTACTAATAGCACACACGGGGCAATACCAGCACAAGCCAGTCTCG\\\nCGGGAACGCTCGTCAGCATACGAAAGAGCTTGAGGCACGCCAATTCGCACTGTCGGGGTCGCTTGGGTGTTTTGCACTA\\\nCCGTCAGGTACGCTAGTATGCGTCCTTCCTTCCAGGGGTATGTGGCTGCGTGGTCAAAAGTGCGGCATTCGTATTTGCT\\\nCCCCGTGCTTGCTCTCACGAACTTGACCTGGAGATCAAGGAGATGCTTCTTGTGGAACCGGACAGCGCATCAACGCAAC\\\nGGATCTACGTTACAGCGTGCATAGCGAGAACGGAGTTGCCGACGACGAAAGCGACACTGGGATCTGTCCGTCGTCATTC\\\nGCGGAAAGCATCCGCTCACGAGGCGGACACTGATTGACACGGTTTTGCAGAAGGTTAGGGGAATAGGTCAAATTGAGTG\\\nGCTTAAAAACGCTATGTCTGGGATTAAAGTGTAGTAAACTGCGGTCAACGGAGACGGTTTTAAGACAGGAGTTCGCAAA\\\nACCAGGCGGGGTCGCCACGACGGCTATTCCTGGTGGTTTAGGCGTACAATGTCCTGAAGAATATTTAAGAAAGAAGCAC\\\nCCCTCGTCGCCTAGAATTACCTACCGCGGTCGACCATACCTTCGATTGTCGCGCCCACCCTCCCATTAGTCGGCAGAGG\\\nTGGTTGTGTTGCGATAGCCCAGCATGATATCCTAAGGCGTTACGCCGATGGATATCCCACGGAATTGCCATAGGCGCTG\\\nAACGCTACACGGACGATACGAACTTATGTATGGAGCGGGTCATCGAAAGGTCATACCCTTGTAGTTAACATGTAGCCCG\\\nGCCCTATTAGTACAGCAGTGCCTTGAGCGGCATTCTCATTATTAAGTTTTCTCTACAGCCAAACGACCAAGTGCACTTC\\\nCGCGGAGCGCGGTGGAGACTCGTCCACCCGGCAGCTCTGTAATAGGGACTAAAAGAGTGATGATAATCATGAGTGCCGC\\\nGTTATGGTGGTGTCGGAACAGAGCGGTCTTACGGCCAGTCGTATCCCTTCTCGAGTTCCGTCCGGTTAAGCGTGACACT\\\nCCCAGTGTACCCGCAAACCGTGATGGCTGTGCTTGGGGTCAATCGCATGTAGGATGGTCTCCAGACACCGGGGCACCAG\\\nTTTTCACGCCCAAAGCATAAACGACGAGCAGTCATGAGAGTCTTAGAACTGGACGTGCCGTTTCTCTGCGAACAACACC\\\nTCGAGCTGTACCGTTGTTGCGCTGCCTAGATGCAGTGCCGCTCCTATCACATTTGCCTCGACGACTGCCGCCTTCGCTG\\\nTTTCCCTAGACACTCAACAGTAAGCGCCTTTTGTAGGCAGGGGCACCCCCTGTCAGTGGCTGCGCCAAAACGTCTTCGG\\\nATCCCCTTGTCCAATCAAACTGACCGAATTCTTTCATTTAAGACCCTAATATGACATCATTAGTGACTAAATGCCACTC\\\nCCAAAATTCTGCCCAGAAGCGTTTAAGTTCGCCCCACTAAAGTTGTCTAAAACGA\";\n\n// 5,000 random nucleotides, GC content = .45\nstatic STR_2: \u0026'static [u8] = b\"CTAAAGTGGCGAAATTTATGGTGTGTGACCCGTTATGCTCCATTTCG\\\nGTCAGTGGGTCATTGCTAGTAGTCGATTGCATTGTCATTCTCCGAGTGATTTAGCGTGACAGCCGCAGGGAACCCATAA\\\nAATGTAATCGTAGTCCATCTGATCGTACTTAGAAATGAAGGTCCCCTTTTACCCACGCACCTGTTTACTCGTCGTTTGC\\\nTTTTAAGAACCGCACGAACCACAGAGCATAAAGAGAACCTCTAGTTCCTTTACAAAGTACTGGTTCCCTTTTCAGCAAG\\\nATGCCTTATCTAAATGCAATGACAGACGTATTCCTCAGGCCACATCGCTTCCTACTTTCGCTGGGATCCATCATTGGCA\\\nGCTGAAACCGCCATTCCATAGTGAGTCCTTCGTCTGTGTCTTTCTGTGCCAAATCGTCTAGCAAATTGCTGATCCAGTT\\\nTATCTCACGAAATTATAGTCATACAGACCGAAATTTTAAATCAAATCACGCGACTAGGCTCAGCTTTATTTTAGTGGTC\\\nATGGGTTTTGGTCCGCCCGAGCGGTGCAACCGATTAGGACCATGTAAAACATTTGTTACAAGTCTTCTTTTAAATACAA\\\nTCTTCCTGCTCAGTAGCGCATGATTATCGTTGTTGCTAGCCAGTGTGGTAAGTAACAGCACCACTGCGAGCCTAATGTG\\\nCCCTTTCCACGAACACAAGGCTATCCGATCCTATATTAGGATTCCGCAATGGGGTTAGCAAATCGCACCCTAAACGATA\\\nTTGAAGACTTGCGATGTACATGCTTTGGTACAATACATACGTGTTCCAGTTGTTATCCTGTATCGGAACTTCAATTATG\\\nCATCGCACCAGCATATTCATGTCATCTAGGAAGAGCGCGTAGGATAAATAATTCAATTAAGATGTCGTTATGCTAGTAT\\\nACGTCTACCCGTCACCGGCCATCTGTGTGCAGATGGGGCGACGAGTTATTGACCCTGATTTCTCCACTTCTAATACCAC\\\nACACTGGGCAATACGAGCTCAAGCTAGTCTCGCAGTAACGCTCATCAGCTAACGAAAGAGTTAAAGGCTCGCTAATTCG\\\nCACTGTCAGGGTCTCTTGGGTGTTTTGCACTAGCGTCAGGTAGGCTAGTATGTGTTTTTCCTTCCAGAGGTATGTGGCT\\\nGCGTGGTCAAATGTGCAGCATACGTATTTGCTCGACGTGTTTAGTCTCTCATACTTCTCCTGGAGATCAAGGAAATGTT\\\nTCTTGTCCAAGTGGACAACGGTTCTACGGAATGGATCTACGTTACTGCCTGCATAAAGAAAACGGAGTTGCTAAGGACG\\\nAAAGCGACTTTAGGTTCTAACTGTTGACTTTGGCGGAAAAGTTTCATTCAGGAAGCAGACACTGATTGACACGGTTTAG\\\nCAGAACGTTTGAGGATTAGGTTAAATTGAGTGGTTTAATATTGGTATGTCTGGGATTAAAATATAGTATAGTGTGTTAA\\\nTCGGAGACGAATTAAAGACACGAGTTCCCAAAATCAAGCGGGCTCATTACAACGGTTAATCCTGGTAGTTTACGTGAAC\\\nAATGTTCTGAAGAAAATTTATGAAAAAAGGACCCGTCATCGCCTACAATTACCTACAACGGTCGACCATACCTTCGATT\\\nATCGTGGCCACTCTCGGATTACACGGCAGAGGTGGTTGTGTTCCGATAGGCCAGTATATTATTCTAAGGCGTTACCCTA\\\nATCATTTTTCATCGGATTTGCTATAGCCCTTGAACGCTACATGCACGAAACCAAATTATGTATACACTGGGTCATCAAT\\\nAGGATATAGTCTTGTAGTTAACATGTAGCCCGGCCGTATTAGTACAGTAGAGCCTTCATTGACATTCTGTTTATTAAAT\\\nTATTTCTACAGCAAAACGATCATATGCAAATCCACAGTGCGCGATAGAGATACATTCACTCGGCTGCTCTGTAATAGGG\\\nACTAAAAAAGTGATGATTATCATGAGTGCCCCGTTATGGTCGTGTTCGATCAGAGCGCTCTTACGAGCAGTCGTATACT\\\nTTCTCGAATTCCGTGCAGTTAAGCGTGACAGTCCCAGTGAACCCACAAAACGTGATGGCAGTCCATGCAATCATACGCA\\\nAGAAGGATGGTCTCCAGACACCGGCGCACCAGTTTTCACGCCGAAAGCATAAACGAGGAGCACAAATGAAAGTGTTTGA\\\nACTGGACCTGTAGTTTCTCTACGAAAAATACCTTGAGCTGTTGCGTTGTTGCGCTGCCTAGATGCAGTGTTGCACATAT\\\nCACTTTTGCTTCAACGACTGCTGCTTTCGCTGTAACCCTAGACAGACAACAATAAGCGCTTTTTGTAGGCAAGAGCTCC\\\nGCCTATGACTAACTGCGCCAAAACATCTTCCAATCCCCTTATCCAATTTAATTCATCGAATTCTTACAATTTAGACCCT\\\nAATATCACATCATTAGACATTAATTGCCTCTGCCAAAATTCTGTCTACAAATGTTTTAGTTCGCTCCAGTAAAGTTGTT\\\nAATAACGACTACTAAATCCGCATGTTACGGGATTTCTTATTAATTCTTTTTTCGTAAGGAACAGCGGATCTTAATGGAT\\\nGGCGCCAGGTGGTATGGAAGCTAATAGCGCGGGTGAGAGGGTAATTAGCCGTCTTCACCAACACAACGCTATCGGGTCA\\\nTACTATAAGATTCCACAATGCGACTACTTATAAGATGTCTTAACGGTATCCGCAACTTGTGATGTGCCTACTATGCTTA\\\nAATGCATATCTCGCTCAGTAACTTTCCAATATGAGAGCATCAATTGTAGATCGGGCCGAGATAATCATGTCGTCACGGA\\\nACTTATTGTAAGAGTAATAATTTAAAAGAGATGTCAGTTTGCTGGTTCACGTAAAGGTTCCTCACACTACCTCTAAATA\\\nAGTGAGCGGTCGTGACATTATCCCTGATTTTCTCACTACTATTAGTACTCACGACACAATTCTACCACAGCCTTGTTTC\\\nGCCAGAATGCCAGTCAGCATAAAGAAGAGCTCAAGGCAGGTCAACTCGCATTGTGAGAGTTACATGAACGTTCGGCACT\\\nACCGACACGAACCTCAGTTAGCGTACATCCTACCAGAGGTCTGTGGCCCCGTGGTCAAAAGTGCGGATTTCGTATTTGC\\\nTGCTCGTCAGTACTTTCAGAATCATGACCTGCACGGTAAAAAGACGCTTATTATGGAGTTCGACATGGCAATAACGCGA\\\nCGAATCTACGTCATGACGAGAATAGTATAAACAAAACTGCTGACGGCAGAAGCGTCAAAGAAGTCTGTAAATTGTTATT\\\nCGCGAAAAACATCCGTCTCCGTGGGGGATAATCACCGACGCCATTTTATAGAAGCCTAGGGGAACAGATTGGTTTAATT\\\nAGCTTAAGAAAGTAAATTCTGGGATTATACTGTAGTAATCACTAATTTACGGTGAGGGTTTTATGGCGGATTTTTACAA\\\nATTCAAACCAGGTGATTTCAACAAATTTTGTTGACGATTTAGGCGCACTATCCCCTAAACTACAAATTAAAAAATAGCG\\\nTTCCTTGACGGCTAGAATTACTTACCGGCCTTCACCATACCTTCGATATTCGCGCCCACTCTCCCATTAATCCGTACAA\\\nGTGGATGTAATGCGATTGTCCGCTAAGATATTCTAACGTGTAACGTAGATAAGTATTTTACAGAGTTGCCGTACGCGTT\\\nGAACACTTCACAGATGATAGGAATTTGCGTATAGAGCGTGTTATTGAGGAGTTATACACCCGTAGACTACAATGGGCCC\\\nAACTCAATCAGAACTCGAGTGCCTTGAATAACATACTCATCACTAAACATTCTCAACAATCAATCGAGCAAGTCCATTA\\\nTCAACGAGTGTGTTGCAGTTTTATTCTCTTGCCAGCATTGTAATAGGCACTAAAAGAATGATGATAGTCATGAGTACTG\\\nAGCTAAGACGGCGTCGATGCATAGCGGACTTTCGGTCAATCACAATTCCTCACGAGACTCGTCCTGTTGAGCGTATCAC\\\nTCTCAATGTACAAGCAACCCAAGAAGGCTGTGCCTGGACTCAACTGGATGCAGGATGAACTCCAGACACGGGGTCACTA\\\nCTCTTCATACATAAAGCAAGAACGTCGAACAGTCATGAAAGTCTTAGTACCGCACGTACCATCTTACTGTGAATATTGC\\\nTTGAAGCTGTACCGTTATTGGGGGGCAAAGATGAAGTTCTCTTCTTTTCATAATTGTACTGACGACAGTCGTGTTCTCG\\\nGTTTCTTCAAAGGTTAAAGAATAAAGGCTTATTGTAGGCAGAGGAACGCCCTTTTAGTGGCTGGCGTTAAGTATCTTCG\\\nGACCCCCTTGTCTATCCAGATTAATCGAATTCTCTCATTTAGGACCTTAGTAAGTCATCATTGGTATTTGAATGCGACC\\\nTTGAAGAAACCGCTTAAAAATGTCAATGGTTGATCCACTAAACTTCATTTAATTAACTCCTAAATCAGCGCGATAGGCT\\\nATTAGAGGTTTAATTTTGTATAGCAAGGTACTTCCGATCTTAATGAATGGCCGGAAAAGGTACGGACGCGATATGCGAG\\\nGGTGAAAGGGCAAATAGACAGGTTCGTCTTTGTCACGCTAGGAGGCAATTCTATAAGAATGCATATTGCATCGATACAT\\\nAAAATGTCTCGATCGCATGCGCAATTTGTGAAGTGTCTATTATCCCTAAGCCCATTTCCCGCATAATAACCCCTGATTG\\\nTATCCGCATTTGATGCTACCCAGGTTGAGTTAGCGTCGAGCTCGCGGAACTTATTGCATGAGTAGAGTTGAGTAAGAGC\\\nTGTTAGATGGCTCGCTGAACTAATAGTTGTCCACAGAACGTCAAGATTAGAAAACGGTTGTAGCATTATCGGAGGTTCT\\\nCTAACTACTATCAATACCCGTGTCTTGACTCTGCTGCGGCTACCTATCGCCTGAAAACCAGTTGGTGTTAAGGGATGCT\\\nCTGTCCAGGACGCCACATGTAGTGAAACTTACATGTTCGTTGGGTTCACCCGACT\";\n\n#[bench]\nfn bench_aligner_wc_local(b: \u0026mut Bencher) {\n    let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n    let mut aligner = Aligner::with_capacity(STR_1.len(), STR_2.len(), -5, -1, \u0026score);\n    b.iter(|| aligner.local(STR_1, STR_2));\n}\n\n#[bench]\nfn bench_aligner_wc_global(b: \u0026mut Bencher) {\n    let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n    let mut aligner = Aligner::with_capacity(STR_1.len(), STR_2.len(), -5, -1, \u0026score);\n    b.iter(|| aligner.global(STR_1, STR_2));\n}\n\n#[bench]\nfn bench_aligner_wc_semiglobal(b: \u0026mut Bencher) {\n    let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n    let mut aligner = Aligner::with_capacity(STR_1.len(), STR_2.len(), -5, -1, \u0026score);\n    b.iter(|| aligner.semiglobal(STR_1, STR_2));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","benches","pattern_matching.rs"],"content":"#![feature(test)]\n\nextern crate test;\n\nuse bio::pattern_matching::bndm::BNDM;\nuse bio::pattern_matching::bom::BOM;\nuse bio::pattern_matching::horspool::Horspool;\nuse bio::pattern_matching::kmp::KMP;\nuse bio::pattern_matching::shift_and::ShiftAnd;\nuse test::Bencher;\n\nstatic TEXT: \u0026'static [u8] = b\"GATCACAGGTCTATCACCCTATTAACCACTCACGGGAGCTCTCCATGC\\\nATTTGGTATTTTCGTCTGGGGGGTATGCACGCGATAGCATTGCGAGACGCTGGAGCCGGAGCACCCTATGTCGCAGTAT\\\nCTGTCTTTGATTCCTGCCTCATCCTATTATTTATCGCACCTACGTTCAATATTACAGGCGAACATACTTACTAAAGTGT\\\nGTTAATTAATTAATGCTTGTAGGACATAATAATAACAATTGAATGTCTGCACAGCCACTTTCCACACAGACATCATAAC\\\nAAAAAATTTCCACCAAACCCCCCCTCCCCCGCTTCTGGCCACAGCACTTAAACACATCTCTGCCAAACCCCAAAAACAA\\\nAGAACCCTAACACCAGCCTAACCAGATTTCAAATTTTATCTTTTGGCGGTATGCACTTTTAACAGTCACCCCCCAACTA\\\nACACATTATTTTCCCCTCCCACTCCCATACTACTAATCTCATCAATACAACCCCCGCCCATCCTACCCAGCACACACAC\\\nACCGCTGCTAACCCCATACCCCGAACCAACCAAACCCCAAAGACACCCCCCACAGTTTATGTAGCTTACCTCCTCAAAG\\\nCAATACACTGAAAATGTTTAGACGGGCTCACATCACCCCATAAACAAATAGGTTTGGTCCTAGCCTTTCTATTAGCTCT\\\nTAGTAAGATTACACATGCAAGCATCCCCGTTCCAGTGAGTTCACCCTCTAAATCACCACGATCAAAAGGAACAAGCATC\\\nAAGCACGCAGCAATGCAGCTCAAAACGCTTAGCCTAGCCACACCCCCACGGGAAACAGCAGTGATTAACCTTTAGCAAT\\\nAAACGAAAGTTTAACTAAGCTATACTAACCCCAGGGTTGGTCAATTTCGTGCCAGCCACCGCGGTCACACGATTAACCC\\\nAAGTCAATAGAAGCCGGCGTAAAGAGTGTTTTAGATCACCCCCTCCCCAATAAAGCTAAAACTCACCTGAGTTGTAAAA\\\nAACTCCAGTTGACACAAAATAGACTACGAAAGTGGCTTTAACATATCTGAACACACAATAGCTAAGACCCAAACTGGGA\\\nTTAGATACCCCACTATGCTTAGCCCTAAACCTCAACAGTTAAATCAACAAAACTGCTCGCCAGAACACTACGAGCCACA\\\nGCTTAAAACTCAAAGGACCTGGCGGTGCTTCATATCCCTCTAGAGGAGCCTGTTCTGTAATCGATAAACCCCGATCAAC\\\nCTCACCACCTCTTGCTCAGCCTATATACCGCCATCTTCAGCAAACCCTGATGAAGGCTACAAAGTAAGCGCAAGTACCC\\\nACGTAAAGACGTTAGGTCAAGGTGTAGCCCATGAGGTGGCAAGAAATGGGCTACATTTTCTACCCCAGAAAACTACGAT\\\nAGCCCTTATGAAACTTAAGGGTCGAAGGTGGATTTAGCAGTAAACTAAGAGTAGAGTGCTTAGTTGAACAGGGCCCTGA\\\nAGCGCGTACACACCGCCCGTCACCCTCCTCAAGTATACTTCAAAGGACATTTAACTAAAACCCCTACGCATTTATATAG\\\nAGGAGACAAGTCGTAACATGGTAAGTGTACTGGAAAGTGCACTTGGACGAACCAGAGTGTAGCTTAACACAAAGCACCC\\\nAACTTACACTTAGGAGATTTCAACTTAACTTGACCGCTCTGAGCTAAACCTAGCCCCAAACCCACTCCACCTTACTACC\\\nAGACAACCTTAGCCAAACCATTTACCCAAATAAAGTATAGGCGATAGAAATTGAAACCTGGCGCAATAGATATAGTACC\\\nGCAAGGGAAAGATGAAAAATTATAACCAAGCATAATATAGCAAGGACTAACCCCTATACCTTCTGCATAATGAATTAAC\\\nTAGAAATAACTTTGCAAGGAGAGCCAAAGCTAAGACCCCCGAAACCAGACGAGCTACCTAAGAACAGCTAAAAGAGCAC\\\nACCCGTCTATGTAGCAAAATAGTGGGAAGATTTATAGGTAGAGGCGACAAACCTACCGAGCCTGGTGATAGCTGGTTGT\\\nCCAAGATAGAATCTTAGTTCAACTTTAAATTTGCCCACAGAACCCTCTAAATCCCCTTGTAAATTTAACTGTTAGTCCA\\\nAAGAGGAACAGCTCTTTGGACACTAGGAAAAAACCTTGTAGAGAGAGTAAAAAATTTAACACCCATAGTAGGCCTAAAA\\\nGCAGCCACCAATTAAGAAAGCGTTCAAGCTCAACACCCACTACCTAAAAAATCCCAAACATATAACTGAACTCCTCACA\\\nCCCAATTGGACCAATCTATCACCCTATAGAAGAACTAATGTTAGTATAAGTAACATGAAAACATTCTCCTCCGCATAAG\\\nCCTGCGTCAGATTAAAACACTGAACTGACAATTAACAGCCCAATATCTACAATCAACCAACAAGTCATTATTACCCTCA\\\nCTGTCAACCCAACACAGGCATGCTCATAAGGAAAGGTTAAAAAAAGTAAAAGGAACTCGGCAAATCTTACCCCGCCTGT\\\nTTACCAAAAACATCACCTCTAGCATCACCAGTATTAGAGGCACCGCCTGCCCAGTGACACATGTTTAACGGCCGCGGTA\\\nCCCTAACCGTGCAAAGGTAGCATAATCACTTGTTCCTTAAATAGGGACCTGTATGAATGGCTCCACGAGGGTTCAGCTG\\\nTCTCTTACTTTTAACCAGTGAAATTGACCTGCCCGTGAAGAGGCGGGCATAACACAGCAAGACGAGAAGACCCTATGGA\\\nGCTTTAATTTATTAATGCAAACAGTACCTAACAAACCCACAGGTCCTAAACTACCAAACCTGCATTAAAAATTTCGGTT\\\nGGGGCGACCTCGGAGCAGAACCCAACCTCCGAGCAGTACATGCTAAGACTTCACCAGTCAAAGCGAACTACTATACTCA\\\nATTGATCCAATAACTTGACCAACGGAACAAGTTACCCTAGGGATAACAGCGCAATCCTATTCTAGAGTCCATATCAACA\\\nATAGGGTTTACGACCTCGATGTTGGATCAGGACATCCCGATGGTGCAGCCGCTATTAAAGGTTCGTTTGTTCAACGATT\\\nAAAGTCCTACGTGATCTGAGTTCAGACCGGAGTAATCCAGGTCGGTTTCTATCTACNTTCAAATTCCTCCCTGTACGAA\\\nAGGACAAGAGAAATAAGGCCTACTTCACAAAGCGCCTTCCCCCGTAAATGATATCATCTCAACTTAGTATTATACCCAC\\\nACCCACCCAAGAACAGGGTTTGTTAAGATGGCAGAGCCCGGTAATCGCATAAAACTTAAAACTTTACAGTCAGAGGTTC\\\nAATTCCTCTTCTTAACAACATACCCATGGCCAACCTCCTACTCCTCATTGTACCCATTCTAATCGCAATGGCATTCCTA\\\nATGCTTACCGAACGAAAAATTCTAGGCTATATACAACTACGCAAAGGCCCCAACGTTGTAGGCCCCTACGGGCTACTAC\\\nAACCCTTCGCTGACGCCATAAAACTCTTCACCAAAGAGCCCCTAAAACCCGCCACATCTACCATCACCCTCTACATCAC\\\nCGCCCCGACCTTAGCTCTCACCATCGCTCTTCTACTATGAACCCCCCTCCCCATACCCAACCCCCTGGTCAACCTCAAC\\\nCTAGGCCTCCTATTTATTCTAGCCACCTCTAGCCTAGCCGTTTACTCAATCCTCTGATCAGGGTGAGCATCAAACTCAA\\\nACTACGCCCTGATCGGCGCACTGCGAGCAGTAGCCCAAACAATCTCATATGAAGTCACCCTAGCCATCATTCTACTATC\\\nAACATTACTAATAAGTGGCTCCTTTAACCTCTCCACCCTTATCACAACACAAGAACACCTCTGATTACTCCTGCCATCA\\\nTGACCCTTGGCCATAATATGATTTATCTCCACACTAGCAGAGACCAACCGAACCCCCTTCGACCTTGCCGAAGGGGAGT\\\nCCGAACTAGTCTCAGGCTTCAACATCGAATACGCCGCAGGCCCCTTCGCCCTATTCTTCATAGCCGAATACACAAACAT\\\nTATTATAATAAACACCCTCACCACTACAATCTTCCTAGGAACAACATATGACGCACTCTCCCCTGAACTCTACACAACA\\\nTATTTTGTCACCAAGACCCTACTTCTAACCTCCCTGTTCTTATGAATTCGAACAGCATACCCCCGATTCCGCTACGACC\\\nAACTCATACACCTCCTATGAAAAAACTTCCTACCACTCACCCTAGCATTACTTATATGATATGTCTCCATACCCATTAC\\\nAATCTCCAGCATTCCCCCTCAAACCTAAGAAATATGTCTGATAAAAGAGTTACTTTGATAGAGTAAATAATAGGAGCTT\\\nAAACCCCCTTATTTCTAGGACTATGAGAATCGAACCCATCCCTGAGAATCCAAAATTCTCCGTGCCACCTATCACACCC\\\nCATCCTAAAGTAAGGTCAGCTAAATAAGCTATCGGGCCCATACCCCGAAAATGTTGGTTATACCCTTCCCGTACTAATT\\\nAATCCCCTGGCCCAACCCGTCATCTACTCTACCATCTTTGCAGGCACACTCATCACAGCGCTAAGCTCGCACTGATTTT\\\nTTACCTGAGTAGGCCTAGAAATAAACATGCTAGCTTTTATTCCAGTTCTAACCAAAAAAATAAACCCTCGTTCCACAGA\\\nAGCTGCCATCAAGTATTTCCTCACGCAAGCAACCGCATCCATAATCCTTCTAATAGCTATCCTCTTCAACAATATACTC\\\nTCCGGACAATGAACCATAACCAATACTACCAATCAATACTCATCATTAATAATCATAATAGCTATAGCAATAAAACTAG\\\nGAATAGCCCCCTTTCACTTCTGAGTCCCAGAGGTTACCCAAGGCACCCCTCTGACATCCGGCCTGCTTCTTCTCACATG\\\nACAAAAACTAGCCCCCATCTCAATCATATACCAAATCTCTCCCTCACTAAACGTAAGCCTTCTCCTCACTCTCTCAATC\\\nTTATCCATCATAGCAGGCAGTTGAGGTGGATTAAACCAAACCCAGCTACGCAAAATCTTAGCATACTCCTCAATTACCC\\\nACATAGGATGAATAATAGCAGTTCTACCGTACAACCCTAACATAACCATTCTTAATTTAACTATTTATATTATCCTAAC\\\nTACTACCGCATTCCTACTACTCAACTTAAACTCCAGCACCACGACCCTACTACTATCTCGCACCTGAAACAAGCTAACA\\\nTGACTAACACCCTTAATTCCATCCACCCTCCTCTCCCTAGGAGGCCTGCCCCCGCTAACCGGCTTTTTGCCCAAATGGG\\\nCCATTATCGAAGAATTCACAAAAAACAATAGCCTCATCATCCCCACCATCATAGCCACCATCACCCTCCTTAACCTCTA\\\nCTTCTACCTACGCCTAATCTACTCCACCTCAATCACACTACTCCCCATATCTAACAACGTAAAAATAAAATGACAGTTT\\\nGAACATACAAAACCCACCCCATTCCTCCCCACACTCATCGCCCTTACCACGCTACTCCTACCTATCTCCCCTTTTATAC\\\nTAATAATCTTATAGAAATTTAGGTTAAATACAGACCAAGAGCCTTCAAAGCCCTCAGTAAGTTGCAATACTTAATTTCT\\\nGTAACAGCTAAGGACTGCAAAACCCCACTCTGCATCAACTGAACGCAAATCAGCCACTTTAATTAAGCTAAGCCCTTAC\\\nTAGACCAATGGGACTTAAACCCACAAACACTTAGTTAACAGCTAAGCACCCTAATCAACTGGCTTCAATCTACTTCTCC\\\nCGCCGCCGGGAAAAAAGGCGGGAGAAGCCCCGGCAGGTTTGAAGCTGCTTCTTCGAATTTGCAATTCAATATGAAAATC\\\nACCTCGGAGCTGGTAAAAAGAGGCCTAACCCCTGTCTTTAGATTTACAGTCCAATGCTTCACTCAGCCATTTTACCTCA\\\nCCCCCACTGATGTTCGCCGACCGTTGACTATTCTCTACAAACCACAAAGACATTGGAACACTATACCTATTATTCGGCG\\\nCATGAGCTGGAGTCCTAGGCACAGCTCTAAGCCTCCTTATTCGAGCCGAGCTGGGCCAGCCAGGCAACCTTCTAGGTAA\\\nCGACCACATCTACAACGTTATCGTCACAGCCCATGCATTTGTAATAATCTTCTTCATAGTAATACCCATCATAATCGGA\\\nGGCTTTGGCAACTGACTAGTTCCCCTAATAATCGGTGCCCCCGATATGGCGTTTCCCCGCATAAACAACATAAGCTTCT\\\nGACTCTTACCTCCCTCTCTCCTACTCCTGCTCGCATCTGCTATAGTGGAGGCCGGAGCAGGAACAGGTTGAACAGTCTA\\\nCCCTCCCTTAGCAGGGAACTACTCCCACCCTGGAGCCTCCGTAGACCTAACCATCTTCTCCTTACACCTAGCAGGTGTC\\\nTCCTCTATCTTAGGGGCCATCAATTTCATCACAACAATTATCAATATAAAACCCCCTGCCATAACCCAATACCAAACGC\\\nCCCTCTTCGTCTGATCCGTCCTAATCACAGCAGTCCTACTTCTCCTATCTCTCCCAGTCCTAGCTGCTGGCATCACTAT\\\nACTACTAACAGACCGCAACCTCAACACCACCTTCTTCGACCCCGCCGGAGGAGGAGACCCCATTCTATACCAACACCTA\\\nTTCTGATTTTTCGGTCACCCTGAAGTTTATATTCTTATCCTACCAGGCTTCGGAATAATCTCCCATATTGTAACTTACT\\\nACTCCGGAAAAAAAGAACCATTTGGATACATAGGTATGGTCTGAGCTATGATATCAATTGGCTTCCTAGGGTTTATCGT\\\nGTGAGCACACCATATATTTACAGTAGGAATAGACGTAGACACACGAGCATATTTCACCTCCGCTACCATAATCATCGCT\\\nATCCCCACCGGCGTCAAAGTATTTAGCTGACTCGCCACACTCCACGGAAGCAATATGAAATGATCTGCTGCAGTGCTCT\\\nGAGCCCTAGGATTCATCTTTCTTTTCACCGTAGGTGGCCTGACTGGCATTGTATTAGCAAACTCATCACTAGACATCGT\\\nACTACACGACACGTACTACGTTGTAGCCCACTTCCACTATGTCCTATCAATAGGAGCTGTATTTGCCATCATAGGAGGC\\\nTTCATTCACTGATTTCCCCTATTCTCAGGCTACACCCTAGACCAAACCTACGCCAAAATCCATTTCACTATCATATTCA\\\nTCGGCGTAAATCTAACTTTCTTCCCACAACACTTTCTCGGCCTATCCGGAATGCCCCGACGTTACTCGGACTACCCCGA\\\nTGCATACACCACATGAAACATCCTATCATCTGTAGGCTCATTCATTTCTCTAACAGCAGTAATATTAATAATTTTCATG\\\nATTTGAGAAGCCTTCGCTTCGAAGCGAAAAGTCCTAATAGTAGAAGAACCCTCCATAAACCTGGAGTGACTATATGGAT\\\nGCCCCCCACCCTACCACACATTCGAAGAACCCGTATACATAAAATCTAGACAAAAAAGGAAGGAATCGAACCCCCCAAA\\\nGCTGGTTTCAAGCCAACCCCATGGCCTCCATGACTTTTTCAAAAAGGTATTAGAAAAACCATTTCATAACTTTGTCAAA\\\nGTTAAATTATAGGCTAAATCCTATATATCTTAATGGCACATGCAGCGCAAGTAGGTCTACAAGACGCTACTTCCCCTAT\\\nCATAGAAGAGCTTATCACCTTTCATGATCACGCCCTCATAATCATTTTCCTTATCTGCTTCCTAGTCCTGTATGCCCTT\\\nTTCCTAACACTCACAACAAAACTAACTAATACTAACATCTCAGACGCTCAGGAAATAGAAACCGTCTGAACTATCCTGC\\\nCCGCCATCATCCTAGTCCTCATCGCCCTCCCATCCCTACGCATCCTTTACATAACAGACGAGGTCAACGATCCCTCCCT\\\nTACCATCAAATCAATTGGCCACCAATGGTACTGAACCTACGAGTACACCGACTACGGCGGACTAATCTTCAACTCCTAC\\\nATACTTCCCCCATTATTCCTAGAACCAGGCGACCTGCGACTCCTTGACGTTGACAATCGAGTAGTACTCCCGATTGAAG\\\nCCCCCATTCGTATAATAATTACATCACAAGACGTCTTGCACTCATGAGCTGTCCCCACATTAGGCTTAAAAACAGATGC\\\nAATTCCCGGACGTCTAAACCAAACCACTTTCACCGCTACACGACCGGGGGTATACTACGGTCAATGCTCTGAAATCTGT\\\nGGAGCAAACCACAGTTTCATGCCCATCGTCCTAGAATTAATTCCCCTAAAAATCTTTGAAATAGGGCCCGTATTTACCC\\\nTATAGCACCCCCTCTACCCCCTCTAGAGCCCACTGTAAAGCTAACTTAGCATTAACCTTTTAAGTTAAAGATTAAGAGA\\\nACCAACACCTCTTTACAGTGAAATGCCCCAACTAAATACTACCGTATGGCCCACCATAATTACCCCCATACTCCTTACA\\\nCTATTCCTCATCACCCAACTAAAAATATTAAACACAAACTACCACCTACCTCCCTCACCAAAGCCCATAAAAATAAAAA\\\nATTATAACAAACCCTGAGAACCAAAATGAACGAAAATCTGTTCGCTTCATTCATTGCCCCCACAATCCTAGGCCTACCC\\\nGCCGCAGTACTGATCATTCTATTTCCCCCTCTATTGATCCCCACCTCCAAATATCTCATCAACAACCGACTAATCACCA\\\nCCCAACAATGACTAATCAAACTAACCTCAAAACAAATGATAACCATACACAACACTAAAGGACGAACCTGATCTCTTAT\\\nACTAGTATCCTTAATCATTTTTATTGCCACAACTAACCTCCTCGGACTCCTGCCTCACTCATTTACACCAACCACCCAA\\\nCTATCTATAAACCTAGCCATGGCCATCCCCTTATGAGCGGGCACAGTGATTATAGGCTTTCGCTCTAAGATTAAAAATG\\\nCCCTAGCCCACTTCTTACCACAAGGCACACCTACACCCCTTATCCCCATACTAGTTATTATCGAAACCATCAGCCTACT\\\nCATTCAACCAATAGCCCTGGCCGTACGCCTAACCGCTAACATTACTGCAGGCCACCTACTCATGCACCTAATTGGAAGC\\\nGCCACCCTAGCAATATCAACCATTAACCTTCCCTCTACACTTATCATCTTCACAATTCTAATTCTACTGACTATCCTAG\\\nAAATCGCTGTCGCCTTAATCCAAGCCTACGTTTTCACACTTCTAGTAAGCCTCTACCTGCACGACAACACATAATGACC\\\nCACCAATCACATGCCTATCATATAGTAAAACCCAGCCCATGACCCCTAACAGGGGCCCTCTCAGCCCTCCTAATGACCT\\\nCCGGCCTAGCCATGTGATTTCACTTCCACTCCATAACGCTCCTCATACTAGGCCTACTAACCAACACACTAACCATATA\\\nCCAATGATGGCGCGATGTAACACGAGAAAGCACATACCAAGGCCACCACACACCACCTGTCCAAAAAGGCCTTCGATAC\\\nGGGATAATCCTATTTATTACCTCAGAAGTTTTTTTCTTCGCAGGATTTTTCTGAGCCTTTTACCACTCCAGCCTAGCCC\\\nCTACCCCCCAATTAGGAGGGCACTGGCCCCCAACAGGCATCACCCCGCTAAATCCCCTAGAAGTCCCACTCCTAAACAC\\\nATCCGTATTACTCGCATCAGGAGTATCAATCACCTGAGCTCACCATAGTCTAATAGAAAACAACCGAAACCAAATAATT\\\nCAAGCACTGCTTATTACAATTTTACTGGGTCTCTATTTTACCCTCCTACAAGCCTCAGAGTACTTCGAGTCTCCCTTCA\\\nCCATTTCCGACGGCATCTACGGCTCAACATTTTTTGTAGCCACAGGCTTCCACGGACTTCACGTCATTATTGGCTCAAC\\\nTTTCCTCACTATCTGCTTCATCCGCCAACTAATATTTCACTTTACATCCAAACATCACTTTGGCTTCGAAGCCGCCGCC\\\nTGATACTGGCATTTTGTAGATGTGGTTTGACTATTTCTGTATGTCTCCATCTATTGATGAGGGTCTTACTCTTTTAGTA\\\nTAAATAGTACCGTTAACTTCCAATTAACTAGTTTTGACAACATTCAAAAAAGAGTAATAAACTTCGCCTTAATTTTAAT\\\nAATCAACACCCTCCTAGCCTTACTACTAATAATTATTACATTTTGACTACCACAACTCAACGGCTACATAGAAAAATCC\\\nACCCCTTACGAGTGCGGCTTCGACCCTATATCCCCCGCCCGCGTCCCTTTCTCCATAAAATTCTTCTTAGTAGCTATTA\\\nCCTTCTTATTATTTGATCTAGAAATTGCCCTCCTTTTACCCCTACCATGAGCCCTACAAACAACTAACCTGCCACTAAT\\\nAGTTATGTCATCCCTCTTATTAATCATCATCCTAGCCCTAAGTCTGGCCTATGAGTGACTACAAAAAGGATTAGACTGA\\\nACCGAATTGGTATATAGTTTAAACAAAACGAATGATTTCGACTCATTAAATTATGATAATCATATTTACCAAATGCCCC\\\nTCATTTACATAAATATTATACTAGCATTTACCATCTCACTTCTAGGAATACTAGTATATCGCTCACACCTCATATCCTC\\\nCCTACTATGCCTAGAAGGAATAATACTATCGCTGTTCATTATAGCTACTCTCATAACCCTCAACACCCACTCCCTCTTA\\\nGCCAATATTGTGCCTATTGCCATACTAGTCTTTGCCGCCTGCGAAGCAGCGGTGGGCCTAGCCCTACTAGTCTCAATCT\\\nCCAACACATATGGCCTAGACTACGTACATAACCTAAACCTACTCCAATGCTAAAACTAATCGTCCCAACAATTATATTA\\\nCTACCACTGACATGACTTTCCAAAAAACACATAATTTGAATCAACACAACCACCCACAGCCTAATTATTAGCATCATCC\\\nCTCTACTATTTTTTAACCAAATCAACAACAACCTATTTAGCTGTTCCCCAACCTTTTCCTCCGACCCCCTAACAACCCC\\\nCCTCCTAATACTAACTACCTGACTCCTACCCCTCACAATCATGGCAAGCCAACGCCACTTATCCAGTGAACCACTATCA\\\nCGAAAAAAACTCTACCTCTCTATACTAATCTCCCTACAAATCTCCTTAATTATAACATTCACAGCCACAGAACTAATCA\\\nTATTTTATATCTTCTTCGAAACCACACTTATCCCCACCTTGGCTATCATCACCCGATGAGGCAACCAGCCAGAACGCCT\\\nGAACGCAGGCACATACTTCCTATTCTACACCCTAGTAGGCTCCCTTCCCCTACTCATCGCACTAATTTACACTCACAAC\\\nACCCTAGGCTCACTAAACATTCTACTACTCACTCTCACTGCCCAAGAACTATCAAACTCCTGAGCCAACAACTTAATAT\\\nGACTAGCTTACACAATAGCTTTTATAGTAAAGATACCTCTTTACGGACTCCACTTATGACTCCCTAAAGCCCATGTCGA\\\nAGCCCCCATCGCTGGGTCAATAGTACTTGCCGCAGTACTCTTAAAACTAGGCGGCTATGGTATAATACGCCTCACACTC\\\nATTCTCAACCCCCTGACAAAACACATAGCCTACCCCTTCCTTGTACTATCCCTATGAGGCATAATTATAACAAGCTCCA\\\nTCTGCCTACGACAAACAGACCTAAAATCGCTCATTGCATACTCTTCAATCAGCCACATAGCCCTCGTAGTAACAGCCAT\\\nTCTCATCCAAACCCCCTGAAGCTTCACCGGCGCAGTCATTCTCATAATCGCCCACGGGCTTACATCCTCATTACTATTC\\\nTGCCTAGCAAACTCAAACTACGAACGCACTCACAGTCGCATCATAATCCTCTCTCAAGGACTTCAAACTCTACTCCCAC\\\nTAATAGCTTTTTGATGACTTCTAGCAAGCCTCGCTAACCTCGCCTTACCCCCCACTATTAACCTACTGGGAGAACTCTC\\\nTGTGCTAGTAACCACGTTCTCCTGATCAAATATCACTCTCCTACTTACAGGACTCAACATACTAGTCACAGCCCTATAC\\\nTCCCTCTACATATTTACCACAACACAATGGGGCTCACTCACCCACCACATTAACAACATAAAACCCTCATTCACACGAG\\\nAAAACACCCTCATGTTCATACACCTATCCCCCATTCTCCTCCTATCCCTCAACCCCGACATCATTACCGGGTTTTCCTC\\\nTTGTAAATATAGTTTAACCAAAACATCAGATTGTGAATCTGACAACAGAGGCTTACGACCCCTTATTTACCGAGAAAGC\\\nTCACAAGAACTGCTAACTCATGCCCCCATGTCTAACAACATGGCTTTCTCAACTTTTAAAGGATAACAGCTATCCATTG\\\nGTCTTAGGCCCCAAAAATTTTGGTGCAACTCCAAATAAAAGTAATAACCATGCACACTACTATAACCACCCTAACCCTG\\\nACTTCCCTAATTCCCCCCATCCTTACCACCCTCGTTAACCCTAACAAAAAAAACTCATACCCCCATTATGTAAAATCCA\\\nTTGTCGCATCCACCTTTATTATCAGTCTCTTCCCCACAACAATATTCATGTGCCTAGACCAAGAAGTTATTATCTCGAA\\\nCTGACACTGAGCCACAACCCAAACAACCCAGCTCTCCCTAAGCTTCAAACTAGACTACTTCTCCATAATATTCATCCCT\\\nGTAGCATTGTTCGTTACATGGTCCATCATAGAATTCTCACTGTGATATATAAACTCAGACCCAAACATTAATCAGTTCT\\\nTCAAATATCTACTCATCTTCCTAATTACCATACTAATCTTAGTTACCGCTAACAACCTATTCCAACTGTTCATCGGCTG\\\nAGAGGGCGTAGGAATTATATCCTTCTTGCTCATCAGTTGATGATACGCCCGAGCAGATGCCAACACAGCAGCCATTCAA\\\nGCAATCCTATACAACCGTATCGGCGATATCGGTTTCATCCTCGCCTTAGCATGATTTATCCTACACTCCAACTCATGAG\\\nACCCACAACAAATAGCCCTTCTAAACGCTAATCCAAGCCTCACCCCACTACTAGGCCTCCTCCTAGCAGCAGCAGGCAA\\\nATCAGCCCAATTAGGTCTCCACCCCTGACTCCCCTCAGCCATAGAAGGCCCCACCCCAGTCTCAGCCCTACTCCACTCA\\\nAGCACTATAGTTGTAGCAGGAATCTTCTTACTCATCCGCTTCCACCCCCTAGCAGAAAATAGCCCACTAATCCAAACTC\\\nTAACACTATGCTTAGGCGCTATCACCACTCTGTTCGCAGCAGTCTGCGCCCTTACACAAAATGACATCAAAAAAATCGT\\\nAGCCTTCTCCACTTCAAGTCAACTAGGACTCATAATAGTTACAATCGGCATCAACCAACCACACCTAGCATTCCTGCAC\\\nATCTGTACCCACGCCTTCTTCAAAGCCATACTATTTATGTGCTCCGGGTCCATCATCCACAACCTTAACAATGAACAAG\\\nATATTCGAAAAATAGGAGGACTACTCAAAACCATACCTCTCACTTCAACCTCCCTCACCATTGGCAGCCTAGCATTAGC\\\nAGGAATACCTTTCCTCACAGGTTTCTACTCCAAAGACCACATCATCGAAACCGCAAACATATCATACACAAACGCCTGA\\\nGCCCTATCTATTACTCTCATCGCTACCTCCCTGACAAGCGCCTATAGCACTCGAATAATTCTTCTCACCCTAACAGGTC\\\nAACCTCGCTTCCCCACCCTTACTAACATTAACGAAAATAACCCCACCCTACTAAACCCCATTAAACGCCTGGCAGCCGG\\\nAAGCCTATTCGCAGGATTTCTCATTACTAACAACATTTCCCCCGCATCCCCCTTCCAAACAACAATCCCCCTCTACCTA\\\nAAACTCACAGCCCTCGCTGTCACTTTCCTAGGACTTCTAACAGCCCTAGACCTCAACTACCTAACCAACAAACTTAAAA\\\nTAAAATCCCCACTATGCACATTTTATTTCTCCAACATACTCGGATTCTACCCTAGCATCACACACCGCACAATCCCCTA\\\nTCTAGGCCTTCTTACGAGCCAAAACCTGCCCCTACTCCTCCTAGACCTAACCTGACTAGAAAAGCTATTACCTAAAACA\\\nATTTCACAGCACCAAATCTCCACCTCCATCATCACCTCAACCCAAAAAGGCATAATTAAACTTTACTTCCTCTCTTTCT\\\nTCTTCCCACTCATCCTAACCCTACTCCTAATCACATAACCTATTCCCCCGAGCAATCTCAATTACAATATATACACCAA\\\nCAAACAATGTTCAACCAGTAACTACTACTAATCAACGCCCATAATCATACAAAGCCCCCGCACCAATAGGATCCTCCCG\\\nAATCAACCCTGACCCCTCTCCTTCATAAATTATTCAGCTTCCTACACTATTAAAGTTTACCACAACCACCACCCCATCA\\\nTACTCTTTCACCCACAGCACCAATCCTACCTCCATCGCTAACCCCACTAAAACACTCACCAAGACCTCAACCCCTGACC\\\nCCCATGCCTCAGGATACTCCTCAATAGCCATCGCTGTAGTATATCCAAAGACAACCATCATTCCCCCTAAATAAATTAA\\\nAAAAACTATTAAACCCATATAACCTCCCCCAAAATTCAGAATAATAACACACCCGACCACACCGCTAACAATCAATACT\\\nAAACCCCCATAAATAGGAGAAGGCTTAGAAGAAAACCCCACAAACCCCATTACTAAACCCACACTCAACAGAAACAAAG\\\nCATACATCATTATTCTCGCACGGACTACAACCACGACCAATGATATGAAAAACCATCGTTGTATTTCAACTACAAGAAC\\\nACCAATGACCCCAATACGCAAAACTAACCCCCTAATAAAATTAATTAACCACTCATTCATCGACCTCCCCACCCCATCC\\\nAACATCTCCGCATGATGAAACTTCGGCTCACTCCTTGGCGCCTGCCTGATCCTCCAAATCACCACAGGACTATTCCTAG\\\nCCATGCACTACTCACCAGACGCCTCAACCGCCTTTTCATCAATCGCCCACATCACTCGAGACGTAAATTATGGCTGAAT\\\nCATCCGCTACCTTCACGCCAATGGCGCCTCAATATTCTTTATCTGCCTCTTCCTACACATCGGGCGAGGCCTATATTAC\\\nGGATCATTTCTCTACTCAGAAACCTGAAACATCGGCATTATCCTCCTGCTTGCAACTATAGCAACAGCCTTCATAGGCT\\\nATGTCCTCCCGTGAGGCCAAATATCATTCTGAGGGGCCACAGTAATTACAAACTTACTATCCGCCATCCCATACATTGG\\\nGACAGACCTAGTTCAATGAATCTGAGGAGGCTACTCAGTAGACAGTCCCACCCTCACACGATTCTTTACCTTTCACTTC\\\nATCTTGCCCTTCATTATTGCAGCCCTAGCAACACTCCACCTCCTATTCTTGCACGAAACGGGATCAAACAACCCCCTAG\\\nGAATCACCTCCCATTCCGATAAAATCACCTTCCACCCTTACTACACAATCAAAGACGCCCTCGGCTTACTTCTCTTCCT\\\nTCTCTCCTTAATGACATTAACACTATTCTCACCAGACCTCCTAGGCGACCCAGACAATTATACCCTAGCCAACCCCTTA\\\nAACACCCCTCCCCACATCAAGCCCGAATGATATTTCCTATTCGCCTACACAATTCTCCGATCCGTCCCTAACAAACTAG\\\nGAGGCGTCCTTGCCCTATTACTATCCATCCTCATCCTAGCAATAATCCCCATCCTCCATATATCCAAACAACAAAGCAT\\\nAATATTTCGCCCACTAAGCCAATCACTTTATTGACTCCTAGCCGCAGACCTCCTCATTCTAACCTGAATCGGAGGACAA\\\nCCAGTAAGCTACCCTTTTACCATCATTGGACAAGTAGCATCCGTACTATACTTCACAACAATCCTAATCCTAATACCAA\\\nCTATCTCCCTAATTGAAAACAAAATACTCAAATGGGCCTGTCCTTGTAGTATAAACTAATACACCAGTCTTGTAAACCG\\\nGAGATGAAAACCTTTTTCCAAGGACAAATCAGAGAAAAAGTCTTTAACTCCACCATTAGCACCCAAAGCTAAGATTCTA\\\nATTTAAACTATTCTCTGTTCTTTCATGGGGAAGCAGATTTGGGTACCACCCAAGTATTGACTCACCCATCAACAACCGC\\\nTATGTATTTCGTACATTACTGCCAGCCACCATGAATATTGTACGGTACCATAAATACTTGACCACCTGTAGTACATAAA\\\nAACCCAATCCACATCAAAACCCCCTCCCCATGCTTACAAGCAAGTACAGCAATCAACCCTCAACTATCACACATCAACT\\\nGCAACTCCAAAGCCACCCCTCACCCACTAGGATACCAACAAACCTACCCACCCTTAACAGTACATAGTACATAAAGCCA\\\nTTTACCGTACATAGCACATTACAGTCAAATCCCTTCTCGTCCCCATGGATGACCCCCCTCAGATAGGGGTCCCTTGACC\\\nACCATCCTCCGTGAAATCAATATCCCGCACAAGAGTGCTACTCTCCTCGCTCCGGGCCCATAACACTTGGGGGTAGCTA\\\nAAGTGAACTGTATCCGACATCTGGTTCCTACTTCAGGGTCATAAAGCCTAAATAGCCCACACGTTCCCCTTAAATAAGA\\\nCATCACGATG\";\n\nstatic PATTERN: \u0026'static [u8] = b\"GCGCGTACACACCGCCCG\";\n\n#[bench]\nfn bench_shift_and(b: \u0026mut Bencher) {\n    b.iter(|| {\n        for _ in 0..10000 {\n            let shiftand = ShiftAnd::new(PATTERN);\n            let _ = shiftand.find_all(TEXT.iter()).collect::\u003cVec\u003cusize\u003e\u003e();\n        }\n    });\n}\n\n#[bench]\nfn bench_bndm(b: \u0026mut Bencher) {\n    b.iter(|| {\n        for _ in 0..10000 {\n            let bndm = BNDM::new(PATTERN);\n            let _ = bndm.find_all(TEXT).collect::\u003cVec\u003cusize\u003e\u003e();\n        }\n    });\n}\n\n#[bench]\nfn bench_bom(b: \u0026mut Bencher) {\n    b.iter(|| {\n        for _ in 0..10000 {\n            let bom = BOM::new(PATTERN);\n            let _ = bom.find_all(TEXT).collect::\u003cVec\u003cusize\u003e\u003e();\n        }\n    });\n}\n\n#[bench]\nfn bench_horspool(b: \u0026mut Bencher) {\n    b.iter(|| {\n        for _ in 0..10000 {\n            let horspool = Horspool::new(PATTERN);\n            let _ = horspool.find_all(TEXT).collect::\u003cVec\u003cusize\u003e\u003e();\n        }\n    });\n}\n\n#[bench]\nfn bench_kmp(b: \u0026mut Bencher) {\n    b.iter(|| {\n        for _ in 0..10000 {\n            let kmp = KMP::new(PATTERN);\n            let _ = kmp.find_all(TEXT.iter()).collect::\u003cVec\u003cusize\u003e\u003e();\n        }\n    });\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","benches","suffix_array.rs"],"content":"#![feature(test)]\n\nextern crate test;\n\nuse test::Bencher;\n\nuse bio::data_structures::suffix_array::*;\n\n#[bench]\nfn bench_suffix_array(b: \u0026mut Bencher) {\n    b.iter(|| suffix_array(b\"GCCTTAACATTATTACGCCTA$\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","build.rs"],"content":"// Adapted from the num_traits crate\n\nuse std::env;\nuse std::io::Write;\nuse std::process::{Command, Stdio};\n\nfn main() {\n    if probe(\"fn main() { 0u128; }\") {\n        println!(\"cargo:rustc-cfg=has_u128\");\n    }\n}\n\n/// Test if a code snippet can be compiled\nfn probe(code: \u0026str) -\u003e bool {\n    let rustc = env::var_os(\"RUSTC\").unwrap_or_else(|| \"rustc\".into());\n    let out_dir = env::var_os(\"OUT_DIR\").expect(\"environment variable OUT_DIR\");\n\n    let mut child = Command::new(rustc)\n        .arg(\"--out-dir\")\n        .arg(out_dir)\n        .arg(\"--emit=obj\")\n        .arg(\"-\")\n        .stdin(Stdio::piped())\n        .spawn()\n        .expect(\"rustc probe\");\n\n    child\n        .stdin\n        .as_mut()\n        .expect(\"rustc stdin\")\n        .write_all(code.as_bytes())\n        .expect(\"write rustc stdin\");\n\n    child.wait().expect(\"rustc probe\").success()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","fuzz","fuzz_targets","banded_aligner.rs"],"content":"#![no_main]\n#[macro_use]\nextern crate libfuzzer_sys;\nextern crate bio;\nuse std::cmp::{min, max};\nuse bio::alignment::{Alignment, AlignmentMode, AlignmentOperation};\nuse bio::alignment::pairwise::{self, banded, Scoring, MatchParams,  MatchFunc};\nuse bio::utils::TextSlice;\n\nfn validate_alignment_score(al: \u0026Alignment, x: TextSlice, y: TextSlice, scoring: \u0026Scoring\u003cMatchParams\u003e) -\u003e bool {\n    use AlignmentOperation::*;\n    let path = al.path();\n    let mut score = 0;\n    if al.mode==AlignmentMode::Custom {\n        if al.xstart \u003e 0 {\n            score += scoring.xclip_prefix;\n        }\n        if al.ystart \u003e 0 {\n            score += scoring.yclip_prefix;\n        }\n        if al.xend \u003c al.xlen {\n            score += scoring.xclip_suffix;\n        }\n        if al.yend \u003c al.ylen {\n            score += scoring.yclip_suffix;\n        }\n    }\n    let mut last_op = None;\n    for (i, j, op) in path {\n        score += match op {\n            Match | Subst =\u003e scoring.match_fn.score(x[i-1], y[j-1]),\n            Del =\u003e if last_op==Some(Del) { scoring.gap_extend } else { scoring.gap_open + scoring.gap_extend },\n            Ins =\u003e if last_op==Some(Ins) { scoring.gap_extend } else { scoring.gap_open + scoring.gap_extend },\n            _ =\u003e 0,\n        };\n        last_op = Some(op);\n    }\n    al.score==score\n}\n\nfuzz_target!(|data: \u0026[u8]| {\n    if data.len() \u003c 50 || data.len() \u003e 300 {\n        return;\n    }\n\n    let (split_byte, data) = data.split_first().unwrap();\n    let (kmer_byte, data) = data.split_first().unwrap();\n    let (window_byte, data) = data.split_first().unwrap();\n    let (match_score_byte, data) = data.split_first().unwrap();\n    let (mismatch_score_byte, data) = data.split_first().unwrap();\n    let (gap_open_byte, data) = data.split_first().unwrap();\n    let (gap_extend_byte, data) = data.split_first().unwrap();\n    let (xclip_prefix_byte, data) = data.split_first().unwrap();\n    let (xclip_suffix_byte, data) = data.split_first().unwrap();\n    let (yclip_prefix_byte, data) = data.split_first().unwrap();\n    let (yclip_suffix_byte, data) = data.split_first().unwrap();\n\n    let alphabets = b\"ACGT\";\n    let v: Vec\u003c_\u003e = data.iter()\n        .map(|i| alphabets[(*i as usize) % alphabets.len()])\n        .collect();\n\n    let kmer_len: usize = 5 + (*kmer_byte as usize) % 10;\n    let window_size: usize = 5 + (*window_byte as usize) % 10;\n    let split_pos: usize = min(data.len() - 1, max(*split_byte as usize, 1));\n\n    let match_score = 1 + (*match_score_byte as i32) % 5;\n    let mismatch_score = -((*mismatch_score_byte as i32) % 10);\n    let gap_open = -((*gap_open_byte as i32) % 20);\n    let gap_extend = -((*gap_extend_byte as i32) % 10);\n\n    let (x, y) = v.split_at(split_pos);\n    println!(\"x: {}, y: {}, k: {}, w: {}, scoring ({}, {}, {}, {})\",\n             String::from_utf8(x.to_vec()).unwrap(),\n             String::from_utf8(y.to_vec()).unwrap(),\n             kmer_len,\n             window_size,\n             gap_open,\n             gap_extend,\n             match_score,\n             mismatch_score);\n    let base_score = Scoring::from_scores(gap_open, gap_extend, match_score, mismatch_score);\n\n    {\n        println!(\"Clip scores ({}, {}, {}, {})\", xclip_prefix_byte, xclip_suffix_byte, yclip_prefix_byte, yclip_suffix_byte);\n        let scoring = Scoring {\n            xclip_prefix: -(*xclip_prefix_byte as i32),\n            xclip_suffix: -(*xclip_suffix_byte as i32),\n            yclip_prefix: -(*yclip_prefix_byte as i32),\n            yclip_suffix: -(*yclip_suffix_byte as i32),\n            ..base_score.clone()\n        };\n        // Banded\n        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);\n        let b_alignment = b_aligner.custom(x, y);\n        assert!(validate_alignment_score(\u0026b_alignment, x, y, \u0026scoring));\n\n        // Full\n        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());\n        let f_alignment = f_aligner.custom(x, y);\n        assert!(validate_alignment_score(\u0026f_alignment, x, y, \u0026scoring));\n\n        // Compare\n        // Passing an empty match will force the banded alignmer to band the full matrix\n        let band_all_alignment = b_aligner.custom_with_matches(x, y, \u0026Vec::new());\n        assert_eq!(band_all_alignment.score, f_alignment.score);\n    }\n\n\n    {\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            xclip_suffix: 0,\n            yclip_suffix: 0,\n            ..base_score.clone()\n        };\n        // Banded\n        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);\n        let b_alignment = b_aligner.custom(x, y);\n        assert_eq!(b_alignment.ystart, 0);\n        assert!(validate_alignment_score(\u0026b_alignment, x, y, \u0026scoring));\n\n        // Full\n        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());\n        let f_alignment = f_aligner.custom(x, y);\n        assert_eq!(f_alignment.ystart, 0);\n        assert!(validate_alignment_score(\u0026f_alignment, x, y, \u0026scoring));\n\n        // Compare\n        // Passing an empty match will force the banded alignmer to band the full matrix\n        let band_all_alignment = b_aligner.custom_with_matches(x, y, \u0026Vec::new());\n        assert_eq!(band_all_alignment.score, f_alignment.score);\n    }\n\n    {\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            xclip_suffix: 0,\n            yclip_prefix: 0,\n            ..base_score.clone()\n        };\n        // Banded\n        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);\n        let b_alignment = b_aligner.custom(x, y);\n        assert_eq!(b_alignment.yend, b_alignment.ylen);\n        assert!(validate_alignment_score(\u0026b_alignment, x, y, \u0026scoring));\n\n        // Full\n        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());\n        let f_alignment = f_aligner.custom(x, y);\n        assert_eq!(f_alignment.yend, f_alignment.ylen);\n        assert!(validate_alignment_score(\u0026f_alignment, x, y, \u0026scoring));\n\n        // Compare\n        // Passing an empty match will force the banded alignmer to band the full matrix\n        let band_all_alignment = b_aligner.custom_with_matches(x, y, \u0026Vec::new());\n        assert_eq!(band_all_alignment.score, f_alignment.score);\n    }\n\n    {\n        let scoring = Scoring {\n            xclip_suffix: 0,\n            yclip_prefix: 0,\n            yclip_suffix: 0,\n            ..base_score.clone()\n        };\n        // Banded\n        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);\n        let b_alignment = b_aligner.custom(x, y);\n        assert_eq!(b_alignment.xstart, 0);\n        assert!(validate_alignment_score(\u0026b_alignment, x, y, \u0026scoring));\n\n        // Full\n        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());\n        let f_alignment = f_aligner.custom(x, y);\n        assert_eq!(f_alignment.xstart, 0);\n        assert!(validate_alignment_score(\u0026f_alignment, x, y, \u0026scoring));\n\n        // Compare\n        // Passing an empty match will force the banded alignmer to band the full matrix\n        let band_all_alignment = b_aligner.custom_with_matches(x, y, \u0026Vec::new());\n        assert_eq!(band_all_alignment.score, f_alignment.score);\n    }\n\n    {\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            yclip_prefix: 0,\n            yclip_suffix: 0,\n            ..base_score.clone()\n        };\n        // Banded\n        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);\n        let b_alignment = b_aligner.custom(x, y);\n        assert_eq!(b_alignment.xend, b_alignment.xlen);\n        assert!(validate_alignment_score(\u0026b_alignment, x, y, \u0026scoring));\n\n        // Full\n        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());\n        let f_alignment = f_aligner.custom(x, y);\n        assert_eq!(f_alignment.xend, f_alignment.xlen);\n        assert!(validate_alignment_score(\u0026f_alignment, x, y, \u0026scoring));\n\n        // Compare\n        // Passing an empty match will force the banded alignmer to band the full matrix\n        let band_all_alignment = b_aligner.custom_with_matches(x, y, \u0026Vec::new());\n        assert_eq!(band_all_alignment.score, f_alignment.score);\n    }\n\n    {\n        // banded\n        let mut aligner = banded::Aligner::with_scoring(base_score.clone(), kmer_len, window_size);\n\n        let alignment = aligner.local(x, y);\n        assert!(alignment.score \u003e= 0);\n        assert!(validate_alignment_score(\u0026alignment, x, y, \u0026base_score));\n\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.xend, alignment.xlen);\n        assert!(validate_alignment_score(\u0026alignment, x, y, \u0026base_score));\n\n        let alignment = aligner.global(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.xend, alignment.xlen);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.yend, alignment.ylen);\n        assert!(validate_alignment_score(\u0026alignment, x, y, \u0026base_score));\n    }\n\n    {\n        // full\n        let mut aligner = pairwise::Aligner::with_scoring(base_score.clone());\n\n        let alignment = aligner.local(x, y);\n        assert!(alignment.score \u003e= 0);\n        assert!(validate_alignment_score(\u0026alignment, x, y, \u0026base_score));\n\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.xend, alignment.xlen);\n        assert!(validate_alignment_score(\u0026alignment, x, y, \u0026base_score));\n\n        let alignment = aligner.global(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.xend, alignment.xlen);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.yend, alignment.ylen);\n        assert!(validate_alignment_score(\u0026alignment, x, y, \u0026base_score));\n    }\n\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","fuzz","fuzz_targets","myers_matching.rs"],"content":"#![no_main]\n#[macro_use] extern crate libfuzzer_sys;\n\nuse std::cmp::{min, max};\nuse bio::pattern_matching::myers::{MyersBuilder, Myers, long};\nuse bio::alignment::Alignment;\nuse bio::alignment::AlignmentOperation::*;\n\n\nfuzz_target!(|data: \u0026[u8]| {\n    if data.len() \u003c 3 {\n        return;\n    }\n\n    let (max_dist, data) = data.split_first().unwrap();\n    let (pattern_len, data) = data.split_first().unwrap();\n    let max_dist = min(64, *max_dist);\n    let pattern_len = max(1, min(64, min(data.len(), *pattern_len as usize)));\n\n    if data.iter().any(|\u0026b| b \u003c 65 || b \u003e 122 || b \u003e 90 \u0026\u0026 b \u003c 97) {\n        return;\n    }\n\n    let (pattern, text) = data.split_at(pattern_len);\n\n    // Test whether builders succeed\n    // TODO: Builder testing could be expanded\n    let max_dist = max_dist as u8;\n    // Test whether builders succeed\n    // TODO: Builder testing could be expanded\n    let _ = MyersBuilder::new().build_64(pattern);\n    let _ = MyersBuilder::new().build_long_64(pattern);\n\n    // Myers objects\n    let mut myers = Myers::\u003cu64\u003e::new(pattern);\n    let mut myers_long = long::Myers::\u003cu8\u003e::new(pattern);\n\n    // No traceback, just searching\n    let end_dist: Vec\u003c_\u003e = myers.find_all_end(text, max_dist).collect();\n    let end_dist_long: Vec\u003c_\u003e = myers_long.find_all_end(text, max_dist as usize)\n        .map(|(end, dist)| (end, dist as u8))\n        .collect();\n    assert_eq!(end_dist, end_dist_long);\n\n    // Test traceback algorithm:\n    // The following code compares the distance from the myers algorithm with the\n    // number of substitutions / InDels found in the alignment path. If the distances\n    // are equal, then the traceback found a valid alignment path.\n    // Additionally, the actual pattern and text are inspected; matches / substitutions\n    // that are unexpectedly (un)equal will cause a panic.\n\n    // 'Default' API\n    let mut aln = Alignment::default();\n    let mut aln_long = Alignment::default();\n    {\n        let mut matches = myers.find_all(text, max_dist);\n        let mut matches_long = myers_long.find_all(text, max_dist as usize);\n\n        matches.alignment(\u0026mut aln); // all insertions to text\n        matches_long.alignment(\u0026mut aln_long);\n\n        let mut end_dist_iter = end_dist.iter();\n        while matches.next_alignment(\u0026mut aln) {\n            assert!(matches_long.next_alignment(\u0026mut aln_long));\n            assert_eq!(aln, aln_long);\n\n            // verify alignment\n            validate_alignment(\u0026aln, pattern, text);\n            assert!(aln.score as u8 \u003c= max_dist);\n\n            // compare to find_all_end() results\n            let (end, dist) = end_dist_iter.next().unwrap();\n            assert_eq!(*end + 1, aln.yend);\n            assert_eq!(*dist, aln.score as u8);\n        }\n        assert!(end_dist_iter.next().is_none());\n        assert!(!matches_long.next_alignment(\u0026mut aln_long));\n    }\n\n    {\n        // Lazy API\n\n        let mut matches = myers.find_all_lazy(text, max_dist);\n        let mut matches_long = myers_long.find_all_lazy(text, max_dist as usize);\n        let mut end_dist_iter = end_dist.iter();\n\n        while let Some((end, dist)) = matches.next() {\n            // compare distances\n            let (end_long, dist_long) = matches_long.next().unwrap();\n            assert_eq!((end, dist), (end_long, dist_long as u8));\n\n            // compare alignments\n            assert!(matches.alignment_at(end, \u0026mut aln));\n            assert!(matches_long.alignment_at(end, \u0026mut aln_long));\n            assert_eq!(aln, aln_long);\n\n            // verify alignment\n            validate_alignment(\u0026aln, pattern, text);\n            assert_eq!(dist, aln.score as u8);\n            assert!(aln.score as u8 \u003c= max_dist);\n\n            // compare to find_all_end() results\n            let (end, dist) = end_dist_iter.next().unwrap();\n            assert_eq!(*end + 1, aln.yend);\n            assert_eq!(*dist, aln.score as u8);\n\n            // larger positions were not yet searched\n            assert!(!matches.alignment_at(end + 1, \u0026mut aln));\n        }\n        assert!(end_dist_iter.next().is_none());\n    }\n\n    // Lazy API with unlimited distance: each position should be found\n\n    let mut matches = myers.find_all_lazy(text, u8::max_value());\n    let mut matches_long = myers_long.find_all_lazy(text, u8::max_value() as usize);\n\n    let mut i = 0;\n    while let Some((end, dist)) = matches.next() {\n        assert_eq!(end, i);\n\n        // compare distances\n        let (end_long, dist_long) = matches_long.next().unwrap();\n        assert_eq!((end, dist), (end_long, dist_long as u8));\n\n        // compare alignments\n        assert!(matches.alignment_at(end, \u0026mut aln));\n        assert!(matches_long.alignment_at(end, \u0026mut aln_long));\n        assert_eq!(aln, aln_long);\n\n        // verify alignment\n        validate_alignment(\u0026aln, pattern, text);\n        assert_eq!(dist, aln.score as u8);\n        assert!(aln.score as u8 \u003c= u8::max_value());\n\n        // larger positions were not yet searched\n        assert!(!matches.alignment_at(end + 1, \u0026mut aln));\n        assert!(!matches_long.alignment_at(end + 1, \u0026mut aln_long));\n        i += 1;\n    }\n});\n\n\n// Validates an Alignment based on the sequences that were used to construct it.\n// - calculates the score using edit distance (mismatches / gap penalties = 1) and\n//   then compares it to the stored score\n// - checks if matches and substitutions are really correct given the actual sequences\nfn validate_alignment(aln: \u0026Alignment, x: \u0026[u8], y: \u0026[u8]) {\n\n    let y = \u0026y[aln.ystart..aln.yend];\n\n    let mut ix = 0;\n    let mut iy = 0;\n    let mut calc_dist = 0;\n    for op in \u0026aln.operations {\n        match *op {\n            Match =\u003e {\n                assert!(x[ix] == y[iy], \"Match operation, but characters are not equal\");\n                ix += 1;\n                iy += 1;\n            }\n            Subst =\u003e {\n                assert!(x[ix] != y[iy], \"Subst operation, but characters are equal\");\n                calc_dist += 1;\n                ix += 1;\n                iy += 1;\n            }\n            Del =\u003e {\n                calc_dist += 1;\n                iy += 1;\n            }\n            Ins =\u003e {\n                calc_dist += 1;\n                ix += 1;\n            }\n            _ =\u003e unreachable!()\n        }\n    }\n\n    assert_eq!(calc_dist, aln.score as usize);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","alignment","distance.rs"],"content":"// Copyright 2015-2017 Vadim Nazarov, Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Various subroutines for computing a distance between sequences. Features\n//! both scalar and efficient vectorized distance functions with SIMD.\n\nuse std::cmp::min;\n\nuse crate::utils::TextSlice;\n\n/// Compute the Hamming distance between two strings. Complexity: O(n).\n///\n/// # Example\n///\n/// ```\n/// use bio::alignment::distance::*;\n///\n/// let x = b\"GTCTGCATGCG\";\n/// let y = b\"TTTAGCTAGCG\";\n/// // GTCTGCATGCG\n/// //  |  ||  |||\n/// // TTTAGCTAGCG\n/// assert_eq!(hamming(x, y), 5);\n/// ```\npub fn hamming(alpha: TextSlice\u003c'_\u003e, beta: TextSlice\u003c'_\u003e) -\u003e u64 {\n    assert_eq!(\n        alpha.len(),\n        beta.len(),\n        \"hamming distance cannot be calculated for texts of different length ({}!={})\",\n        alpha.len(),\n        beta.len()\n    );\n    let mut dist = 0;\n    for (a, b) in alpha.iter().zip(beta) {\n        if a != b {\n            dist += 1;\n        }\n    }\n    dist\n}\n\n/// Compute the Levenshtein (or Edit) distance between two strings. Complexity: O(n * m) with\n/// n and m being the length of the given texts.\n///\n/// # Example\n///\n/// ```\n/// use bio::alignment::distance::*;\n///\n/// let x = b\"ACCGTGGAT\";\n/// let y = b\"AAAAACCGTTGAT\";\n/// // ----ACCGTGGAT\n/// //     ||||| |||\n/// // AAAAACCGTTGAT\n/// let ldist = levenshtein(x, y); // Distance is 5\n/// assert_eq!(ldist, 5);\n/// ```\n#[allow(unused_assignments)]\npub fn levenshtein(alpha: TextSlice\u003c'_\u003e, beta: TextSlice\u003c'_\u003e) -\u003e u32 {\n    let mut columns = [vec![0u32; alpha.len() + 1], vec![0u32; alpha.len() + 1]];\n    let mut i_prev = 0;\n    let mut i_cur = 1;\n\n    for i in 0..columns[0].len() {\n        columns[0][i] = i as u32;\n    }\n\n    for (j, item) in beta.iter().enumerate() {\n        i_cur %= 2;\n        i_prev = 1 - i_cur;\n\n        columns[i_cur][0] = 1 + j as u32;\n        for i in 1..columns[0].len() {\n            columns[i_cur][i] = min(\n                columns[i_prev][i - 1] + if alpha[i - 1] == *item { 0 } else { 1 },\n                min(columns[i_cur][i - 1] + 1, columns[i_prev][i] + 1),\n            );\n        }\n\n        i_cur += 1;\n    }\n\n    columns[i_cur - 1][columns[0].len() - 1]\n}\n\npub mod simd {\n    //! String distance routines accelerated with Single Instruction Multiple Data (SIMD)\n    //! intrinsics.\n    //!\n    //! These routines will automatically fallback to scalar versions if AVX2 or SSE4.1 is\n    //! not supported by the CPU.\n    //!\n    //! With AVX2, SIMD-accelerated Hamming distance can reach up to 40 times faster than\n    //! the scalar version on strings that are long enough.\n    //!\n    //! The performance of SIMD-accelerated Levenshtein distance depends on the number of\n    //! edits between two strings, so it can perform anywhere from 2 times to nearly 1000\n    //! times faster than the scalar version. When the two strings are completely different,\n    //! there could be no speedup at all. It is important to note that the algorithms work\n    //! best when the number of edits is known to be small compared to the length of the\n    //! strings (for example, 10% difference). This should be applicable in many situations.\n    //!\n    //! If AVX2 support is not available, there is a speed penalty for using SSE4.1 with\n    //! smaller vectors.\n\n    use crate::utils::TextSlice;\n\n    /// SIMD-accelerated Hamming distance between two strings. Complexity: O(n / w), for\n    /// SIMD vectors of length w (usually w = 16 or w = 32).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alignment::distance::simd::*;\n    ///\n    /// let x = b\"GTCTGCATGCG\";\n    /// let y = b\"TTTAGCTAGCG\";\n    /// // GTCTGCATGCG\n    /// //  |  ||  |||\n    /// // TTTAGCTAGCG\n    /// assert_eq!(hamming(x, y), 5);\n    /// ```\n    pub fn hamming(alpha: TextSlice\u003c'_\u003e, beta: TextSlice\u003c'_\u003e) -\u003e u64 {\n        assert_eq!(\n            alpha.len(),\n            beta.len(),\n            \"simd hamming distance cannot be calculated for texts of different length ({}!={})\",\n            alpha.len(),\n            beta.len()\n        );\n        // triple_accel Hamming routine returns an u32\n        triple_accel::hamming(alpha, beta) as u64\n    }\n\n    /// SIMD-accelerated Levenshtein (or Edit) distance between two strings. Complexity:\n    /// O(k / w * (n + m)), with n and m being the length of the given texts, k being the\n    /// number of edits, and w being the length of the SIMD vectors (usually w = 16 or\n    /// w = 32).\n    ///\n    /// Uses exponential search, which is approximately two times slower than the usual\n    /// O(n * m) implementation if the number of edits between the two strings is very large,\n    /// but much faster for cases where the edit distance is low (when less than half of the\n    /// characters in the strings differ).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alignment::distance::simd::*;\n    ///\n    /// let x = b\"ACCGTGGAT\";\n    /// let y = b\"AAAAACCGTTGAT\";\n    /// // ----ACCGTGGAT\n    /// //     ||||| |||\n    /// // AAAAACCGTTGAT\n    /// let ldist = levenshtein(x, y); // Distance is 5\n    /// assert_eq!(ldist, 5);\n    /// ```\n    pub fn levenshtein(alpha: TextSlice\u003c'_\u003e, beta: TextSlice\u003c'_\u003e) -\u003e u32 {\n        triple_accel::levenshtein_exp(alpha, beta)\n    }\n\n    /// SIMD-accelerated bounded Levenshtein (or Edit) distance between two strings.\n    /// Complexity: O(k / w * (n + m)), with n and m being the length of the given texts,\n    /// k being the threshold on the number of edits, and w being the length of the SIMD vectors\n    /// (usually w = 16 or w = 32).\n    ///\n    /// If the Levenshtein distance between two strings is greater than the threshold k, then\n    /// `None` is returned. This is useful for efficiently calculating whether two strings\n    /// are similar.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alignment::distance::simd::*;\n    ///\n    /// let x = b\"ACCGTGGAT\";\n    /// let y = b\"AAAAACCGTTGAT\";\n    /// // ----ACCGTGGAT\n    /// //     ||||| |||\n    /// // AAAAACCGTTGAT\n    /// let ldist = bounded_levenshtein(x, y, 5); // Distance is 5\n    /// assert_eq!(ldist, Some(5));\n    ///\n    /// let ldist = bounded_levenshtein(x, y, 4); // Threshold too low!\n    /// assert_eq!(ldist, None);\n    /// ```\n    pub fn bounded_levenshtein(alpha: TextSlice\u003c'_\u003e, beta: TextSlice\u003c'_\u003e, k: u32) -\u003e Option\u003cu32\u003e {\n        triple_accel::levenshtein::levenshtein_simd_k(alpha, beta, k)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use std::u32;\n\n    #[test]\n    fn test_hamming_dist_good() {\n        let x = b\"GTCTGCATGCG\";\n        let y = b\"TTTAGCTAGCG\";\n        // GTCTGCATGCG\n        //  |  ||  |||\n        // TTTAGCTAGCG\n        assert_eq!(hamming(x, y), 5);\n    }\n\n    #[test]\n    fn test_simd_hamming_dist_good() {\n        let x = b\"GTCTGCATGCG\";\n        let y = b\"TTTAGCTAGCG\";\n        // GTCTGCATGCG\n        //  |  ||  |||\n        // TTTAGCTAGCG\n        assert_eq!(simd::hamming(x, y), 5);\n    }\n\n    #[test]\n    #[should_panic(\n        expected = \"hamming distance cannot be calculated for texts of different length (11!=8)\"\n    )]\n    fn test_hamming_dist_bad() {\n        let x = b\"GACTATATCGA\";\n        let y = b\"TTTAGCTC\";\n        hamming(x, y);\n    }\n\n    #[test]\n    #[should_panic(\n        expected = \"simd hamming distance cannot be calculated for texts of different length (11!=8)\"\n    )]\n    fn test_simd_hamming_dist_bad() {\n        let x = b\"GACTATATCGA\";\n        let y = b\"TTTAGCTC\";\n        simd::hamming(x, y);\n    }\n\n    #[test]\n    fn test_levenshtein_dist() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        // ----ACCGTGGAT\n        //     ||||| |||\n        // AAAAACCGTTGAT\n        assert_eq!(levenshtein(x, y), 5);\n        assert_eq!(levenshtein(x, y), levenshtein(y, x));\n        assert_eq!(levenshtein(b\"AAA\", b\"TTTT\"), 4);\n        assert_eq!(levenshtein(b\"TTTT\", b\"AAA\"), 4);\n    }\n\n    #[test]\n    fn test_simd_levenshtein_dist() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        // ----ACCGTGGAT\n        //     ||||| |||\n        // AAAAACCGTTGAT\n        assert_eq!(simd::levenshtein(x, y), 5);\n        assert_eq!(simd::levenshtein(x, y), simd::levenshtein(y, x));\n        assert_eq!(simd::levenshtein(b\"AAA\", b\"TTTT\"), 4);\n        assert_eq!(simd::levenshtein(b\"TTTT\", b\"AAA\"), 4);\n    }\n\n    #[test]\n    fn test_simd_bounded_levenshtein_dist() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        // ----ACCGTGGAT\n        //     ||||| |||\n        // AAAAACCGTTGAT\n        assert_eq!(simd::bounded_levenshtein(x, y, u32::MAX), Some(5));\n        assert_eq!(\n            simd::bounded_levenshtein(x, y, u32::MAX),\n            simd::bounded_levenshtein(y, x, u32::MAX)\n        );\n        assert_eq!(\n            simd::bounded_levenshtein(b\"AAA\", b\"TTTT\", u32::MAX),\n            Some(4)\n        );\n        assert_eq!(\n            simd::bounded_levenshtein(b\"TTTT\", b\"AAA\", u32::MAX),\n            Some(4)\n        );\n    }\n}\n","traces":[{"line":27,"address":[5843664],"length":1,"stats":{"Line":0},"fn_name":"hamming"},{"line":28,"address":[5843949,5843761,5843903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[5843723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[5843747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[5843911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[5843935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[5843860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[5844573,5843872,5844266,5844402,5844578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[5844466,5844541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[5844504,5844543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[5844592,5845047],"length":1,"stats":{"Line":0},"fn_name":"levenshtein"},{"line":62,"address":[5844663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[5844993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[5845005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[5845192,5845349,5845017,5845444,5845070],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[5845389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[5845693,5847426,5845465,5845316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[5845773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[5845793,5845864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[5845845,5845897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[5846063,5847405,5846330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[5847269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[5846827,5846370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[5846876,5846798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[5847431,5847418,5846294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[5847472,5845657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[5915520],"length":1,"stats":{"Line":0},"fn_name":"hamming"},{"line":126,"address":[5915733,5915779,5915614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[5915579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[5915600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[5915741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[5915765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[5916080,5915708],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[5916096],"length":1,"stats":{"Line":0},"fn_name":"levenshtein"},{"line":161,"address":[5916120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[5916144],"length":1,"stats":{"Line":0},"fn_name":"bounded_levenshtein"},{"line":190,"address":[5916173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[6310896],"length":1,"stats":{"Line":0},"fn_name":"test_hamming_dist_good"},{"line":202,"address":[6310903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[6310915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[6311045,6310927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[6311088],"length":1,"stats":{"Line":0},"fn_name":"test_simd_hamming_dist_good"},{"line":212,"address":[6311095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[6311107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[6311119,6311237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[6311280],"length":1,"stats":{"Line":0},"fn_name":"test_hamming_dist_bad"},{"line":225,"address":[6311284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[6311296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[6311308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[6311344],"length":1,"stats":{"Line":0},"fn_name":"test_simd_hamming_dist_bad"},{"line":235,"address":[6311348],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[6311360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[6311372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[6311408],"length":1,"stats":{"Line":0},"fn_name":"test_levenshtein_dist"},{"line":242,"address":[6311415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[6311430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[6311445,6311596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[6311806,6311548,6311635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[6311854,6311987,6311758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[6311939,6312136,6312035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[6312192],"length":1,"stats":{"Line":0},"fn_name":"test_simd_levenshtein_dist"},{"line":255,"address":[6312199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[6312214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[6312380,6312229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[6312590,6312419,6312332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[6312638,6312542,6312771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[6312723,6312920,6312819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[6312976],"length":1,"stats":{"Line":0},"fn_name":"test_simd_bounded_levenshtein_dist"},{"line":268,"address":[6312983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[6312998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[6313029,6313180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[6313424,6313270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[6313119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[6313221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[6313468,6313621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[6313363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[6313665,6313773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[6313560],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":78},{"path":["/","home","todd","rust-bio","src","alignment","mod.rs"],"content":"// Copyright 2014-2015 Johannes Köster, Vadim Nazarov, Patrick Marks\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Various alignment and distance computing algorithms.\n\npub mod distance;\npub mod pairwise;\npub mod poa;\npub mod sparse;\n\n// Re-export the alignment types.\npub use bio_types::alignment::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","alignment","pairwise","banded.rs"],"content":"// Copyright 2014-2015 Johannes Köster, Vadim Nazarov, Patrick Marks\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Banded Smith-Waterman alignment for fast comparison of long strings.\n//! Use sparse dynamic programming to find a 'backbone' alignment from exact\n//! k-mer matches, then compute the SW alignment in a 'band' surrounding the\n//! backbone, with a configurable width w. This method is not guaranteed\n//! to recover the Smith-Waterman alignment, but will usually find the same\n//! alignment if a) there is a reasonable density of exact k-mer matches\n//! between the sequences, and b) the width parameter w is larger than the\n//! excursion of the alignment path from diagonal between successive kmer\n//! matches.  This technique is employed in long-read aligners (e.g. BLASR and BWA)\n//! to drastically reduce runtime compared to Smith Waterman.\n//! Complexity roughly O(min(m,n) * w)\n//!\n//! # Example\n//!\n//! ```\n//! use bio::alignment::pairwise::banded::*;\n//! use bio::alignment::pairwise::{Scoring, MIN_SCORE};\n//! use bio::alignment::sparse::hash_kmers;\n//! use bio::alignment::AlignmentOperation::*;\n//! use std::iter::repeat;\n//!\n//! let x = b\"AGCACACGTGTGCGCTATACAGTAAGTAGTAGTACACGTGTCACAGTTGTACTAGCATGAC\";\n//! let y = b\"AGCACACGTGTGCGCTATACAGTACACGTGTCACAGTTGTACTAGCATGAC\";\n//! let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n//! let k = 8; // kmer match length\n//! let w = 6; // Window size for creating the band\n//! let mut aligner = Aligner::new(-5, -1, score, k, w);\n//! let alignment = aligner.local(x, y);\n//! // aligner.global(x, y), aligner.semiglobal(x, y) are also supported\n//! assert_eq!(alignment.ystart, 0);\n//! assert_eq!(alignment.xstart, 0);\n//!\n//! // For cases where the reference is reused multiple times, we can invoke the\n//! // pre-hashed version of the solver\n//! let x = b\"AGCACAAGTGTGCGCTATACAGGAAGTAGGAGTACACGTGTCA\";\n//! let y = b\"CAGTTGTACTAGCATGACCAGTTGTACTAGCATGACAGCACACGTGTGCGCTATACAGTAAGTAGTAGTACACGTGTCA\\\n//!     CAGTTGTACTAGCATGACCAGTTGTACTAGCATGAC\";\n//! let y_kmers_hash = hash_kmers(y, k);\n//! let alignment = aligner.semiglobal_with_prehash(x, y, \u0026y_kmers_hash);\n//! assert_eq!(alignment.score, 37);\n//!\n//! // In addition to the standard modes (Global, Semiglobal and Local), a custom alignment\n//! // mode is supported which supports a user-specified clipping penalty. Clipping is a\n//! // special boundary condition where you are allowed to clip off the beginning/end of\n//! // the sequence for a fixed penalty. See bio::alignment::pairwise for a more detailed\n//! // explanation\n//!\n//! // The following example considers a modification of the semiglobal mode where you are allowed\n//! // to skip a prefix of the target sequence x, for a penalty of -10, but you have to consume\n//! // the rest of the string in the alignment\n//!\n//! let scoring = Scoring {\n//!     gap_open: -5,\n//!     gap_extend: -1,\n//!     match_fn: |a: u8, b: u8| if a == b { 1i32 } else { -3i32 },\n//!     match_scores: Some((1, -3)),\n//!     xclip_prefix: -10,\n//!     xclip_suffix: MIN_SCORE,\n//!     yclip_prefix: 0,\n//!     yclip_suffix: 0,\n//! };\n//! let x = b\"GGGGGGACGTACGTACGTGTGCATCATCATGTGCGTATCATAGATAGATGTAGATGATCCACAGT\";\n//! let y = b\"AAAAACGTACGTACGTGTGCATCATCATGTGCGTATCATAGATAGATGTAGATGATCCACAGTAAAA\";\n//! let mut aligner = Aligner::with_capacity_and_scoring(x.len(), y.len(), scoring, k, w);\n//! let alignment = aligner.custom(x, y);\n//! println!(\"{}\", alignment.pretty(x, y));\n//! assert_eq!(alignment.score, 49);\n//! let mut correct_ops = Vec::new();\n//! correct_ops.push(Yclip(4));\n//! correct_ops.push(Xclip(6));\n//! correct_ops.extend(repeat(Match).take(59));\n//! correct_ops.push(Yclip(4));\n//! assert_eq!(alignment.operations, correct_ops);\n//!\n//! // aligner.custom_with_prehash(x, y, \u0026y_kmers_hash) is also supported\n//! ```\n\nuse crate::alignment::{Alignment, AlignmentOperation};\nuse crate::utils::TextSlice;\nuse std::cmp::{max, min, Ordering};\nuse std::i32;\nuse std::ops::Range;\n\nuse super::*;\nuse crate::alignment::pairwise::Scoring;\nuse crate::alignment::sparse;\nuse crate::alignment::sparse::HashMapFx;\n\nconst MAX_CELLS: usize = 5_000_000;\nconst DEFAULT_MATCH_SCORE: i32 = 2;\n\n/// A banded implementation of Smith-Waterman aligner (SWA).\n/// Unlike the full SWA, this implementation computes the alignment between a pair of sequences\n/// only inside a 'band' withing the dynamic programming matrix. The band is constructed using the\n/// Sparse DP routine (see sparse::sdpkpp), which uses kmer matches to build the best common\n/// subsequence (including gap penalties) between the two strings. The band is constructed around\n/// this subsequence (using the window length 'w'), filling in the gaps.\n///\n/// In the case where there are no k-mer matches, the  aligner will fall back to a full alignment,\n/// by setting the band to contain the full matrix.\n///\n/// Banded aligner will proceed to compute the alignment only when the total number of cells\n/// in the band is less than MAX_CELLS (currently set to 10 million), otherwise it returns an\n/// empty alignment\n#[allow(non_snake_case)]\npub struct Aligner\u003cF: MatchFunc\u003e {\n    S: [Vec\u003ci32\u003e; 2],\n    I: [Vec\u003ci32\u003e; 2],\n    D: [Vec\u003ci32\u003e; 2],\n    Lx: Vec\u003cusize\u003e,\n    Ly: Vec\u003cusize\u003e,\n    Sn: Vec\u003ci32\u003e,\n    traceback: Traceback,\n    scoring: Scoring\u003cF\u003e,\n\n    band: Band,\n    k: usize,\n    w: usize,\n}\n\nconst DEFAULT_ALIGNER_CAPACITY: usize = 200;\n\nimpl\u003cF: MatchFunc\u003e Aligner\u003cF\u003e {\n    /// Create new aligner instance with given gap open and gap extend penalties\n    /// and the score function.\n    ///\n    /// # Arguments\n    ///\n    /// * `gap_open` - the score for opening a gap (should be negative)\n    /// * `gap_extend` - the score for extending a gap (should be negative)\n    /// * `match_fn` - function that returns the score for substitutions (also see bio::scores)\n    /// * `k` - kmer length used in constructing the band\n    /// * `w` - width of the band\n    pub fn new(gap_open: i32, gap_extend: i32, match_fn: F, k: usize, w: usize) -\u003e Self {\n        Aligner::with_capacity(\n            DEFAULT_ALIGNER_CAPACITY,\n            DEFAULT_ALIGNER_CAPACITY,\n            gap_open,\n            gap_extend,\n            match_fn,\n            k,\n            w,\n        )\n    }\n\n    /// Create new aligner instance. The size hints help to\n    /// avoid unnecessary memory allocations.\n    ///\n    /// # Arguments\n    ///\n    /// * `m` - the expected size of x\n    /// * `n` - the expected size of y\n    /// * `gap_open` - the score for opening a gap (should be negative)\n    /// * `gap_extend` - the score for extending a gap (should be negative)\n    /// * `match_fn` - function that returns the score for substitutions (also see bio::scores)\n    /// * `k` - kmer length used in constructing the band\n    /// * `w` - width of the band\n    pub fn with_capacity(\n        m: usize,\n        n: usize,\n        gap_open: i32,\n        gap_extend: i32,\n        match_fn: F,\n        k: usize,\n        w: usize,\n    ) -\u003e Self {\n        Aligner {\n            band: Band::new(m, n),\n            S: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            I: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            D: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            Lx: Vec::with_capacity(n + 1),\n            Ly: Vec::with_capacity(m + 1),\n            Sn: Vec::with_capacity(m + 1),\n            traceback: Traceback::with_capacity(m, n),\n            scoring: Scoring::new(gap_open, gap_extend, match_fn),\n            k,\n            w,\n        }\n    }\n\n    /// Create new aligner instance with scoring and size hint. The size hints help to\n    /// avoid unnecessary memory allocations.\n    ///\n    /// # Arguments\n    ///\n    /// * `m` - the expected size of x\n    /// * `n` - the expected size of y\n    /// * `scoring` - the scoring struct\n    /// * `k` - kmer length used in constructing the band\n    /// * `w` - width of the band\n    pub fn with_capacity_and_scoring(\n        m: usize,\n        n: usize,\n        scoring: Scoring\u003cF\u003e,\n        k: usize,\n        w: usize,\n    ) -\u003e Self {\n        assert!(scoring.gap_open \u003c= 0, \"gap_open can't be positive\");\n        assert!(scoring.gap_extend \u003c= 0, \"gap_extend can't be positive\");\n        assert!(\n            scoring.xclip_prefix \u003c= 0,\n            \"Clipping penalty (x prefix) can't be positive\"\n        );\n        assert!(\n            scoring.xclip_suffix \u003c= 0,\n            \"Clipping penalty (x suffix) can't be positive\"\n        );\n        assert!(\n            scoring.yclip_prefix \u003c= 0,\n            \"Clipping penalty (y prefix) can't be positive\"\n        );\n        assert!(\n            scoring.yclip_suffix \u003c= 0,\n            \"Clipping penalty (y suffix) can't be positive\"\n        );\n\n        Aligner {\n            band: Band::new(m, n),\n            S: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            I: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            D: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            Lx: Vec::with_capacity(n + 1),\n            Ly: Vec::with_capacity(m + 1),\n            Sn: Vec::with_capacity(m + 1),\n            traceback: Traceback::with_capacity(m, n),\n            scoring,\n            k,\n            w,\n        }\n    }\n\n    /// Create new aligner instance with scoring and size hint. The size hints help to\n    /// avoid unnecessary memory allocations.\n    ///\n    /// # Arguments\n    ///\n    /// * `m` - the expected size of x\n    /// * `n` - the expected size of y\n    /// * `scoring` - the scoring struct\n    /// * `k` - kmer length used in constructing the band\n    /// * `w` - width of the band\n    pub fn with_scoring(scoring: Scoring\u003cF\u003e, k: usize, w: usize) -\u003e Self {\n        Aligner::with_capacity_and_scoring(\n            DEFAULT_ALIGNER_CAPACITY,\n            DEFAULT_ALIGNER_CAPACITY,\n            scoring,\n            k,\n            w,\n        )\n    }\n\n    /// Return a mutable reference to scoring. Useful if you want to have a\n    /// single aligner object but want to modify the scores within it for\n    /// different cases\n    pub fn get_mut_scoring(\u0026mut self) -\u003e \u0026mut Scoring\u003cF\u003e {\n        \u0026mut self.scoring\n    }\n\n    /// Compute the alignment with custom clip penalties\n    ///\n    /// # Arguments\n    ///\n    /// * `x` - Textslice\n    /// * `y` - Textslice\n    pub fn custom(\u0026mut self, x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) -\u003e Alignment {\n        self.band = Band::create(x, y, self.k, self.w, \u0026self.scoring);\n        self.compute_alignment(x, y)\n    }\n\n    /// Compute the alignment with custom clip penalties with 'y' being pre-hashed\n    /// (see sparse::hash_kmers)\n    ///\n    /// # Arguments\n    ///\n    /// * `x` - Textslice\n    /// * `y` - Textslice\n    pub fn custom_with_prehash(\n        \u0026mut self,\n        x: TextSlice\u003c'_\u003e,\n        y: TextSlice\u003c'_\u003e,\n        y_kmer_hash: \u0026HashMapFx\u003c\u0026[u8], Vec\u003cu32\u003e\u003e,\n    ) -\u003e Alignment {\n        self.band = Band::create_with_prehash(x, y, self.k, self.w, \u0026self.scoring, y_kmer_hash);\n        self.compute_alignment(x, y)\n    }\n\n    /// Compute the alignment with custom clip penalties with the kmer matches\n    /// between x and y being pre-computed as a Vector of pairs (xpos, ypos)\n    /// and sorted.\n    ///\n    /// # Arguments\n    ///\n    /// * `x` - Textslice\n    /// * `y` - Textslice\n    /// * `matches` - Vector of kmer matching pairs (xpos, ypos)\n    pub fn custom_with_matches(\n        \u0026mut self,\n        x: TextSlice\u003c'_\u003e,\n        y: TextSlice\u003c'_\u003e,\n        matches: \u0026[(u32, u32)],\n    ) -\u003e Alignment {\n        self.band = Band::create_with_matches(x, y, self.k, self.w, \u0026self.scoring, \u0026matches);\n        self.compute_alignment(x, y)\n    }\n\n    /// Compute the alignment with custom clip penalties with the kmer matches\n    /// between x and y being pre-computed as a Vector of pairs (xpos, ypos)\n    /// and sorted. The matches are expanded diagonally in both directions\n    /// allowing upto a user specified number of mismatches. This is useful\n    /// in constructing the band correctly, particularly when a higher frequency\n    /// of mismatches are expected.\n    ///\n    /// # Arguments\n    ///\n    /// * `x` - Textslice\n    /// * `y` - Textslice\n    /// * `matches` - Vector of kmer matching pairs (xpos, ypos)\n    /// * `allowed_mismatches` - Extend the matches diagonally allowing upto\n    /// the specified number of mismatches (Option\u003cusize\u003e)\n    /// * `use_lcskpp_union` - Extend the results from sdpkpp using lcskpp\n    pub fn custom_with_expanded_matches(\n        \u0026mut self,\n        x: TextSlice\u003c'_\u003e,\n        y: TextSlice\u003c'_\u003e,\n        matches: Vec\u003c(u32, u32)\u003e,\n        allowed_mismatches: Option\u003cusize\u003e,\n        use_lcskpp_union: bool,\n    ) -\u003e Alignment {\n        let expanded_matches = match allowed_mismatches {\n            Some(m) =\u003e sparse::expand_kmer_matches(x, y, self.k, \u0026matches, m),\n            None =\u003e matches,\n        };\n\n        self.band = if use_lcskpp_union {\n            let match_score = match self.scoring.match_scores {\n                Some((m, _)) =\u003e m,\n                None =\u003e DEFAULT_MATCH_SCORE,\n            };\n            let path = sparse::sdpkpp_union_lcskpp_path(\n                \u0026expanded_matches,\n                self.k,\n                match_score as u32,\n                self.scoring.gap_open,\n                self.scoring.gap_extend,\n            );\n            Band::create_from_match_path(\n                x,\n                y,\n                self.k,\n                self.w,\n                \u0026self.scoring,\n                \u0026path,\n                \u0026expanded_matches,\n            )\n        } else {\n            Band::create_with_matches(x, y, self.k, self.w, \u0026self.scoring, \u0026expanded_matches)\n        };\n\n        self.compute_alignment(x, y)\n    }\n\n    /// Compute the alignment with custom clip penalties by constructing\n    /// a band along the `matches` as defined by `path`. This is only\n    /// for advanced uses, where one would want to control the kmer\n    /// backbone that is used for creating the band.\n    ///\n    /// # Arguments\n    ///\n    /// * `x` - Textslice\n    /// * `y` - Textslice\n    /// * `matches` - Vector of kmer matching pairs (xpos, ypos)\n    /// * `path` - Vector of indices pointing to `matches` vector\n    /// which defines a path. The validity of the path is not checked.\n    pub fn custom_with_match_path(\n        \u0026mut self,\n        x: TextSlice,\n        y: TextSlice,\n        matches: \u0026[(u32, u32)],\n        path: \u0026[usize],\n    ) -\u003e Alignment {\n        self.band =\n            Band::create_from_match_path(x, y, self.k, self.w, \u0026self.scoring, path, matches);\n        self.compute_alignment(x, y)\n    }\n\n    // Computes the alignment. The band needs to be populated prior\n    // to calling this function\n    #[inline(never)]\n    fn compute_alignment(\u0026mut self, x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) -\u003e Alignment {\n        if self.band.num_cells() \u003e MAX_CELLS {\n            // Too many cells in the band. Return an empty alignment\n            return Alignment {\n                score: MIN_SCORE,\n                ystart: 0,\n                xstart: 0,\n                yend: 0,\n                xend: 0,\n                ylen: 0,\n                xlen: 0,\n                operations: Vec::new(),\n                mode: AlignmentMode::Custom,\n            };\n        }\n\n        let (m, n) = (x.len(), y.len());\n        self.traceback.init(m, n);\n\n        for k in 0..2 {\n            self.I[k].clear();\n            self.D[k].clear();\n            self.S[k].clear();\n            self.D[k].extend(repeat(MIN_SCORE).take(m + 1));\n            self.I[k].extend(repeat(MIN_SCORE).take(m + 1));\n            self.S[k].extend(repeat(MIN_SCORE).take(m + 1));\n        }\n        self.Lx.clear();\n        self.Lx.extend(repeat(0usize).take(n + 1));\n        self.Ly.clear();\n        self.Ly.extend(repeat(0usize).take(m + 1));\n        self.Sn.clear();\n        self.Sn.extend(repeat(MIN_SCORE).take(m + 1));\n\n        {\n            // Handle j = 0\n            let curr = 0;\n            let i_start = self.band.ranges[0].start;\n            let i_end = self.band.ranges[0].end;\n            if i_start == 0 {\n                self.S[curr][0] = 0;\n            }\n\n            for i in max(1, i_start)..i_end {\n                let mut tb = TracebackCell::new();\n                tb.set_all(TB_START);\n                if i == 1 {\n                    self.I[curr][i] = self.scoring.gap_open + self.scoring.gap_extend;\n                    tb.set_i_bits(TB_START);\n                } else {\n                    // Insert all i characters\n                    let i_score = self.scoring.gap_open + self.scoring.gap_extend * (i as i32);\n                    let c_score =\n                        self.scoring.xclip_prefix + self.scoring.gap_open + self.scoring.gap_extend; // Clip then insert\n                    if i_score \u003e c_score {\n                        self.I[curr][i] = i_score;\n                        tb.set_i_bits(TB_INS);\n                    } else {\n                        self.I[curr][i] = c_score;\n                        tb.set_i_bits(TB_XCLIP_PREFIX);\n                    }\n                }\n\n                if i == m {\n                    tb.set_s_bits(TB_XCLIP_SUFFIX);\n                }\n\n                if self.I[curr][i] \u003e self.S[curr][i] {\n                    self.S[curr][i] = self.I[curr][i];\n                    tb.set_s_bits(TB_INS);\n                }\n\n                if self.scoring.xclip_prefix \u003e self.S[curr][i] {\n                    self.S[curr][i] = self.scoring.xclip_prefix;\n                    tb.set_s_bits(TB_XCLIP_PREFIX);\n                }\n\n                // Track the score if we do a suffix clip (x) after this character\n                if self.S[curr][i] + self.scoring.xclip_suffix \u003e self.S[curr][m] {\n                    self.S[curr][m] = self.S[curr][i] + self.scoring.xclip_suffix;\n                    self.Lx[0] = m - i;\n                    self.traceback.get_mut(m, 0).set_s_bits(TB_XCLIP_SUFFIX);\n                }\n\n                self.traceback.set(i, 0, tb);\n            }\n\n            for i in i_end..min(m + 1, self.band.ranges[min(n, 1)].end) {\n                self.S[curr][i] = MIN_SCORE;\n                self.I[curr][i] = MIN_SCORE;\n            }\n\n            if i_end \u003c (m + 1) {\n                self.S[curr][m] = MIN_SCORE;\n            }\n            // Track the score if we do clip (y) from origin\n            if self.scoring.yclip_prefix \u003e self.scoring.yclip_suffix {\n                self.Sn[0] = self.scoring.yclip_prefix;\n                self.traceback.get_mut(0, n).set_s_bits(TB_YCLIP_PREFIX);\n            } else {\n                self.Sn[0] = self.scoring.yclip_suffix;\n                self.Ly[0] = n;\n                self.traceback.get_mut(0, n).set_s_bits(TB_YCLIP_SUFFIX);\n            }\n        }\n\n        for j in 1..=n {\n            let curr = j % 2;\n            let prev = 1 - curr;\n\n            let i_start = self.band.ranges[j].start;\n            let i_end = self.band.ranges[j].end;\n\n            if i_start == 0 {\n                // Handle i = 0\n                let mut tb = TracebackCell::new();\n                self.I[curr][0] = MIN_SCORE;\n\n                if j == 1 {\n                    self.D[curr][0] = self.scoring.gap_open + self.scoring.gap_extend;\n                    tb.set_d_bits(TB_START);\n                } else {\n                    // Delete all j characters\n                    let d_score = self.scoring.gap_open + self.scoring.gap_extend * (j as i32);\n                    let c_score =\n                        self.scoring.yclip_prefix + self.scoring.gap_open + self.scoring.gap_extend;\n                    if d_score \u003e c_score {\n                        self.D[curr][0] = d_score;\n                        tb.set_d_bits(TB_DEL);\n                    } else {\n                        self.D[curr][0] = c_score;\n                        tb.set_d_bits(TB_YCLIP_PREFIX);\n                    }\n                }\n\n                if self.D[curr][0] \u003e self.scoring.yclip_prefix {\n                    self.S[curr][0] = self.D[curr][0];\n                    tb.set_s_bits(TB_DEL);\n                } else {\n                    self.S[curr][0] = self.scoring.yclip_prefix;\n                    tb.set_s_bits(TB_YCLIP_PREFIX);\n                }\n\n                // Track the score if we do suffix clip (y) from here\n                if self.S[curr][0] + self.scoring.yclip_suffix \u003e self.Sn[0] {\n                    self.Sn[0] = self.S[curr][0] + self.scoring.yclip_suffix;\n                    self.Ly[0] = n - j;\n                    self.traceback.get_mut(0, n).set_s_bits(TB_YCLIP_SUFFIX);\n                }\n                self.traceback.set(0, j, tb);\n            }\n\n            for i in i_start.saturating_sub(1)..i_start {\n                self.S[curr][i] = MIN_SCORE;\n                self.I[curr][i] = MIN_SCORE;\n                self.D[curr][i] = MIN_SCORE;\n            }\n            self.S[curr][m] = MIN_SCORE;\n\n            let q = y[j - 1];\n            let xclip_score = self.scoring.xclip_prefix\n                + max(\n                    if j == n {\n                        max(self.scoring.yclip_prefix, self.Sn[0])\n                    } else {\n                        self.scoring.yclip_prefix\n                    },\n                    self.scoring.gap_open + self.scoring.gap_extend * (j as i32),\n                );\n\n            for i in max(1, i_start)..i_end {\n                let p = x[i - 1];\n                let mut tb = TracebackCell::new();\n\n                let m_score = self.S[prev][i - 1] + self.scoring.match_fn.score(p, q);\n\n                let i_score = self.I[curr][i - 1] + self.scoring.gap_extend;\n                let s_score = self.S[curr][i - 1] + self.scoring.gap_open + self.scoring.gap_extend;\n                let mut best_i_score;\n                if i_score \u003e s_score {\n                    best_i_score = i_score;\n                    tb.set_i_bits(TB_INS);\n                } else {\n                    best_i_score = s_score;\n                    tb.set_i_bits(self.traceback.get(i - 1, j).get_s_bits());\n                }\n                if j == n {\n                    let clip_score =\n                        self.Sn[i - 1] + self.scoring.gap_open + self.scoring.gap_extend;\n                    if clip_score \u003e best_i_score {\n                        best_i_score = clip_score;\n                        tb.set_i_bits(TB_YCLIP_SUFFIX);\n                    }\n                }\n\n                let d_score = self.D[prev][i] + self.scoring.gap_extend;\n                let s_score = self.S[prev][i] + self.scoring.gap_open + self.scoring.gap_extend;\n                let best_d_score;\n                if d_score \u003e s_score {\n                    best_d_score = d_score;\n                    tb.set_d_bits(TB_DEL);\n                } else {\n                    best_d_score = s_score;\n                    tb.set_d_bits(self.traceback.get(i, j - 1).get_s_bits());\n                }\n\n                if i == m {\n                    tb.set_s_bits(TB_XCLIP_SUFFIX);\n                } else {\n                    self.S[curr][i] = MIN_SCORE;\n                }\n                let mut best_s_score = self.S[curr][i];\n\n                if m_score \u003e best_s_score {\n                    best_s_score = m_score;\n                    tb.set_s_bits(if p == q { TB_MATCH } else { TB_SUBST });\n                }\n\n                if best_i_score \u003e best_s_score {\n                    best_s_score = best_i_score;\n                    tb.set_s_bits(TB_INS);\n                }\n\n                if best_d_score \u003e best_s_score {\n                    best_s_score = best_d_score;\n                    tb.set_s_bits(TB_DEL);\n                }\n\n                if xclip_score \u003e best_s_score {\n                    best_s_score = xclip_score;\n                    tb.set_s_bits(TB_XCLIP_PREFIX);\n                }\n\n                let yclip_score = self.scoring.yclip_prefix\n                    + self.scoring.gap_open\n                    + self.scoring.gap_extend * (i as i32);\n                if yclip_score \u003e best_s_score {\n                    best_s_score = yclip_score;\n                    tb.set_s_bits(TB_YCLIP_PREFIX);\n                }\n\n                self.S[curr][i] = best_s_score;\n                self.I[curr][i] = best_i_score;\n                self.D[curr][i] = best_d_score;\n\n                // Track the score if we do suffix clip (x) from here\n                if self.S[curr][i] + self.scoring.xclip_suffix \u003e self.S[curr][m] {\n                    self.S[curr][m] = self.S[curr][i] + self.scoring.xclip_suffix;\n                    self.Lx[j] = m - i;\n                    self.traceback.get_mut(m, j).set_s_bits(TB_XCLIP_SUFFIX);\n                }\n\n                // Track the score if we do suffix clip (y) from here\n                if self.S[curr][i] + self.scoring.yclip_suffix \u003e self.Sn[i] {\n                    self.Sn[i] = self.S[curr][i] + self.scoring.yclip_suffix;\n                    self.Ly[i] = n - j;\n                    self.traceback.get_mut(i, n).set_s_bits(TB_YCLIP_SUFFIX);\n                }\n\n                self.traceback.set(i, j, tb);\n            }\n\n            // Suffix clip (y) from i = m and reset Sn[m] if required\n            if self.S[curr][m] + self.scoring.yclip_suffix \u003e self.Sn[m] {\n                self.Sn[m] = self.S[curr][m] + self.scoring.yclip_suffix;\n                self.Ly[m] = n - j;\n                self.traceback.get_mut(m, n).set_s_bits(TB_YCLIP_SUFFIX);\n            }\n            if i_end \u003c (m + 1) {\n                self.traceback.get_mut(m, j).set_s_bits(TB_XCLIP_SUFFIX);\n                self.S[curr][m] = MIN_SCORE;\n            }\n\n            for i in i_end..min(m + 1, self.band.ranges[min(n, j + 1)].end) {\n                self.S[curr][i] = MIN_SCORE;\n                self.I[curr][i] = MIN_SCORE;\n                self.D[curr][i] = MIN_SCORE;\n            }\n        }\n\n        // Handle suffix clipping in the j=n case\n        for i in 0..=m {\n            let j = n;\n            let curr = j % 2;\n            // These entries are not set in the loop above and could contain leftover\n            // values from previous columns. Reset them to MIN_SCORE\n            if i != m \u0026\u0026 (i \u003c self.band.ranges[j].start || i \u003e self.band.ranges[j].end) {\n                self.S[curr][i] = MIN_SCORE;\n            }\n            if self.Sn[i] \u003e self.S[curr][i] {\n                self.S[curr][i] = self.Sn[i];\n                self.traceback.get_mut(i, j).set_s_bits(TB_YCLIP_SUFFIX);\n            }\n            if self.S[curr][i] + self.scoring.xclip_suffix \u003e self.S[curr][m] {\n                self.S[curr][m] = self.S[curr][i] + self.scoring.xclip_suffix;\n                self.Lx[j] = m - i;\n                self.traceback.get_mut(m, j).set_s_bits(TB_XCLIP_SUFFIX);\n            }\n        }\n\n        // Since there could be a change in the last column of S,\n        // recompute the last column of I as this could also change\n        for i in max(1, self.band.ranges[n].start)..self.band.ranges[n].end {\n            let j = n;\n            let curr = j % 2;\n            let s_score = self.S[curr][i - 1] + self.scoring.gap_open + self.scoring.gap_extend;\n            if s_score \u003e self.I[curr][i] {\n                self.I[curr][i] = s_score;\n                let s_bit = self.traceback.get(i - 1, j).get_s_bits();\n                self.traceback.get_mut(i, j).set_i_bits(s_bit);\n            }\n            if s_score \u003e self.S[curr][i] {\n                self.S[curr][i] = s_score;\n                self.traceback.get_mut(i, j).set_s_bits(TB_INS);\n                if self.S[curr][i] + self.scoring.xclip_suffix \u003e self.S[curr][m] {\n                    self.S[curr][m] = self.S[curr][i] + self.scoring.xclip_suffix;\n                    self.Lx[j] = m - i;\n                    self.traceback.get_mut(m, j).set_s_bits(TB_XCLIP_SUFFIX);\n                }\n            }\n        }\n\n        for j in 1..=n {\n            let d_score = self.scoring.gap_open + self.scoring.gap_extend * (j as i32);\n            if d_score \u003e self.scoring.yclip_prefix {\n                self.traceback.get_mut(0, j).set_s_bits(TB_DEL);\n            } else {\n                self.traceback.get_mut(0, j).set_s_bits(TB_YCLIP_PREFIX);\n            }\n            if j == n {\n                let mut best_score = max(d_score, self.scoring.yclip_prefix);\n                if self.scoring.yclip_suffix \u003e best_score {\n                    best_score = self.scoring.yclip_suffix;\n                    self.traceback.get_mut(0, j).set_s_bits(TB_YCLIP_SUFFIX);\n                }\n                if (self.scoring.xclip_suffix + best_score) \u003e self.S[n % 2][m] {\n                    self.S[n % 2][m] = self.scoring.xclip_suffix + best_score;\n                    self.Lx[n] = m;\n                    self.traceback.get_mut(m, n).set_s_bits(TB_XCLIP_SUFFIX);\n                }\n            }\n        }\n\n        for i in 1..=m {\n            let c_score = self.scoring.gap_open + self.scoring.gap_extend * (i as i32);\n            if c_score \u003e self.scoring.xclip_prefix {\n                self.traceback.get_mut(i, 0).set_s_bits(TB_INS);\n            } else {\n                self.traceback.get_mut(i, 0).set_s_bits(TB_XCLIP_PREFIX);\n            }\n            if i == m {\n                let mut best_score = max(c_score, self.scoring.xclip_prefix);\n                if self.scoring.xclip_suffix \u003e best_score {\n                    best_score = self.scoring.xclip_suffix;\n                    self.traceback.get_mut(i, 0).set_s_bits(TB_XCLIP_SUFFIX);\n                }\n                if (self.scoring.yclip_suffix + best_score) \u003e self.S[n % 2][m] {\n                    self.S[n % 2][m] = self.scoring.yclip_suffix + best_score;\n                    self.Ly[m] = n;\n                    self.traceback.get_mut(m, n).set_s_bits(TB_YCLIP_SUFFIX);\n                }\n            }\n        }\n\n        let mut i = m;\n        let mut j = n;\n        let mut operations = Vec::with_capacity(x.len());\n        let mut xstart: usize = 0usize;\n        let mut ystart: usize = 0usize;\n        let mut xend = m;\n        let mut yend = n;\n\n        let mut last_layer = self.traceback.get(i, j).get_s_bits();\n\n        loop {\n            let next_layer: u16;\n            match last_layer {\n                TB_START =\u003e break,\n                TB_INS =\u003e {\n                    operations.push(AlignmentOperation::Ins);\n                    next_layer = self.traceback.get(i, j).get_i_bits();\n                    i -= 1;\n                }\n                TB_DEL =\u003e {\n                    operations.push(AlignmentOperation::Del);\n                    next_layer = self.traceback.get(i, j).get_d_bits();\n                    j -= 1;\n                }\n                TB_MATCH =\u003e {\n                    operations.push(AlignmentOperation::Match);\n                    next_layer = self.traceback.get(i - 1, j - 1).get_s_bits();\n                    i -= 1;\n                    j -= 1;\n                }\n                TB_SUBST =\u003e {\n                    operations.push(AlignmentOperation::Subst);\n                    next_layer = self.traceback.get(i - 1, j - 1).get_s_bits();\n                    i -= 1;\n                    j -= 1;\n                }\n                TB_XCLIP_PREFIX =\u003e {\n                    operations.push(AlignmentOperation::Xclip(i));\n                    xstart = i;\n                    i = 0;\n                    next_layer = self.traceback.get(0, j).get_s_bits();\n                }\n                TB_XCLIP_SUFFIX =\u003e {\n                    operations.push(AlignmentOperation::Xclip(self.Lx[j]));\n                    i -= self.Lx[j];\n                    xend = i;\n                    next_layer = self.traceback.get(i, j).get_s_bits();\n                }\n                TB_YCLIP_PREFIX =\u003e {\n                    operations.push(AlignmentOperation::Yclip(j));\n                    ystart = j;\n                    j = 0;\n                    next_layer = self.traceback.get(i, 0).get_s_bits();\n                }\n                TB_YCLIP_SUFFIX =\u003e {\n                    operations.push(AlignmentOperation::Yclip(self.Ly[i]));\n                    j -= self.Ly[i];\n                    yend = j;\n                    next_layer = self.traceback.get(i, j).get_s_bits();\n                }\n                _ =\u003e panic!(\"Dint expect this!\"),\n            }\n            last_layer = next_layer;\n            // println!(\"{} of {}, {} of {} - {}\", i, m, j, n, last_layer);\n        }\n\n        // Handle the case when the traceback ends outside the band other than at (0, 0)\n        if i != 0 {\n            // Insert all i characters\n            let i_score = self.scoring.gap_open + self.scoring.gap_extend * (i as i32);\n            if i_score \u003e self.scoring.xclip_prefix {\n                operations.resize(operations.len() + i, AlignmentOperation::Ins);\n                xstart = 0;\n            } else {\n                operations.push(AlignmentOperation::Xclip(i));\n                xstart = i;\n            }\n        }\n        if j != 0 {\n            // Delete all j characters\n            let d_score = self.scoring.gap_open + self.scoring.gap_extend * (j as i32);\n            if d_score \u003e self.scoring.yclip_prefix {\n                operations.resize(operations.len() + j, AlignmentOperation::Del);\n                ystart = 0;\n            } else {\n                operations.push(AlignmentOperation::Yclip(j));\n                ystart = j;\n            }\n        }\n\n        operations.reverse();\n        Alignment {\n            score: self.S[n % 2][m],\n            ystart,\n            xstart,\n            yend,\n            xend,\n            ylen: n,\n            xlen: m,\n            operations,\n            mode: AlignmentMode::Custom,\n        }\n    }\n\n    /// Calculate global alignment of x against y.\n    pub fn global(\u0026mut self, x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) -\u003e Alignment {\n        // Store the current clip penalties\n        let clip_penalties = [\n            self.scoring.xclip_prefix,\n            self.scoring.xclip_suffix,\n            self.scoring.yclip_prefix,\n            self.scoring.yclip_suffix,\n        ];\n\n        // Temporarily Over-write the clip penalties\n        self.scoring.xclip_prefix = MIN_SCORE;\n        self.scoring.xclip_suffix = MIN_SCORE;\n        self.scoring.yclip_prefix = MIN_SCORE;\n        self.scoring.yclip_suffix = MIN_SCORE;\n\n        // Compute the alignment\n        let mut alignment = self.custom(x, y);\n        alignment.mode = AlignmentMode::Global;\n\n        // Set the clip penalties to the original values\n        self.scoring.xclip_prefix = clip_penalties[0];\n        self.scoring.xclip_suffix = clip_penalties[1];\n        self.scoring.yclip_prefix = clip_penalties[2];\n        self.scoring.yclip_suffix = clip_penalties[3];\n\n        alignment\n    }\n\n    /// Calculate semiglobal alignment of x against y (x is global, y is local).\n    pub fn semiglobal(\u0026mut self, x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) -\u003e Alignment {\n        // Store the current clip penalties\n        let clip_penalties = [\n            self.scoring.xclip_prefix,\n            self.scoring.xclip_suffix,\n            self.scoring.yclip_prefix,\n            self.scoring.yclip_suffix,\n        ];\n\n        // Temporarily Over-write the clip penalties\n        self.scoring.xclip_prefix = MIN_SCORE;\n        self.scoring.xclip_suffix = MIN_SCORE;\n        self.scoring.yclip_prefix = 0;\n        self.scoring.yclip_suffix = 0;\n\n        // Compute the alignment\n        let mut alignment = self.custom(x, y);\n        alignment.mode = AlignmentMode::Semiglobal;\n\n        // Filter out Xclip and Yclip from alignment.operations\n        alignment.filter_clip_operations();\n\n        // Set the clip penalties to the original values\n        self.scoring.xclip_prefix = clip_penalties[0];\n        self.scoring.xclip_suffix = clip_penalties[1];\n        self.scoring.yclip_prefix = clip_penalties[2];\n        self.scoring.yclip_suffix = clip_penalties[3];\n\n        alignment\n    }\n\n    /// Calculate semiglobal alignment of x against y (x is global, y is local).\n    /// This function accepts the hash map of the kmers of y. This is useful\n    /// in cases where we are interested in repeated alignment of different\n    /// queries against the same reference. The user can precompute the HashMap\n    /// using sparse::hash_kmers and invoke this function to speed up the\n    /// alignment computation.\n    pub fn semiglobal_with_prehash(\n        \u0026mut self,\n        x: TextSlice\u003c'_\u003e,\n        y: TextSlice\u003c'_\u003e,\n        y_kmer_hash: \u0026HashMapFx\u003c\u0026[u8], Vec\u003cu32\u003e\u003e,\n    ) -\u003e Alignment {\n        // Store the current clip penalties\n        let clip_penalties = [\n            self.scoring.xclip_prefix,\n            self.scoring.xclip_suffix,\n            self.scoring.yclip_prefix,\n            self.scoring.yclip_suffix,\n        ];\n\n        // Temporarily Over-write the clip penalties\n        self.scoring.xclip_prefix = MIN_SCORE;\n        self.scoring.xclip_suffix = MIN_SCORE;\n        self.scoring.yclip_prefix = 0;\n        self.scoring.yclip_suffix = 0;\n\n        // Compute the alignment\n        let mut alignment = self.custom_with_prehash(x, y, y_kmer_hash);\n        alignment.mode = AlignmentMode::Semiglobal;\n\n        // Filter out Xclip and Yclip from alignment.operations\n        alignment.filter_clip_operations();\n\n        // Set the clip penalties to the original values\n        self.scoring.xclip_prefix = clip_penalties[0];\n        self.scoring.xclip_suffix = clip_penalties[1];\n        self.scoring.yclip_prefix = clip_penalties[2];\n        self.scoring.yclip_suffix = clip_penalties[3];\n\n        alignment\n    }\n\n    /// Calculate local alignment of x against y.\n    pub fn local(\u0026mut self, x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) -\u003e Alignment {\n        // Store the current clip penalties\n        let clip_penalties = [\n            self.scoring.xclip_prefix,\n            self.scoring.xclip_suffix,\n            self.scoring.yclip_prefix,\n            self.scoring.yclip_suffix,\n        ];\n\n        // Temporarily Over-write the clip penalties\n        self.scoring.xclip_prefix = 0;\n        self.scoring.xclip_suffix = 0;\n        self.scoring.yclip_prefix = 0;\n        self.scoring.yclip_suffix = 0;\n\n        // Compute the alignment\n        let mut alignment = self.custom(x, y);\n        alignment.mode = AlignmentMode::Local;\n\n        // Filter out Xclip and Yclip from alignment.operations\n        alignment.filter_clip_operations();\n\n        // Set the clip penalties to the original values\n        self.scoring.xclip_prefix = clip_penalties[0];\n        self.scoring.xclip_suffix = clip_penalties[1];\n        self.scoring.yclip_prefix = clip_penalties[2];\n        self.scoring.yclip_suffix = clip_penalties[3];\n\n        alignment\n    }\n\n    #[allow(dead_code)]\n    pub fn visualize(\u0026self, alignment: \u0026Alignment) {\n        // First populate the band\n        let mut view = vec!['.'; self.band.rows * self.band.cols];\n        let index = |i, j| i * self.band.cols + j;\n        for j in 0..self.band.ranges.len() {\n            let range = \u0026self.band.ranges[j];\n            for i in range.start..range.end {\n                view[index(i, j)] = 'x';\n            }\n        }\n\n        // Populate the path\n        let path = alignment.path();\n        for p in path {\n            view[index(p.0, p.1)] = '\\\\';\n        }\n\n        for i in 0..self.band.rows {\n            for j in 0..self.band.cols {\n                print!(\"{}\", view[index(i, j)]);\n            }\n            println!();\n        }\n    }\n}\n\ntrait MatchPair {\n    fn continues(\u0026self, p: Option\u003c(u32, u32)\u003e) -\u003e bool;\n}\n\nimpl MatchPair for (u32, u32) {\n    fn continues(\u0026self, p: Option\u003c(u32, u32)\u003e) -\u003e bool {\n        match p {\n            Some(_p) =\u003e (self.0 == _p.0 + 1 \u0026\u0026 self.1 == _p.1 + 1),\n            None =\u003e false,\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct Band {\n    rows: usize,\n    cols: usize,\n    ranges: Vec\u003cRange\u003cusize\u003e\u003e,\n}\n\nimpl Band {\n    // Create new Band instance with given size\n    //\n    // # Arguments\n    //\n    // * `m` - the expected size of x\n    // * `n` - the expected size of y\n    //\n    fn new(m: usize, n: usize) -\u003e Self {\n        Band {\n            rows: m + 1,\n            cols: n + 1,\n            ranges: vec![m + 1..0; n + 1],\n        }\n    }\n\n    // Add cells around a kmer of length 'k', starting at 'start', which are within a\n    // distance of 'w' in x or y directions to the band.\n    fn add_kmer(\u0026mut self, start: (u32, u32), k: usize, w: usize) {\n        let (r, c) = (start.0 as usize, start.1 as usize);\n        // println!(\"{} {} {}\", r, k, self.rows);\n        debug_assert!(r + k \u003c= self.rows);\n        debug_assert!(c + k \u003c= self.cols);\n\n        if k == 0 {\n            return;\n        }\n\n        let i = r.saturating_sub(w);\n        for j in c.saturating_sub(w)..min(c + w + 1, self.cols) {\n            self.ranges[j].start = min(self.ranges[j].start, i);\n        }\n\n        let mut i = r.saturating_sub(w);\n        for j in min(c + w, self.cols)..min(c + k + w, self.cols) {\n            self.ranges[j].start = min(self.ranges[j].start, i);\n            i += 1;\n        }\n\n        let mut i = r + w + k;\n        let mut j = (c + k - 1).saturating_sub(w);\n        loop {\n            if j \u003c= c.saturating_sub(w) {\n                break;\n            }\n            j -= 1;\n            i -= 1;\n            self.ranges[j].end = max(self.ranges[j].end, min(i, self.rows));\n        }\n\n        let i = min(r + w + k, self.rows);\n        for j in (c + k - 1).saturating_sub(w)..min(c + k + w, self.cols) {\n            self.ranges[j].end = max(self.ranges[j].end, i);\n        }\n    }\n\n    // Add cells around a specific position to the band. An cell which is within 'w' distance\n    // in x or y directions are added\n    fn add_entry(\u0026mut self, pos: (u32, u32), w: usize) {\n        let (r, c) = (pos.0 as usize, pos.1 as usize);\n\n        let istart = r.saturating_sub(w);\n        let iend = min(r + w + 1, self.rows);\n        for j in c.saturating_sub(w)..min(c + w + 1, self.cols) {\n            self.ranges[j].start = min(self.ranges[j].start, istart);\n            self.ranges[j].end = max(self.ranges[j].end, iend);\n        }\n    }\n\n    // Each gap generates a line from the start to end.\n    fn add_gap(\u0026mut self, start: (u32, u32), end: (u32, u32), w: usize) {\n        let nrows = end.0 - start.0;\n        let ncols = end.1 - start.1;\n        if nrows \u003e ncols {\n            for r in start.0..end.0 {\n                let c = start.1 + (end.1 - start.1) * (r - start.0) / (end.0 - start.0);\n                self.add_entry((r, c), w);\n            }\n        } else {\n            for c in start.1..end.1 {\n                let r = start.0 + (end.0 - start.0) * (c - start.1) / (end.1 - start.1);\n                self.add_entry((r, c), w);\n            }\n        }\n    }\n\n    // The band needs to start either at (0,0) or at a point that is zero score from (0,0).\n    // This naturally sets the start positions correctly for global, semiglobal and local\n    // modes. Similarly the band has to either end at (m,n) or at a point from which there is\n    // a zero score path to (m,n).\n    //\n    // At the minimum, irrespective of the score (0,0)-\u003estart or end-\u003e(m,n), we extend the band\n    // diagonally for a length \"lazy_extend\"(2k) or when it hits the corner, whichever happens first\n    //\n    // start - the index of the first matching kmer in LCSk++\n    // end - the index of the last matching kmer in LCSk++\n    //\n    fn set_boundaries\u003cF: MatchFunc\u003e(\n        \u0026mut self,\n        start: (u32, u32),\n        end: (u32, u32),\n        k: usize,\n        w: usize,\n        scoring: \u0026Scoring\u003cF\u003e,\n    ) {\n        let lazy_extend: usize = 2 * k;\n\n        // -------------- START --------------\n        // Nothing to do if the start is already at (0,0)\n        let (r, c) = (start.0 as usize, start.1 as usize);\n        if !(r == 0usize \u0026\u0026 c == 0usize) {\n            let mut score_to_start = if r \u003e 0 { scoring.xclip_prefix } else { 0i32 };\n            score_to_start += if c \u003e 0 { scoring.yclip_prefix } else { 0i32 };\n\n            if score_to_start == 0 {\n                // Just do a \"lazy_extend\"\n                // First diagonally\n                let d = min(lazy_extend, min(r, c));\n                self.add_kmer(((r - d) as u32, (c - d) as u32), d, w);\n\n                // If we hit one of the edges before completing lazy_extend\n                self.add_gap(\n                    (\n                        r.saturating_sub(lazy_extend) as u32,\n                        c.saturating_sub(lazy_extend) as u32,\n                    ),\n                    ((r - d) as u32, (c - d) as u32),\n                    w,\n                );\n            } else {\n                // we need to find a zero cost cell\n\n                // First try the diagonal\n                let diagonal_score = match r.cmp(\u0026c) {\n                    // We will hit (r-c, 0)\n                    Ordering::Greater =\u003e scoring.xclip_prefix,\n                    // We will hit (0, c-r)\n                    Ordering::Less =\u003e scoring.yclip_prefix,\n                    Ordering::Equal =\u003e 0,\n                };\n\n                if diagonal_score == 0 {\n                    let d = min(r, c);\n                    self.add_kmer(((r - d) as u32, (c - d) as u32), d, w);\n                    // Make sure we do at least \"lazy_extend\" extension\n                    let start = (\n                        r.saturating_sub(lazy_extend) as u32,\n                        c.saturating_sub(lazy_extend) as u32,\n                    );\n                    let end = ((r - d) as u32, (c - d) as u32);\n                    if (start.0 \u003c= end.0) \u0026\u0026 (start.1 \u003c= end.1) {\n                        self.add_gap(start, end, w);\n                    }\n                } else {\n                    // Band to origin\n                    self.add_gap((0u32, 0u32), start, w);\n                }\n            }\n        }\n\n        // -------------- END --------------\n        // Nothing to do if the last kmer ends at (m, n)\n        let (r, c) = (end.0 as usize + k, end.1 as usize + k);\n        debug_assert!(r \u003c= self.rows);\n        debug_assert!(c \u003c= self.cols);\n        if !(r == self.rows \u0026\u0026 c == self.cols) {\n            let mut score_from_end = if r == self.rows {\n                0\n            } else {\n                scoring.xclip_suffix\n            };\n            score_from_end += if c == self.cols {\n                0\n            } else {\n                scoring.yclip_suffix\n            };\n\n            if score_from_end == 0 {\n                // Just a lazy_extend\n                let d = min(lazy_extend, min(self.rows - r, self.cols - c));\n                self.add_kmer((r as u32, c as u32), d, w);\n\n                let r1 = min(self.rows, r + d) - 1;\n                let c1 = min(self.cols, c + d) - 1;\n                let r2 = min(self.rows, r + lazy_extend);\n                let c2 = min(self.cols, c + lazy_extend);\n                if (r1 \u003c= r2) \u0026\u0026 (c1 \u003c= c2) {\n                    self.add_gap((r1 as u32, c1 as u32), (r2 as u32, c2 as u32), w);\n                }\n            } else {\n                // we need to find a zero cost cell\n\n                // First try the diagonal\n                let dr = self.rows - r;\n                let dc = self.cols - c;\n                let diagonal_score = match dr.cmp(\u0026dc) {\n                    // We will hit (r+dc, self.cols)\n                    Ordering::Greater =\u003e scoring.xclip_suffix,\n                    // We will hit (self.rows, c+dr)\n                    Ordering::Less =\u003e scoring.yclip_suffix,\n                    // We will hit the corner\n                    Ordering::Equal =\u003e 0,\n                };\n\n                if diagonal_score == 0 {\n                    let d = min(dr, dc);\n                    self.add_kmer((r as u32, c as u32), d, w);\n                    // Make sure we do at least \"lazy_extend\" extension\n                    let r1 = min(self.rows, r + d) - 1;\n                    let c1 = min(self.cols, c + d) - 1;\n                    let r2 = min(self.rows, r + lazy_extend);\n                    let c2 = min(self.cols, c + lazy_extend);\n                    if (r1 \u003c= r2) \u0026\u0026 (c1 \u003c= c2) {\n                        self.add_gap((r1 as u32, c1 as u32), (r2 as u32, c2 as u32), w);\n                    }\n                } else {\n                    // Band to lower right corner\n                    let rows = self.rows as u32;\n                    let cols = self.cols as u32;\n                    self.add_gap((r as u32, c as u32), (rows as u32, cols as u32), w);\n                }\n            }\n        }\n    }\n\n    fn create\u003cF: MatchFunc\u003e(\n        x: TextSlice\u003c'_\u003e,\n        y: TextSlice\u003c'_\u003e,\n        k: usize,\n        w: usize,\n        scoring: \u0026Scoring\u003cF\u003e,\n    ) -\u003e Band {\n        let matches = sparse::find_kmer_matches(x, y, k);\n        Band::create_with_matches(x, y, k, w, scoring, \u0026matches)\n    }\n\n    fn create_with_prehash\u003cF: MatchFunc\u003e(\n        x: TextSlice\u003c'_\u003e,\n        y: TextSlice\u003c'_\u003e,\n        k: usize,\n        w: usize,\n        scoring: \u0026Scoring\u003cF\u003e,\n        y_kmer_hash: \u0026HashMapFx\u003c\u0026[u8], Vec\u003cu32\u003e\u003e,\n    ) -\u003e Band {\n        let matches = sparse::find_kmer_matches_seq2_hashed(x, y_kmer_hash, k);\n        Band::create_with_matches(x, y, k, w, scoring, \u0026matches)\n    }\n\n    fn create_with_matches\u003cF: MatchFunc\u003e(\n        x: TextSlice\u003c'_\u003e,\n        y: TextSlice\u003c'_\u003e,\n        k: usize,\n        w: usize,\n        scoring: \u0026Scoring\u003cF\u003e,\n        matches: \u0026[(u32, u32)],\n    ) -\u003e Band {\n        if matches.is_empty() {\n            let mut band = Band::new(x.len(), y.len());\n            band.full_matrix();\n            return band;\n        }\n\n        let match_score = match scoring.match_scores {\n            Some((m, _)) =\u003e m,\n            None =\u003e DEFAULT_MATCH_SCORE,\n        };\n\n        let res = sparse::sdpkpp(\n            matches,\n            k,\n            match_score as u32,\n            scoring.gap_open,\n            scoring.gap_extend,\n        );\n        Band::create_from_match_path(x, y, k, w, scoring, \u0026res.path, \u0026matches)\n    }\n\n    fn create_from_match_path\u003cF: MatchFunc\u003e(\n        x: TextSlice\u003c'_\u003e,\n        y: TextSlice\u003c'_\u003e,\n        k: usize,\n        w: usize,\n        scoring: \u0026Scoring\u003cF\u003e,\n        path: \u0026[usize],\n        matches: \u0026[(u32, u32)],\n    ) -\u003e Band {\n        let mut band = Band::new(x.len(), y.len());\n\n        if matches.is_empty() {\n            band.full_matrix();\n            return band;\n        }\n\n        let ps = path[0];\n        let pe = path[path.len() - 1];\n\n        // Set the boundaries\n        band.set_boundaries(matches[ps], matches[pe], k, w, scoring);\n        let mut prev: Option\u003c(u32, u32)\u003e = None;\n\n        for \u0026idx in path {\n            let curr = matches[idx];\n            if curr.continues(prev) {\n                let p = prev.unwrap();\n                band.add_entry((p.0 + k as u32, p.1 + k as u32), w);\n            } else {\n                if let Some(p) = prev {\n                    band.add_gap((p.0 + (k - 1) as u32, p.1 + (k - 1) as u32), curr, w)\n                }\n                band.add_kmer(curr, k, w);\n            }\n            prev = Some(curr);\n        }\n        band\n    }\n\n    fn full_matrix(\u0026mut self) {\n        self.ranges.clear();\n        self.ranges.resize(self.cols, 0..self.rows);\n    }\n\n    fn num_cells(\u0026self) -\u003e usize {\n        let mut banded_cells = 0;\n        for j in 0..self.ranges.len() {\n            banded_cells += self.ranges[j].end.saturating_sub(self.ranges[j].start);\n        }\n        banded_cells\n    }\n\n    #[allow(dead_code)]\n    fn visualize(\u0026self) {\n        let mut view = vec!['.'; self.rows * self.cols];\n        let index = |i, j| i * self.cols + j;\n        for j in 0..self.ranges.len() {\n            let range = \u0026self.ranges[j];\n            for i in range.start..range.end {\n                view[index(i, j)] = 'x';\n            }\n        }\n\n        for i in 0..self.rows {\n            for j in 0..self.cols {\n                print!(\"{}\", view[index(i, j)]);\n            }\n            println!();\n        }\n    }\n\n    #[allow(dead_code)]\n    fn stat(\u0026self) {\n        let total_cells = self.rows * self.cols;\n        let banded_cells = self.num_cells();\n        let percent_cells = (banded_cells as f64) / (total_cells as f64) * 100.0;\n        println!(\n            \" {} of {} cells are in the band ({2:.2}%)\",\n            banded_cells, total_cells, percent_cells\n        );\n    }\n}\n\n//box creating reverse intervals for test\n\n#[cfg(test)]\nmod banded {\n    use crate::alignment::pairwise::{self, banded, Scoring};\n    use crate::alignment::sparse::hash_kmers;\n    use crate::utils::TextSlice;\n\n    // Check that the banded alignment is equivalent to the exhaustive SW alignment\n    fn compare_to_full_alignment_local(x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) {\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n\n        let mut banded_aligner =\n            banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let banded_alignment = banded_aligner.local(x, y);\n        // banded_aligner.visualize(\u0026banded_alignment);\n\n        let mut full_aligner = pairwise::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let full_alignment = full_aligner.local(x, y);\n\n        assert_eq!(banded_alignment, full_alignment);\n    }\n\n    fn compare_to_full_alignment_global(x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) {\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n\n        let mut banded_aligner =\n            banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let banded_alignment = banded_aligner.global(x, y);\n        banded_aligner.visualize(\u0026banded_alignment);\n\n        let mut full_aligner = pairwise::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let full_alignment = full_aligner.global(x, y);\n\n        assert_eq!(banded_alignment, full_alignment);\n    }\n\n    fn compare_to_full_alignment_semiglobal(x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) {\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n\n        let mut banded_aligner =\n            banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let banded_alignment = banded_aligner.semiglobal(x, y);\n        banded_aligner.visualize(\u0026banded_alignment);\n\n        let mut full_aligner = pairwise::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let full_alignment = full_aligner.semiglobal(x, y);\n        // banded_aligner.visualize(\u0026full_alignment);\n\n        assert_eq!(banded_alignment, full_alignment);\n\n        let set = hash_kmers(y, 10);\n        let banded_alignment = banded_aligner.semiglobal_with_prehash(x, y, \u0026set);\n        assert_eq!(banded_alignment, full_alignment);\n    }\n\n    #[test]\n    fn test_band_add_entry() {\n        let mut band = banded::Band::new(10, 10);\n        band.add_entry((3u32, 3u32), 3usize);\n        assert_eq!(\n            band.ranges,\n            [\n                0..7,\n                0..7,\n                0..7,\n                0..7,\n                0..7,\n                0..7,\n                0..7,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n            ]\n        );\n        band.add_entry((9u32, 9u32), 2usize);\n        assert_eq!(\n            band.ranges,\n            [\n                0..7,\n                0..7,\n                0..7,\n                0..7,\n                0..7,\n                0..7,\n                0..7,\n                7..11,\n                7..11,\n                7..11,\n                7..11,\n            ]\n        );\n        band.add_entry((7u32, 5u32), 2usize);\n        assert_eq!(\n            band.ranges,\n            [\n                0..7,\n                0..7,\n                0..7,\n                0..10,\n                0..10,\n                0..10,\n                0..10,\n                5..11,\n                7..11,\n                7..11,\n                7..11,\n            ]\n        );\n\n        let mut band = banded::Band::new(10, 10);\n        band.add_entry((0u32, 0u32), 2usize);\n        assert_eq!(\n            band.ranges,\n            [\n                0..3,\n                0..3,\n                0..3,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n            ]\n        );\n\n        let mut band = banded::Band::new(10, 10);\n        band.add_entry((10u32, 10u32), 2usize);\n        assert_eq!(\n            band.ranges,\n            [\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                8..11,\n                8..11,\n                8..11,\n            ]\n        );\n\n        let mut band = banded::Band::new(10, 10);\n        band.add_entry((10u32, 0u32), 2usize);\n        assert_eq!(\n            band.ranges,\n            [\n                8..11,\n                8..11,\n                8..11,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n            ]\n        );\n\n        let mut band = banded::Band::new(10, 10);\n        band.add_entry((0u32, 10u32), 2usize);\n        assert_eq!(\n            band.ranges,\n            [\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                11..0,\n                0..3,\n                0..3,\n                0..3,\n            ]\n        );\n        band.stat();\n    }\n\n    fn compare_add_kmer_and_add_entry(start: (u32, u32), k: usize, w: usize, m: usize, n: usize) {\n        let mut band1 = banded::Band::new(m, n);\n        band1.add_kmer(start, k, w);\n\n        let mut band2 = banded::Band::new(m, n);\n        for i in 0..k {\n            band2.add_entry((start.0 + i as u32, start.1 + i as u32), w);\n        }\n        assert_eq!(band1.ranges, band2.ranges);\n    }\n\n    #[test]\n    fn test_band_add_kmer() {\n        compare_add_kmer_and_add_entry((3u32, 3u32), 4, 2, 10, 10);\n        compare_add_kmer_and_add_entry((3u32, 3u32), 8, 2, 10, 10);\n        compare_add_kmer_and_add_entry((5u32, 0u32), 6, 3, 10, 10);\n    }\n\n    #[test]\n    fn test_same() {\n        let x =\n            b\"ACGTATCATAGACCCTAGATAGGGTTGTGTAGATGATCCACAGACGTATCATAGATTAGATAGGGTTGTGTAGATGATTCC\\\n        ACAG\";\n        let y = *x;\n        compare_to_full_alignment_local(x, \u0026y);\n        compare_to_full_alignment_global(x, \u0026y);\n        compare_to_full_alignment_semiglobal(x, \u0026y);\n    }\n\n    #[test]\n    fn test_big() {\n        let query =\n            b\"CATCTCCACCCACCCTATCCAACCCTGGGGTGGCAGGTCGTGAGTGACAGCCCCAAGGACACCAAGGGATGAAGCTT\\\n        CTCCTGTGCTGAGATCCTTCTCGGACTTTCTGAGAGGCCACGCAGAACAGGAGGCCCCATCTCCCGTTCTTACTCAGAAGCTGTCAGCAGG\\\n        GCTGGGCTCAAGATGAACCCGTGGCCGGCCCCACTCCCCAGCTCTTGCTTCAGGGCCTCACGTTTCGCCCCCTGAGGCCTGGGGGCTCCAT\\\n        CCTCACGGCTGGAGGGGCTCTCAGAACATCTGGTG\";\n\n        let target =\n            b\"CCTCCCATCTCCACCCACCCTATCCAACCCTGGGGTGGCAGGTCATGAGTGACAGCCCCAAGGACACCAAGGGATG\\\n        AAGCTTCTCCTGTGCTGAGATCCTTCTCGGACTTTCTGAGAGGCCACGCAGAACAGGAGGCCCCATCTCCCGTTCTTACTCAGAAGCTGTC\\\n        AGCAGGGCTGGGCTCAAGATGAACCCGTGGCCGGCCCCACTCCCCAGCTCTTGCTTCAGGGCCTCACGTTTCGCCCCCTGAGGCCTGGGGG\\\n        CTCCGTCCTCACGGCTGGAGGGGCTCTCAGAACATCTGGTGGGCTCCGTCCTCACGGCTGGAGGGGCTCTCAGAACATCTGGTGGGCTCCG\\\n        TCCTCACGGCTGGAGGGGCTCTCAGAACATCTGGTGGGCTCCGTCCTCACGGCTGGAGGGGCTCTCAGAACATCTGGTGCACGGCTCCCAA\\\n        CTCTCTTCCGGCCAAGGATCCCGTGTTCCTGAAATGTCTTTCTACCAAACACAGTTGCTGTGTAACCACTCATTTCATTTTCCTAATTTGT\\\n        GTTGATCCAGGACACGGGAGGAGACCTGGGCAGCGGCGGACTCATTGCAGGTCGCTCTGCGGTGAGGACGCCACAGGCAC\";\n\n        compare_to_full_alignment_local(query, target);\n        // compare_to_full_alignment_global(query, target);\n        // compare_to_full_alignment_semiglobal(query, target);\n    }\n\n    #[test]\n    fn test_deletion() {\n        let x = b\"AGCACACGTGTGCGCTATACAGTACACGTGTCACAGTTGTACTAGCATGAC\";\n        let y = b\"AGCACACGTGTGCGCTATACAGTAAAAAAAACACGTGTCACAGTTGTACTAGCATGAC\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_insertion() {\n        let x = b\"AGCACACGTGTGCGCTATACAGTAAGTAGTAGTACACGTGTCACAGTTGTACTAGCATGAC\";\n        let y = b\"AGCACACGTGTGCGCTATACAGTACACGTGTCACAGTTGTACTAGCATGAC\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_substitutions() {\n        let x = b\"AGCACACGTGTGCGCTATACAGTAAGTAGTAGTACACGTGTCACAGTTGTACTAGCATGAC\";\n        let y = b\"AGCACAAGTGTGCGCTATACAGGAAGTAGGAGTACACGTGTCACATTTGTACTAGCATGAC\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_overhangs1() {\n        let x = b\"CGCTATACAGTAAGTAGTAGTACACGTGTCACAGTTGTACTAGCATGAC\";\n        let y = b\"AGCACAAGTGTGAGCACAAGTGTGCGCTATACAGGAAGTAGGAGTACACGTGTCACATTTGTACTAGCATGAC\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_overhangs2() {\n        let x = b\"GCACACGAGCACACGTAGCACACGTGTGCGCTATACAGTAAGTAGTAGTACACGTGTCACAGTTGTACTAGCATGAC\";\n        let y = b\"TATACAGGAAGTAGGAGTACACGTGTCACATTTGTACTAGCATGAC\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_overhangs3() {\n        let x = b\"AGCACACGTGTGCGCTATACAGTAAGTAGTAGTACACGTG\";\n        let y = b\"AGCACAAGTGTGCGCTATACAGGAAGTAGGAGTACACGTGTCACATTTGTACTAGCATGAC\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_overhangs4() {\n        let x = b\"AGCACACGTGTGCGCTATACAGTAAGTAGTAGTACACGTGTCACAGTTGTACTAGCATGACCAGTTGTACTAGCATGAC\";\n        let y = b\"AGCACAAGTGTGCGCTATACAGGAAGTAGGAGTACACGTGTCA\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_overhangs5() {\n        let x = b\"AGCACAAGTGTGCGCTATACAGGAAGTAGGAGTACACGTGTCA\";\n        let y = b\"CAGTTGTACTAGCATGACCAGTTGTACTAGCATGACAGCACACGTGTGCGCTATACAGTAAGTAGTAGTACACGTGTCA\\\n            CAGTTGTACTAGCATGACCAGTTGTACTAGCATGAC\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_band_starts_inside() {\n        let x = b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGGGGGGGGGGGGGGGGGGGG\";\n        let y = b\"TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTGGGGGGGGGGGGGGGGGGGG\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_band_ends_inside() {\n        let x = b\"GGGGGGGGGGGGGGGGGGGGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n        let y = b\"GGGGGGGGGGGGGGGGGGGGTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    #[test]\n    fn test_band_is_fully_inside() {\n        let x = b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGGGGGGGGGGGGGGGGGGGG\\\n        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n        let y = b\"TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTGGGGGGGGGGGGGGGGGGGG\\\n        TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT\";\n        compare_to_full_alignment_local(x, y);\n        compare_to_full_alignment_global(x, y);\n        compare_to_full_alignment_semiglobal(x, y);\n    }\n\n    // #[test]\n    // fn test_failure() {\n    //     let x = b\"AGAATTTTAGTGATCATATCGTTAACAGCTCCTGAGGGGACTTGGCCCAGCTGGAATAGCTACATGGCAGATTTTTCGTTCACGTTTTCTCTTCGCGATGTTCATCACTGCTTCTACCATATCGAGACCCGTTTATTGACTTCAGACAATGAGGAGCAATTAGGACGTTTATACGATGTTAGCGCGTTTAATAACTCACTGATATGCCACAGGCGCAGGCCTGACAAAGTTTATCCGGGGTCGGGAAAGCTGTGCCCTCATCCAAGTGCTCAGCTAACCAGCAACTGTCGGCTAATTCTTAGATATACCGGATTTATTAACACTGGCCTGACATCCTATACCGAGTAGGCCCCCAAAGTAATTGATGTTCCCGCAACTACTACTCCCGAGGCTAGGTCGAGTCCTACTCCAAGACATCCTGCGTAAAGACAAGGCGCTGACTTGACGTAGTAAAGACCTGGCGCGGGATACACACAGCATAGCGTGAAGCACAGACAAACTGAAGTGGCCGAAGAGAATCTAACAATGGTAC\";\n    //     let y = b\"GTTTCGATGCTCACTGAACAGTAGAGTTTACGCCCAACGGTTAGTACCTCGCTAAGGGAGTGGGTGTCCGGGCAGAATTTTAGTGATCATATCGTTAACAGCTCCTGAGGGGACTTGGCCCAGCTGGAATAGCTACATGGCAGATTTTTCGTTCACGTTTTCTCTTCCCGATGTTCATCACTGCTTCTACCATATCGCATCCAAGTGCTCAGCTAACCAGCAACTGTCGGCTAATTCTTAGATATACCGGATTTATTAACACTGGCCTGACATCCTATACCGAGTAGGCCCCCAAAGTAATTGATGTTCCCGCAACTACTACTCCCGAGGCTAGGTATTTGTACCTGTTGCCGCCACGTATCGGGGGCGCTACGGGCGGCACGGCCCGATGCCTTGCTTCCCAGGGTGTTTTTTAGGATTCGATTCAGTGGTCGGTCGGGCTTTAAGCGGTCCAGATCTTAGCTGTATCTCGAGTCCTACTCCAAGACGTCCTGCGTAAAGACAAGGCGCTGACTTGACGTAGTAAAGACCTGGCGCGGGATACACACAGCATAGCGTGAAGCACAGACAAACTGAAGTGGCCGAAGAGAATCTAACAATGGTACTGACAGG\";\n    //     compare_to_full_alignment_semiglobal(x, y);\n    // }\n\n    use crate::alignment::AlignmentOperation::*;\n    use crate::scores::blosum62;\n    use std::iter::repeat;\n\n    #[test]\n    fn test_semiglobal() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    // Test case for underflow of the SW score.\n    #[test]\n    fn test_semiglobal_gap_open_lt_mismatch() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -5i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -1, -1, \u0026score, 10, 10);\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Del, Match, Ins, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_global_affine_ins() {\n        let x = b\"ACGAGAACA\";\n        let y = b\"ACGACA\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.global(x, y);\n\n        println!(\"aln:\\n{}\", alignment.pretty(x, y));\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Ins, Ins, Ins, Match, Match, Match]\n        );\n    }\n\n    #[test]\n    fn test_local_empty() {\n        let x = b\"NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN\";\n        let y = b\"AACGTACGATACGTGGGTTGTCACACGTGTCGCGCGGCAACACATCAGACTCTAACAGCATCATCAGCACGTGACA\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.local(x, y);\n\n        println!(\"aln:\\n{}\", alignment.pretty(x, y));\n        assert_eq!(alignment.x_aln_len(), 0);\n        assert_eq!(alignment.y_aln_len(), 0);\n    }\n\n    #[test]\n    fn test_global_affine_ins2() {\n        let x = b\"AGATAGATAGATAGGGAGTTGTGTAGATGATCCACAGT\";\n        let y = b\"AGATAGATAGATGTAGATGATCCACAGT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.global(x, y);\n\n        println!(\"aln:\\n{}\", alignment.pretty(x, y));\n\n        let mut correct = Vec::new();\n        correct.extend(repeat(Match).take(11));\n        correct.extend(repeat(Ins).take(10));\n        correct.extend(repeat(Match).take(17));\n\n        assert_eq!(alignment.operations, correct);\n    }\n\n    #[test]\n    fn test_local_affine_ins2() {\n        let x = b\"ACGTATCATAGATAGATAGGGTTGTGTAGATGATCCACAG\";\n        let y = b\"CGTATCATAGATAGATGTAGATGATCCACAGT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.local(x, y);\n        assert_eq!(alignment.xstart, 1);\n        assert_eq!(alignment.ystart, 0);\n    }\n\n    #[test]\n    fn test_local() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.local(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_global() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.global(x, y);\n\n        println!(\"\\naln:\\n{}\", alignment.pretty(x, y));\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Del, Del, Del, Del, Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_blosum62() {\n        let x = b\"AAAA\";\n        let y = b\"AAAA\";\n        let score = \u0026blosum62;\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, score, 10, 10);\n        let alignment = aligner.global(x, y);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.score, 16);\n        assert_eq!(alignment.operations, [Match, Match, Match, Match]);\n    }\n\n    #[test]\n    fn test_issue11() {\n        let y = b\"TACC\"; //GTGGAC\";\n        let x = b\"AAAAACC\"; //GTTGACGCAA\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.global(x, y);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Ins, Ins, Ins, Subst, Match, Match, Match]\n        );\n    }\n\n    #[test]\n    fn test_issue12_1() {\n        let x = b\"CCGGCA\";\n        let y = b\"ACCGTTGACGC\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.ystart, 1);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Subst, Subst, Subst]\n        );\n    }\n\n    #[test]\n    fn test_issue12_2() {\n        let y = b\"CCGGCA\";\n        let x = b\"ACCGTTGACGC\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.ystart, 0);\n\n        assert_eq!(\n            alignment.operations,\n            [Subst, Match, Ins, Ins, Ins, Ins, Ins, Ins, Subst, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_issue12_3() {\n        let y = b\"CCGTCCGGCAA\";\n        let x = b\"AAAAACCGTTGACGCAA\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.semiglobal(x, y);\n\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [\n                Ins, Ins, Ins, Ins, Ins, Ins, Match, Subst, Subst, Match, Subst, Subst, Subst,\n                Match, Match, Match, Match,\n            ]\n        );\n\n        let mut aligner = banded::Aligner::with_capacity(y.len(), x.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.semiglobal(y, x);\n\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Subst, Subst, Match, Subst, Subst, Subst, Match, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_left_aligned_del() {\n        let x = b\"GTGCATCATGTG\";\n        let y = b\"GTGCATCATCATGTG\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.global(x, y);\n        println!(\"\\naln:\\n{}\", alignment.pretty(x, y));\n\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [\n                Match, Match, Match, Del, Del, Del, Match, Match, Match, Match, Match, Match,\n                Match, Match, Match,\n            ]\n        );\n    }\n\n    // Test that trailing deletions are correctly handled\n    // in global mode\n    #[test]\n    fn test_global_right_del() {\n        let x = b\"AACCACGTACGTGGGGGGA\";\n        let y = b\"CCACGTACGT\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.global(x, y);\n\n        println!(\"\\naln:\\n{}\", alignment.pretty(x, y));\n\n        println!(\"score:{}\", alignment.score);\n        assert_eq!(alignment.score, -9);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [\n                Ins, Ins, Match, Match, Match, Match, Match, Match, Match, Match, Match, Match,\n                Ins, Ins, Ins, Ins, Ins, Ins, Ins,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_left_aligned_ins() {\n        let x = b\"GTGCATCATCATGTG\";\n        let y = b\"GTGCATCATGTG\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score, 10, 10);\n        let alignment = aligner.global(x, y);\n        println!(\"\\naln:\\n{}\", alignment.pretty(x, y));\n\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [\n                Match, Match, Match, Ins, Ins, Ins, Match, Match, Match, Match, Match, Match,\n                Match, Match, Match,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_aligner_new() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::new(-5, -1, \u0026score, 10, 10);\n\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n\n        let alignment = aligner.local(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n\n        let alignment = aligner.global(x, y);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Del, Del, Del, Del, Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_semiglobal_simple() {\n        let x = b\"GAAAACCGTTGAT\";\n        let y = b\"ACCGTGGATGGG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = banded::Aligner::new(-5, -1, \u0026score, 10, 10);\n        let alignment = aligner.semiglobal(x, y);\n\n        assert_eq!(\n            alignment.operations,\n            [Ins, Ins, Ins, Ins, Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_insert_only_semiglobal() {\n        let x = b\"TTTT\";\n        let y = b\"AAAA\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let mut aligner = banded::Aligner::new(-5, -1, \u0026score, 10, 10);\n        let alignment = aligner.semiglobal(x, y);\n\n        assert_eq!(alignment.operations, [Ins, Ins, Ins, Ins]);\n    }\n\n    #[test]\n    fn test_insert_in_between_semiglobal() {\n        let x = b\"GGGGG\";\n        let y = b\"GGTAGGG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let mut aligner = banded::Aligner::new(-5, -1, \u0026score, 10, 10);\n        let alignment = aligner.semiglobal(x, y);\n\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Del, Del, Match, Match, Match]\n        );\n    }\n\n    #[test]\n    fn test_xclip_prefix_custom() {\n        let x = b\"GGGGGGATG\";\n        let y = b\"ATG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).xclip(-5);\n\n        let mut aligner = banded::Aligner::with_scoring(scoring, 10, 10);\n        let alignment = aligner.custom(x, y);\n\n        assert_eq!(alignment.operations, [Xclip(6), Match, Match, Match]);\n    }\n\n    #[test]\n    fn test_yclip_prefix_custom() {\n        let y = b\"GGGGGGATG\";\n        let x = b\"ATG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).yclip(-5);\n\n        let mut aligner = banded::Aligner::with_scoring(scoring, 10, 10);\n        let alignment = aligner.custom(x, y);\n\n        assert_eq!(alignment.operations, [Yclip(6), Match, Match, Match]);\n    }\n\n    #[test]\n    fn test_xclip_suffix_custom() {\n        let x = b\"GAAAA\";\n        let y = b\"CG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).xclip(-5).yclip(0);\n\n        let mut aligner = banded::Aligner::with_scoring(scoring, 10, 10);\n        let alignment = aligner.custom(x, y);\n\n        assert_eq!(alignment.operations, [Yclip(1), Match, Xclip(4)]);\n    }\n\n    #[test]\n    fn test_yclip_suffix_custom() {\n        let y = b\"GAAAA\";\n        let x = b\"CG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).yclip(-5).xclip(0);\n\n        let mut aligner = banded::Aligner::with_scoring(scoring, 10, 10);\n        let alignment = aligner.custom(x, y);\n\n        assert_eq!(alignment.operations, [Xclip(1), Match, Yclip(4)]);\n    }\n\n    #[test]\n    fn test_longer_string_all_operations() {\n        let x = b\"TTTTTGGGGGGATGGCCCCCCTTTTTTTTTTGGGAAAAAAAAAGGGGGG\";\n        let y = b\"GGGGGGATTTCCCCCCCCCTTTTTTTTTTAAAAAAAAA\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).xclip(-5).yclip(0);\n\n        let mut aligner = banded::Aligner::with_scoring(scoring, 10, 10);\n        let alignment = aligner.custom(x, y);\n\n        println!(\"{}\", alignment.pretty(x, y));\n        assert_eq!(alignment.score, 7);\n    }\n\n    #[test]\n    fn test_yclip_suffix_only() {\n        let x = b\"GGACTTCGGAAGGCACTACTGAAACTCCGT\";\n        let y = b\"AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC\";\n        let base_score = Scoring::from_scores(0, -1, 1, -1);\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            xclip_suffix: 0,\n            yclip_suffix: 0,\n            ..base_score\n        };\n        let mut aligner = banded::Aligner::with_scoring(scoring, 6, 5);\n        let alignment = aligner.custom(x, y);\n        assert_eq!(alignment.ystart, 0);\n    }\n\n    #[test]\n    fn test_yclip_prefix_only() {\n        let x = b\"AATAATAAAAAAA\";\n        let y = b\"AAAAAAGTTTCACCTTA\";\n        let base_score = Scoring::from_scores(0, -1, 1, -1);\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            xclip_suffix: 0,\n            yclip_prefix: 0,\n            ..base_score\n        };\n        let mut aligner = banded::Aligner::with_scoring(scoring, 6, 5);\n        let alignment = aligner.custom(x, y);\n        assert_eq!(alignment.yend, alignment.ylen);\n    }\n\n    #[test]\n    fn test_traceback_outside_band() {\n        let x = b\"TTGTGGGTGGGGGGAAAAAAAAA\";\n        let y = b\"GACAAGAGCCCAAGGAAAGAAAA\";\n        let base_score = Scoring::from_scores(-5, 0, 1, -3);\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            xclip_suffix: 0,\n            yclip_suffix: 0,\n            ..base_score\n        };\n        let kmer_len = 5;\n        let window_len = 5;\n        let mut al = pairwise::banded::Aligner::with_scoring(scoring, kmer_len, window_len);\n        let alignment = al.custom(x, y);\n        assert_eq!(alignment.ystart, 0);\n    }\n\n    #[test]\n    fn test_deletions_ouside_band() {\n        let x = b\"AAAAATTGAGGAGTAATAGTAAA\";\n        let y = b\"AAAAAAAAAAAAGGAAGG\";\n        let base_score = Scoring::from_scores(-13, 0, 1, -5);\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            xclip_suffix: -136,\n            yclip_prefix: -112,\n            yclip_suffix: -51,\n            ..base_score\n        };\n        let kmer_len = 5;\n        let window_len = 8;\n        let mut al = pairwise::banded::Aligner::with_scoring(scoring, kmer_len, window_len);\n        let alignment = al.custom(x, y);\n        assert_eq!(alignment.score, -13);\n        assert_eq!(\n            alignment.operations,\n            [\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Del,\n                Xclip(23)\n            ]\n        );\n    }\n\n    #[test]\n    fn test_insertion_ouside_band() {\n        let x = b\"AATCTAAAAAAAAAAAAAAAAC\";\n        let y = b\"AATATAAAAAGAAAAAGAA\";\n\n        let base_score = Scoring::from_scores(-15, 0, 1, -6);\n\n        let scoring = Scoring {\n            xclip_prefix: -255,\n            xclip_suffix: -255,\n            yclip_prefix: 0,\n            yclip_suffix: -54,\n            ..base_score\n        };\n        let kmer_len = 5;\n        let window_len = 7;\n        let mut al = pairwise::banded::Aligner::with_scoring(scoring, kmer_len, window_len);\n        let alignment = al.custom(x, y);\n        assert_eq!(alignment.score, -15);\n        assert_eq!(\n            alignment.operations,\n            [\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Ins,\n                Yclip(19)\n            ]\n        );\n    }\n\n    #[test]\n    fn test_insertion_after_clip() {\n        let x = b\"AAAAAAGTAAAATTT\";\n        let y = b\"AAAAAAAAAAACAAAAAAG\";\n\n        let base_score = Scoring::from_scores(-3, 0, 3, -5);\n\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            yclip_prefix: 0,\n            yclip_suffix: 0,\n            ..base_score\n        };\n        let kmer_len = 5;\n        let window_len = 7;\n        let mut al = pairwise::banded::Aligner::with_scoring(scoring, kmer_len, window_len);\n        let alignment = al.custom(x, y);\n        assert_eq!(alignment.score, 24);\n    }\n\n    #[test]\n    fn test_only_clips() {\n        let x = b\"GTAAAAAAGCCCAGA\";\n        let y = b\"AAAGTAAAAACAATGACAAAAAAAA\";\n        let base_score = Scoring::from_scores(-15, -5, 1, -5);\n        let scoring = Scoring {\n            xclip_prefix: -255,\n            xclip_suffix: -22,\n            yclip_prefix: -54,\n            yclip_suffix: -50,\n            ..base_score\n        };\n        let kmer_len = 10;\n        let window_len = 10;\n        let mut al = pairwise::banded::Aligner::with_scoring(scoring, kmer_len, window_len);\n        let alignment = al.custom(x, y);\n        assert_eq!(alignment.score, -72);\n    }\n\n    #[test]\n    fn test_zero_score_clips() {\n        let x = b\"AA\";\n        let y = b\"CC\";\n        let kmer_len = 5;\n        let window_len = 5;\n\n        let base_score = Scoring::from_scores(-1, -1, 1, -1);\n        {\n            let scoring = Scoring {\n                xclip_prefix: 0,\n                yclip_prefix: 0,\n                ..base_score.clone()\n            };\n            let mut al = pairwise::banded::Aligner::with_scoring(scoring, kmer_len, window_len);\n            let alignment = al.custom(x, y);\n            assert_eq!(alignment.score, 0);\n        }\n\n        {\n            let scoring = Scoring {\n                xclip_prefix: 0,\n                yclip_suffix: 0,\n                ..base_score.clone()\n            };\n            let mut al = pairwise::banded::Aligner::with_scoring(scoring, kmer_len, window_len);\n            let alignment = al.custom(x, y);\n            assert_eq!(alignment.score, 0);\n        }\n\n        {\n            let scoring = Scoring {\n                xclip_suffix: 0,\n                yclip_prefix: 0,\n                ..base_score.clone()\n            };\n            let mut al = pairwise::banded::Aligner::with_scoring(scoring, kmer_len, window_len);\n            let alignment = al.custom(x, y);\n            assert_eq!(alignment.score, 0);\n        }\n\n        {\n            let scoring = Scoring {\n                xclip_suffix: 0,\n                yclip_suffix: 0,\n                ..base_score\n            };\n            let mut al = pairwise::banded::Aligner::with_scoring(scoring, kmer_len, window_len);\n            let alignment = al.custom(x, y);\n            assert_eq!(alignment.score, 0);\n        }\n    }\n}\n","traces":[{"line":139,"address":[8196208,8195920,8196112,8196016],"length":1,"stats":{"Line":0},"fn_name":"new\u003c\u0026closure-0\u003e"},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[8240284,8216304,8224284,8230284,8228304,8240304,8222284,8238284,8226304,8198304,8212304,8232304,8218284,8206284,8210304,8196304,8204284,8222304,8234284,8238304,8212284,8202304,8198284,8200304,8226284,8216284,8218304,8214304,8202284,8200284,8220284,8224304,8236304,8206304,8228284,8210284,8204304,8230304,8234304,8236284,8242284,8220304,8232284,8208284,8208304,8214284],"length":1,"stats":{"Line":0},"fn_name":"with_capacity\u003c\u0026closure-0\u003e"},{"line":173,"address":[8240413,8228413,8196413,8212413,8208413,8204413,8238413,8198413,8222413,8220413,8236413,8218413,8200413,8232413,8214413,8230413,8202413,8224413,8210413,8216413,8226413,8206413,8234413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[8232602,8216521,8198449,8214602,8196449,8220602,8204449,8210449,8202449,8218602,8238602,8236521,8202521,8206449,8206521,8240602,8232449,8238521,8240449,8222449,8226602,8208602,8204521,8218521,8228602,8198602,8204602,8196602,8234449,8220449,8222521,8216602,8200521,8216449,8226521,8230521,8210521,8224602,8220521,8234602,8228449,8230449,8206602,8238449,8224521,8236602,8222602,8230602,8208521,8232521,8212602,8202602,8196521,8208449,8218449,8214449,8200602,8234521,8226449,8212521,8210602,8200449,8228521,8212449,8214521,8240521,8198521,8224449,8236449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[8224806,8220806,8220920,8210920,8218806,8234806,8236806,8198920,8232806,8196920,8236920,8224920,8222806,8210806,8214806,8240806,8216806,8226920,8204806,8238920,8214920,8216920,8218920,8196806,8212806,8202920,8206806,8234920,8226806,8202806,8228806,8222920,8200806,8240920,8230806,8232920,8230920,8238806,8200920,8228920,8204920,8208920,8198806,8208806,8212920,8206920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[8231244,8229130,8215244,8203244,8231130,8205130,8215130,8241130,8207130,8239130,8217130,8219244,8235244,8221244,8233244,8225244,8199244,8209130,8205244,8203130,8241244,8201130,8229244,8223130,8217244,8237244,8239244,8211130,8227244,8223244,8227130,8201244,8235130,8237130,8197130,8213130,8225130,8221130,8213244,8207244,8211244,8197244,8219130,8209244,8233130,8199130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[8211454,8237454,8209454,8199454,8239454,8241454,8197454,8201454,8229454,8215454,8213454,8225454,8205454,8233454,8227454,8221454,8231454,8203454,8219454,8207454,8217454,8235454,8223454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[8235572,8209572,8231572,8197572,8211572,8233572,8239572,8227572,8205572,8207572,8215572,8213572,8217572,8221572,8199572,8201572,8237572,8203572,8219572,8241572,8225572,8223572,8229572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[8223691,8219691,8217691,8215691,8197691,8221691,8203691,8227691,8239691,8213691,8205691,8235691,8229691,8211691,8231691,8209691,8233691,8207691,8241691,8199691,8225691,8237691,8201691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[8209817,8217817,8207817,8199817,8223817,8231817,8237817,8197817,8219817,8229817,8233817,8227817,8241817,8211817,8205817,8239817,8225817,8203817,8213817,8221817,8215817,8201817,8235817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[8213837,8197837,8231837,8201837,8225837,8219837,8209837,8205837,8237837,8203837,8223837,8227837,8215837,8207837,8235837,8199837,8211837,8233837,8229837,8217837,8241837,8221837,8239837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[8246720,8242304,8246699,8248922,8251136,8253337,8255531,8253322,8251130,8251115,8244491,8253344,8248907,8244512,8248928,8246714,8255546,8244506],"length":1,"stats":{"Line":0},"fn_name":"with_capacity_and_scoring\u003c\u0026closure-0\u003e"},{"line":204,"address":[8242378,8246827,8251210,8246794,8253451,8244619,8242411,8251242,8249002,8249035,8253418,8244586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[8253530,8251321,8246906,8246812,8249020,8244698,8242396,8244604,8253436,8249114,8242490,8251227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[8253522,8251313,8244748,8242540,8242482,8246956,8244690,8253580,8249164,8249106,8251371,8246898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[8251306,8249099,8246891,8253515,8242475,8244683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[8249156,8251363,8251424,8244740,8242593,8253633,8253572,8244801,8249217,8247009,8242532,8246948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[8244733,8253565,8242525,8249149,8251356,8246941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[8251477,8244793,8253686,8249209,8253625,8249270,8244854,8251416,8242646,8242585,8247062,8247001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[8251409,8246994,8249202,8242578,8253618,8244786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[8242638,8244846,8253678,8251469,8249262,8251535,8244912,8242704,8253744,8247054,8249328,8247120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[8253671,8251462,8249255,8242631,8244839,8247047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[8247113,8242697,8249321,8253737,8251528,8244905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[8247158,8251573,8249480,8253782,8249366,8244950,8251687,8247272,8245064,8253896,8242856,8242742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[8243180,8249804,8243066,8254106,8249690,8247596,8251897,8245388,8247482,8245274,8252011,8254220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[8254544,8243390,8252335,8250128,8247920,8250014,8243504,8245712,8254430,8245598,8252221,8247806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[8248130,8250338,8245922,8243714,8252545,8254754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[8252663,8254872,8246040,8243832,8250456,8248248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[8248367,8252782,8246159,8250575,8254991,8243951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[8255117,8244077,8246285,8252908,8248493,8250701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[8256032,8255840,8255648,8255552,8255936,8255744],"length":1,"stats":{"Line":0},"fn_name":"with_scoring\u003cbio::alignment::pairwise::MatchParams\u003e"},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[8255682,8255778,8255970,8255586,8256066,8255874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[8258751,8262176,8262783,8263119,8260767,8263520,8264864,8256128,8259759,8264463,8262848,8262447,8260496,8258144,8264799,8257136,8261103,8262512,8257407,8265807,8257743,8259824,8257472,8260431,8258816,8257071,8262111,8258415,8260832,8263455,8261840,8265536,8259488,8257808,8258079,8264192,8265200,8264127,8265471,8258480,8260095,8256464,8263791,8264528,8263184,8259152,8261504,8263856,8261168,8259087,8261439,8261775,8259423,8256735,8256399,8265135,8256800,8260160],"length":1,"stats":{"Line":0},"fn_name":"custom\u003c\u0026closure-0\u003e"},{"line":272,"address":[8265771,8265308,8256572,8261612,8258715,8265644,8257916,8263964,8257707,8264972,8264300,8262747,8262411,8256236,8257580,8259932,8265435,8261948,8257371,8261276,8258379,8260731,8258043,8258252,8259051,8259723,8264636,8256699,8261403,8260059,8263292,8260940,8256363,8260395,8260604,8262284,8259387,8264091,8257244,8262956,8263628,8258588,8263419,8264427,8263755,8261739,8257035,8264763,8262075,8259260,8260268,8262620,8261067,8256908,8258924,8265099,8259596,8263083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[8264079,8260719,8265759,8263743,8256687,8260047,8264751,8256351,8258031,8257695,8261055,8258703,8257359,8261391,8261727,8257023,8263407,8262735,8262399,8259375,8258367,8265087,8259039,8260383,8259711,8265423,8263071,8262063,8264415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[8266163,8265872],"length":1,"stats":{"Line":0},"fn_name":"custom_with_prehash\u003c\u0026closure-0\u003e"},{"line":289,"address":[8266127,8265994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[8266115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[9303709,9064300,9184012,8625360,9423436,8665245,8705168,8665264,8585456,8385917,8784972,8665260,8904684,9223920,9303724,9223916,8824861,8625356,9263820,9024385,8346028,8545552,9184016,8944588,8505644,8545533,8864784,9343613,9144108,9343628,8745068,8306128,8385932,8944592,8824876,8824880,9064304,9303728,8984477,8505648,8306109,8585437,8784957,8425840,9343632,8904688,8266224,9263824,8705164,8346013,9223901,8745072,8864765,9104189,8545548,9104208,8465725,9024400,9183997,9383517,9423421,8745053,8585452,8425821,9383536,8346032,8904669,8625341,9263805,8984496,8705149,8944573,8465744,9144093,9383532,9144112,9064285,9104204,8306124,8984492,8425836,8864780,8505629,8385936,8465740,8784976],"length":1,"stats":{"Line":0},"fn_name":"compute_alignment\u003c\u0026closure-0\u003e"},{"line":396,"address":[9303848,8545672,8785096,9383656,8585576,9024520,8346152,8505768,8665384,8745192,8306248,8625480,8904808,8386056,8705288,8266344,9224040,8425960,9144232,8825000,9104328,8944712,9263944,8465864,8984616,8864904,9343752,9064424,9184136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[8465957,9024613,8266437,9383749,8904901,9104421,8346245,8825093,8665477,9064517,8545765,8944805,8386149,8306341,9264037,8426053,8585669,9303941,8505861,8864997,8625573,8785189,9343845,8705381,9224133,8984709,9144325,8745285,9184229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[9184207,9383727,8864975,8465935,8426031,9224111,9024591,9104399,8785167,9303919,8825071,8346223,8266415,9343823,8625551,8745263,8944783,9264015,8505839,8904879,8585647,8545743,9064495,8705359,9144303,8665455,8306319,8386127,8984687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[9024572,8665603,9224092,8865123,8266563,8545724,9304067,9263996,8346371,9303900,8984668,8625532,8625699,9343971,8904860,8705507,8944931,8585795,8745244,8505987,8705340,8665436,8545891,8306467,8466083,8984835,9064476,8306300,8585628,8426012,8944764,9104380,9383875,8505820,9144451,9224259,8905027,9343804,8825219,9024739,8745411,8346204,9264163,8785315,8386275,9383708,9144284,9184355,8465916,8386108,8426179,8825052,9184188,9104547,8864956,9064643,8266396,8785148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[8266665,9383977,8905129,8665705,8306569,8426281,8984937,8625801,8386377,8785417,9224361,8865225,8346473,9064745,9104649,8705609,8545993,9264265,8745513,9184457,8466185,9144553,9024841,8585897,8506089,8825321,9304169,9344073,8945033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[8547143,8945045,8945217,8266849,8866375,8386389,8905313,9025991,8745525,9144737,9305319,9384161,8705793,8347623,8985121,9385127,8387527,8307719,8506101,8785429,9104833,8426293,8466197,8984949,9184469,9104661,8905141,8586081,8546005,8865237,8746663,9224373,8825333,9265415,8306753,8427431,9025025,8706759,9145703,8587047,8626951,8625813,9105799,8386561,8625985,9225511,8745697,9144565,9224545,9064929,9264277,9304353,8705621,8826471,8906279,9383989,8825505,9345223,8546177,8346657,8267815,9264449,9185607,8665889,8585909,8466369,8785601,8786567,8346485,8946183,8507239,8865409,8426465,8266677,9344257,9024853,9064757,9344085,8666855,8665717,9065895,9304181,9184641,8467335,8986087,8306581,8506273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[8985161,8825545,9104873,8785641,9224585,8546217,8266889,8346697,8665929,8426505,8626025,8586121,8865449,8745737,8945257,8506313,8306793,9344297,8466409,8905353,9264489,9064969,8386601,9304393,9144777,9184681,9025065,8705833,9384201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[8825631,8466495,9025151,9065055,8945343,8745823,8785727,8386687,8905439,8506399,8546303,9264575,8705919,8586207,9104959,8626111,9304479,8985247,9144863,8306879,8666015,9384287,8346783,8426591,9184767,9344383,8266975,9224671,8865535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[8905525,9065141,9224757,9105045,8386773,8306965,8945429,8985333,8666101,8865621,9344469,9025237,9144949,8346869,8426677,8706005,8586293,8466581,8506485,9264661,8546389,8785813,8626197,9184853,8825717,8745909,9384373,8267061,9304565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[8745991,9025319,8307047,8706087,9145031,8546471,8865703,8985415,8905607,8466663,8346951,8506567,8785895,8386855,9224839,9184935,8825799,9105127,9384455,8666183,9344551,8586375,8426759,9065223,9304647,9264743,8945511,8626279,8267143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[8307275,8586603,9304875,9225067,9025547,8666411,9145259,8347179,9185163,8985643,8426987,8746219,8387083,8626507,8706315,9344779,8506795,8546699,8905835,9264971,8826027,8865931,8786123,8267371,8945739,9065451,8466891,9384683,9105355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[9305103,9265199,9384911,9225295,8507023,8307503,8626735,8546927,9345007,8866159,9065679,9105583,8945967,8706543,8985871,8586831,8427215,8467119,8347407,8906063,8666639,8267599,8387311,8826255,8746447,9145487,8786351,9025775,9185391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[8905295,8705775,8346639,8825487,9104815,9344239,8945199,9224527,8466351,8586063,8266831,8865391,8306735,9144719,8745679,8665871,8426447,9025007,8625967,8506255,9384143,8785583,9264431,9184623,8985103,9304335,9064911,8386543,8546159],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[9026004,9185620,8427444,9065908,9305332,8786580,9345236,8307732,9145716,8706772,8347636,8387540,8587060,9105812,8507252,8946196,8666868,9385140,8547156,9265428,8866388,8986100,8746676,8626964,8906292,9225524,8826484,8267828,8467348],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[9385304,8587224,9185784,8547320,9345400,9225688,8507416,8706936,8786744,9105976,8467512,8906456,8267992,8866552,8667032,8427608,9145880,8946360,8307896,9066072,8627128,8347800,8826648,8387704,9026168,8986264,9305496,8746840,9265592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[9225709,9145901,8986285,8547341,8746861,9066093,9105997,8507437,9185805,8268013,8866573,8587245,8826669,8946381,8906477,8627149,9305517,8786765,8307917,8706957,8467533,8427629,8347821,9265613,8387725,9026189,8667053,9345421,9385325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[9185969,9106161,8268177,9265777,8347985,9385489,8587409,8866737,8467697,9225873,8786929,8627313,9026353,8308081,8707121,8667217,8986449,8547505,8427793,8387889,9146065,8906641,9305681,8826833,8507601,9345585,8747025,8946545,9066257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[8467717,8707141,9066277,8587429,8866757,9385509,8507621,8547525,8387909,8826853,9225893,9146085,8986469,9345605,8348005,8786949,8627333,8427813,8308101,9265797,9106181,8906661,9185989,8268197,8667237,8946565,9305701,8747045,9026373],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[8787110,9345766,8866918,8467878,8986630,8747206,8427974,8827014,8667398,9265958,8627494,8268358,8507782,9066438,8308262,9226054,8906822,9186150,9305862,9385670,9026534,8946726,8348166,9106342,9146246,8587590,8388070,8547686,8707302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[9146258,8507794,8627506,8427986,8906834,8388082,8707314,8348178,8946738,9026546,8747218,8787122,8268370,8986642,9265970,8467890,8667410,9186162,8587602,8308274,8547698,8827026,9066450,9345778,9385682,8866930,9226066,9305874,9106354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[9026616,8547768,9146328,8428056,8348248,8787192,8867000,8587672,8467960,8268440,9345848,9186232,9266040,8946808,8507864,8986712,8627576,9385752,9106424,8707384,8906904,9226136,9305944,8308344,8747288,8827096,8388152,8667480,9066520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[8627647,8986783,8428135,8308500,9146407,9306015,9026695,8348327,8587828,8946964,9345919,8986791,9026772,8547839,8867156,8827175,8747367,8268519,8308415,9146484,8507935,9026687,8747359,8667636,9066591,8348319,9345927,8348404,8747444,8268596,8468116,8468031,8986868,8587743,8627732,8787263,8787348,8906975,8388231,8946879,9186388,8707540,8587751,9346004,9306023,9306100,8388308,9385831,8388223,8667559,8667551,9226207,9226292,9186311,8906983,8707463,8946887,9066599,8827167,8627655,8308423,8707455,8428212,9266111,9226215,8507943,8827252,9186303,9266196,8547924,8268511,9106495,8468039,9385908,9146399,8428127,9385823,8508020,8867071,8787271,9106580,8907060,8547847,9266119,8867079,9066676,9106503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[9226213,9186350,9066597,8507941,8547886,9146405,8707461,8587749,8308421,8547845,8907022,8348366,8627653,8906981,9385870,9066638,8986789,8667598,8827173,8627694,9306062,9186309,8428133,8946926,8308462,8428174,9026734,8507982,8468078,9345966,9266158,8388270,9146446,9106542,8787310,8787269,8468037,8986830,8747365,8348325,8946885,8667557,9226254,9026693,8747406,8867118,9266117,9306021,8827214,8707502,9345925,9385829,8587790,8268558,8867077,8388229,8268517,9106501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[8507953,8272026,9070106,8747377,8348337,8547942,8268788,9186406,8870586,9306033,9226310,8351834,8827444,8388241,8348596,8787366,8308692,8587761,8707732,8468308,8787540,8268614,8867174,9066694,8907078,8907252,8311930,8428230,9229722,8910490,9106513,8627665,9186321,8308433,9106772,9106598,8950394,9226225,8468049,8867089,8790778,9309530,9110010,9026790,9149914,8268529,9346196,9266129,9189818,8671066,8388500,9266214,9146502,8986886,8627750,8428404,8511450,8508212,8867348,8990298,8827270,9385926,9066609,8388326,8710970,8391738,8428145,8707473,8827185,9146417,9306118,8667828,8348422,9030202,8471546,8787281,8548116,8707558,8431642,9186580,9266388,8588020,8946982,8747636,8747462,9226484,8587846,8906993,8986801,8627924,8667569,9306292,9345937,8947156,9026964,8468134,8551354,8308518,9146676,9349434,9346022,8830682,8508038,8750874,9269626,8667654,8946897,8591258,9385841,8547857,9026705,9066868,8987060,8631162,9389338,9386100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[8747681,8867393,9106817,9226529,9186625,8707777,9386145,8947201,8907297,8787585,8627969,8667873,9146721,8348641,8987105,8388545,8508257,9266433,8428449,8588065,8308737,8827489,9027009,9066913,8548161,8468353,9306337,9346241,8268833],"length":1,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[8747689,9266441,8667881,8627977,9306345,8907305,8508265,9146729,8947209,8388553,8588073,9106825,8827497,8787593,9386153,8548169,8308745,8428457,9027017,8867401,8268841,8348649,8987113,9066921,8707785,9186633,9346249,8468361,9226537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[8868586,8867424,8309930,9267626,8987136,8428480,8508288,8548192,8628000,8669066,9108010,8268864,9187818,8667904,8988298,8388576,9106848,9387338,9066944,8629162,8748874,9186656,8588096,8509450,8270026,9346272,9147914,9347434,8788778,9226560,8468384,8828682,9027040,9307530,9266464,9146752,8389738,8747712,8947232,8349834,8707808,8308768,8787616,8469546,8907328,8348672,9068106,8948394,9028202,8827520,8708970,8589258,8908490,9306368,9386176,8549354,9227722,8429642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[8628893,8628014,9307261,8308782,9066958,8668797,8868317,8788509,8548206,9027054,8469277,9027933,9187549,9267357,8748605,8468398,8349565,8388590,8269757,9147645,8948125,8828413,8588989,9186670,8389469,8348686,8429373,8747726,8827534,8988029,8987150,8947246,8549085,8428494,8707822,9387069,9306382,8787630,8908221,8588110,8667918,9347165,9346286,8508302,8907342,9227453,8268878,9106862,9146766,8708701,8509181,9107741,9266478,8867438,9226574,9067837,8309661,9386190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[9386389,8468597,8867637,9027105,9107061,8668117,9106913,8468449,8508501,9186721,8987349,8269077,8827585,8827733,8388641,8707873,8787681,9266677,8588161,9306581,8907541,8947445,8508353,9346337,8388789,8588309,8428693,8548257,9306433,8308833,8867489,8907393,8548405,8947297,8987201,8268929,8747925,8747777,8787829,9266529,9186869,8628213,9226773,8308981,9386241,8348737,9346485,8428545,8628065,9226625,9027253,8708021,8667969,8348885,9146965,9067157,9146817,9067009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[8787874,9027377,8787801,8349009,8907586,8827857,9186993,8269201,8987394,9147089,8309105,9226897,8428665,9107106,9346457,8827778,9306626,9067202,8628337,9266649,8867609,8548377,8308953,9266722,8309026,9346609,8747970,8867761,9027225,8628258,8508546,8747897,8708066,8987473,8947490,9266801,8548529,9147010,8708145,8348930,8628185,8947417,9226745,8907665,8748049,8867682,8508473,9306705,8468642,8468569,9346530,8907513,9067281,8388834,8668089,9186841,8668162,8588433,9107185,8388761,8668241,8947569,8348857,9226818,8588354,9186914,8269049,9386361,8428817,9386513,9067129,8269122,8548450,9146937,8428738,8707993,8508625,8588281,9027298,8787953,8987321,8468721,9386434,9306553,9107033,8388913,8827705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[9067275,9187271,8708423,8548807,8907659,8388907,8549080,8508903,8468715,9306699,9387064,8788231,8428811,8469272,8987751,8748043,8668519,8787947,8389191,8508619,8947563,8509176,9386791,9227175,8947847,8429368,9147083,8748327,8907943,8748600,8349287,8987467,9147367,9347160,9267352,8309656,9226891,8309099,8708139,9107736,9187544,9227448,8269752,8588984,8948120,9307256,9267079,8429095,9067559,9067832,9306983,8668235,8668792,8828135,8309383,8349560,8628888,8868039,9027371,9107463,8588711,8708696,9386507,9027928,8827851,8628615,8828408,8788504,8468999,9147640,8628331,8908216,8867755,9346887,9107179,9027655,8548523,8868312,8349003,9266795,8269479,9186987,8269195,8588427,8988024,9346603,8389464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[8748084,9067316,9386548,8867796,8428852,8588468,9266836,9226932,9306740,8907700,9187028,9346644,8787988,8628372,8468756,9107220,8708180,9147124,8349044,8388948,8827892,8987508,8508660,9027412,8668276,8269236,8548564,8947604,8309140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[8508655,8349039,9227223,9266831,8748375,9346935,9306735,8867791,9107215,8548559,9346639,8349335,9107511,8708471,8269527,8309135,8748079,8628663,8588759,9067311,9267127,9226927,8309431,9307031,9147415,8947895,8788279,8668567,9027703,8428847,9386839,9067607,8987503,9027407,9187319,9147119,8987799,8429143,8827887,8907695,8508951,8868087,8469047,9386543,8628367,8388943,8389239,8787983,8708175,8468751,8588463,8907991,8947599,8548855,8668271,8269231,9187023,8828183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[9107481,9346905,8589452,9387343,8868591,9347439,8708975,8828687,9227727,8509455,8349305,9068111,9387532,8908495,8669071,9028396,8389932,8629356,8429113,8270031,8907961,8788972,8469551,8948399,8948588,9108015,9187823,8908684,8828153,9147385,8389209,8788783,8589263,8868780,8549548,9386809,8389743,9227916,8309401,8509644,8469740,8429647,8310124,8629167,8709164,8548825,9068300,9188012,9307535,9267631,8668537,8987769,8469017,8988303,8788249,8270220,8549359,9267097,8309935,8828876,9227193,9108204,9267820,8269497,8868057,8669260,8588729,8628633,9067577,8749068,9027673,8508921,8708441,8350028,8429836,9307724,8748879,9148108,9028207,9347628,8988492,9307001,9187289,8349839,8947865,8748345,9147919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[8350445,8948590,8669262,8908686,8350030,8669677,8270222,8549550,8829293,8909101,9188429,8789389,8868782,8749070,9348045,8429838,8988909,9108621,9148110,8430253,8629773,8310541,8709581,8470157,8828878,9267822,9307726,8509646,8869197,8390349,9387534,9028813,9268237,9228333,9347630,9387949,8270637,8749485,9028398,9068717,8510061,8629358,8310126,9308141,8788974,9068302,8709166,9227918,8949005,9148525,8469742,8589869,8589454,8389934,8988494,9188014,9108206,8549965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[9307845,9347749,8789093,8390053,9108325,8350149,8589573,8828997,9228037,8549669,8709285,8948709,9387653,8629477,8669381,8469861,8749189,8310245,8908805,8429957,8270341,9028517,9267941,9068421,9188133,8868901,8988613,9148229,8509765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[9108631,8709591,8630114,8310882,9068727,8629783,9308151,8988919,8270978,9268247,8949015,8430594,9188770,8989250,9029154,8270647,9387959,8749826,8829303,8470167,9348055,8709922,8869538,8949346,8829634,8350455,8310551,9348386,8869207,8669687,8589879,8670018,9148866,9268578,9228674,9308482,8749495,8549975,8789399,8590210,8350786,8909111,9388290,9028823,9188439,8430263,8390359,8550306,9108962,8510071,8470498,9228343,8789730,8390690,8909442,9148535,9069058,8510402],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[9228424,8470248,8749576,9028904,9148616,8789480,8949096,8829384,8270728,8909192,8989000,9188520,9308232,8350536,8310632,9108712,9348136,8669768,8430344,9268328,8709672,9068808,8589960,8390440,8629864,8550056,8510152,9388040,8869288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[9348388,8511081,9268580,8351465,9109641,8350788,8789732,9388969,8470500,8391369,8830313,8550308,8311561,8310884,8630793,8869540,8471177,8870217,8431273,8749828,9029833,8949348,9149545,9069737,8590212,9309161,8590889,8710601,8750505,8909444,9228676,9269257,8910121,8950025,8390692,9229353,9188772,8550985,8829636,8270980,9148868,8709924,8430596,8271657,9029156,9108964,8510404,8670697,9069060,9189449,9308484,8989929,8670020,9349065,8989252,8630116,9388292,8790409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[9188940,9308652,9109132,8710092,9268748,9149036,8271148,8869708,8909612,8749996,8789900,8949516,8430764,8670188,8590380,9388460,9069228,8470668,8630284,9228844,8550476,8390860,8350956,9348556,8829804,8510572,9029324,8311052,8989420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[8949693,8750173,8311229,9149213,8909789,9189117,9069405,8430941,8391037,9229021,8989597,8829981,9268925,8510749,8869885,8790077,8470845,8670365,8630461,9029501,8710269,8271325,9348733,8590557,9388637,8550653,9109309,8351133,9308829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[8870010,8590682,8510874,9308954,9348858,9109434,8470970,8909914,8830106,9029626,8949818,8790202,8670490,8311354,9069530,9189242,8351258,8710394,8630586,8750298,9229146,8989722,8391162,9388762,8550778,8271450,9269050,9149338,8431066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[8471195,8750523,9149563,8670715,8391387,9349083,8311579,8950043,8830331,8710619,8431291,8511099,8271675,9309179,8790427,8590907,8910139,9189467,8989947,9069755,9109659,9388987,9229371,8870235,8551003,9029851,8351483,8630811,9269275],"length":1,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[9190168,9269976,8431663,9110504,8827416,8627896,8711464,8671416,8831032,8710991,8910984,8870607,9389688,8468280,8348568,9269647,8791272,8910511,9270120,9066840,8431992,9110360,8391759,8747608,9030696,8990792,9149935,9070127,8511471,8751368,9070600,8548088,8511944,8352184,9386072,8551704,9030552,8392088,8631512,9230216,9349784,8711320,8907224,8272376,9150408,9309880,8667800,8471896,8308664,8751224,9349455,8830703,8671087,9146648,9346168,8272520,9310024,8870936,8631183,8787512,8950415,9389359,8551375,8312424,9226456,8947128,9229743,8472040,8551848,8791128,9190312,8707704,8388472,8272047,8671560,8831176,8987032,8471567,9070456,8950888,9266360,8268760,8910840,9349928,9150264,8950744,8867320,9230072,8591752,8587992,8790799,8392232,8871080,8511800,8990648,8508184,9110031,8312280,9189839,8432136,9389832,8990319,9309551,8631656,9030223,9026936,8428376,8311951,9306264,8591608,8750895,9186552,9106744,8352328,8591279,8351855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[8551760,9190224,9230128,9389744,8910896,9150320,8831088,9070512,8392144,8671472,9309936,8711376,8631568,8870992,8950800,8791184,8432048,8272432,9349840,8591664,8751280,9110416,8990704,9030608,8352240,8312336,9270032,8511856,8471952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[8871042,9150370,8791234,8950850,8392194,9349890,8432098,8711426,8671522,9070562,8751330,9230178,8352290,8910946,9190274,8272482,8631618,8591714,8472002,8551810,9309986,9110466,9389794,9270082,8990754,8312386,9030658,8831138,8511906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[9190140,8990620,9110525,8511772,8831197,8950716,8910812,9230044,8751389,8671388,9349756,9309852,8631677,8432157,9030524,8551676,8631484,9389660,9150429,9110332,9070621,8352349,8272541,8990813,8431964,8312252,8511965,9150236,8751196,8791100,8352156,8791293,9310045,9190333,8871101,8392253,8870908,9030717,8831004,9070428,9389853,9269948,8591580,9230237,8312445,8711292,8950909,8911005,8671581,8551869,8471868,9270141,9349949,8472061,8272348,8591773,8711485,8392060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[8871140,9230276,8711524,8392292,9389892,8791332,9349988,8312484,8512004,9310084,9190372,8472100,8591812,8671620,9030756,8432196,8911044,9070660,8751428,9110564,8272580,8551908,9270180,8631716,9150468,8990852,8950948,8352388,8831236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[9270928,8671680,8312907,9070720,9230336,8352448,8911792,8472848,8751488,9231024,8631776,9270603,8951371,8272640,8273328,8871888,9350411,9310144,8552656,9030816,9151216,8551968,9390640,9230699,8472160,8432619,9310832,8711584,8791392,8672368,8432944,9310507,8871563,9031179,8632139,8791755,8911104,8592235,8552331,8392352,8831659,9071083,9190432,8512752,9390315,8313232,8951008,8911467,9150528,8831296,8871200,9111312,9190795,8393040,8312544,9110987,8991600,8711947,8672043,8432256,8472523,9110624,8951696,8592560,8751851,9071408,8512064,8352811,8632464,9150891,9389952,8752176,8591872,8831984,8990912,8792080,9270240,9350048,8273003,9031504,8392715,8512427,9191120,9350736,8712272,8353136,8991275],"length":1,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[9150607,8911183,9390031,9190511,9310223,8990991,9230415,8352527,8312623,8591951,9350127,8392431,8951087,8831375,8711663,8671759,8512143,9110703,8472239,9030895,8631855,8552047,8272719,9270319,8432335,9070799,8791471,8871279,8751567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[8951164,8911260,8512220,8631932,8472316,9150684,9030972,9190588,9390108,8272796,8711740,8312700,8592028,9310300,8871356,8831452,9270396,8392508,9110780,8751644,8552124,8791548,8352604,9070876,8671836,8991068,9350204,8432412,9230492],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[8552388,8911126,9111044,8512484,9230756,9190852,8751908,8712004,8831318,8672100,8951030,9230358,8352868,8312566,8392772,8352470,8272662,9350070,9150550,8273060,8392374,8312964,8512086,9350468,9031236,8591894,9389974,9310564,9390372,9070742,8631798,9110646,8871222,9150948,8791414,9190454,8432676,8831716,8632196,9071140,8871620,8432278,8791812,8911524,8592292,8990934,8991332,9030838,8551990,9270660,8472580,8671702,8472182,8951428,8751510,8711606,9310166,9270262],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[8951430,9111046,9150950,9190854,8273062,8751910,9230758,9310566,9350470,8911526,9270662,8592294,8791814,9031238,8312966,9390374,8432678,8512486,8552390,8871622,8392774,8831718,8352870,8672102,8991334,8632198,8472582,9071142,8712006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[8392833,9350529,8552449,9190913,8672161,9270721,8512545,9310625,8712065,8831777,8313025,8871681,8991393,8911585,9111105,9390433,8472641,8751969,9151009,8791873,8273121,9071201,8432737,8951489,9031297,9230817,8592353,8352929,8632257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[8767962,8488634,9390798,8911477,9350894,8792238,9151221,8273013,8887674,8672373,9310517,8393045,9031189,9167002,9310837,8792085,9206906,9271086,9406426,8433102,8807866,8472853,8648250,9231029,8432949,8512757,9350741,9246810,9310990,8592565,8552341,9270613,8832142,9151374,9270933,8712430,9111470,9127098,8911797,8711957,9031662,8568442,8313390,8273486,8752334,8393198,9071413,8688154,8368922,8831669,9047290,8991605,8313237,8528538,8312917,8608346,8831989,8592245,9071566,8991285,9110997,8712277,8392725,8991758,8353141,9230709,8728058,8632622,8911950,8592718,8448730,9366522,9326618,8353294,9190805,8432629,8871893,9390645,8329018,9191125,8967482,8791765,8512910,8672053,9350421,8552661,9087194,9111317,8752181,9071093,8872046,8847770,8871573,8472533,8951701,9191278,8632469,9150901,8951381,9031509,9286714,8512437,8927578,8751861,9007390,8352821,8289114,8632149,8552814,8672526,8408826,9231182,9390325,8473006,8273333,8951854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[8872086,8273526,9071606,8712470,8792278,8393238,8433142,8512950,8353334,9111510,8991798,8552854,9390838,9231222,8672566,8632662,8951894,9151414,9311030,8832182,8473046,9191318,9350934,9031702,8313430,9271126,8911990,8592758,8752374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[9351042,9111530,8513058,9231330,8632682,8712490,8433250,8912098,9191426,8473154,9031722,8273634,8353354,8552962,8552874,9191338,8592866,8393346,8353442,9111618,8672586,8433162,9311138,8672674,9271234,8991818,8952002,9390946,9151522,9071626,8313538,9231242,9271146,8832290,8792298,8832202,8473066,8991906,9071714,8872194,8792386,8273546,9350954,8872106,8951914,8393258,8512970,8712578,8592778,9311050,9390858,9031810,8912010,8752482,8752394,8313450,8632770,9151434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[8592920,8672641,8952056,9390913,8473121,8632824,9071768,9031864,9191480,8712545,8313505,9231297,9311192,8912065,9071681,8353496,8672728,8832344,8991873,8353409,8393313,8313592,8912152,8792353,8513025,8592833,8792440,8552929,8273601,9151489,9351009,9191393,8832257,8433217,8553016,9271288,8433304,9111585,8872161,9031777,8712632,9391000,9231384,8752449,8273688,8872248,8951969,8632737,8513112,8991960,8752536,9111672,9351096,9311105,9151576,9271201,8473208,8393400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[9111691,9191499,8712651,8433323,9071787,9031883,8393419,8513131,8353515,8553035,9391019,9151595,8592939,8752555,8952075,9351115,8912171,8473227,8991979,8273707,8313611,8632843,8872267,9271307,8672747,9231403,8792459,9311211,8832363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[9231470,9155277,9235085,9311299,8593027,8792547,8672835,8712718,8836045,8792526,8992046,8433390,8636525,9151662,8875949,9391107,9271395,8596621,9035565,8516813,8915853,8756237,8273795,8796141,8393486,9351203,8357197,8995661,8553123,8473294,9151683,8832451,8593006,8553102,8513219,8556717,8952142,8353582,8476909,8393507,9031950,8277389,8513198,8672814,8752643,8992067,8273774,9311278,8397101,9071854,8955757,9195181,9031971,9191587,9231491,8632910,9111758,9391086,8676429,8716333,8872334,8952163,9354797,8437005,9351182,8712739,9191566,8872355,9274989,9271374,8353603,9314893,8832430,8317293,8912238,8912259,9115373,8473315,9075469,9394701,8313678,8752622,8313699,9111779,8433411,8632931,9071875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[8273785,8832441,9191577,8353593,8952153,8912249,9391097,8672825,8712729,9031961,8513209,9311289,8393497,9111769,8792537,8992057,8632921,9271385,8553113,8313689,9351193,8473305,8593017,8752633,8872345,9151673,9071865,8433401,9231481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[8992144,8952240,8752720,8832528,8633008,8273872,8553200,8912336,9032048,8353680,8313776,8792624,9111856,8513296,8712816,9311376,9071952,8433488,8872432,8593104,9271472,8393584,9151760,9391184,9231568,9351280,9191664,8672912,8473392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[8953712,9231687,9153232,8433607,9271591,8792743,8674384,8275344,8393703,9151879,9392656,8754192,8473511,8474864,8593223,8993616,9311495,9032167,8872551,8794096,9312848,8832647,8553319,8315248,9111975,8712935,8673031,9272944,8834000,9191783,9391303,8554672,8514768,8434960,9351399,9352752,8952359,8634480,8714288,8992263,8912455,9033520,8313895,8353799,8395056,8273991,9113328,8633127,9193136,9073424,9233040,8594576,8873904,9072071,8355152,8913808,8513415,8752839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[8712949,9271605,8832661,8434636,8594252,9231701,9113004,8393717,8953388,8913484,9352428,9072085,8553333,8673045,9033196,8993292,8473525,8554348,8752853,8793772,9151893,8474540,8353813,9392332,8872565,8394732,8952373,8992277,9272620,9312524,9032181,8753868,8674060,8792757,8873580,8634156,9111989,8354828,9311509,8433621,8314924,8274005,8912469,8633141,9191797,8275020,8593237,9391317,8514444,8833676,9152908,8713964,9351413,8513429,8313909,9073100,9192812,9232716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[8792808,8313960,8513480,9271656,9072284,8633192,9231900,9311708,9231752,8473724,8274204,8832712,9112188,8952424,8872764,9351612,8673096,8872616,8753052,8952572,8314108,8593288,8633340,8553384,8832860,9351464,8393916,9191848,9271804,9391516,9032380,8393768,8433820,9391368,9072136,8673244,9032232,8992328,8433672,8553532,8912520,8792956,9191996,8713000,9151944,8752904,8274056,8992476,8473576,8912668,9311560,9152092,8713148,9112040,8513628,8354012,8353864,8593436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[8992600,8274176,8753024,8753176,9231872,9391561,8553577,8513673,8793001,8513752,8713120,9032504,8553504,9112312,8673368,8793080,9152064,9232024,8393888,8513600,9192041,8912640,9351736,8753097,8992448,9311832,8433792,8593481,8593408,8912792,9391640,9391488,8553656,8872888,8314153,8673216,8473696,9351657,8354136,8952617,8952544,9271849,9072408,9072256,8673289,9192120,8832905,8354057,9112233,9112160,8992521,8393961,9152216,8633464,8593560,8473848,9271776,8832832,8872809,8274328,8713193,8792928,8394040,8314080,8353984,9032352,9311680,9191968,9072329,8314232,9231945,8274249,8872736,9032425,8633385,8713272,9152137,8912713,9311753,8433944,8433865,9351584,9271928,8832984,8473769,8952696,8633312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[9032498,9392004,9352100,9112306,9192114,8753855,8674047,8514116,8394404,9152210,8513746,8793759,8354500,8753170,8832978,9152895,8633458,8434623,9232388,9232703,8753540,8394034,8793074,9312196,8713636,8833663,8833348,9072772,8673732,8913156,9311826,8593554,8274322,9112991,8953375,9033183,8474527,9391634,8873567,8912786,8953060,8394719,8873252,9271922,8433938,8673362,9232018,8713951,8952690,8793444,8634143,9392319,8713266,9192799,9272607,8633828,8434308,8992594,8993279,8275007,8314911,8274692,9352415,8314596,9073087,8354815,8872882,8913471,8553650,9351730,9192484,8554335,8593924,8474212,9312511,8992964,8594239,9152580,8514431,8554020,8473842,9072402,8354130,8314226,9272292,9032868,9112676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[8912858,8633530,8673434,9232090,8833050,9152282,8713338,9311898,9351802,8314298,9072474,8992666,8872954,8473914,8952762,9112378,8354202,8593626,8394106,8513818,9391706,9192186,8553722,8753242,8274394,9271994,8434010,8793146,9032570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[9192530,8553694,9311870,8354546,8433982,9072818,9391678,8633874,8473886,8593970,8912830,8713682,8993010,9152254,8753586,9032914,8513790,8673778,8394450,9351774,8793490,8274366,9032542,8314642,9112722,8314270,8793118,8833394,9192158,9271966,8673406,8554066,8833022,9112350,8992638,8434354,8873298,8474258,8633502,8713310,8274738,9152626,9072446,8953106,9232062,9352146,8354174,8394078,9392050,8872926,8514162,9232434,8952734,9312242,9272338,8753214,8593598,8913202],"length":1,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[9073445,9072782,9312869,8354510,8554693,8953733,9232398,8994204,8274702,9393555,8276243,9032878,8275932,8953070,8635379,8714876,8793454,9193724,9273843,9034108,8674405,8635068,8673742,8794117,8713646,8594597,8992974,8434981,8994515,8316147,8555260,8434318,9113349,8514126,8714309,8754780,9154131,8874803,8753550,8954611,8913829,9353651,8874492,9153253,9033541,8356051,8474222,8395955,9233939,8515356,8794995,8554030,8355173,9313747,9392677,8315836,9153820,8314606,8394414,8595475,8395077,9194035,9034419,8754213,8834021,9193157,8715187,9112686,8634501,9352110,8913166,8834899,8833358,9114227,8993637,9113916,9192494,9074012,8873262,8794684,8755091,8435859,8595164,8474885,9233061,8873925,8435548,8593934,8633838,8355740,8674972,8914396,8675283,9074323,9273532,9272965,9272302,8315269,8395644,9152590,8954300,8914707,8475763,9353340,8475452,9352773,8555571,9393244,8515667,9233628,9392014,9313436,8275365,8514789,9312206,8834588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[8355324,9193308,8754364,8953884,8674556,8275516,9273116,9113500,9153404,8834172,9392828,8993788,9233212,8794268,9033692,9073596,8874076,8554844,8315420,8594748,8913980,9352924,8435132,8475036,8514940,8714460,8395228,8634652,9313020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[9113459,9034154,9033651,8794227,9153363,8993747,8954346,8315882,8754826,8275978,9153866,8714419,9073555,9313482,8913939,8754323,9193770,8794730,8634611,9113962,8435594,8514899,8953843,8475498,8994250,8674515,8275475,8834634,8515402,9233171,8435091,8395187,8474995,8675018,9273578,8554803,9353386,9393290,8874035,8395690,8834131,8714922,9392787,9233674,9273075,9352883,8874538,8595210,8315379,9193267,8635114,8594707,8914442,8555306,8355283,9074058,9312979,8355786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[8356072,8436652,8755884,8595174,9113926,9354444,9075116,8715980,8795788,9394348,8915500,8396748,8555592,8476556,9154152,9153830,9273864,8636172,8275942,8995308,8515688,8954632,8834598,8914728,8555270,8755112,8556364,9314540,9273542,9114248,9193734,8355750,8435880,8914406,8834920,8316940,9393254,8635078,8795016,8955404,9353672,8435558,9115020,8874824,9034118,9035212,8595496,8596268,8875596,8515366,9233638,9274636,8714886,8874502,8675304,9313446,9034440,8676076,8277036,8674982,8356844,9074022,8835692,9074344,9234732,8276264,9353350,9194056,9313768,9154924,8794694,8754790,8395654,8475784,8395976,8994214,8994536,8475462,9194828,9393576,8635400,8954310,8715208,8516460,8316168,9233960,8315846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[8356277,8755317,8396181,8835125,9194261,9114453,9034645,9353877,8675509,8635605,8715413,8475989,9154357,8875029,8436085,8555797,9274069,9234165,8595701,9074549,8994741,8316373,8954837,9393781,8914933,9313973,8276469,8795221,8515893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[8356512,9314208,8436320,9234400,8915168,9354112,8316608,8675744,8556032,9154592,8994976,9074784,9034880,8635840,8276704,8795456,8835360,8875264,8715648,9194496,9394016,8396416,9114688,8476224,8955072,8755552,8516128,8595936,9274304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[8795581,8276829,9154717,8955197,8835485,8396541,8356637,9274429,9354237,9194621,8675869,9035005,8316733,8715773,8915293,9314333,8596061,9394141,8556157,8436445,8875389,8635965,9114813,8516253,9074909,8755677,8476349,8995101,9234525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[8596286,9154942,9075134,8715998,8277054,9274654,8955422,8915518,8676094,8316958,8556382,9234750,8516478,8875614,9394366,8396766,8636190,8476574,8356862,9314558,9194846,8795806,8755902,9115038,8995326,8835710,8436670,9354462,9035230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[8556738,9151747,8915874,8437026,8952227,8672899,8955952,9231555,8636720,8632995,8716528,8593091,8597213,9395293,8437597,9354818,8313763,8752707,8357392,9111843,8676624,9275184,8995682,9235106,8996253,8357218,9075664,8796733,8995856,9035760,8596642,9195202,8636546,8876541,8872419,8317314,9354992,8637117,8317885,8756829,9315485,8836637,9036157,8476930,8517405,8353667,8553187,9115568,9076061,8277584,8397693,8676450,9191651,9195773,8517008,8473379,9311363,8916048,8477104,9115965,8712803,9391171,8437200,8836066,8397122,9195376,9115394,9071939,8796336,8677021,8912323,8716925,8277981,8796162,9155298,9314914,8433475,8556912,8916445,8756432,8756258,8836240,9032035,9275010,8876144,8792611,9235677,8992131,9394722,8273859,8956349,8397296,8716354,8875970,8557309,8832515,9235280,8393571,8596816,8955778,9275581,9155869,8357789,9271459,9394896,9351267,9315088,9075490,8516834,9355389,9155472,9035586,8477501,8513283,8277410,8317488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[9155512,8357432,9394936,8437240,8916088,9075704,8995896,8517048,8317528,8796376,8836280,8716568,8397336,8477144,8676664,9115608,9275224,8636760,8955992,9315128,9035800,8596856,8277624,9235320,8556952,8876184,9195416,9355032,8756472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[9155631,8596975,8836399,8277743,9355151,8876303,8517167,9115727,8756591,9395055,8636879,8397455,9235439,8796495,8477263,9275343,8317647,9315247,9075823,8357551,8956111,8716687,8557071,8437359,8676783,8996015,9195535,8916207,9035919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[8836522,8796618,9395178,8676906,8637002,9355274,9235562,9275466,8916330,8397578,9036042,9195658,8557194,9155754,9315370,8597098,8956234,8716810,8477386,8876426,8317770,8357674,9075946,9115850,8277866,8756714,8437482,8996138,8517290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[9075636,9315060,8597242,9115994,9235252,8956378,8756404,8677050,8317460,9315514,8277556,8995828,8477530,9155444,9195348,8916474,9355418,8955924,8796762,9036186,8516980,8477076,9235706,8317914,8836666,9394868,8437172,8876116,8397268,8278010,9275610,8676596,9195802,8876570,8996282,8716954,8437626,9035732,8916020,8836212,9395322,9115540,8637146,8517434,9275156,8397722,8557338,8716500,9354964,8796308,9155898,8596788,8556884,8357364,8636692,8357818,8756858,9076090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[9235961,9355500,8797017,8956460,9036268,9315769,8757113,8477785,8517516,8557593,8876825,9036441,8717209,8796844,8996537,8357900,8677305,9156153,8318169,9076345,9195884,8278265,8397977,8956633,8397804,8756940,9315596,8317996,9275692,8637401,9116076,9196057,8437708,9355673,8557420,8358073,8597497,8637228,8437881,9395577,9235788,8836748,8278092,8677132,8876652,8916556,8836921,8996364,9076172,9395404,8597324,9155980,9275865,8517689,8477612,8717036,8916729,9116249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[9395541,9275829,9076712,8637768,8996501,9395944,9116616,8677269,8397941,9036405,9076653,9355637,9156520,9196365,8557557,8278632,8597461,9116213,8278229,8318477,8677672,9355981,8557901,8637365,9236328,8717517,8956941,8837288,8877133,8438248,9196021,8517653,9236269,8836885,9156117,8717173,8557960,8837229,9276232,8956597,8597864,9036808,8916693,8797325,9116557,8677613,8757480,9156461,8717576,8437845,9316136,8757421,8438189,8358440,8517997,8797384,8637709,8757077,9076309,8318536,9395885,8996845,8278573,8996904,8477749,8917037,8398285,9315733,8917096,8358381,9196424,8358037,9036749,9235925,8398344,8478093,8877192,9316077,8478152,8318133,8796981,8518056,9276173,8876789,8957000,9356040,8597805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[8597740,8916972,9116492,8797260,8757356,8717452,8358316,9196300,8478028,8996780,9316012,8837164,9156396,8557836,8956876,8438124,9355916,9395820,9036684,9276108,8877068,8677548,9076588,8637644,8278508,9236204,8318412,8398220,8517932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[8557632,9076384,8996514,8358050,8597474,9355712,9275904,8397954,8358112,8956672,8597536,8757090,8876864,8876802,8916768,8757152,8557570,8836960,8916706,8836898,8477824,8318146,8717186,8996576,8677282,9076322,8797056,8637378,9315808,9116288,8437858,9036480,8278242,9236000,8477762,8318208,8517728,9235938,8398016,9196034,8517666,8278304,9036418,9395616,9315746,9196096,9275842,9355650,8637440,8796994,8717248,9156130,9156192,8437920,9116226,8956610,9395554,8677344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[8278314,9156202,9196106,9076394,8477834,9395626,8717258,8677354,8797066,8557642,8398026,9275914,9355722,9036490,8517738,8757162,9116298,8358122,9315818,8996586,8637450,8916778,8956682,9236010,8836970,8437930,8597546,8876874,8318218],"length":1,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[8517715,8677331,9395603,8836947,8956659,8996563,8876851,9196083,9156179,9036467,8398003,9235987,8557619,9315795,8318195,8477811,8637427,8757139,9355699,9116275,8437907,8916755,8278291,8358099,8797043,9076371,8597523,8717235,9275891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[8916993,8278529,8557857,8517827,8597635,8717473,8637539,8797281,9116513,9395715,8757251,8358337,8956771,8278403,8318433,9076609,8438019,9276129,9196195,8557731,8318307,8398115,8517953,9355937,8438145,8398241,8996801,8916867,8477923,8757377,8797155,8877089,8996675,9236225,8597761,9316033,9276003,8876963,8677443,8837185,9196321,8717347,8956897,8637665,9156417,9116387,8837059,8358211,9355811,9156291,9036705,9236099,8478049,9315907,9036579,9395841,8677569,9076483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[8886025,8797430,8757459,8358486,8677884,8557939,8996883,9316115,9196403,8597910,8837334,9276444,8677718,8278844,9396156,9036854,8797363,8327369,8606697,8597843,8278611,9236540,9356019,8518102,8766313,8447081,9236374,9045641,9356086,8717555,8917142,9085545,8637747,8318748,9205257,8598076,8438294,9076924,8677651,8996950,9276278,8558006,9156566,8837267,9395990,8398323,8478198,8486985,8526889,8877238,9285065,8518268,9395923,8407177,8637814,9125449,8287465,8686505,8358419,8717788,8806217,8278678,9076691,8917075,8877171,8478364,9116595,9156732,9165353,8957212,8846121,8877404,9196470,8438460,9037020,8726409,9236307,9116828,8398390,8956979,8558172,8757692,8646601,9316182,9324969,8965833,9276211,9005741,9316348,8478131,9356252,8717622,8518035,8438227,9116662,8997116,8917308,8318582,8837500,8367273,8757526,8957046,9036787,8566793,9404777,8358652,9245161,8318515,9196636,8797596,8925929,9364873,8398556,8637980,9156499,9076758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[9037201,8797777,8797636,8358692,8398737,9156772,9236721,9117009,8837540,9116868,8757873,8717828,8997297,9236580,8757732,8638020,9037060,8558353,8318788,8478545,8837681,8717969,9356292,8997156,8957252,8917489,9316388,9156913,9316529,8518449,9276625,9196676,9076964,8598257,8638161,8318929,8438641,8279025,8598116,8278884,9196817,8877585,8398596,8917348,9396196,8558212,8438500,8877444,9077105,8678065,9276484,8677924,8358833,9356433,8478404,8957393,8518308,9396337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[9276599,9156887,9196791,9356407,8837655,9396311,8997271,8957367,8478519,9077079,8757847,8917463,8518423,9316503,8278999,8318903,9236695,8558327,8598231,8638135,8877559,8678039,8358807,9037175,8438615,8717943,8398711,9116983,8797751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[8558680,9037528,8598584,9237048,8997628,8438968,8838008,9356760,9197144,8398763,8279051,8358859,8957720,8318955,9356459,8877611,8717995,9276952,9077432,8638187,8757899,8798104,9157240,8558379,8319256,9156939,9316856,8837707,8279352,9276651,9396363,8917816,9396664,8359160,8997323,8758200,9077131,8438667,9316555,8957419,9236747,8518475,8678091,9117336,8598283,8478571,8518776,9196843,9037227,8797803,8877912,8478872,8399064,8917515,8678392,8638488,8718296,9117035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[8798158,8718283,8798091,8558734,8678379,9197131,8279339,8837995,9037515,9197410,8838062,8319522,9317122,9117323,9357026,8957774,8758466,9037794,8917803,8279618,9037582,9316843,9237035,9356814,8718562,8877899,9277218,8918082,8997615,9077698,9117602,8319310,8479138,8758254,9396718,9396651,9396930,9157227,9117390,9356747,8638542,9277006,9077486,8718350,8957986,8997682,8359147,8478859,8558946,9157294,9197198,9077419,8598638,8798370,8359426,8878178,9276939,8439234,9316910,8598850,8359214,8279406,8838274,8399118,8917870,8319243,8877966,8758187,8598571,8438955,8399051,8638754,8997894,8518830,8957707,9237314,8638475,8519042,8439022,9237102,8558667,9157506,8678658,8518763,8678446,8478926,8399330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[9357347,8957973,8758520,9077752,9277272,8678645,9277205,8878232,8997881,8758787,9357080,8918136,8359747,9157827,9037848,8599171,8678712,8998215,8838261,8918069,8758453,8838595,9157560,9197731,8558933,9357013,9078019,8718549,8598904,8399317,8559000,8878165,9396917,8359480,9117656,9077685,8479125,8439288,9397251,8399384,8638741,8958040,9197397,9037781,9038115,9237635,8319843,8519363,9277539,8798691,8319576,8559267,9317443,8997948,9237368,8319509,9317109,8519029,8639075,8279672,8678979,9117923,8798357,9317176,8718883,8838328,8359413,8878499,9197464,8479459,8439221,8958307,8479192,8918403,8439555,9396984,8399651,8718616,8638808,8279605,8798424,8279939,9237301,9117589,8598837,8519096,9157493],"length":1,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[9397245,9198784,8520416,8319837,8360800,9277533,9357341,8998209,8479760,9118976,8559261,9039168,8400704,9158880,8440608,8798685,8759088,8919456,8759840,9397552,8479453,8439549,8480512,8559568,8838589,9117917,8399645,8998516,9118224,8878493,9079072,8918704,8519664,8600224,8560320,8599472,8839648,8519357,8279933,9358400,8320896,8640128,8399952,8758781,8958608,9198032,9158128,8360048,9078013,8439856,8678973,9237936,9038109,9237629,9278592,8719936,9277840,9318496,8798992,8718877,8918397,8359741,8280992,8958301,9317744,9078320,8799744,9197725,9317437,8878800,8838896,8320144,8599165,9157821,8679280,8719184,8959360,9398304,8639069,8879552,8999268,8680032,9238688,9038416,8639376,9357648,8280240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[8718993,9157937,8599281,9277649,8359857,8679089,8280049,8399761,8559377,9317553,8998325,9237745,9118033,8798801,8439665,8878609,8838705,8639185,9038225,8479569,9397361,8958417,9357457,9078129,8758897,8519473,9197841,8319953,8918513],"length":1,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[8758840,8918456,8878552,8838648,9237688,8399704,8279992,8998268,9397304,8359800,9357400,9277592,9157880,8439608,8958360,9317496,9197784,8599224,8798744,9038168,8519416,8679032,9078072,9117976,8319896,8559320,8718936,8479512,8639128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[8639135,9038175,8679647,8319903,9278207,9078687,9237695,9157887,8759455,9358015,9277599,8998883,9317503,8599231,8479519,9197791,8838655,8280607,8919071,8758847,8878559,9397311,8679039,8279999,9397919,8639743,8439615,8879167,8958367,8320511,9357407,8360415,8998275,8799359,8599839,8359807,8719551,9198399,8839263,8559935,8399711,8918463,9238303,8519423,8958975,8400319,8440223,8480127,8520031,9078079,8718943,9118591,9038783,8798751,9158495,9117983,8559327,9318111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[8878818,8519682,9397570,8280258,9357666,8399970,9078338,8360066,8799010,8360805,8759845,8439874,9398309,8959365,9198050,8680037,8560325,8520421,9317762,8679298,8400709,8719941,8440613,9238693,8719202,8799749,8559586,9278597,8759106,8320901,8320162,8919461,8600229,8958626,8839653,9118242,8998534,9039173,9118981,8918722,8879557,8999273,8599490,8479778,8480517,9358405,9038434,9237954,8280997,8639394,9318501,9277858,9079077,9158885,9198789,8640133,8838914,9158146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":582,"address":[9358658,8520674,9358426,9158906,9318522,9079330,8800002,8919714,8680058,8320922,9119234,8281018,9278618,8719962,8400962,8440634,8400730,9238714,8440866,9238946,8640386,8839674,8999294,8919482,8879578,9079098,8520442,8839906,8640154,8760098,8321154,9398562,9119002,9159138,8879810,8720194,9199042,9398330,8361058,8560346,8759866,8480770,8360826,8959618,9318754,9039194,9198810,8480538,9039426,8560578,8600482,8680290,9278850,8999526,8959386,8799770,8600250,8281250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[8440896,8321184,8560567,8441099,8880043,9199031,8560608,8640619,9318987,8760087,8959648,8520704,8481003,9159127,8400992,8640416,8959851,8839895,8401195,8321387,9199072,9398592,8400951,9239179,8839936,8680523,8999759,8281280,9278880,9119264,8919744,8560811,8919947,8680320,8959607,8879799,9238935,9358688,8361291,8600512,9039659,9039456,8600715,9199275,8480759,8640375,8520907,8760128,8281483,8600471,9279083,9079563,9039415,9159371,9119223,8999556,9358891,8879840,9398551,9119467,8680279,8720183,9318784,8361088,8919703,8361047,8480800,8520663,8760331,8800032,9079319,9358647,9159168,8720427,8321143,8999515,8281239,9238976,8800235,9318743,9398795,9278839,8799991,8840139,8720224,8440855,9079360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[8919756,8680332,9398604,8480812,8401004,8760140,8520716,9079372,8600524,9318796,8440908,8361100,9039468,8321196,8879852,9278892,8800044,9119276,9199084,8720236,8999568,8959660,9358700,8281292,8560620,9238988,9159180,8839948,8640428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[8999943,9119477,8800245,8521091,9398979,8600725,8321397,9239189,9318997,9039843,8560995,8959861,8880053,8481013,8520917,8840323,8640629,8481187,9079573,8680707,8960035,8919957,8600899,9279267,8760341,9119651,9159381,9039669,9199285,8920131,9359075,8441109,9079747,9239363,8760515,9279093,8281667,8281493,9398805,8361301,9358901,8880227,8401205,8560821,9319171,8361475,9159555,8441283,8401379,8999769,8321571,8680533,8720437,8720611,8640803,8840149,8800419,9199459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[9199513,8800406,8361462,8441270,9279513,9079734,8281913,8600886,9319225,9359129,8481241,8640790,8920118,8880281,8680953,8920185,9039830,8800473,8720857,9119897,9399225,8720598,8640857,9039897,9319158,8760502,8641049,9000189,8840310,9199705,9279321,8960281,8361721,8880473,9359321,8321558,8281721,8840569,9159609,8281654,9398966,9119705,9079993,8481174,8960089,9279254,8441529,9159542,8321817,8361529,8880214,8561049,8560982,8680761,9239609,8521337,9399033,8920377,8521145,8840377,9239417,9159801,8321625,9239350,8441337,9199446,9119638,8601145,8999930,9079801,8760569,8561241,9319417,8999997,8720665,9040089,8521078,8960022,8760761,8481433,8600953,8401433,8401625,9359062,8401366,8800665,8680694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[9279814,9239603,9040083,9279507,9280587,8961355,9359622,8680947,8761835,8401926,9319718,8402699,8841643,8721931,8920371,8601139,9001263,8482507,9159795,8282214,9079987,9240683,9081067,9200779,8521638,8921451,8361715,8801739,8321811,8481734,9119891,8881547,9160102,9399219,8441523,9000490,8800659,8642123,8401619,8960275,8761062,9160875,8602219,8720851,8960582,9239910,9359315,8322891,9000183,8641350,9399526,8362022,8681254,9120198,9200006,9199699,9080294,9040390,8920678,8840870,8641043,8362795,8682027,9319411,8880467,9320491,8721158,9360395,8880774,8521331,8800966,8282987,9400299,8481427,8760755,8561542,8561235,9120971,8322118,8281907,9041163,8562315,8840563,8522411,8441830,8442603,8601446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[8481543,8720967,9399335,8960391,9040199,8641159,9080103,8681063,8880583,9000299,8840679,8601255,8920487,9279623,8521447,8361831,9319527,9239719,9120007,9359431,8321927,8800775,9159911,8282023,8561351,8401735,8760871,9199815,8441639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[8561294,8601198,8521390,8920430,8361774,9319470,8880526,9159854,9239662,9000242,8281966,8481486,8441582,9279566,8960334,9399278,8641102,8800718,8720910,8401678,8760814,8840622,8681006,9119950,9080046,8321870,9199758,9040142,9359374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[8720917,9119957,9319477,8840629,8960949,8880533,9040149,8482101,8441589,9399893,9160469,9159861,8361781,9040757,8761429,8322485,8601813,8960341,8681013,8522005,8641717,9239669,9000857,8401685,8921045,9280181,9120565,8362389,9279573,8841237,8321877,9080661,8801333,8920437,8641109,9200373,8481493,8561301,9240277,9399285,8281973,8561909,9359989,8760821,8721525,8282581,8402293,9080053,9320085,9359381,8881141,8442197,8681621,8521397,8601205,8800725,9000249,9199765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":601,"address":[8880792,9121312,8642340,8283328,8482724,8841860,9241024,8961572,8323232,9239928,8562532,9400516,8682368,8282232,9399544,9001480,8601464,8442944,9001604,9320832,8402916,8482848,8721176,8682244,9400640,8322136,8722272,8762052,9200996,8442820,8800984,8403040,9359640,9280804,8642464,8362040,8562656,9200024,9121188,9080312,9081408,8840888,9320708,8801956,8561560,9279832,8283204,9160120,8602436,8761080,9041380,8481752,8802080,9319736,9040408,9120216,8363012,9161216,8841984,8441848,8762176,8681272,9000508,9360736,8641368,8881888,8722148,8921792,8522628,9280928,9161092,9360612,9041504,9201120,8521656,9240900,8961696,8363136,8921668,8602560,8920696,9081284,8323108,8960600,8522752,8881764,8401944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[9201046,9041176,8363062,8881814,8682294,8602232,8322904,8442616,9041430,9240696,8921718,8402966,8482520,8961622,9200792,9400566,8283000,9001276,9121238,8522678,9081334,8442870,9280854,8761848,8722198,9360408,8841656,8522424,8362808,8283254,8921464,8682040,9320504,9400312,9001530,8323158,9360662,8841910,9081080,8961368,8881560,8562582,9161142,9280600,8602486,8562328,8802006,8642136,9240950,8402712,8642390,9320758,8762102,9160888,8482774,9120984,8721944,8801752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[8722158,9081434,9161102,8562682,9320858,8482734,8961722,9041390,8283214,8842010,8881774,8961582,9241050,9121198,9400666,9360622,9280954,8642350,8881914,8522638,8323118,8682254,9400526,8682394,9280814,8363022,8841870,8482874,8602586,8323258,9161242,9360762,8403066,9081294,9201146,9001630,8921818,9201006,8921678,8762062,8602446,8283354,9240910,9041530,9320718,9121338,8562542,8442970,9001490,8801966,8722298,8522778,8762202,8442830,8642490,8802106,8363162,8402926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[9361191,9121422,9281383,8403495,9041959,8921902,8483303,9241134,9400750,8722382,8642574,9201230,8722727,8682823,8363591,8443054,9360846,8603015,8842439,8882343,8363246,8642919,9320942,8562766,8443399,9041614,9002059,8323342,8602670,8283783,9081518,9321287,9241479,9281038,9081863,8482958,9121767,8403150,8283438,9401095,8522862,8922247,8802535,8563111,8523207,8842094,8762286,8323687,8682478,8961806,9161671,8881998,9001714,8802190,9161326,8762631,9201575,8962151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[8602705,8323377,9081553,9281073,8722417,8363281,9201265,8882033,8762321,8562801,9320977,8682513,9241169,8842129,8482993,9041649,8642609,8961841,8443089,8921937,9161361,9121457,8802225,9360881,8522897,9400785,8403185,9001749,8283473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[9161368,9041656,8961848,8323384,8722424,9081560,8882040,9121464,9281080,8602712,9400792,8762328,8363288,9001756,8522904,8921944,9320984,8283480,8443096,8842136,9360888,8642616,9201272,8562808,9241176,8682520,8403192,8483000,8802232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[8323689,9321508,8922468,8842441,8403716,8683044,9121988,9401097,9002061,8483305,9241700,9241481,8363812,8283785,8802537,9281604,8443401,8802756,8722948,9041961,9121769,8603236,8563332,8882345,9361193,8762633,8682825,9201796,8643140,8323908,9042180,8603017,9002280,8642921,9161673,8962153,8882564,8762852,8563113,8922249,8284004,8483524,9081865,9281385,8363593,8962372,8403497,8443620,9201577,9161892,9321289,9082084,9361412,9401316,8722729,8523209,8842660,8523428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[9401118,9201598,9241502,8363614,8603038,9121790,8722750,8962174,8842462,9321310,8802558,9002082,8563134,9161694,8483326,9361214,9041982,8762654,8882366,8682846,8283806,9081886,8922270,8443422,9281406,8323710,8403518,8523230,8642942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[8962374,8364033,9401537,8323910,9281606,9002282,9122209,9202017,8483526,8523649,8882785,8403937,8802758,8723169,9121990,9281825,9042401,8842881,9321729,8563334,8324129,8962593,8643142,8922470,8842662,9082305,9361414,8683046,9201798,8603457,9241921,9321510,8443622,9361633,8922689,8762854,8284006,8722950,9042182,9162113,8403718,8284225,9161894,8882566,8443841,8763073,9082086,8363814,8483745,8683265,8603238,8563553,9241702,8643361,9002501,8523430,8802977,9401318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[8483547,9401339,8683067,8603259,9281627,8962395,9201819,9082107,8762875,8882587,9042203,8563355,9122011,8922491,9241723,9161915,8802779,9321531,8643163,8842683,8284027,9361435,8523451,8323931,8443643,8363835,8722971,9002303,8403739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[8443850,8883006,8523658,8404158,8324350,8563774,8723178,8882794,9042410,8284446,8643582,9162122,9042622,9321738,8603466,8763082,8483754,8683274,9202026,8683486,8922910,8643370,8563562,8842890,9321950,9082314,8403946,9281834,9401546,9162334,8962602,9122430,9202238,8603678,8284234,8483966,8444062,8364254,9122218,9401758,8723390,9361642,9241930,8763294,9242142,9082526,8523870,9002510,9002722,8843102,8962814,8803198,9282046,8364042,8802986,8922698,8324138,9361854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":624,"address":[8284255,8922719,8443871,9321759,8324159,8603487,8403967,8563583,8962623,9162143,9082335,9122239,8483775,8643391,9241951,8364063,8882815,8763103,9361663,8683295,9401567,9202047,9281855,9042431,8842911,8523679,9002531,8803007,8723199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[8523880,8923104,8404235,8963008,8643758,9362030,8723584,9162411,8643776,8324526,9242336,8324427,8444139,8444256,8364430,8284640,8843296,9361864,8763488,8364448,9282123,8803374,9002799,8923086,9282240,8922987,8883182,9042816,8843179,8603688,8563950,8484043,8883200,8404352,8763304,9082603,9242219,8643659,9322027,9362048,9082702,9082536,8563851,9282222,8284622,8723566,8763371,8962891,8723400,9122440,9122507,8483976,8524046,8484142,8723467,8523947,9202248,8922920,8603872,9202414,9401952,8883016,8603854,8284523,9282056,9002732,8843278,8324360,9202315,8803208,9322144,8962990,9162510,8803275,9202432,9162528,9361931,8563968,8364264,8843112,8404334,8643592,9242318,8444072,8683496,9321960,9162344,8763470,8324544,9322126,8683662,8683680,8883083,8603755,9122624,8364331,8484160,9042632,9401934,9242152,8524064,9122606,8563784,9002898,8284456,9082720,8683563,8962824,9401835,9042699,8404168,8803392,9002916,9042798,9401768,8444238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[9282185,8404210,9242281,8364393,9042674,8324489,8683625,8444114,9322089,9242194,8962953,8803337,9002774,9162386,8524009,8763346,8404297,8723529,8883145,8284585,8603817,9282098,8923049,8883058,9042761,8723442,8603730,9361906,8922962,8763433,8643634,9202377,8563826,8563913,9322002,8843154,9162473,9082665,9082578,8444201,9002861,8962866,9361993,8484018,8843241,8284498,9401897,9122569,8683538,8484105,8364306,8803250,9401810,8523922,9202290,9122482,8324402,8643721],"length":1,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[8803381,9122654,8284670,9082750,8564201,8763721,9162517,8883433,9162761,9322377,8923134,8563957,9043049,8284873,8683710,8484149,9402185,9202421,8604105,8524094,9122857,8524297,9082953,8324574,8603902,8444489,8843285,8284629,8803422,8364681,9362078,9282270,8643765,9242569,8963241,8563998,8444245,9082709,8683669,8364437,8643806,8843326,8723573,9202462,9282229,8644009,9242366,9202665,9282473,8324533,8683913,8923337,8923093,8723614,9042846,8883230,9322133,8843529,8364478,8963038,9042805,8763477,8803625,9362281,9362037,8603861,8404585,8404341,8324777,9242325,9401982,8962997,8524053,8883189,8444286,9003149,8763518,8723817,9162558,9401941,8484393,9002905,9322174,9122613,9002946,8404382,8484190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":632,"address":[9122666,8324586,9282282,8963050,8883242,8803434,8763530,8843338,8364490,8683722,9162570,9242378,8643818,8284682,8524106,9202474,8564010,9042858,9401994,8723626,8923146,9082762,9002958,8404394,8444298,9322186,8484202,8603914,9362090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[8683923,8723827,8524307,8644019,8963251,9402195,8284883,9322387,8923347,8364691,9003159,9162771,9242579,8883443,8324787,9362291,8763731,8564211,9082963,9043059,9122867,8404595,8604115,8484403,8444499,9202675,9282483,8843539,8803635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":637,"address":[9202811,8843675,8883579,9003295,8923483,8285019,8723963,8684059,8444635,8484539,8364827,9083099,8963387,9162907,9362427,9123003,8604251,8564347,8763867,9322523,8524443,9242715,9043195,8803771,8404731,9402331,8324923,9282619,8644155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[8604391,8285159,8524583,8364967,9282759,9402471,8724103,8803911,9362567,8444775,8684199,9123143,8325063,9043335,8484679,8404871,8963527,9202951,8564487,9003435,8883719,9083239,9163047,9322663,8923623,9242855,8843815,8644295,8764007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":641,"address":[9004520,8725188,8844900,9323748,8765092,9084324,8484819,8564627,9403556,9003575,8804051,8525668,9124228,8804996,8685284,9283844,8366052,8923763,9322803,9043475,8445860,8565572,8326148,8924708,8883859,8405956,9083379,8764147,9044420,8644435,9123283,8604531,9203091,9402611,9363652,8286244,8645380,8605476,9242995,8724243,8485764,8524723,8963667,8365107,9362707,8684339,9164132,9243940,8405011,8843955,8444915,8325203,9163187,8285299,9204036,8964612,9282899,8884804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[9203393,8325505,8924065,8804353,9243297,8564929,8525025,9083681,8963969,8644737,9363009,8445217,8485121,8604833,9323105,8844257,9283201,8884161,8724545,9123585,8405313,9043777,8684641,8285601,8365409,8764449,9003877,9402913,9163489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[8525328,8565232,9163792,8445520,8884464,8405616,8804656,8645040,9203696,9123888,9044080,8964272,8764752,8924368,8325808,9083984,9283504,9323408,9363312,8365712,9004180,9403216,8485424,8684944,9243600,8605136,8285904,8724848,8844560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[8685081,8764889,8365849,8605273,9283641,8924505,8964409,8525465,8804793,9124025,8325945,8844697,9243737,8565369,8645177,9084121,9203833,9403353,8286041,9004317,8485561,9163929,8405753,8445657,9363449,9044217,9323545,8884601,8724985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[8884814,8486599,8845735,9324583,8566407,9204046,9243950,8844910,8726023,9044430,9124238,9323758,8405966,9045255,9363662,8964622,8685294,9004530,8445870,8805831,9005355,9244775,8485774,8326158,9204871,8646215,8686119,8326983,9125063,8526503,8605486,9164142,9085159,8885639,9084334,8965447,8446695,9284679,8725198,8765927,8765102,8805006,8606311,8366887,9403566,8287079,8565582,9364487,8525678,8645390,9164967,9404391,8366062,8286254,8925543,8924718,9283854,8406791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[8765344,8565824,9363904,9403808,8805248,9204288,9324000,8845152,8525920,9284096,8924960,9164384,8725440,8486016,8645632,9044672,8366304,8885056,8964864,9084576,8685536,8406208,8326400,8605728,9004772,8286496,9124480,9244192,8446112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":650,"address":[9404051,8486259,8805491,8366547,8446355,8965107,8885299,8406451,8725683,9124723,9204531,9084819,8845395,8765587,9005015,8925203,8645875,9164627,9284339,8286739,9324243,8605971,9244435,8566067,8326643,9044915,8526163,8685779,9364147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":651,"address":[8845532,8805628,8566204,8965244,8286876,9284476,9084956,8685916,8406588,9005152,8925340,9204668,8606108,9324380,9244572,8486396,8526300,8646012,8366684,9404188,9045052,9124860,8765724,9364284,8885436,9164764,8446492,8725820,8326780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[8925569,8446721,8805857,8366913,8566433,8406817,8486625,8646241,8885665,8726049,9005381,9404417,8526529,9284705,9125089,8327009,8765953,9324609,8606337,9204897,8287105,9164993,8686145,8965473,9244801,9085185,9045281,8845761,9364513],"length":1,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[8917288,8837480,9166170,8926746,8478344,8487014,8886054,8598056,9285882,8757672,8398536,8886842,8965862,9156712,9006558,9324998,8487802,8318728,8287494,9396136,9325786,8966650,8518248,9245978,8558152,9206074,9076904,8288282,8766342,9285094,8566822,8367302,8846150,8925958,8647418,8686534,8607514,8677864,8606726,8328186,8327398,8407994,9045670,8567610,8846938,8807034,8767130,9365690,9085574,8646630,9404806,8447110,8957192,9165382,9356232,8997096,8438440,9364902,8806246,8727226,8687322,8278824,9037000,9236520,9126266,9046458,8368090,9316328,9005770,9116808,9086362,8726438,9196616,9276424,8637960,8358632,8407206,8526918,9125478,8447898,8877384,9205286,8797576,8527706,9245190,8717768,9405594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":659,"address":[9405011,8606931,8367507,9085779,8527123,8846355,9125683,8766547,9045875,8686739,9245395,8407411,8447315,8806451,8726643,9165587,8287699,9325203,9005975,9365107,8567027,9285299,8926163,9205491,8646835,8886259,8327603,8966067,8487219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[9205734,8647078,9046118,8367750,9285542,8686982,8487462,8407654,8287942,8447558,8567270,9165830,8846598,8527366,9086022,8886502,8726886,9245638,8926406,9325446,9405254,9006218,8966310,8766790,8806694,9365350,8327846,9125926,8607174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":661,"address":[8727023,9405391,9285679,8966447,9325583,8886639,8567407,9086159,8487599,8447695,8407791,9245775,8806831,9165967,9006355,9205871,8327983,8687119,8607311,8647215,8766927,8367887,9046255,9365487,8527503,9126063,8288079,8926543,8846735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":663,"address":[9405604,9046468,8767140,8727236,9325796,8487812,9245988,8886852,8288292,8607524,9086372,8926756,8807044,8966660,8328196,8527716,9126276,8567620,9206084,9365700,8846948,9285892,8368100,8408004,8647428,8447908,9166180,8687332,9006568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[8487913,8727337,8408105,8966761,9325897,9166281,9126377,9365801,8767241,9086473,8807145,9006669,8288393,8448009,8328297,9246089,8886953,9206185,9046569,8647529,8527817,8567721,8368201,8847049,8687433,9405705,8926857,8607625,9285993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":665,"address":[8807356,8528028,8727548,9126588,9246300,9206396,8687644,8448220,9326108,8368412,9366012,8887164,8607836,8288604,8647740,8767452,9006880,8966972,8328508,8488124,9166492,8847260,9086684,9286204,9046780,9405916,8567932,8927068,8408316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[8927988,8528551,9246419,9406035,8368935,9286323,8568852,9326227,8648263,8647859,8767975,8328627,8408839,8607955,8767571,8329031,8568455,8289127,9127111,8807475,8489044,9326631,9286727,8449140,8728468,9207316,8927591,8967892,8727667,8807879,9087207,8408435,8568051,9206515,8967091,9406439,9167412,8608359,8967495,8329428,8847379,9366932,8927187,8847783,9127508,8887687,9047700,8848180,9406836,8688167,8528948,9366535,9047303,8608756,9327028,8288723,8289524,8448743,9006999,8728071,8488243,8808276,8688564,8687763,8888084,9046899,9086803,8448339,9167015,9206919,9126707,8369332,8409236,9246823,8768372,8648660,9287124,9166611,9247220,8528147,9366131,9087604,8887283,9007800,8368531,9007403,8488647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[8688207,8768015,9167055,8807919,9406479,8329071,9127151,8648303,8847823,8927631,8967535,8488687,8887727,9246863,8608399,8728111,8368975,9366575,9206959,9087247,9286767,9047343,8408879,9326671,8528591,8289167,9007443,8568495,8448783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[8847942,8289286,8688326,8369094,9167174,9366694,9087366,8887846,8608518,9406598,8448902,9007562,8528710,9127270,9246982,8408998,8728230,8768134,8329190,9286886,8808038,8568614,9207078,9047462,8488806,9326790,8967654,8648422,8927750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":671,"address":[9287009,9207201,8289409,8449025,8927873,8728353,8808161,9167297,8369217,8967777,8648545,8528833,9087489,8329313,9127393,8768257,9326913,9007685,9406721,8887969,8608641,8488929,8409121,8848065,9366817,9247105,8688449,8568737,9047585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[8848185,8329623,9310967,8369337,8728473,9329172,9129652,8730612,8770516,9271063,8968087,8531092,8951831,8528953,9009944,9087609,8353271,8433079,9087799,8728663,9247225,8491188,9350871,8489049,9289268,8872023,8329433,8552791,9071543,8911927,9089748,8832119,9366937,8850324,9247415,8752311,8768567,9111447,8927993,8489239,9390775,9007995,8810420,8690708,8808471,8529143,9127513,8449145,8449335,8570996,8768377,8289529,9047705,8331572,8888089,8592695,9407031,8970036,8291668,8688569,8648855,8451284,9367127,8313367,9327033,9169556,9209460,8712407,9047895,8991735,8650804,9408980,8393175,8409431,9127703,8472983,8273463,8409241,9167417,8632599,9207321,8608761,8411380,9049844,9207511,8848375,9231159,9249364,9287319,8608951,8672503,8512887,8930132,9327223,8610900,8792215,8371476,8888279,8648665,9007805,9191255,9287129,8569047,9031639,8890228,8928183,9406841,8289719,8568857,9167607,9151351,8688759,8967897,8369527,8808281,9369076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":677,"address":[8888319,9167647,8688799,8569087,8928223,9008035,8449375,8808511,9207551,8608991,8409471,8329663,8489279,8648895,9367167,9087839,8968127,9127743,9287359,8848415,9407071,8289759,8768607,8529183,9047935,9247455,8728703,9327263,8369567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[9207559,8409479,9287367,8928231,8529191,9087847,9407079,9127751,8449383,9008043,8648903,8688807,8848423,9247463,9167655,9367175,8968135,8888327,8329671,8768615,8728711,8569095,9047943,8369575,8289767,8808519,8489287,8608999,9327271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":681,"address":[8768635,8289787,9167675,9367195,8968155,9327291,8728731,9127771,9407099,8648923,8928251,8569115,8369595,8888347,9047963,9207579,8409499,8329691,9008063,8609019,8529211,8808539,9087867,8489307,9247483,9287387,8449403,8848443,8688827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[9287602,8609234,9008278,8768850,9127986,8449618,9327506,9207794,8649138,9088082,9247698,8489522,8290002,8329906,8689042,9167890,9048178,8728946,8848658,8409714,9407314,8888562,8928466,9367410,8569330,8968370,8808754,8529426,8369810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[8410423,9048305,8928593,9247825,9408023,8609361,9407441,8490231,8370519,9288311,8649847,8689169,8729073,8489649,9207921,9248407,8969079,8929175,9128695,8649265,8609943,8809463,9168017,9327633,8529553,8570039,9048887,8849367,8889271,8689751,9287729,9328215,9367537,8290711,8888689,8409841,8449745,8729655,8330033,8530135,9368119,8808881,9168599,8848785,8768977,8290129,9088791,8569457,8968497,9008405,8330615,9008987,8769559,8450327,9128113,9088209,9208503,8369937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[8928782,8529742,8649454,8489838,8689358,9248014,8888878,9168206,9327822,8848974,9088398,8449934,8769166,8290318,9208110,8968686,8729262,9367726,8809070,8609550,8410030,8569646,8370126,8330222,9008594,9048494,9407630,9287918,9128302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[9288108,8928972,9367916,8330412,8968876,8609740,9407820,8569836,9088588,9048684,8529932,8290508,8450124,8889068,8849164,8809260,8649644,9328012,8370316,9208300,9248204,8689548,9128492,9008784,8729452,8490028,9168396,8410220,8769356],"length":1,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[8970034,8371474,9088801,8650802,9408033,8929185,8370529,9168609,9248417,8770514,9408978,8810418,9048897,8609953,9089746,8491186,9049842,8649857,8490241,8690706,8330625,8809473,8530145,8450337,8729665,9209458,9129650,8969089,9208513,8689761,8850322,8730610,9328225,8610898,9369074,8531090,9249362,8849377,8451282,9288321,8889281,9128705,9329170,9008997,9009942,8410433,8890226,8570994,8570049,8291666,8411378,8930130,9169554,9368129,8769569,9289266,8331570,8290721],"length":1,"stats":{"Line":0},"fn_name":null},{"line":689,"address":[8490543,8969391,9089103,8370831,8570351,8690063,8849679,9248719,9129007,8889583,9168911,8929487,8530447,8410735,8769871,8809775,9208815,9328527,8330927,9368431,9009299,8729967,9408335,8610255,8650159,9049199,8291023,8450639,9288623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[8650462,9288926,8969694,8411038,8530750,8770174,9368734,9408638,8570654,8450942,8810078,8331230,9049502,8371134,8610558,9129310,8929790,9089406,9209118,8849982,8490846,9249022,9009602,8730270,8690366,9169214,9328830,8291326,8889886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[9408775,8650599,9289063,8969831,8371271,8690503,8770311,8490983,8291463,9249159,8331367,9328967,8890023,8411175,9129447,8929927,8451079,9169351,9009739,8530887,8810215,9209255,8570791,8610695,9089543,9368871,8850119,8730407,9049639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":697,"address":[8411393,8853511,9369356,8291681,9249644,8451297,9172743,8888227,8611180,9329185,8294855,9287267,8614087,8411660,8531372,8451564,8813607,8973223,8371756,8574183,8770529,8930412,8449283,8968035,8928131,9207459,8653991,8369475,8568995,8489187,9089761,8893415,9132839,8571276,8648803,8690721,8728611,9292455,9212647,8374663,9092935,9169569,8414567,9249377,8454471,8810700,9010224,8970049,8371489,8491201,8808419,8848323,9169836,8329571,9013131,9087747,8773703,8650817,8810433,8768515,8693895,8970316,9367075,9332359,9408993,8730892,9372263,9289548,9167555,8494375,9329452,9412167,8409379,8850604,9209740,9289281,8610913,8529091,8571009,9129665,8733799,8933319,9050124,8608899,9009957,8890508,8289667,8651084,9369089,9247363,9252551,9409260,8291948,8491468,9209473,8334759,9327171,8331852,8850337,8730625,9127651,9047843,8770796,9049857,8930145,9129932,8531105,9053031,8331585,8534279,9007943,8890241,9406979,8688707,9090028,8690988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[8970356,8691028,9329492,8531412,9249684,8451604,9369396,8611220,8730932,8491508,8411700,9289588,8291988,8890548,8571316,9129972,8810740,8770836,9209780,8331892,8930452,8371796,9010264,8651124,9090068,9050164,9409300,8850644,9169876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[9090076,8970364,9010272,9289596,8291996,8371804,8491516,8691036,8331900,9409308,8730940,9369404,8890556,8850652,9249692,8611228,8451612,8411708,9169884,9050172,8930460,9209788,9329500,8571324,8651132,8770844,9129980,8531420,8810748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":700,"address":[8611560,8731272,8850672,9369736,8970696,8890576,8292016,9409640,8531752,9090408,9130312,9170216,8411728,9369424,8292328,8451632,8771176,8331920,9130000,8491536,9209808,9329520,8611248,9050504,8491848,8571656,9289616,8810768,8332232,9010604,9289928,9249712,8451944,8372136,8651464,9329832,9169904,8770864,8930480,8811080,8571344,9010292,8691056,8850984,8691368,8730960,8890888,8651152,9250024,8412040,8970384,9090096,9050192,9210120,9409328,8531440,8930792,8371824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[9050491,8491835,9130366,8930779,8930846,9409627,9130299,8531739,9250011,9090462,9409694,8651451,8611614,8771163,9370828,8332219,8931884,9010658,8691355,9410732,8531806,8971788,8412027,8451998,9210174,9210107,8651518,8412094,8652556,8332286,8292382,9289915,8692460,8293420,8571643,8571710,8811134,8731259,8372123,9051596,8372190,8851038,9131404,8890942,8852076,8292315,8572748,9329819,8612652,8413132,9369790,8373228,8812172,9289982,8970683,9251116,9291020,8731326,9011696,9250078,8532844,8691422,8890875,9050558,9010591,8333324,8491902,9170270,8732364,9091500,8453036,9090395,9330924,9329886,9170203,8970750,8611547,8451931,8811067,8772268,9211212,8771230,9171308,9369723,8891980,8850971,8492940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[9210270,8372286,8292478,9290078,8332382,8571806,8851134,8412190,8970846,9090558,8891038,8930942,9170366,9369886,8731422,8691518,9250174,8491998,8611710,8452094,9409790,9050654,8771326,8811230,9130462,9010754,8651614,9329982,8531902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[8891172,8811364,9290585,8692162,8293122,9410434,8452738,8731556,8851268,9330489,8771460,8292985,9409924,8732066,8292612,9250818,8891545,8611844,9290212,8691652,8771970,8452228,9170873,8333026,9011261,8492132,8851778,9051298,8412834,8971353,8372793,8970980,8931076,9330116,9091202,8971490,9130969,8612217,8891682,8572313,9090692,9170500,8492642,9250681,8332889,8931449,8532546,8532409,9171010,8571940,9010888,8532036,8372930,9091065,8692025,8652121,9290722,9011398,9330626,9051161,8612354,8811874,8572450,8731929,8412697,8452601,9050788,8332516,8651748,9130596,8931586,8492505,8771833,9210404,9250308,9210914,8811737,9410297,8412324,8372420,9370530,8851641,9370393,9370020,9210777,9131106,8652258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[8851810,8811906,9011430,8293154,9410466,8652290,8333058,8891714,9250850,9330658,9131138,8452770,9210946,9290754,9051330,8372962,9370562,8772002,8492674,9171042,8971522,8692194,8412866,8732098,8532578,8931618,8612386,8572482,9091234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":706,"address":[9370838,8532854,9211222,8413142,9051606,9410742,8772278,8812182,8732374,9011706,8373238,8333334,8652566,8492950,9330934,9091510,8891990,8572758,9291030,9251126,8931894,9131414,8971798,9171318,8852086,8612662,8293430,8453046,8692470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[8812311,9291159,8572887,8892119,9331063,9171447,8413271,9370967,8493079,9251255,8532983,9091639,8971927,8453175,8732503,8373367,8652695,8772407,9211351,8692599,8333463,9011835,9131543,8852215,8932023,9051735,9410871,8293559,8612791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[9411009,9211489,9331201,8812449,8652833,8932161,9371105,9091777,8333601,8732641,8852353,8892257,9291297,8293697,8972065,9171585,9251393,8772545,8493217,8573025,8533121,9011973,8413409,8453313,8692737,9131681,8612929,8373505,9051873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[8893413,9091988,8933317,8852564,9092933,9131892,8932372,8853509,9252549,8653044,8293908,8574181,8534277,9211700,8613140,9052084,9371316,8812660,9212645,8373716,9331412,8454469,8614085,8413620,9172741,8813605,9372261,8772756,9171796,8294853,8374661,8414565,9251604,8494373,9412165,8892468,9132837,8533332,9411220,8773701,9292453,8732852,8573236,8972276,8333812,8653989,9053029,9012184,8693893,8453524,8692948,8334757,8733797,9291508,8493428,9332357,8973221,9013129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":710,"address":[9052386,8374018,8972578,9371618,8812962,9331714,8453826,9132194,9012486,8733154,8852866,9411522,9251906,8773058,9291810,8413922,9212002,8493730,8693250,9092290,8573538,8533634,8334114,8653346,8294210,8932674,8892770,9172098,8613442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[8733457,9411825,8773361,8414225,8334417,8932977,8613745,8294513,9332017,8573841,9132497,8454129,8972881,8813265,9172401,9292113,9052689,8374321,8853169,8653649,9212305,8533937,9252209,8494033,8693553,9092593,9012789,8893073,9371921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":712,"address":[9411962,8773498,8613882,8294650,8813402,8534074,9212442,8414362,8693690,8374458,9172538,8653786,8893210,8573978,9372058,8334554,8973018,9052826,9332154,9292250,9092730,8933114,8454266,8733594,9012926,8853306,9132634,9252346,8494170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[8574188,8730860,8895263,8534284,8334926,9010192,9133006,8973228,8454638,9174591,9252556,8496223,8694062,9209708,9050092,9412172,8853516,9249612,8893582,8973390,8815455,8970284,8414734,8416415,9332364,8813774,8614254,8935167,9053198,8411628,8773870,8733966,8850572,8975071,8813612,9214495,9013136,9094783,8614092,8611148,9053036,8653996,9134687,8336607,9292460,8773708,8531340,9374111,8491436,8571244,9212814,8933486,8651052,8855359,8770764,9132844,8810668,8414572,9292622,8615935,8494542,8930380,8733804,8576031,8735647,8933324,8536127,8655839,9289516,9329420,8374830,8451532,9093102,9414015,9294303,9013298,9212652,8534446,9129900,8294860,9412334,8654158,8693900,8695743,8331820,8690956,8291916,8853678,9054879,9372430,9089996,9334207,9172910,8890476,8454476,8371724,8775551,8296703,9409228,8334764,9332526,8295022,9172748,8494380,9169804,9252718,9372268,9369324,8374668,8376511,9092940,9254399,8574350,9014979,8456319,8893420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[8375000,9332566,8534616,9053368,8414904,8694232,8694102,8853718,8973560,8574520,8893622,9053238,9013338,8574390,9212984,8295192,9252758,8773910,8454678,8295062,8494582,8813814,8933526,9372470,8654328,9412374,8334966,9212854,8454808,8335096,9372600,8933656,8734136,8774040,8973430,8374870,9292662,8494712,8734006,9292792,8614424,9412504,8654198,9093142,8813944,8414774,9172950,9332696,9133046,8853848,9252888,9013468,9133176,8614294,8893752,9093272,9173080,8534486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[9413017,8694745,8455321,8414894,8894265,9173593,8375513,8973550,9093570,8854146,8614414,9133689,8455106,8893742,9332994,8335086,8495010,8973858,9253401,9292782,9373113,8295182,9293090,8854361,9212974,8335394,9293305,9333209,8415417,9173378,8335609,8934169,9093785,8535129,8415202,9372590,8374990,9332686,9253186,8295705,8454798,8853838,8774338,8734126,8574818,8694222,9372898,8495225,9133474,8534606,8574510,9213497,8813934,8614937,8774030,8614722,8814457,9213282,8933954,8734434,9252878,9412494,9133166,9053358,9013458,8974073,9412802,8375298,8814242,9173070,8734649,8295490,9093262,8894050,8494702,8534914,8694530,9013981,8774553,8654626,8654318,9053666,8933646,9053881,9013766,8575033,8654841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[8454899,8933747,8893843,8494803,8973651,9093363,9133267,8414995,8654419,8295283,8814035,9292883,8694323,8734227,9252979,9372691,8574611,8853939,9213075,9053459,9013559,8614515,9412595,8534707,8335187,8774131,9332787,8375091,9173171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":722,"address":[9053414,8375046,9093318,8933702,9213030,9252934,8494758,8774086,8973606,8335142,8295238,9292838,9013514,8893798,9332742,8813990,8534662,8614470,8414950,9412550,9173126,8454854,9133222,9372646,8694278,8853894,8734182,8574566,8654374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":724,"address":[8534932,8495230,9253406,8295508,8614942,8734654,8934174,8974078,8574836,9013784,9333214,9053886,9213502,8894068,8654846,8654644,8415422,8774558,9053684,8854164,9133492,8575038,8774356,8375316,9013986,9372916,8734452,8335614,8455326,8694750,8295710,9412820,8814260,8973876,8535134,9133694,8854366,8415220,9293108,8375518,9213300,8495028,9173396,9093588,8335412,9093790,9333012,8814462,9293310,9373118,8614740,8455124,8933972,8694548,8894270,9173598,9413022,9253204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[8455346,9093810,9253426,8654866,8335634,8575058,9173618,8774578,8894290,9293330,9373138,8934194,8295730,9413042,8694770,8734674,9333234,9014006,8614962,8974098,8854386,9213522,8814482,9053906,9133714,8535154,8495250,8415442,8375538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":726,"address":[9094092,8455628,8654892,9413068,9173644,8695052,9333260,9133740,8296012,8535436,8335916,8934220,9213804,9373420,8535180,8495276,9054188,8455372,9413324,8655148,8694796,8774860,8575084,9093836,9213548,8814764,8295756,9373164,8495532,8615244,8854412,9333516,8774604,8734700,8375564,9173900,8614988,8894572,9014288,8335660,9014032,8415468,9253452,8375820,9053932,9293612,8974124,9253708,8974380,8734956,8854668,9133996,9293356,8575340,8415724,8814508,8934476,8894316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":727,"address":[8375600,9373200,8934256,8575120,9253488,8455408,9213584,8814544,8734736,9413104,8774640,8415504,8654928,8335696,9014068,9293392,8495312,8894352,9333296,9093872,9133776,8295792,8694832,8615024,8974160,8535216,9053968,8854448,9173680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":728,"address":[8654941,8535229,8974173,9413117,9014081,8854461,8615037,8734749,8934269,8894365,9093885,8774653,9133789,8575133,9053981,9213597,8455421,9333309,8814557,9293405,8335709,8694845,9173693,9373213,8495325,8295805,8375613,8415517,9253501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":730,"address":[8296701,8975069,8416413,8695741,9293622,8375830,8576029,8415734,8655158,8735645,8536125,8814774,8455638,8854678,9173910,8734966,9174589,9094102,8974390,8335926,9333526,9414013,8934486,8655837,8935165,8496221,8895261,8615254,9054198,9214493,9054877,9094781,8615933,9413334,8894582,9014298,9374109,9254397,9253718,8296022,8774870,8456317,9134685,8495542,8855357,9373430,8815453,9014977,8376509,8535446,9334205,8695062,8575350,8775549,8336605,9294301,9134006,9213814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":731,"address":[8535652,9373636,9293828,9214020,8974596,8376036,8455844,8575556,8854884,9413540,8894788,8814980,9174116,8615460,8296228,8336132,9014504,9054404,8415940,8934692,8735172,8655364,9253924,9134212,8775076,9333732,9094308,8495748,8695268],"length":1,"stats":{"Line":0},"fn_name":null},{"line":732,"address":[9333939,9134419,8575763,8815187,9214227,8495955,9174323,8735379,8416147,9254131,9294035,8655571,9014711,9094515,8775283,8934899,9054611,9413747,8974803,8894995,8535859,9373843,8695475,8855091,8336339,8456051,8615667,8296435,8376243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":733,"address":[8615730,8575826,8496018,8934962,9413810,8815250,8416210,8735442,9214290,8695538,9174386,9254194,9054674,8456114,8296498,8376306,8775346,8974866,9134482,8336402,8655634,8535922,8895058,9294098,9094578,9334002,9014774,9373906,8855154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":738,"address":[8376516,8853646,8538010,9214697,8494510,9016862,8695945,8735849,8775753,8815657,8975076,9056762,8895268,8378394,8697626,8536329,9374313,8534414,8895465,8374798,9292590,8657722,8296708,8418298,8733934,8576233,9096666,8498106,9334212,9014984,8376713,9336090,8694030,9332494,9415898,8815460,8615940,8935369,8737530,8777434,8336809,9414020,8338490,9375994,8935172,8655844,9174793,9094985,8937050,8616137,8294990,9054884,9252686,8416617,8817338,8496228,9015181,9132974,8975273,8855561,9172878,8775556,9216378,9374116,9134692,8735652,8855364,8454606,9212782,9174596,8933454,8416420,9055081,8577914,9093070,8574318,8897146,9294505,8857242,9294308,8414702,8656041,8773838,8334894,9136570,8695748,8296905,8614222,9256282,9134889,9053166,8976954,8617818,8536132,8298586,9296186,8458202,9254601,8496425,9334409,8654126,9254404,8336612,8893550,9214500,9094788,8576036,9372398,9414217,8456324,8813742,9176474,8973358,8456521,9013266,9412302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":739,"address":[9174963,8775923,9374353,9294675,9015221,9174833,8536499,9055251,9334449,8656081,9414257,9055121,8895505,8496465,8296945,8536369,9294545,8456691,9095025,9095155,8297075,8935409,8855601,8935539,8735889,8855731,8616307,8496595,8975443,8376883,8895635,8576273,9414387,9334579,8696115,8416657,8576403,8336979,8336849,8616177,8456561,8656211,9135059,9214867,8695985,8376753,9254641,9015351,8815697,8736019,8416787,9374483,9254771,9134929,9214737,8815827,8775793,8975313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":740,"address":[9095145,8417085,8456681,9374781,8736317,9254761,8855721,9095668,8337492,9374473,8896148,9294665,9414900,8895933,9055764,8736532,9255284,8576701,8696413,8536797,9334877,8975433,8776436,8417300,9015341,9175476,9135357,9135049,8537012,8456989,8576916,8935529,8935837,8975741,8336969,9295188,9414685,8496893,9175261,8496585,8337277,8776221,9015649,8816125,9174953,9215380,8377396,8616297,9015864,8457204,9414377,8696628,8696105,8376873,8616605,8856244,8656201,9055549,9215165,8656724,8297588,8297373,9055241,8936052,8576393,9335092,9214857,8497108,8815817,8736009,8856029,9374996,8775913,9334569,8377181,8656509,8975956,8616820,8416777,9135572,8816340,9095453,8536489,9294973,8297065,8895625,9255069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":741,"address":[9015442,8616398,8736110,8496686,8576494,8456782,9175054,9374574,8815918,8895726,9294766,8855822,8376974,8536590,9055342,9414478,9214958,8337070,8416878,9135150,9095246,9334670,8776014,9254862,8696206,8935630,8656302,8975534,8297166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[8297121,8576449,8456737,8855777,9294721,8416833,8656257,8337025,9055297,9135105,8895681,8815873,9254817,9374529,9334625,9015397,8736065,8376929,9214913,8696161,8536545,9095201,8775969,8935585,9414433,8496641,8616353,9175009,8975489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":745,"address":[8656527,9334895,9255289,8337295,8457209,9135577,8576921,8816345,8696633,9215385,8776239,8656729,8337497,8537017,9015869,8417305,9414905,9255087,9215183,9055567,8975759,9135375,8856047,8736537,8297391,8616623,8936057,9175279,9015667,9335097,8536815,8816143,8297593,8616825,8377401,9375001,9294991,8497113,9095471,8935855,8975961,8856249,8896153,8576719,8377199,8496911,8417103,9095673,8696431,8457007,9175481,9414703,8895951,8736335,9055769,9295193,9374799,8776441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":746,"address":[8856269,8497133,8297613,8337517,8457229,9295213,8896173,9015889,8696653,8537037,8816365,8656749,8417325,9255309,8616845,9375021,9335117,8576941,8975981,8377421,9055789,8936077,9215405,9175501,8736557,9095693,9414925,8776461,9135597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":747,"address":[9016171,9215431,9175783,9295495,8656775,9415207,8337799,8297639,8896455,8497159,8576967,8537063,8617127,8616871,8377447,8976263,9335399,9215687,8776487,8497415,9095975,8896199,8457511,8976007,8856295,9375303,8736583,9414951,8776743,9056071,8856551,8337543,8377703,8696679,9375047,9255591,8657031,8936359,9335143,8816391,8417351,9135879,8537319,8457255,8417607,9175527,8736839,9135623,9015915,8936103,9095719,8816647,9255335,8297895,8577223,9055815,8696935,9295239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":748,"address":[8856331,8616907,8696715,8577003,9255371,9375083,9095755,8457291,9215467,8976043,9295275,9335179,9135659,9414987,8896235,8497195,8736619,8656811,8337579,8776523,9015951,8816427,8537099,8417387,8297675,9055851,9175563,8936139,8377483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":749,"address":[8616920,9055864,9255384,8457304,9215480,8377496,9135672,8577016,9095768,8976056,8776536,9175576,9295288,8417400,8537112,9335192,9415000,8497208,8856344,8297688,9375096,8337592,8816440,8656824,8736632,8896248,8936152,8696728,9015964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":751,"address":[8377713,8497425,9255601,8577233,9056081,9056760,8777432,9216376,9016860,8736849,8418296,8657720,8696945,9295505,9016181,8457521,8378392,9095985,8936369,9296184,9135889,8498104,8856561,9136568,8297905,9375992,8896465,8776753,8617816,8976273,8458200,8337809,9336088,9415217,9096664,8816657,8857240,8937048,9415896,8538008,8338488,8657041,8537329,8897144,8617137,8737528,9176472,8697624,8417617,8577912,9375313,9335409,9215697,8298584,8976952,9256280,9175793,8817336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":752,"address":[8617343,8936575,9096191,8298111,8856767,9415423,9175999,9335615,8697151,8537535,8657247,9255807,8577439,9215903,9136095,8377919,9295711,8417823,8338015,8976479,8497631,9056287,8816863,8896671,8776959,9375519,8457727,9016387,8737055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[8976686,8657454,8856974,9295918,8777166,8577646,9056494,9256014,8896878,9176206,8497838,8936782,8617550,8298318,9375726,9216110,8418030,9415630,8737262,8697358,8817070,8537742,8378126,9136302,8457934,9016594,9096398,8338222,9335822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":754,"address":[8857037,9216173,8617613,8817133,8497901,8378189,9335885,9295981,8936845,9136365,9056557,9176269,8418093,8697421,8777229,8737325,8338285,9016657,8457997,9415693,8657517,9375789,9096461,8976749,8298381,8537805,9256077,8577709,8896941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":759,"address":[8855518,8336766,8815614,8416574,8376670,8576190,8975230,9214654,9414174,9055038,9334366,8655998,8695902,8536286,9294462,9254558,8775710,8735806,9015138,8935326,8496382,9134846,8296862,9094942,8616094,8895422,8456478,9374270,9174750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[9254566,8376678,9174758,8456486,8895430,9094950,8416582,9334374,8576198,8296870,8975238,8855526,8656006,8616102,8496390,8775718,8935334,8735814,9134854,8815622,9374278,9414182,8536294,9055046,9015146,8695910,9214662,8336774,9294470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":761,"address":[9096679,8536302,9214670,8298599,9055054,9094958,8418311,8376686,8976967,8296878,8456494,8697639,9294478,9415911,8897159,9134862,8616110,9056775,9296199,8695918,8498119,9016875,8416590,8937063,8576206,9254574,9216391,8737543,9136583,8857255,9336103,8577927,9174766,8855534,8935342,8975246,8538023,8336782,9414190,9374286,9176487,8656014,8775726,8338503,8378407,9256295,8657735,9015154,8817351,8895438,8496398,9376007,8815630,8458215,9334382,8617831,8735822,8777447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":762,"address":[8577964,8298636,8977004,9136620,8458252,9176524,8937100,8538060,8697676,9016912,9336140,8617868,9216428,8817388,8897196,9376044,9096716,8498156,8857292,8418348,9056812,8338540,9296236,8378444,8777484,8737580,9415948,9256332,8657772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":763,"address":[9016924,8538072,9176536,8378456,9216440,9376056,8937112,8617880,8777496,8897208,9256344,9336152,8697688,8817400,8498168,8977016,8737592,8577976,9136632,8418360,8298648,8657784,8458264,8338552,9296248,9415960,8857304,9096728,9056824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":764,"address":[8777508,8697700,9336164,8498180,9376068,8657796,9056836,9096740,9176548,8538084,8857316,9216452,8937124,8617892,8458276,8977028,8817412,9296260,9016936,8378468,9136644,8418372,8298660,8338564,9256356,8897220,9415972,8577988,8737604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":765,"address":[8498188,9256364,8897228,9296268,8378476,9415980,8697708,8298668,9056844,8577996,9096748,8418380,9016944,9376076,9136652,9216460,8777516,8657804,9176556,8817420,8937132,8338572,8617900,8538092,8977036,8737612,9336172,8458284,8857324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":767,"address":[8698254,8418926,9296276,8618446,9336568,9016952,8857332,8737620,8857870,8538100,8658200,9376622,8897624,9336718,9416526,8538638,8738158,8817428,8937678,9137198,8977044,9415988,8618296,8299214,8738008,8977432,8458680,8578004,8378872,8857720,9096756,9296664,9216468,9136660,8697716,9057390,9256910,8937528,8538488,8657812,8777912,9256760,8937140,8658350,9296814,9376084,8578542,9097294,9137048,8418388,8897774,8378484,9217006,8498734,9097144,8458292,9057240,9176564,8777524,9376472,8778062,8298676,8698104,9017340,8578392,8498584,8379022,8339118,8458830,9216856,8338580,8617908,8817966,8498196,8418776,8977582,9256372,9056852,9416376,8817816,8897236,8299064,9177102,8338968,9017490,9176952,9336180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":769,"address":[8819237,9337989,8779333,8579813,8899045,8420197,8938949,9058661,8460101,8699525,8739429,9218277,9258181,8978853,9018761,8539909,8619717,9098565,9417797,8300485,8380293,9178373,9138469,8340389,9377893,8500005,9298085,8659621,8859141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":770,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":771,"address":[8859660,8302243,9059180,9220782,9180131,9382328,8739948,8301004,8584248,9022046,8980108,8304362,9102442,8820492,8703402,8940707,8501763,9298604,8863576,8424074,8384170,8540428,9182250,9300590,8780588,8542414,8622222,8820995,9261466,9021266,8663498,9302520,9138988,9061946,9259436,8783768,9059916,8899564,8461859,9339244,8782618,8982138,9221562,8781838,8662126,9379651,8982730,8819756,8423482,9180878,8382051,8424632,9141754,8422702,8343674,9339747,8421955,9142904,8983288,9381770,8743864,8380812,8902330,9299843,9340494,8821742,8903480,8860899,9062538,8779852,9178892,8541667,8700780,8461356,9420302,8900300,9262616,8460620,9219532,8583098,8664056,8462606,8463386,8581571,8621475,9139724,9101070,8701283,8344266,8623002,9258700,8384728,9260686,8901550,8662906,9259939,8942234,8939468,8342147,9023196,9419052,8342894,8940204,9103000,9421674,8544344,9341866,8581068,8741934,8541164,8383578,9181658,8703960,8580332,9063096,9342424,8303770,8624152,8464536,8740684,8503882,9378412,8822522,8623594,8823672,9099820,9019280,8340908,8620236,9099084,9299340,9341274,9142346,9022638,9060419,9179628,8660140,8421452,9100323,8702810,8543194,8941454,8661379,8583690,9262058,8783210,8503290,8823114,8781091,8344824,9421082,8980611,8742714,8341644,8381548,9101850,9020519,8942826,9301370,9419555,8860396,8943384,8302990,9338508,9380398,8979372,8582318,8743306,8543786,9140974,8502510,9061166,9381178,9220035,8861646,8382798,8660876,8981358,8463978,8304920,9182808,8863018,9418316,8500524,9422232,9379148,8900803,8501260,8504440,8862426,8301740,9020016,9222712,9222154,8741187,9301962,9218796,8620972,8420716,8902922,9140227,8700044,8702030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":772,"address":[9256918,9017498,9177110,9097302,8698262,8817974,8538646,9376630,9336726,8498742,8578550,8618454,8897782,8299222,8857878,8937686,8418934,9217014,8658358,9057398,8977590,9296822,8738166,8778070,8339126,9137206,8379030,8458838,9416534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":774,"address":[8818073,8299321,8738265,9097401,8618553,9137305,8419033,8658457,9416633,8897881,9296921,8339225,8538745,9217113,8698361,9057497,8458937,9017597,8498841,8578649,8857977,8778169,8977689,8379129,9376729,9336825,8937785,9177209,9257017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":775,"address":[8344688,9421720,9262571,9222200,8743819,8584112,8743352,8903435,8982776,8703915,8703824,9062584,8902968,8903344,8943248,9302384,8344779,9102955,9062960,8424496,9222667,9063051,9382192,9182763,8663920,8863531,8983152,8304784,9182296,9422096,9422187,8783256,8743728,8464024,9023151,8543832,8584203,8943339,8504304,9341912,9102864,9222576,9142392,8304875,8504395,8983243,8544208,8464400,8544299,8664011,9022684,8663544,8464491,9342379,8823536,8863064,8424587,9023060,8783632,8624107,8384683,9142859,8384216,8823160,9302475,8783723,8583736,8624016,8942872,8703448,8503928,9302008,8384592,8823627,9182672,9381816,8344312,9382283,8863440,9342288,9142768,9262480,8424120,8304408,9102488,8623640,9262104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":776,"address":[8703965,9182771,8384691,8504445,8783731,9262579,8504403,8584253,9302483,8943389,8464541,8424637,8624157,9182813,8983251,8823677,9023201,8304883,8424595,8664061,9262621,8863539,8584211,8743827,8743869,8983293,9342429,8344829,9103005,8344787,8664019,9302525,9023159,9382291,9063059,8943347,8703923,8823635,8464499,9063101,9142909,8304925,8903485,9102963,8863581,8384733,9222717,8783773,8544307,9422195,8624115,8903443,9222675,9342387,9422237,9142867,8544349,9382333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":778,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":779,"address":[8818119,8937831,8379175,8897927,8299367,9017643,9376775,9416679,8618599,8419079,8458983,9177255,8578695,8698407,8778215,8738311,8339271,9057543,8977735,8658503,9137351,8858023,9097447,9257063,9217159,8538791,9336871,9296967,8498887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":780,"address":[9341320,8782664,8663340,8662952,8423916,9301911,8463927,8543735,8503336,8384012,8344108,9181704,8663447,8822568,8543240,9421516,8623048,8583532,9182199,8823063,8942668,8703351,8982572,8743255,9421128,8384119,8383624,9341708,9381612,8303816,8982679,8343720,8783052,8543628,9062380,9301416,8902764,9301804,8902376,9341815,8503831,8304204,8862860,9182092,8463820,9222103,9261512,8583639,9261900,9142295,8344215,8463432,8783159,9421623,8623543,9062487,9381224,9022092,8703244,8623436,8902871,8942775,8822956,9221608,8702856,8423528,9141800,9022587,8862472,9381719,9022480,9061992,8862967,8743148,9101896,9142188,8503724,9262007,8742760,8942280,9221996,8982184,8583144,8424023,9102391,9102284,8304311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":781,"address":[8862975,9142303,8823071,8703407,9102399,8583647,9062543,9262063,9341871,8743263,9222111,8543743,8503839,9102447,9142351,8623599,8663503,9421631,9022595,9182255,9381775,8304367,9022643,8304319,8823119,9222159,8902879,8703359,9262015,9301967,8344223,9182207,8503887,8583695,8663455,8463935,9421679,8463983,8623551,8384175,8942831,8942783,8543791,8783167,8344271,8384127,8743311,8424031,9381727,8982735,8902927,9062495,8783215,8424079,8982687,8863023,9341823,9301919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":784,"address":[8738357,8977781,8818165,8498933,9017689,9057589,8379221,8459029,8299413,8897973,9376821,8658549,9177301,9137397,8698453,8858069,9416725,8339317,9297013,9336917,9257109,8937877,9217205,9097493,8618645,8578741,8538837,8419125,8778261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[8742585,9420348,8862297,9380444,8383301,9180924,8902201,9380901,8782489,8821788,9220828,9221285,8502556,9061669,8342940,8981404,8463109,8543065,9260732,8702533,9381049,8822393,9340540,8901596,8423205,9101721,8303036,8382844,9141625,8941500,9420953,8503013,8582821,8582969,8742437,9101116,8383449,9420805,9340997,8861692,8781884,8822245,8622725,9141020,8741980,8782341,9061817,8982009,8463257,8981861,8702076,8941957,8422748,9021917,9061212,8542917,8582364,9341145,8462652,8343545,9181381,8503161,8542460,8702681,8902053,8303493,9301093,8862149,8423353,8622268,9181529,8942105,9301241,9261337,9021769,9101573,8303641,8662777,9221433,9261189,9141477,8622873,8662629,9021312,8662172,9300636,8343397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[9021925,8942113,9221441,9101801,9181537,8702761,8343553,8742665,9420961,8383457,9341153,9221513,9181609,8822473,8662785,8782569,9141705,9301321,8902209,9301249,8862305,8463337,8383529,8303649,9421033,8902281,9061825,8622881,9141633,8782497,8503241,8543145,9021997,8662857,9061897,9381129,8742593,8702689,8423433,8862377,8582977,8423361,9341225,8622953,9261417,8982017,9101729,8982089,8463265,9261345,8543073,8822401,8583049,8942185,9381057,8503169,8303721,8343625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":787,"address":[8662898,9301375,8942239,8623007,8503295,9181663,9021968,8782540,8822527,9022038,9421087,8463308,8742706,8303775,8343679,9101855,8822514,9341196,8782610,8622994,9381183,9181650,9381100,8543116,8942226,9101772,8383583,8702815,9341266,9101842,8303762,8902335,8902322,8303692,9381170,9061868,9261388,8423404,9181580,9421074,8503212,8742719,8343666,8423474,9261471,8822444,8742636,8702732,8622924,8583020,8862418,8982143,9221484,9061951,8862348,8702802,8583090,8902252,8862431,8982130,9301362,8782623,9341279,8543186,8942156,8583103,8343596,9301292,9061938,9022051,9221567,9141759,9141746,9141676,8463378,8503282,8383500,9261458,8383570,8423487,8982060,8662828,9421004,8543199,8463391,8662911,9221554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":789,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":790,"address":[8858115,8459075,8419171,8618691,8658595,9217251,8339363,9177347,8698499,8299459,8379267,8778307,9017735,9097539,8538883,9376867,9416771,9297059,8818211,9257155,8498979,9336963,8937923,9137443,8898019,8977827,9057635,8738403,8578787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":791,"address":[9300461,8900816,9100336,8462329,9060889,8941325,9060432,9419568,9100941,8501776,8701753,9380121,8980624,8542137,9180144,8302713,8781561,8741657,8502381,9260557,8981229,9140845,9259952,8781104,8621488,8901273,8821465,8461872,8940720,9021137,9260409,8382521,8821613,8582041,8941177,8661392,8661997,9020989,8861517,8582189,9339760,8860912,8502233,9340217,8581584,8302861,8621945,8701296,9020532,8462477,9220505,9379664,9140240,8382669,9340365,9420173,9061037,9100793,8302256,9180749,8781709,8622093,8861369,8542285,8701901,9140697,9180601,8342765,8382064,9220048,8821008,8741200,8421968,9220653,9380269,9299856,8981081,8541680,8422573,9420025,8661849,8342160,8342617,9300313,8741805,8422425,8901421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":792,"address":[9380349,8302941,9340373,8981237,8462485,8422653,8821693,9340445,8382749,8542293,9021145,9260565,8781717,8582197,8821621,9140853,8462557,9101021,9100949,8741813,8662077,8941333,8342773,9260637,8941405,8622101,9420181,9061117,8502389,9180757,8861597,8502461,8901429,9300541,8342845,8422581,8861525,9220733,8981309,8662005,8542365,8781789,9380277,8741885,8382677,9140925,8622173,8701981,8302869,8901501,9021217,9220661,8582269,8701909,9180829,9300469,9420253,9061045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":793,"address":[8382803,8622214,9340486,8821747,9260678,8342816,8342886,8901555,8462611,9380320,9260691,8382790,9420307,9180870,8422694,8622227,9100992,9140966,8582323,8422624,9021258,8981350,8781843,8502502,8901472,9101062,9140896,8741856,9061088,8502515,8701952,8542406,8781830,8502432,9061158,8542336,9340416,8861568,8741926,8981280,8941446,9180800,8542419,9220774,9220704,8462528,9300582,8302982,9300595,8302995,8662118,9420224,9180883,8582310,8821664,8382720,9140979,9380403,8342899,8781760,9380390,8622144,8981363,8861651,8821734,8702022,8462598,8422707,8741939,8941376,8662048,9021188,9101075,8702035,8662131,9300512,8302912,9061171,9220787,9340499,9420294,8941459,9021271,8582240,8861638,9260608,8901542],"length":1,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":796,"address":[8578833,9097585,8778353,8499025,8419217,8738449,8818257,9337009,8858161,8977873,9057681,9376913,9297105,8538929,9416817,8698545,9257201,8379313,8339409,8898065,9137489,8299505,8459121,9177393,8618737,8937969,9217297,9017781,8658641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[9299353,8341657,9419065,9099833,8940217,9020029,8381561,8820505,9339257,9179641,8620985,8421465,8740697,8461369,8780601,9059929,8501273,8860409,8660889,9219545,9259449,8581081,8541177,8700793,8900313,8980121,8301753,9139737,9379161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":798,"address":[8421481,8740713,8940233,8980137,9259465,9139753,8820521,9219561,9099849,8860425,8621001,8381577,9179657,8700809,8301769,8461385,8341673,9299369,8501289,8900329,9339273,8660905,8541193,9020045,9379177,9059945,8780617,8581097,9419081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[8621467,9020404,9259824,8900795,9140112,8581456,8541659,8900341,8940592,8501301,8341685,9379536,9100208,8461744,8461851,9180016,8820533,8381936,8302235,8302128,8980496,9259477,9060411,9179669,8661264,8820987,8581563,8700821,8382043,9060304,9140219,8381589,9419547,8581109,8701275,8342139,9299381,8541205,9419440,8701168,9219573,8621360,9219920,9220027,8980603,8860784,8740725,9379643,9099861,8421840,8461397,9379189,8741072,8660917,8541552,9180123,9259931,8780976,8820880,8940245,9059957,8342032,9339285,8980149,9020057,8900688,8661371,8421947,9020511,9100315,8741179,9139765,8621013,9419093,9339739,8860437,8780629,9299728,8301781,8940699,8781083,8421493,9299835,8860891,8501755,8501648,9339632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[9017851,9257271,9177463,9057751,8938039,8299575,9178905,8979385,8460633,8698615,9137559,8700057,9139001,8500537,8899577,9376983,8738519,8580345,9298617,8420729,8939481,8578903,8379383,8618807,9337079,8459191,8380825,9416887,8339479,9218809,8858231,9258713,8658711,8419287,9019293,8818327,8301017,9099097,9297175,9097655,9217367,8538999,9418329,9059193,8859673,8660153,8620249,8778423,9338521,8739961,8898135,8819769,8977943,8340921,9378425,8779865,8499095,8540441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[8380887,8620816,9378992,8660720,8460695,9298679,9299184,8779927,8900144,9139063,8541008,9339088,8820336,8421296,8940048,8899639,8501104,8979952,9179472,8780432,8660215,8420791,8939543,8341488,9139568,8580407,9418896,8859735,8819831,9258775,9178967,9099159,9219376,9059760,8461200,9019860,9019355,8620311,8740528,9338583,9418391,8500599,9099664,8540503,8979447,8301079,8740023,8700624,9378487,8301584,8700119,9259280,8860240,8580912,8381392,8340983,9218871,9059255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":804,"address":[8380996,8780036,8740132,8341092,8899748,8620420,8500708,9099268,8700228,9418500,9059364,9139172,8540612,8819940,8939652,8580516,8420900,8301188,8460804,8660324,9298788,9218980,9179076,9338692,8859844,9378596,9258884,9019464,8979556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":805,"address":[8980100,8341529,9139716,8780580,9338708,8620436,9218996,8860281,9099284,9378612,8899764,9418937,9259428,8501252,9139609,8301204,9299225,9219524,8900185,8900292,8979572,9179092,8381012,8501145,8500724,9179620,8581060,8580953,8700244,9099812,9258900,8820484,8660340,8740148,8421337,8341636,9339236,9419044,8979993,9020008,9219417,8421444,8461348,9019901,8301732,8660868,9059908,9379140,8620857,8859860,9418516,8740676,8341108,8820377,8660761,9339129,9179513,8540628,8580532,8939668,8700772,8940089,8860388,9139188,8700665,8780052,9299332,8620964,9298804,8780473,8420916,8301625,8461241,8381540,8541156,8541049,8819956,9099705,9019480,9059380,9379033,9259321,8940196,8381433,8740569,9059801,8460820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[8339526,8459238,9097702,9297222,9177510,9416934,8698662,8658758,8738566,8299622,8539046,9137606,9257318,8379430,8578950,8977990,9057798,8419334,8938086,9217414,8499142,8618854,8898182,9377030,8778470,8818374,9337126,9017898,8858278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":809,"address":[8619730,8978866,9058674,9258194,8420210,8938962,8500018,9138482,8859154,8699538,8300498,9218290,8899058,9018774,9178386,8819250,8340402,8659634,8579826,9098578,8739442,8779346,9377906,8539922,9298098,8380306,8460114,9338002,9417810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":810,"address":[9178402,9018790,8460130,8420226,9098594,8859170,9258210,8899074,8340418,9058690,9218306,8619746,8978882,8500034,9138498,8380322,8659650,9338018,8938978,9377922,8699554,8579842,8819266,9417826,8779362,8739458,9298114,8300514,8539938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":811,"address":[8460142,9258585,8420708,8620228,9019165,9378404,9138980,8939460,9018802,8380697,9059172,9418201,8739833,8420601,8659662,8979257,8460612,8939353,8540313,8539950,8619758,9298489,8580217,8460505,8579854,8700036,9019272,8978894,8819748,8420238,8899556,9059065,9298596,9178777,8660132,9098969,8739940,8300889,9338500,8859545,9298126,9418308,8540420,8859652,8899449,8500409,8779844,8779374,8380804,9338030,9178884,8699929,8300996,8580324,8859182,8340430,9138873,9099076,8979364,9178414,9417838,9258222,8739470,9138510,9377934,8340900,9218788,8699566,8899086,8300526,8819641,9098606,8660025,8938990,9258692,9378297,8779737,8819278,9218318,9058702,8340793,8380334,8620121,9338393,8500516,9218681,8500046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":813,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":814,"address":[9257388,8698732,8299692,8459308,9337196,8499212,9417004,9377100,9217484,9137676,8778540,8898252,8858348,8419404,8978060,8658828,9097772,8738636,9297292,8618924,8379500,8579020,8539116,9177580,9057868,8818444,9017968,8938156,8339596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[8539232,8299808,8898873,8698848,8818560,8738752,9137792,8579136,8619040,9018084,8539737,8978176,8619545,8739257,9018589,8499833,8339712,8459929,9417120,8858969,9377216,8420025,9097888,8938272,9217600,8419520,8819065,8978681,9257504,9177696,9377721,8340217,9218105,8658944,8898368,9138297,9098393,9258009,9337312,8858464,9417625,9297913,8379616,8300313,8459424,9057984,8778656,8579641,9337817,8499328,8699353,8380121,8779161,9178201,8938777,9297408,9058489,8659449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[8499437,8419629,9018193,9297517,8299917,8978285,9217709,8339821,8778765,8379725,9337421,9177805,9377325,9417229,8579245,8938381,8659053,8738861,9097997,8898477,8818669,9257613,9137901,8539341,8858573,8619149,9058093,8698957,8459533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[8340365,8738877,8938818,9377341,8818685,9137917,8420066,9218146,8978829,8579682,8380269,9018737,8459549,9258050,8699501,8419645,8420173,8819106,9297533,8659069,9058530,8699394,8339837,9178242,8899021,9098541,9177821,8659490,9417666,8858589,8978301,8739298,8898493,9138445,8539357,8300461,9018630,9337858,8300354,8299933,8340258,8779202,8579789,8739405,9178349,9098013,9138338,8779309,9377762,8778781,9297954,8379741,8859117,8859010,9217725,9218253,8659597,9257629,8978722,8459970,8539885,8380162,8499453,9377869,9337965,9298061,8579261,8499874,9258157,8619165,8460077,8539778,9018209,8938925,9058109,8938397,9058637,8619693,8619586,9417245,8898914,8819213,8698973,9098434,9337437,9417773,8499981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":819,"address":[9137252,8977636,8778116,8379076,8339172,9017544,9336772,8857924,8299268,8618500,8897828,9177156,8578596,9057444,8418980,9256964,8538692,8738212,9296868,8937732,8458884,8818020,9217060,8498788,9376676,8698308,9416580,9097348,8658404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[9298069,9018745,8420181,8539893,9258165,9098549,8579797,8460085,8899029,8380277,8340373,9417781,8859125,8499989,9218261,9138453,8978837,8819221,8739413,8659605,9178357,8619701,8938933,9377877,9058645,8300469,8779317,9337973,8699509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[8857957,9296901,8419013,8783806,8344862,9057477,8384766,9063134,8818053,9017577,9177189,8544382,9376709,8379109,9262654,8624190,9137285,9217093,9342462,8823710,8703998,9256997,9023234,8937765,8943422,9097381,8664094,8743902,8299301,8304958,8578629,8538725,8903518,9422270,9302558,8458917,8698341,8983326,9416613,8424670,8504478,9382366,8897861,8618533,8584286,9222750,9103038,8738245,8778149,8863614,8977669,9336805,8464574,9142942,8339205,9182846,8658437,8498821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":828,"address":[9063147,8584299,8464710,8664230,8983462,8544518,8664107,9222886,8624326,8344998,9222763,8903531,8704011,8304971,9182859,8464587,8983339,8903654,8783819,9382379,9422406,8384779,9103174,9382502,9262790,9342598,8544395,9302571,8943435,8424683,8624203,9182982,8704134,8823846,9302694,9342475,8424806,9103051,8584422,9262667,8823723,8744038,8504491,8743915,9422283,8504614,9063270,8863627,8943558,9143078,9023247,8783942,8305094,8863750,8344875,9023370,8384902,9142955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":829,"address":[9263059,8544787,9382771,8744028,8624316,8464979,8704403,8305084,9183251,9262780,9302963,8823836,9222876,8345267,8943827,8903923,8344988,9342867,8424796,9063539,8385171,9103164,9143068,9302684,8783932,8384892,9382492,8983731,9182972,8504604,9023639,8504883,9143347,9422396,8425075,9223155,8544508,8584691,8664220,8744307,9103443,8664499,8864019,9422675,8784211,8704124,8863740,8943548,9342588,8824115,8903644,8584412,8305363,8983452,8624595,9023360,8464700,9063260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":830,"address":[8384997,8823941,8943653,8624421,8345093,8544613,9422501,8983557,8584517,8464805,8784037,8704229,8863845,8305189,9023465,9063365,9342693,9382597,9103269,9302789,8664325,8504709,8744133,9183077,9262885,9222981,9143173,8424901,8903749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":831,"address":[9422634,9183210,8824074,8943786,8624554,9023598,8425034,8345226,9063498,8863978,8504842,9143306,8983690,8704362,8385130,8744266,9223114,8664458,8305322,8584650,8903882,8544746,9263018,9382730,9103402,9342826,8464938,8784170,9302922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":833,"address":[8345031,8983495,8903687,9183015,9222919,9382535,8424839,9422439,9023403,9103207,9063303,8305127,8544551,9143111,8664263,9302727,8504647,8464743,8384935,8704167,9342631,8943591,8584455,8823879,8783975,8863783,8624359,9262823,8744071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":834,"address":[8864003,9223139,8784195,9263043,8305347,8624579,9183235,8903907,8425059,8345251,8544771,8983715,9143331,8385155,8464963,8744291,9342851,9063523,8824099,9382755,9023623,8504867,9103427,9302947,8704387,8584675,9422659,8664483,8943811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":837,"address":[8664470,9382742,8784182,9263061,8464950,9183253,8983733,8305334,8864021,8584693,9103414,8784213,9342869,8544758,8943829,8863990,8305365,8425077,8425046,8504854,9063510,9063541,8345238,8824086,8584662,8624566,8903894,8385142,9223126,9422646,9183222,8903925,8664501,8385173,8345269,8544789,9342838,9382773,9143349,8983702,9422677,9223157,8744309,9302934,9263030,8704374,9023610,8744278,8824117,9143318,8504885,8943798,8464981,9103445,8704405,9023641,9302965,8624597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[8624610,8305501,8983869,9183389,9063677,8664514,9183266,8624733,8584829,8385309,8824130,8385186,9023777,8504898,9422690,9303101,8465117,9342882,9223170,8784226,8704541,8744445,8345282,8584706,9382909,8544925,8983746,8864034,8704418,9143485,8744322,8464994,8425090,8864157,8505021,9103458,8903938,8904061,9422813,8943842,9143362,9263074,8784349,8664637,8425213,8824253,9382786,8943965,9103581,9343005,8544802,9063554,9263197,9023654,8305378,9223293,8345405,9302978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":840,"address":[8904051,9223283,8664928,8425504,8585120,9383200,8305491,8784339,9183379,8944256,8704832,8465107,8983859,8624723,8625024,9063968,8345395,9382899,9063667,9343296,8385299,9103571,9023767,8425203,8824544,8584819,8305792,9103872,8824243,9342995,8943955,9183680,8544915,8545216,8904352,9143475,9263187,9423104,8664627,8984160,8505011,9223584,8465408,8505312,8744736,8385600,8345696,9024068,9303392,8784640,9422803,9263488,8704531,8864147,8744435,8864448,9303091,9143776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[8983964,8584924,8784444,8864252,8545020,8664732,8624828,9183484,9263292,8744540,8385404,9143580,8505116,9223388,8305596,8345500,9422908,9103676,8704636,8425308,9383004,9343100,8904156,9303196,8824348,9023872,8944060,8465212,9063772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":842,"address":[8744673,8425441,8505249,8904289,9343233,8545153,8824481,8664865,9423041,9183617,9063905,9103809,9303329,9383137,8984097,8465345,8624961,8784577,8305729,8385537,8585057,8345633,8704769,9143713,9024005,9263425,8944193,9223521,8864385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":844,"address":[8983902,8744478,8345438,9223326,8505054,9422846,8943998,9303134,8465150,9103614,9063710,8624766,8904094,8425246,8305534,8385342,9343038,8544958,8664670,8784382,8584862,9382942,9263230,9183422,8824286,9143518,8704574,9023810,8864190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":845,"address":[8505296,8345680,9383184,9143760,9423088,8545200,8904336,8784624,9183664,8425488,8824528,8944240,9024052,8744720,8465392,9063952,8664912,9223568,9103856,8984144,8305776,9263472,9343280,8864432,8585104,8625008,9303376,8704816,8385584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":849,"address":[8784589,9063980,9183692,8465420,8944268,8385549,8385612,9024080,9343245,8425516,8744748,9423116,8305741,8664940,8704781,9223596,9063917,9103821,8984109,8944205,8904301,8864460,9303341,9263500,9024017,8625036,8505324,8305804,9183629,9343308,8585132,8465357,8505261,9143788,8545165,8744685,8824493,8904364,9103884,8784652,8704844,8824556,9303404,9383212,8624973,9423053,9383149,8864397,8345645,8585069,8425453,9223533,9143725,8664877,9263437,8545228,8345708,8984172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[8984191,9263519,8385631,9103903,8904383,9423135,8824575,9303423,8944287,9223615,8625055,8345727,8505343,8744767,8545247,8585151,8864479,9183711,8425535,9063999,8704863,9143807,9383231,8664959,9024099,8784671,9343327,8465439,8305823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":864,"address":[9423888,9423440,9425232,9424336,9424560,9424784,9425456,9423664,9425008,9424112],"length":1,"stats":{"Line":0},"fn_name":"global\u003c\u0026closure-0\u003e"},{"line":866,"address":[9425082,9425306,9423962,9423514,9425530,9424410,9424634,9423738,9424858,9424186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":867,"address":[9425056,9424608,9423936,9423488,9424384,9425280,9425504,9424832,9423712,9424160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":868,"address":[9423718,9423494,9424390,9423942,9424838,9425062,9425286,9425510,9424614,9424166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":869,"address":[9423501,9424621,9425517,9424845,9425293,9424397,9423725,9425069,9424173,9423949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":870,"address":[9425524,9423732,9424404,9424628,9423508,9424180,9423956,9424852,9425076,9425300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":874,"address":[9424204,9424428,9424652,9424876,9423756,9423980,9425100,9425548,9425324,9423532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":875,"address":[9423990,9424438,9424886,9423542,9424662,9424214,9425558,9425110,9423766,9425334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":876,"address":[9425120,9425568,9425344,9424224,9423776,9424448,9423552,9424000,9424896,9424672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":877,"address":[9423562,9424010,9424682,9425354,9424234,9424458,9424906,9425130,9423786,9425578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":880,"address":[9425364,9423796,9425140,9424692,9424020,9424244,9424916,9425588,9423572,9424468],"length":1,"stats":{"Line":0},"fn_name":null},{"line":881,"address":[9425608,9425384,9424040,9424488,9423592,9424264,9424712,9425160,9424936,9423816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":884,"address":[9425398,9424278,9423830,9424950,9424054,9424726,9425174,9425622,9424502,9423606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":885,"address":[9424736,9424512,9423840,9424064,9425632,9425184,9424288,9423616,9425408,9424960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":886,"address":[9424298,9423850,9423626,9424522,9425194,9425642,9424970,9424074,9424746,9425418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":887,"address":[9424084,9423636,9423860,9425652,9425204,9425428,9424980,9424532,9424756,9424308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":889,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":893,"address":[9426746,9426474,9426214,9428106,9428378,9427846,9428118,9427584,9427312,9427834,9427562,9426486,9425680,9427290,9427018,9428390,9425942,9428128,9426496,9427302,9427040,9427574,9427856,9427030,9426758,9425930,9425952,9426768,9426202,9426224],"length":1,"stats":{"Line":0},"fn_name":"semiglobal\u003c\u0026closure-0\u003e"},{"line":895,"address":[9427930,9427386,9425754,9426842,9426570,9426298,9427658,9426026,9427114,9428202],"length":1,"stats":{"Line":0},"fn_name":null},{"line":896,"address":[9425728,9428176,9427904,9426544,9427360,9426272,9427632,9426000,9426816,9427088],"length":1,"stats":{"Line":0},"fn_name":null},{"line":897,"address":[9427638,9426550,9426278,9426822,9427910,9425734,9426006,9427094,9428182,9427366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":898,"address":[9426557,9426013,9425741,9426829,9426285,9427645,9427917,9428189,9427101,9427373],"length":1,"stats":{"Line":0},"fn_name":null},{"line":899,"address":[9426836,9428196,9427652,9427924,9427108,9426292,9426564,9426020,9425748,9427380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":903,"address":[9425772,9426860,9427948,9427676,9426316,9426588,9427404,9426044,9427132,9428220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":904,"address":[9427142,9427958,9426326,9427414,9425782,9427686,9426870,9426054,9426598,9428230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":905,"address":[9427152,9426064,9427696,9426608,9427424,9426336,9427968,9428240,9426880,9425792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":906,"address":[9425802,9427162,9426346,9427434,9426618,9427978,9426074,9428250,9427706,9426890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":909,"address":[9425812,9427172,9427988,9427716,9428260,9426628,9426084,9426900,9426356,9427444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":910,"address":[9426366,9427182,9427726,9427998,9428270,9426638,9426094,9426910,9427454,9425822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":913,"address":[9428282,9427738,9426922,9428010,9425834,9426650,9427194,9427466,9426378,9426106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":916,"address":[9427215,9428303,9427759,9426943,9428031,9426127,9427487,9425855,9426399,9426671],"length":1,"stats":{"Line":0},"fn_name":null},{"line":917,"address":[9428041,9427225,9427769,9425865,9426137,9426409,9426953,9428313,9427497,9426681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":918,"address":[9428051,9427779,9426691,9427507,9427235,9426147,9428323,9426419,9425875,9426963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":919,"address":[9428061,9425885,9427517,9428333,9426973,9426429,9426157,9427245,9427789,9426701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":921,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":930,"address":[9428400,9428664,9428676],"length":1,"stats":{"Line":0},"fn_name":"semiglobal_with_prehash\u003c\u0026closure-0\u003e"},{"line":937,"address":[9428483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":938,"address":[9428457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":939,"address":[9428463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":940,"address":[9428469],"length":1,"stats":{"Line":0},"fn_name":null},{"line":941,"address":[9428476],"length":1,"stats":{"Line":0},"fn_name":null},{"line":945,"address":[9428501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":946,"address":[9428511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":947,"address":[9428521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":948,"address":[9428531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":951,"address":[9428541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":952,"address":[9428555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":955,"address":[9428567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":958,"address":[9428588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":959,"address":[9428598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":960,"address":[9428608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":961,"address":[9428618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":963,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":967,"address":[9428960,9429766,9429494,9428950,9429776,9429232,9430038,9430026,9429754,9428688,9428938,9429504,9429210,9429482,9429222],"length":1,"stats":{"Line":0},"fn_name":"local\u003c\u0026closure-0\u003e"},{"line":969,"address":[9429306,9429034,9428762,9429578,9429850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":970,"address":[9429824,9429008,9429280,9428736,9429552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":971,"address":[9429558,9428742,9429830,9429286,9429014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":972,"address":[9429565,9429293,9429837,9429021,9428749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":973,"address":[9429844,9429300,9429028,9429572,9428756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":977,"address":[9429868,9428780,9429596,9429324,9429052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":978,"address":[9428790,9429334,9429062,9429878,9429606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":979,"address":[9428800,9429344,9429888,9429072,9429616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":980,"address":[9429082,9429626,9428810,9429354,9429898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":983,"address":[9429636,9429908,9429092,9429364,9428820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":984,"address":[9429374,9429918,9428830,9429646,9429102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":987,"address":[9428842,9429658,9429930,9429114,9429386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":990,"address":[9428863,9429951,9429135,9429407,9429679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":991,"address":[9429689,9429961,9429417,9428873,9429145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":992,"address":[9429971,9428883,9429699,9429427,9429155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":993,"address":[9429165,9429437,9429709,9428893,9429981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":995,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":999,"address":[9430048,9432224,9434369,9432193],"length":1,"stats":{"Line":0},"fn_name":"visualize\u003c\u0026closure-0\u003e"},{"line":1001,"address":[9430079,9432255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1002,"address":[9434427,9432366,9434400,9430190,9434587,9434560],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003c\u0026closure-0\u003e"},{"line":1003,"address":[9430502,9430198,9430364,9432374,9432540,9432678,9430794,9432970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1004,"address":[9432718,9430542],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1005,"address":[9430598,9433122,9430807,9432774,9432983,9430946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1006,"address":[9433015,9430839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1011,"address":[9430480,9432656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1012,"address":[9431177,9430951,9433333,9433127,9433598,9431422,9433353,9431157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1013,"address":[9433481,9431305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1016,"address":[9432188,9433603,9431427,9434364,9431629,9433805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1017,"address":[9434340,9431666,9432164,9431897,9434073,9433842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1018,"address":[9431929,9434105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1020,"address":[9431850,9434026,9432169,9434345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1030,"address":[4680928],"length":1,"stats":{"Line":0},"fn_name":"continues"},{"line":1031,"address":[4680991,4680984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1032,"address":[4681001,4680971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1033,"address":[4680986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1053,"address":[4681200],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":1055,"address":[4681273,4681234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1056,"address":[4681326,4681255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1057,"address":[4681308,4681366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1063,"address":[4681552],"length":1,"stats":{"Line":0},"fn_name":"add_kmer"},{"line":1064,"address":[4681623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1066,"address":[4681691,4681805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1067,"address":[4681851,4681912,4681785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1069,"address":[4681904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1070,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1073,"address":[4682012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1074,"address":[4682476,4682632,4682101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1075,"address":[4682516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1078,"address":[4682455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1079,"address":[4682653,4683108,4683307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1080,"address":[4683148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1081,"address":[4683312,4683264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1084,"address":[4683358,4683073,4683460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1085,"address":[4683606,4683498,4683440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1086,"address":[4684864,4684859],"length":1,"stats":{"Line":0},"fn_name":"add_entry"},{"line":1087,"address":[4683743,4683662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1088,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1090,"address":[4683748,4684599,4684633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1091,"address":[4684607,4684676,4684715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1092,"address":[4684758,4684684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1095,"address":[4683800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1096,"address":[4683973,4684112,4684578,4684444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1097,"address":[4684481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1103,"address":[4684864],"length":1,"stats":{"Line":0},"fn_name":"add_entry"},{"line":1104,"address":[4684935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1106,"address":[4685052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1107,"address":[4685076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1108,"address":[4685575,4685814,4685295,4685819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1109,"address":[4685612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1110,"address":[4685720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1115,"address":[4685824],"length":1,"stats":{"Line":0},"fn_name":"add_gap"},{"line":1116,"address":[4685903,4685950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1117,"address":[4685935,4685988,4686001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1118,"address":[4685995,4686207,4686707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1119,"address":[4686094,4686623,4686220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1120,"address":[4686593,4686252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1121,"address":[4686558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1124,"address":[4686039,4686644,4687125,4687120,4686717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1125,"address":[4687090,4686749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1126,"address":[4687055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1142,"address":[9460240,9495968,9511280,9521488,9572528,9557216,9526592,9516384,9480656,9531696,9455136,9501072,9577632,9450032,9439824,9485760,9536800,9547008,9434720,9470448,9541904,9475552,9567424,9552112,9465344,9506176,9444928,9490864,9562320],"length":1,"stats":{"Line":0},"fn_name":"set_boundaries\u003c\u0026closure-0\u003e"},{"line":1150,"address":[9440074,9521738,9455386,9572778,9526724,9439956,9552362,9536932,9445178,9577764,9516634,9501204,9465476,9562570,9496100,9460490,9511530,9486010,9465594,9552244,9480788,9547258,9557348,9491114,9450282,9572660,9547140,9516516,9531828,9557466,9460372,9567556,9475684,9501322,9526842,9445060,9511412,9470580,9506308,9496218,9434970,9531946,9577882,9475802,9455268,9470698,9480906,9434852,9542036,9567674,9542154,9537050,9506426,9562452,9521620,9450164,9485892,9490996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1154,"address":[9531881,9577817,9536985,9465529,9455321,9557401,9440009,9542089,9470633,9475737,9572713,9450217,9460425,9485945,9491049,9526777,9511465,9506361,9445113,9521673,9552297,9434905,9496153,9567609,9501257,9547193,9480841,9516569,9562505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1155,"address":[9552349,9501309,9450312,9435000,9445165,9491101,9567704,9542184,9572765,9450269,9496248,9552392,9547288,9526829,9521768,9486040,9531933,9470685,9455416,9531976,9562557,9577912,9537080,9480936,9480893,9572808,9562600,9542141,9501352,9547245,9557453,9475789,9465624,9557496,9475832,9516664,9521725,9460477,9511517,9434957,9526872,9516621,9470728,9567661,9496205,9465581,9455373,9440104,9506456,9511560,9491144,9485997,9460520,9537037,9577869,9506413,9440061,9445208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1156,"address":[9567753,9557545,9440153,9537129,9552441,9450361,9491193,9475881,9460569,9445257,9562649,9532025,9496297,9501401,9486089,9516713,9465673,9542233,9506505,9470777,9480985,9511609,9526921,9577961,9547337,9521817,9435049,9572857,9455465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1157,"address":[9578003,9455507,9532067,9557587,9562787,9537171,9440291,9450403,9557683,9491331,9511747,9496339,9501443,9465811,9506643,9552483,9547475,9567795,9562691,9475923,9521859,9496435,9486227,9445395,9516851,9476019,9486131,9435187,9501539,9521955,9460707,9552579,9460611,9450499,9542371,9572899,9572995,9532163,9537267,9516755,9567891,9481027,9455603,9470819,9470915,9491235,9440195,9527059,9465715,9547379,9526963,9511651,9435091,9481123,9542275,9506547,9578099,9445299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1159,"address":[9467515,9533867,9578087,9559387,9447099,9503243,9538971,9579803,9547463,9527047,9513451,9476007,9506631,9440279,9544075,9455591,9465799,9435175,9450487,9477723,9554283,9472619,9470903,9508347,9436891,9491319,9521943,9441995,9572983,9511735,9552567,9487931,9516839,9562775,9557671,9501527,9542359,9460695,9537255,9445383,9532151,9498139,9574699,9462411,9486215,9493035,9569595,9452203,9528763,9518555,9564491,9549179,9457307,9567879,9523659,9496423,9482827,9481111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1162,"address":[9521985,9511777,9563850,9486257,9512810,9542401,9547505,9456666,9461770,9501569,9496465,9471978,9470945,9460737,9455633,9436250,9492394,9552609,9476049,9543434,9528122,9537297,9574058,9481153,9579162,9477082,9533226,9435217,9538330,9506673,9451562,9445425,9491361,9527089,9450529,9568954,9465841,9578129,9440321,9516881,9517914,9553642,9558746,9507706,9502602,9557713,9497498,9532193,9441354,9548538,9466874,9573025,9446458,9523018,9562817,9482186,9487290,9567921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1163,"address":[9441384,9456696,9533256,9507736,9446488,9477112,9466904,9568984,9528152,9517944,9574088,9563880,9553672,9492424,9482216,9512840,9451592,9497528,9538360,9436280,9487320,9502632,9548568,9579192,9523048,9558776,9472008,9461800,9543464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1166,"address":[9457241,9513385,9498073,9441929,9569529,9452137,9503177,9528697,9462345,9518489,9554217,9447033,9477657,9559321,9538905,9579737,9508281,9492969,9523593,9467449,9574633,9564425,9533801,9482761,9544009,9487865,9436825,9549113,9472553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1168,"address":[9569203,9497747,9436499,9564099,9513059,9518163,9446707,9492643,9472227,9538579,9507955,9441603,9456915,9451811,9467123,9548787,9482435,9523267,9543683,9462019,9487539,9533475,9579411,9574307,9528371,9477331,9502851,9553891,9558995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1169,"address":[9548867,9467203,9569283,9451891,9553971,9513139,9528451,9559075,9477411,9472307,9523347,9436579,9538659,9487619,9482515,9533555,9574387,9492723,9462099,9518243,9564179,9456995,9497827,9579491,9446787,9502931,9508035,9441683,9543763],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1171,"address":[9564461,9513421,9513233,9492817,9538753,9528545,9574481,9436861,9447069,9554065,9467297,9467485,9548961,9487901,9462193,9498109,9533649,9543857,9523629,9441777,9533837,9482797,9457277,9544045,9457089,9559169,9579773,9472401,9441965,9436673,9574669,9503025,9451985,9477693,9559357,9528733,9462381,9508317,9487713,9508129,9452173,9503213,9554253,9538941,9523441,9482609,9569565,9564273,9446881,9549149,9497921,9579585,9477505,9518337,9493005,9472589,9569377,9518525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1178,"address":[9557818,9491486,9573130,9537435,9522110,9501604,9522020,9460842,9460862,9486362,9573163,9568026,9562852,9557748,9450667,9471070,9435322,9450634,9537422,9568046,9578267,9547643,9532318,9440356,9496500,9440446,9460875,9552734,9552644,9450564,9522123,9465876,9578254,9522090,9527227,9527124,9435355,9455758,9476154,9557838,9573060,9568059,9445550,9506708,9567956,9455738,9527214,9547630,9471083,9552747,9532331,9511812,9486382,9445530,9450654,9455771,9511902,9562955,9440459,9506811,9496570,9547610,9501694,9516916,9491499,9470980,9517006,9532298,9465966,9573150,9506778,9562922,9481291,9496590,9511882,9445563,9517019,9460772,9491396,9445460,9486395,9486292,9532228,9465979,9496603,9435342,9542506,9455668,9471050,9481188,9557851,9547540,9537402,9476187,9481278,9578234,9440426,9542539,9516986,9511915,9506798,9578164,9552714,9476084,9537332,9476174,9481258,9501674,9562942,9491466,9501707,9465946,9435252,9542526,9542436,9527194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1180,"address":[9476197,9445488,9440384,9496613,9445573,9455696,9435365,9578192,9516944,9522133,9506821,9567984,9522048,9501632,9552672,9511925,9557776,9542549,9578277,9471008,9501717,9486320,9496528,9537445,9435280,9460800,9547653,9527152,9537360,9573173,9532341,9511840,9450677,9573088,9455781,9471093,9542464,9465904,9465989,9527237,9557861,9491509,9450592,9440469,9517029,9568069,9486405,9491424,9506736,9532256,9476112,9481301,9552757,9460885,9562880,9547568,9562965,9481216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1182,"address":[9532308,9465956,9557828,9481268,9471060,9522100,9445540,9455748,9511892,9460852,9496580,9486372,9547620,9516996,9568036,9506788,9435332,9527204,9562932,9578244,9440436,9491476,9450644,9552724,9501684,9573140,9537412,9476164,9542516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1183,"address":[9450656,9491488,9481280,9511904,9552736,9435344,9527216,9486384,9501696,9537424,9445552,9440448,9547632,9471072,9517008,9578256,9522112,9465968,9532320,9496592,9460864,9476176,9557840,9455760,9568048,9542528,9506800,9573152,9562944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1186,"address":[9547785,9481433,9486537,9547663,9445705,9552767,9573183,9461017,9486415,9501727,9527247,9517161,9522265,9501849,9578287,9578409,9496623,9450687,9511935,9476207,9455791,9532473,9557993,9573305,9512057,9440601,9455913,9532351,9445583,9542681,9527369,9481311,9506953,9465999,9568201,9542559,9506831,9435375,9440479,9466121,9517039,9476329,9491519,9460895,9562975,9537577,9522143,9557871,9563097,9496745,9471103,9568079,9491641,9471225,9435497,9537455,9450809,9552889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1187,"address":[9578297,9450697,9460905,9568089,9496633,9542569,9491529,9435385,9537465,9440489,9532361,9557881,9476217,9506841,9573193,9445593,9562985,9552777,9547673,9522153,9466009,9471113,9455801,9527257,9501737,9481321,9517049,9511945,9486425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1188,"address":[9537631,9547839,9471279,9527423,9455967,9435551,9501903,9578463,9445759,9558047,9491695,9461071,9563151,9450863,9440655,9573359,9512111,9568255,9552943,9496799,9466175,9476383,9532527,9481487,9522319,9517215,9486591,9542735,9507007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1190,"address":[9578842,9553322,9507386,9446138,9435930,9481866,9527802,9512490,9517594,9568634,9548218,9441034,9492074,9451242,9502282,9573738,9466554,9497178,9471658,9558426,9538010,9476762,9522698,9456346,9486970,9461450,9563530,9532906,9543114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1191,"address":[9537850,9573578,9522538,9456186,9481706,9476602,9497018,9445978,9461290,9568474,9466394,9578682,9471498,9451082,9507226,9553162,9563370,9486810,9512330,9440874,9532746,9558266,9502122,9548058,9435770,9527642,9491914,9517434,9542954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1192,"address":[9481786,9507306,9573658,9578762,9446058,9435850,9558346,9440954,9517514,9476682,9502202,9527722,9512410,9491994,9497098,9553242,9466474,9456266,9471578,9548138,9522618,9568554,9543034,9486890,9563450,9537930,9532826,9461370,9451162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1194,"address":[9548386,9568802,9466722,9461464,9486984,9492088,9497192,9482034,9578856,9517608,9538178,9466568,9446152,9471672,9476776,9543282,9481880,9527970,9522712,9512504,9573752,9548232,9436098,9451256,9435944,9456360,9487138,9456514,9512658,9563544,9497346,9461618,9451410,9538024,9441202,9527816,9517762,9558594,9563698,9579010,9492242,9568648,9522866,9553336,9507554,9502450,9573906,9446306,9533074,9502296,9476930,9507400,9553490,9532920,9558440,9441048,9471826,9543128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1195,"address":[9574037,9543312,9461600,9497328,9446336,9482064,9517744,9492224,9558624,9456645,9502432,9461648,9533104,9548416,9476912,9451541,9558576,9446437,9451440,9579040,9456544,9492272,9466704,9512640,9553472,9441184,9563728,9471957,9533056,9517893,9548517,9461749,9436229,9497376,9517792,9543413,9476960,9471856,9456496,9487120,9446288,9528000,9512688,9507536,9579141,9451392,9436128,9568933,9553621,9466853,9538309,9533205,9502480,9568784,9573936,9507584,9558725,9548368,9487168,9578992,9487269,9436080,9482165,9441232,9573888,9482016,9492373,9512789,9522848,9538160,9563680,9502581,9522997,9471808,9527952,9477061,9522896,9553520,9466752,9568832,9441333,9497477,9543264,9538208,9507685,9563829,9528101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1196,"address":[9477027,9456611,9512755,9446403,9441299,9579107,9553587,9451507,9533171,9436195,9461715,9507651,9522963,9574003,9497443,9466819,9543379,9471923,9517859,9563795,9502547,9538275,9558691,9528067,9548483,9482131,9487235,9492339,9568899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1200,"address":[9573264,9568160,9527328,9435456,9512016,9460976,9532432,9537536,9471184,9501808,9486496,9445664,9506912,9557952,9496704,9563056,9481392,9517120,9578368,9491600,9440560,9552848,9522224,9466080,9547744,9542640,9476288,9450768,9455872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1207,"address":[9461034,9437069,9547802,9573322,9477743,9450826,9462589,9574719,9481450,9503263,9579981,9549357,9477901,9574877,9528941,9506970,9467535,9532490,9569615,9518733,9501866,9486554,9447277,9466138,9564669,9513471,9534045,9537594,9564511,9542698,9487951,9483005,9527386,9518575,9508525,9467693,9544253,9538991,9455930,9452223,9436911,9558010,9471242,9533887,9472639,9503421,9435514,9498317,9539149,9512074,9452381,9528783,9523679,9442015,9491658,9569773,9457327,9568218,9578426,9563114,9517178,9457485,9482847,9496762,9544095,9447119,9445722,9554303,9488109,9552906,9554461,9476346,9493213,9472797,9442173,9522282,9559407,9559565,9579823,9508367,9523837,9498159,9462431,9440618,9549199,9493055,9513629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1208,"address":[9518794,9488095,9539210,9579967,9518719,9452367,9508586,9447263,9523823,9503482,9554447,9529002,9472858,9564730,9554522,9513690,9477887,9513615,9493274,9528927,9549343,9580042,9447338,9437055,9544239,9523898,9462650,9467679,9564655,9452442,9493199,9508511,9539135,9437130,9534031,9467754,9534106,9498378,9482991,9462575,9549418,9569759,9503407,9457546,9442159,9488170,9472783,9483066,9559626,9569834,9574938,9442234,9574863,9544314,9498303,9559551,9477962,9457471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1209,"address":[9477947,9508571,9442287,9513743,9498363,9483119,9544299,9580095,9508639,9437183,9559611,9467807,9559679,9493259,9544367,9580027,9554575,9569887,9457599,9462703,9574923,9534159,9447323,9523951,9513675,9518779,9564715,9437115,9549403,9472843,9523883,9488223,9478015,9503535,9472911,9564783,9518847,9457531,9503467,9539263,9534091,9452427,9467739,9554507,9539195,9483051,9549471,9498431,9574991,9569819,9493327,9452495,9462635,9442219,9488155,9528987,9447391,9529055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1210,"address":[9575021,9467800,9457629,9478008,9518877,9523981,9529085,9472941,9508632,9442280,9523944,9544397,9493357,9437176,9478045,9462696,9559672,9518840,9569917,9503565,9488253,9437213,9580125,9574984,9554568,9564813,9462733,9498461,9452525,9503528,9569880,9539293,9513736,9529048,9483112,9564776,9452488,9539256,9534189,9483149,9467837,9544360,9508669,9493320,9442317,9513773,9488216,9554605,9580088,9549464,9559709,9472904,9447384,9498424,9457592,9534152,9549501,9447421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1211,"address":[9554704,9575097,9473040,9549577,9513872,9524080,9498537,9437289,9488352,9529161,9467936,9493456,9508745,9534288,9452601,9544496,9473017,9524057,9539392,9564889,9437312,9564912,9457728,9493433,9483225,9503641,9447497,9503664,9549600,9569993,9442393,9442416,9554681,9544473,9478121,9518976,9580201,9462809,9580224,9575120,9457705,9467913,9534265,9508768,9462832,9513849,9452624,9488329,9447520,9570016,9518953,9529184,9483248,9559808,9539369,9559785,9498560,9478144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1212,"address":[9508770,9554706,9467938,9488354,9529186,9534290,9478146,9447522,9493458,9580226,9513874,9564914,9549602,9570018,9473042,9503666,9437314,9442418,9483250,9452626,9575122,9457730,9462834,9544498,9559810,9524082,9498562,9539394,9518978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1214,"address":[9518966,9462822,9488342,9549590,9467926,9478134,9508758,9544486,9483238,9493446,9524070,9534278,9442406,9457718,9570006,9529174,9498550,9575110,9554694,9513862,9580214,9539382,9452614,9559798,9447510,9564902,9503654,9437302,9473030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1216,"address":[9488381,9559874,9539445,9478210,9478264,9570045,9564978,9539458,9493485,9529213,9503730,9457848,9452690,9457781,9529250,9534317,9508834,9462898,9564965,9498613,9570136,9447549,9483277,9519096,9570069,9462885,9447573,9468056,9519029,9575173,9478173,9565032,9442469,9575149,9503693,9437378,9549629,9559861,9575186,9452677,9498680,9442445,9483368,9549720,9539512,9554733,9570082,9524133,9473093,9473106,9442536,9519005,9488418,9437432,9483301,9452653,9488472,9524109,9478197,9508797,9519042,9554757,9575240,9554824,9508821,9488405,9493522,9544549,9503784,9513925,9498589,9544562,9534341,9559928,9498626,9473160,9468002,9549653,9457757,9559837,9493576,9513901,9437341,9467989,9467965,9529304,9442482,9554770,9493509,9508888,9580290,9447640,9447586,9580253,9539421,9503717,9524146,9513992,9534354,9549666,9473069,9580344,9564941,9462952,9544616,9452744,9462861,9437365,9580277,9513938,9544525,9483314,9534408,9524200,9457794,9529237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1217,"address":[9564967,9519031,9559863,9534343,9452679,9575175,9447575,9488407,9580279,9554759,9503719,9462887,9498615,9437367,9493511,9467991,9457783,9478199,9524135,9549655,9513927,9529239,9508823,9473095,9544551,9442471,9570071,9539447,9483303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1219,"address":[9437355,9570059,9544539,9442459,9467979,9488395,9478187,9447563,9524123,9457771,9529227,9519019,9498603,9554747,9575163,9513915,9452667,9580267,9559851,9493499,9564955,9508811,9462875,9473083,9549643,9483291,9503707,9534331,9539435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1222,"address":[9442524,9513980,9575228,9493564,9478252,9508876,9580332,9447628,9498668,9452732,9437420,9462940,9534396,9488460,9565020,9539500,9468044,9544604,9524188,9473148,9529292,9457836,9559916,9503772,9519084,9554812,9483356,9570124,9549708],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1224,"address":[9530760,9462998,9515448,9580390,9520552,9551176,9498726,9500136,9561384,9442582,9449096,9489928,9473206,9495032,9447686,9581800,9546072,9459304,9493622,9474616,9556280,9437478,9478310,9488518,9539558,9529350,9468102,9554870,9479720,9576696,9469512,9484824,9571592,9464408,9505240,9519142,9534454,9503830,9457894,9452790,9566488,9565078,9510344,9514038,9525656,9524246,9454200,9483414,9575286,9570182,9549766,9540968,9443992,9535864,9544662,9559974,9508934,9438888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1225,"address":[9576884,9581988,9469700,9444180,9474804,9505428,9464596,9439076,9536052,9485012,9561572,9454388,9556468,9495220,9449284,9515636,9571780,9541156,9520740,9551364,9490116,9510532,9525844,9500324,9566676,9479908,9530948,9546260,9459492],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1227,"address":[9439287,9490170,9546314,9541367,9582199,9520951,9480119,9459703,9500378,9561626,9505482,9444234,9479962,9525898,9485223,9510743,9454442,9515847,9536263,9526055,9444391,9582042,9485066,9464650,9475015,9474858,9464807,9439130,9536106,9561783,9495431,9541210,9566730,9556679,9566887,9520794,9577095,9551418,9449495,9510586,9531159,9454599,9576938,9556522,9495274,9551575,9490327,9449338,9531002,9515690,9505639,9500535,9571991,9469911,9571834,9546471,9469754,9459546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1228,"address":[9469885,9444557,9480159,9464781,9454639,9531199,9551549,9572031,9546445,9495597,9526221,9541341,9495471,9566861,9444365,9454573,9541407,9516013,9439327,9439261,9556845,9515887,9475055,9470077,9475181,9510717,9464847,9500701,9521117,9546511,9556719,9485263,9577135,9505805,9551741,9459743,9510783,9500509,9449535,9526095,9567053,9572157,9536429,9474989,9500575,9546637,9485197,9541533,9449661,9561949,9439453,9582239,9454765,9480285,9480093,9531325,9459869,9520991,9536237,9582173,9490367,9536303,9490301,9495405,9459677,9531133,9520925,9490493,9485389,9505679,9577261,9505613,9526029,9556653,9571965,9566927,9449469,9510909,9469951,9561757,9582365,9551615,9464973,9561823,9515821,9577069,9444431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1229,"address":[9475221,9526261,9521157,9531365,9465013,9490533,9515988,9561924,9500676,9459844,9556820,9531300,9485429,9510949,9505780,9567093,9546612,9470117,9582340,9536469,9495637,9490468,9454805,9439428,9541573,9444597,9567028,9551716,9546677,9572197,9444532,9459909,9449701,9556885,9464948,9572132,9577236,9475156,9495572,9439493,9470052,9505845,9582405,9521092,9551781,9541508,9500741,9536404,9526196,9561989,9480325,9485364,9577301,9454740,9510884,9480260,9516053,9449636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1230,"address":[9516128,9444672,9577376,9531440,9526336,9465088,9511024,9439568,9572272,9505920,9454880,9470192,9459984,9495712,9546752,9562064,9449776,9480400,9490608,9541648,9567168,9500816,9582480,9485504,9551856,9536544,9521232,9475296,9556960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1231,"address":[9526589,9480648,9495960,9577471,9562312,9557208,9475391,9444767,9480653,9439816,9547000,9480495,9500911,9450024,9490703,9470445,9465341,9501069,9567263,9460232,9516381,9455128,9495807,9572525,9551951,9470440,9439821,9526431,9582728,9460079,9541901,9495965,9465336,9572367,9536792,9460237,9572520,9475549,9577624,9552109,9470287,9577629,9501064,9511272,9582733,9485757,9547005,9526584,9506173,9541896,9536639,9552104,9516376,9516223,9567416,9536797,9454975,9506168,9546847,9490861,9562317,9567421,9485599,9541743,9490856,9449871,9511277,9521327,9531693,9455133,9465183,9511119,9439663,9531535,9531688,9506015,9521480,9557213,9562159,9444925,9582575,9475544,9444920,9557055,9485752,9450029,9521485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1232,"address":[9511210,9557146,9516314,9495898,9449962,9552042,9470378,9526522,9501002,9444858,9460170,9455066,9475482,9490794,9485690,9582666,9465274,9541834,9567354,9480586,9506106,9439754,9577562,9531626,9521418,9546938,9572458,9562250,9536730],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1238,"address":[9452913,9534500,9565201,9560020,9534577,9473252,9498772,9447732,9580513,9483537,9463121,9442628,9570305,9503876,9493745,9580436,9468225,9575332,9544785,9575409,9498849,9478433,9509057,9508980,9524292,9529396,9442705,9570228,9524369,9503953,9473329,9452836,9437601,9519188,9549812,9519265,9539681,9554993,9514084,9458017,9560097,9463044,9493668,9529473,9539604,9549889,9483460,9488564,9544708,9488641,9457940,9437524,9468148,9514161,9565124,9447809,9478356,9554916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1239,"address":[9565277,9483575,9493821,9509133,9575447,9498887,9452889,9514237,9473367,9575385,9468263,9447847,9452951,9534653,9580489,9483613,9478509,9442781,9437677,9442681,9498825,9570381,9437577,9503991,9447885,9565177,9544823,9452989,9493783,9463197,9458055,9549927,9514137,9529449,9509033,9478471,9570343,9575485,9493721,9519241,9534615,9560073,9549865,9458093,9457993,9498925,9519341,9539719,9534553,9560173,9539657,9565239,9539757,9529549,9473405,9442743,9488617,9529511,9447785,9544761,9580551,9554969,9488679,9468301,9437639,9544861,9524407,9504029,9503929,9519303,9478409,9580589,9524445,9524345,9463097,9560135,9555069,9509095,9468201,9549965,9570281,9514199,9483513,9555031,9463159,9473305,9488717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1240,"address":[9483583,9580681,9498895,9499017,9555141,9544933,9437769,9534725,9442873,9575455,9473497,9452959,9514342,9437647,9529519,9458185,9498997,9499030,9519311,9575590,9483685,9580694,9473375,9483705,9442886,9447855,9509225,9453094,9580661,9550037,9524517,9478601,9519446,9550057,9509238,9544953,9565247,9473477,9549935,9483718,9437749,9493913,9504121,9539862,9580559,9458063,9488822,9570486,9570473,9493926,9514329,9442751,9458165,9478614,9509103,9565382,9524550,9514309,9560265,9544966,9570351,9447957,9509205,9488809,9524415,9463167,9529641,9468393,9555174,9463269,9437782,9504134,9468406,9488789,9519413,9478479,9565349,9539829,9575557,9488687,9504101,9550070,9458198,9519433,9503999,9534758,9468373,9468271,9529654,9560245,9453061,9442853,9473510,9565369,9539727,9560278,9514207,9447990,9555161,9493893,9447977,9529621,9575577,9560143,9524537,9534745,9534623,9544831,9539849,9570453,9555039,9463302,9478581,9493791,9463289,9453081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1242,"address":[9539872,9437792,9448000,9524475,9555184,9478539,9509248,9544976,9463312,9565307,9458208,9483728,9580704,9555099,9529579,9565392,9519456,9534768,9473520,9437707,9483643,9560288,9493851,9575515,9473435,9468331,9468416,9570496,9493936,9560203,9514352,9453104,9534683,9458123,9509163,9488747,9453019,9504144,9499040,9580619,9442811,9447915,9529664,9463227,9442896,9514267,9570411,9524560,9575600,9544891,9504059,9549995,9519371,9550080,9478624,9498955,9488832,9539787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1244,"address":[9504111,9565359,9509215,9514319,9575567,9544943,9499007,9570463,9580671,9550047,9524527,9468383,9458175,9463279,9478591,9539839,9483695,9534735,9473487,9560255,9442863,9493903,9453071,9555151,9437759,9488799,9519423,9447967,9529631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1246,"address":[9539851,9442875,9575579,9468395,9509227,9447979,9493915,9560267,9499019,9519435,9473499,9529643,9580683,9463291,9478603,9534747,9458187,9504123,9544955,9483707,9565371,9453083,9570475,9524539,9437771,9514331,9550059,9555163,9488811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1249,"address":[9575777,9555361,9514362,9499050,9580714,9458218,9539882,9443073,9504321,9509258,9580881,9483738,9524570,9458385,9493946,9499217,9453114,9519633,9534945,9504154,9570506,9575610,9448177,9560298,9509425,9570673,9478634,9555194,9514529,9463322,9524737,9463489,9489009,9529674,9448010,9550090,9442906,9540049,9544986,9437969,9565402,9468593,9488842,9519466,9494113,9473530,9453281,9550257,9468426,9473697,9534778,9483905,9565569,9529841,9437802,9478801,9560465,9545153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1250,"address":[9560308,9453124,9534788,9499060,9437812,9544996,9504164,9514372,9488852,9519476,9580724,9550100,9570516,9529684,9575620,9458228,9448020,9442916,9463332,9478644,9539892,9493956,9483748,9468436,9555204,9509268,9473540,9565412,9524580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1251,"address":[9509475,9489059,9580931,9494163,9575827,9453331,9570723,9473747,9524787,9555411,9504371,9529891,9540099,9443123,9550307,9458435,9560515,9499267,9463539,9514579,9545203,9468643,9438019,9519683,9478851,9534995,9565619,9448227,9483955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1253,"address":[9484202,9499324,9550554,9529948,9453388,9489306,9473804,9581178,9575884,9448474,9509532,9499514,9463786,9494410,9530138,9514636,9524844,9478908,9484012,9565676,9560572,9555658,9525034,9545260,9443180,9494220,9438076,9448284,9555468,9468890,9438266,9535052,9570780,9535242,9576074,9453578,9479098,9550364,9565866,9458682,9514826,9463596,9519930,9540346,9570970,9504428,9545450,9489116,9509722,9473994,9458492,9560762,9468700,9443370,9540156,9504618,9580988,9519740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1254,"address":[9438312,9453546,9509912,9555626,9545496,9468858,9453624,9489352,9576264,9484170,9525002,9565912,9530328,9535210,9555704,9581146,9458728,9571016,9438456,9499704,9453768,9519976,9443416,9469080,9540392,9535432,9514872,9519898,9494600,9581224,9576120,9499560,9530106,9504586,9571160,9565834,9494456,9566056,9448442,9499482,9479144,9438234,9474040,9468936,9484392,9514794,9520120,9540536,9463832,9555848,9509690,9448664,9474184,9550600,9545418,9576042,9504664,9509768,9443560,9545640,9535288,9581368,9484248,9463976,9515016,9463754,9525080,9560730,9479288,9540314,9504808,9458872,9489496,9550744,9479066,9448520,9570938,9525224,9530184,9550522,9560808,9473962,9443338,9458650,9489274,9560952,9494378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1255,"address":[9458841,9550713,9566102,9443529,9535478,9509881,9550790,9443606,9566025,9581337,9555817,9489542,9479334,9545686,9453737,9448633,9438425,9504777,9540582,9494646,9484438,9514985,9448710,9525193,9489465,9520166,9499750,9464022,9438502,9576310,9469049,9530297,9520089,9535401,9530374,9479257,9576233,9453814,9540505,9571129,9545609,9509958,9484361,9560921,9463945,9499673,9581414,9504854,9474230,9560998,9555894,9469126,9571206,9525270,9458918,9515062,9474153,9494569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1256,"address":[9566180,9453892,9530452,9484516,9545764,9469204,9555972,9494724,9458996,9571284,9520244,9438580,9515140,9504932,9479412,9540660,9561076,9474308,9581492,9535556,9499828,9443684,9525348,9576388,9489620,9510036,9464100,9448788,9550868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1257,"address":[9581608,9454008,9443971,9571571,9525635,9550984,9484632,9571400,9479528,9448904,9505048,9459283,9556088,9515427,9474424,9484803,9499944,9561192,9546051,9454179,9469491,9494840,9515256,9556259,9530739,9525464,9469320,9459112,9566467,9510152,9474595,9443800,9449075,9479699,9545880,9540776,9438696,9561363,9520360,9540947,9505219,9520531,9535672,9510323,9535843,9438867,9576504,9576675,9495011,9566296,9489907,9530568,9489736,9500115,9551155,9464387,9464216,9581779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1258,"address":[9520469,9551093,9474533,9479637,9489845,9561301,9443909,9535781,9500053,9571509,9581717,9484741,9510261,9566405,9515365,9556197,9449013,9525573,9576613,9505157,9459221,9545989,9494949,9530677,9464325,9454117,9540885,9469429,9438805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1262,"address":[9473612,9458300,9570588,9580796,9539964,9509340,9483820,9575692,9560380,9448092,9514444,9494028,9442988,9565484,9545068,9453196,9463404,9499132,9519548,9468508,9488924,9437884,9478716,9504236,9524652,9534860,9529756,9550172,9555276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1263,"address":[9483832,9539976,9580808,9565496,9499144,9488936,9575704,9478728,9545080,9448104,9494040,9550184,9443000,9458312,9560392,9509352,9437896,9570600,9463416,9524664,9555288,9468520,9473624,9534872,9453208,9514456,9504248,9529768,9519560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1264,"address":[9494051,9529779,9463427,9524675,9550195,9504259,9575715,9539987,9570611,9509363,9514467,9458323,9565507,9560403,9437907,9519571,9443011,9555299,9580819,9534883,9488947,9468531,9483843,9499155,9545091,9478739,9448115,9453219,9473635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1270,"address":[9590060,9585900,9591056,9591020,9584940,9587856,9584300,9585936,9585580,9591980,9586860,9591376,9589456,9587180,9584656,9583020,9589740,9589100,9583660,9583980,9586576,9587216,9585616,9585260,9590096,9589136,9583376,9584336,9589420,9584976,9587536,9583340,9588496,9591696,9586540,9586896,9584016,9588780,9591660,9585296,9583056,9588460,9591340,9590700,9588176,9586256,9590416,9590736,9582736,9587500,9587820,9584620,9586220,9583696,9588816,9588140,9590380,9589776],"length":1,"stats":{"Line":0},"fn_name":"create\u003c\u0026closure-0\u003e"},{"line":1277,"address":[9591489,9587969,9591169,9589569,9585089,9586689,9582849,9584129,9588289,9590529,9583169,9587649,9589889,9589249,9585409,9586369,9587009,9584449,9583809,9590209,9586049,9584769,9590849,9585729,9583489,9588929,9591809,9587329,9588609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1278,"address":[9583190,9583830,9584790,9587350,9589270,9584150,9590550,9587990,9584470,9586710,9586070,9589590,9586390,9590230,9591510,9591830,9590870,9585110,9588630,9588310,9585430,9582870,9583510,9591190,9585750,9588950,9587670,9587030,9589910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1281,"address":[9592324,9592016],"length":1,"stats":{"Line":0},"fn_name":"create_with_prehash\u003c\u0026closure-0\u003e"},{"line":1289,"address":[9592153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1290,"address":[9592174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1293,"address":[9607488,9595968,9598128,9603542,9609302,9603888,9610022,9597782,9612902,9608208,9612528,9600662,9599222,9606422,9606768,9592368,9594902,9600288,9597062,9594528,9599942,9596342,9610368,9605328,9611808,9604608,9602102,9593462,9601728,9599568,9602822,9607862,9598502,9608582,9605702,9593088,9595248,9598848,9607142,9596688,9602448,9608928,9597408,9609648,9594182,9601382,9603168,9604262,9593808,9606048,9601008,9611462,9595622,9604982,9610742,9592742,9611088,9612182],"length":1,"stats":{"Line":0},"fn_name":"create_with_matches\u003c\u0026closure-0\u003e"},{"line":1301,"address":[9596849,9595409,9594689,9609809,9612689,9600449,9601169,9610529,9611969,9605489,9593249,9604769,9592529,9606209,9601889,9611249,9604049,9599729,9593969,9608369,9607649,9602609,9603329,9596129,9598289,9609089,9599009,9606929,9597569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1302,"address":[9612767,9602687,9607007,9604127,9606287,9601247,9601967,9593327,9595487,9604847,9603407,9612047,9592607,9594047,9594767,9600527,9605567,9599807,9596927,9607727,9609887,9596207,9609167,9599087,9597647,9610607,9611327,9598367,9608447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1303,"address":[9603470,9595550,9612110,9602750,9592670,9604190,9601310,9611390,9597710,9606350,9599150,9605630,9599870,9610670,9602030,9604910,9607790,9598430,9608510,9594830,9596270,9609230,9593390,9607070,9594110,9600590,9612830,9596990,9609950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1304,"address":[9596285,9610685,9612845,9612125,9602765,9600605,9601325,9607805,9611405,9592685,9609965,9599165,9599885,9608525,9609245,9606365,9602045,9597725,9598445,9593405,9607085,9595565,9594845,9597005,9604925,9603485,9605645,9604205,9594125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1307,"address":[9594235,9604302,9598555,9612955,9607902,9596382,9610062,9607182,9597835,9592795,9612942,9609342,9605755,9600715,9598542,9594222,9607915,9600702,9595662,9607195,9610075,9601422,9609355,9603595,9595675,9606475,9605742,9610795,9593502,9604315,9602862,9599982,9605022,9602875,9602155,9594942,9602142,9606462,9603582,9596395,9597115,9601435,9599995,9610782,9611502,9597102,9599262,9593515,9608635,9605035,9599275,9611515,9592782,9612235,9597822,9608622,9612222,9594955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1308,"address":[9594738,9601445,9606978,9604325,9595458,9607205,9594965,9599778,9609138,9598565,9612018,9595685,9592578,9612738,9611298,9607698,9597845,9605538,9605045,9596178,9597125,9599285,9610805,9602658,9594018,9603378,9607925,9601218,9600725,9596405,9603605,9605765,9609365,9606258,9599058,9604098,9593525,9602885,9600005,9592805,9609858,9602165,9596898,9594245,9601938,9612965,9604818,9610085,9593298,9610578,9608418,9608645,9606485,9597618,9600498,9598338,9611525,9612245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1309,"address":[9602864,9602144,9601424,9606464,9610064,9612944,9596384,9592784,9603584,9593504,9609344,9605024,9599984,9608624,9597104,9599264,9607904,9600704,9612224,9594224,9598544,9607184,9597824,9610784,9605744,9611504,9604304,9595664,9594944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1313,"address":[9596435,9605075,9594275,9610835,9605795,9611555,9595715,9608675,9597875,9607235,9612275,9598595,9602195,9607955,9604355,9602915,9603635,9600755,9592835,9606515,9610115,9601475,9600035,9609395,9597155,9593555,9599315,9612995,9594995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1315,"address":[9600051,9611571,9593571,9609411,9606531,9592851,9612291,9608691,9607971,9610131,9597171,9595011,9602931,9596451,9595731,9599331,9613011,9603651,9607251,9602211,9601491,9600771,9605811,9604371,9610851,9598611,9594291,9605091,9597891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1316,"address":[9600779,9598619,9596459,9599339,9593579,9612299,9602219,9602939,9603659,9594299,9606539,9601499,9592859,9600059,9605099,9607259,9613019,9607979,9595019,9605819,9608699,9597899,9610139,9610859,9611579,9597179,9595739,9609419,9604379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1317,"address":[9601503,9603663,9610143,9599343,9592863,9607263,9595743,9610863,9608703,9609423,9595023,9605823,9602223,9597183,9606543,9611583,9605103,9598622,9613023,9597903,9600783,9602943,9600063,9607983,9596463,9594303,9593583,9604383,9612303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1319,"address":[9612322,9593602,9594322,9602962,9595042,9604402,9600802,9607282,9602242,9596482,9600082,9609442,9610882,9606562,9608722,9603682,9599362,9613042,9611602,9610162,9597922,9598641,9608002,9605122,9605842,9592882,9601522,9597202,9595762],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1322,"address":[9652119,9615408,9671559,9675864,9636984,9632664,9628359,9634848,9647799,9637008,9641319,9649968,9658584,9626208,9626199,9660759,9624024,9632688,9645639,9624039,9617568,9641328,9669384,9665079,9626184,9652128,9645648,9630528,9673719,9649959,9662904,9619719,9656439,9654288,9647808,9675879,9658599,9617559,9636999,9632679,9630504,9639144,9619704,9641304,9667248,9652104,9624048,9621888,9649944,9615399,9660744,9643464,9645624,9615384,9662928,9669399,9634824,9643479,9619728,9667239,9665064,9656424,9658608,9654264,9643488,9673704,9628368,9656448,9671568,9621864,9639168,9617544,9621879,9665088,9660768,9667224,9630519,9662919,9639159,9634839,9671544,9613248,9628344,9673728,9654279,9669408,9647784],"length":1,"stats":{"Line":0},"fn_name":"create_from_match_path\u003c\u0026closure-0\u003e"},{"line":1331,"address":[9650228,9671828,9624308,9637268,9643748,9635108,9654548,9667508,9632948,9658868,9665348,9652388,9628628,9648068,9673988,9615668,9639428,9641588,9619988,9645908,9617828,9630788,9626468,9669668,9622148,9613508,9656708,9661028,9663188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1333,"address":[9617917,9663277,9635197,9637357,9656797,9665437,9667597,9674077,9671917,9643837,9641677,9630877,9639517,9613597,9620077,9650317,9615757,9628717,9654637,9645997,9648157,9633037,9669757,9626557,9622237,9658957,9661117,9652477,9624397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1334,"address":[9641776,9633136,9622336,9639616,9674176,9620176,9624496,9650416,9652576,9667696,9615856,9665536,9648256,9661216,9643936,9613696,9663376,9637456,9628816,9672016,9618016,9654736,9659056,9630976,9635296,9669856,9656896,9646096,9626656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1335,"address":[9656911,9650431,9654751,9624511,9615871,9622351,9663391,9639631,9672031,9637471,9628831,9613711,9674191,9667711,9652591,9643951,9641791,9661231,9620191,9630991,9618031,9659071,9648271,9633151,9635311,9646111,9665551,9669871,9626671],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1338,"address":[9628794,9659122,9635362,9654851,9669971,9667674,9635411,9622314,9659171,9650394,9650531,9639594,9644002,9665514,9652642,9663442,9646162,9672131,9624562,9620242,9663354,9633114,9631091,9661282,9654714,9646074,9652691,9630954,9661331,9626771,9674242,9648371,9654802,9641891,9667762,9633202,9656962,9628882,9648234,9648322,9652554,9659034,9656874,9615971,9644051,9663491,9618131,9628931,9617994,9671994,9622402,9635274,9669834,9613811,9631042,9624611,9639731,9615922,9626722,9661194,9624474,9672082,9641754,9643914,9615834,9669922,9618082,9622451,9613674,9626634,9637571,9646211,9667811,9650482,9637522,9657011,9620154,9633251,9665602,9674291,9665651,9674154,9613762,9637434,9639682,9641842,9620291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1339,"address":[9626958,9631061,9665681,9644021,9615941,9639701,9669941,9613781,9674478,9648558,9624641,9635441,9657041,9652661,9661301,9672101,9663461,9659358,9637541,9648341,9613998,9622421,9631278,9616001,9663678,9628901,9635598,9674261,9626741,9618161,9672161,9620478,9620321,9650718,9622481,9659141,9674321,9616158,9628961,9652721,9633438,9633281,9618318,9641861,9661518,9648401,9661361,9650561,9641921,9646181,9626801,9652878,9672318,9642078,9633221,9654821,9620261,9631121,9637601,9667781,9639918,9644081,9635381,9663521,9654881,9656981,9624798,9618101,9639761,9659201,9667998,9657198,9670001,9622638,9665621,9646241,9650501,9655038,9644238,9670158,9624581,9646398,9613841,9637758,9665838,9629118,9667841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1342,"address":[9657251,9670130,9642131,9631250,9616211,9652931,9659411,9650771,9633410,9672290,9618371,9626930,9639971,9613970,9646370,9661490,9644210,9665810,9624851,9672371,9648611,9655010,9652850,9631331,9614051,9674450,9629171,9637811,9650690,9620531,9670211,9635570,9622691,9667970,9622610,9668051,9661571,9657170,9618290,9620450,9644291,9624770,9642050,9674531,9633491,9637730,9655091,9663650,9663731,9659330,9646451,9627011,9639890,9665891,9635651,9629090,9616130,9648530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1343,"address":[9620730,9627210,9638010,9650970,9663930,9655290,9672570,9618570,9666090,9646650,9670410,9674730,9633690,9631530,9653130,9644490,9616410,9657450,9661770,9635850,9642330,9629370,9659610,9614250,9640170,9622890,9648810,9625050,9668250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1345,"address":[9638021,9631541,9675457,9666101,9640181,9672738,9668418,9664098,9620898,9644501,9629381,9647377,9640338,9618738,9661781,9619297,9664657,9625061,9622901,9668261,9663941,9659778,9666817,9666258,9627378,9638737,9650981,9655458,9670421,9673297,9674898,9625218,9629538,9618581,9631698,9643057,9621457,9627221,9671137,9651697,9656017,9627937,9633701,9648821,9638178,9636018,9635861,9623058,9614418,9648978,9617137,9658177,9634417,9651138,9646818,9616421,9614977,9632257,9623617,9630097,9616578,9636577,9649537,9640897,9655301,9662497,9642341,9633858,9625777,9660337,9614261,9646661,9644658,9645217,9674741,9659621,9653141,9672581,9668977,9653857,9653298,9657461,9670578,9661938,9657618,9642498,9620741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1346,"address":[9640505,9631865,9638218,9625385,9633898,9623225,9657658,9659818,9651178,9672905,9636185,9659945,9631738,9618905,9621065,9664138,9638345,9629578,9618778,9646858,9672778,9614458,9655498,9675065,9668458,9644825,9636058,9666298,9661978,9627545,9616618,9653338,9623098,9627418,9668585,9614585,9642665,9620938,9644698,9664265,9670618,9649145,9674938,9634025,9649018,9629705,9653465,9666425,9625258,9616745,9662105,9657785,9646985,9642538,9651305,9640378,9655625,9670745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1347,"address":[9652099,9642690,9614504,9627866,9636210,9645146,9658579,9668906,9641299,9660739,9653786,9675859,9640530,9670770,9630499,9674984,9631784,9616770,9643459,9649170,9670664,9617066,9640826,9671539,9675386,9616664,9659970,9636979,9666344,9628339,9619699,9634050,9644744,9631890,9621386,9614610,9646904,9655544,9625410,9627570,9672824,9644850,9659864,9672930,9627464,9636104,9668504,9668610,9654259,9671066,9618824,9647779,9651224,9667219,9645619,9655946,9618930,9662024,9649939,9642584,9662426,9624019,9625304,9673699,9615379,9653384,9623546,9651330,9621090,9634819,9636506,9629624,9666450,9647010,9639139,9669379,9653490,9630026,9620984,9657704,9638264,9656419,9625706,9651626,9655650,9675090,9664586,9642986,9647306,9664184,9664290,9638370,9617539,9632659,9634346,9673226,9658106,9619226,9649466,9626179,9633944,9649064,9623250,9666746,9660266,9623144,9665059,9640424,9632186,9629730,9662130,9638666,9662899,9657810,9614906,9621859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1348,"address":[9659998,9651358,9629758,9670798,9666478,9655678,9614638,9672958,9636238,9638398,9668638,9662158,9627598,9625438,9634078,9657838,9616798,9640558,9644878,9618958,9642718,9621118,9675118,9647038,9623278,9631918,9649198,9653518,9664318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1349,"address":[9666581,9619061,9642821,9638501,9647141,9644981,9632021,9634181,9673061,9629861,9655781,9664421,9662261,9668741,9660101,9651461,9653621,9657941,9640661,9675221,9623381,9627701,9625541,9621221,9614741,9670901,9649301,9616901,9636341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1351,"address":[9673364,9632324,9621470,9638804,9643124,9614990,9636644,9672936,9675524,9647016,9671150,9656030,9664724,9657816,9640536,9615044,9618936,9621524,9655656,9617150,9644856,9632270,9675096,9625844,9651710,9666884,9658244,9645284,9658190,9629736,9668616,9651336,9662564,9621096,9671204,9656084,9623684,9619364,9636216,9614616,9675470,9634056,9636590,9630110,9653924,9662510,9653870,9659976,9625416,9647444,9630164,9616776,9649604,9642696,9666830,9649550,9643070,9619310,9640910,9627950,9653496,9638750,9664296,9623256,9660350,9673310,9649176,9662136,9651764,9634484,9668990,9623630,9628004,9634430,9627576,9631896,9669044,9645230,9647390,9640964,9638376,9660404,9664670,9625790,9617204,9666456,9670776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1352,"address":[9619346,9653983,9658303,9632383,9669103,9621583,9664783,9643183,9651823,9634543,9638863,9636703,9630146,9660463,9673346,9625903,9638786,9651746,9660386,9623666,9630223,9671186,9619423,9640946,9669026,9647503,9623743,9627986,9643106,9632306,9675506,9645266,9658226,9628063,9656143,9617186,9621506,9649586,9666943,9641023,9615026,9662546,9664706,9636626,9649663,9673423,9617263,9675583,9625826,9671263,9615103,9653906,9666866,9662623,9656066,9634466,9645343,9647426],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1354,"address":[9658262,9662582,9669062,9638822,9625862,9647462,9645302,9671222,9636662,9630182,9660422,9623702,9628022,9664742,9673382,9651782,9656102,9617222,9621542,9619382,9666902,9643142,9649622,9632342,9634502,9615062,9675542,9653942,9640982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1356,"address":[9655948,9660268,9671068,9666748,9664588,9638668,9623548,9653788,9668908,9649468,9632188,9647308,9634348,9642988,9673228,9614908,9621388,9619228,9675388,9630028,9625708,9651628,9645148,9636508,9640828,9617068,9658108,9662428,9627868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1358,"address":[9672707,9674867,9651107,9635987,9661907,9616547,9640307,9633827,9670547,9646787,9629507,9631667,9668387,9648947,9666227,9642467,9620867,9653267,9644627,9655427,9623027,9659747,9618707,9657587,9625187,9627347,9664067,9638147,9614387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1361,"address":[4687136],"length":1,"stats":{"Line":0},"fn_name":"full_matrix"},{"line":1362,"address":[4687150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1363,"address":[4687164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1366,"address":[4687216],"length":1,"stats":{"Line":0},"fn_name":"num_cells"},{"line":1367,"address":[4687236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1368,"address":[4687391,4687585,4687245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1369,"address":[4687620,4687428,4687558,4687590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1375,"address":[4689226,4687632],"length":1,"stats":{"Line":0},"fn_name":"visualize"},{"line":1376,"address":[4687647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1377,"address":[4687751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1378,"address":[4688113,4687759,4687922,4688384],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1379,"address":[4688153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1380,"address":[4688397,4688206,4688530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1381,"address":[4688429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1385,"address":[4688665,4688030,4689221,4688551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1386,"address":[4688702,4689197,4688930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1387,"address":[4688962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1389,"address":[4689202,4688883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1394,"address":[4689264],"length":1,"stats":{"Line":0},"fn_name":"stat"},{"line":1395,"address":[4689284,4689330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1396,"address":[4689318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1397,"address":[4689360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1398,"address":[4689447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1414,"address":[4281755,4281056],"length":1,"stats":{"Line":0},"fn_name":"compare_to_full_alignment_local"},{"line":1415,"address":[5717968,5717990],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1417,"address":[4281115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1419,"address":[4281233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1422,"address":[4281407,4281316,4281250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1423,"address":[4281450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1425,"address":[4281663,4281465,4281588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1428,"address":[4282511,4281792],"length":1,"stats":{"Line":0},"fn_name":"compare_to_full_alignment_global"},{"line":1429,"address":[5718032,5718054],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1431,"address":[4281851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1433,"address":[4281969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1434,"address":[4281989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1436,"address":[4282110,4282043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1437,"address":[4282206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1439,"address":[4282419,4282221,4282344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1442,"address":[4282544,4283645],"length":1,"stats":{"Line":0},"fn_name":"compare_to_full_alignment_semiglobal"},{"line":1443,"address":[5718096,5718118],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1445,"address":[4282603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1447,"address":[4282736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1448,"address":[4282759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1450,"address":[4282883,4282816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1451,"address":[4282982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1454,"address":[4283120,4282997,4283206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1456,"address":[4283189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1457,"address":[4283272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1458,"address":[4283440,4283515,4283317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1462,"address":[4284560,4286468],"length":1,"stats":{"Line":0},"fn_name":"test_band_add_entry"},{"line":1463,"address":[4284567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1464,"address":[4284588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1465,"address":[4284644,4284786,4284864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1481,"address":[4284792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1482,"address":[4285090,4284910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1498,"address":[4285018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1499,"address":[4285137,4285266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1516,"address":[4285246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1517,"address":[4285313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1518,"address":[4285538,4285369,4285499],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1535,"address":[4285518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1536,"address":[4285585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1537,"address":[4285771,4285810,4285641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1554,"address":[4285790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1555,"address":[4285857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1556,"address":[4286082,4285913,4286043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1573,"address":[4286062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1574,"address":[4286129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1575,"address":[4286185,4286315,4286346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1591,"address":[4286329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1594,"address":[4284537,4283680],"length":1,"stats":{"Line":0},"fn_name":"compare_add_kmer_and_add_entry"},{"line":1595,"address":[4283810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1596,"address":[4283852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1598,"address":[4283883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1599,"address":[4284240,4283935,4284066,4284435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1600,"address":[4284277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1602,"address":[4284444,4284475,4284146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1606,"address":[4286496],"length":1,"stats":{"Line":0},"fn_name":"test_band_add_kmer"},{"line":1607,"address":[4286500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1608,"address":[4286546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1609,"address":[4286594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1613,"address":[4286656],"length":1,"stats":{"Line":0},"fn_name":"test_same"},{"line":1614,"address":[4286660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1617,"address":[4286672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1618,"address":[4286694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1619,"address":[4286719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1620,"address":[4286744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1624,"address":[4286784],"length":1,"stats":{"Line":0},"fn_name":"test_big"},{"line":1625,"address":[4286788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1631,"address":[4286800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1640,"address":[4286812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1646,"address":[4286848],"length":1,"stats":{"Line":0},"fn_name":"test_deletion"},{"line":1647,"address":[4286852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1648,"address":[4286864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1649,"address":[4286876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1650,"address":[4286905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1651,"address":[4286934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1655,"address":[4286976],"length":1,"stats":{"Line":0},"fn_name":"test_insertion"},{"line":1656,"address":[4286980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1657,"address":[4286992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1658,"address":[4287004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1659,"address":[4287033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1660,"address":[4287062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1664,"address":[4287104],"length":1,"stats":{"Line":0},"fn_name":"test_substitutions"},{"line":1665,"address":[4287108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1666,"address":[4287120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1667,"address":[4287132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1668,"address":[4287159],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1669,"address":[4287186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1673,"address":[4287232],"length":1,"stats":{"Line":0},"fn_name":"test_overhangs1"},{"line":1674,"address":[4287236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1675,"address":[4287248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1676,"address":[4287260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1677,"address":[4287289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1678,"address":[4287318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1682,"address":[4287360],"length":1,"stats":{"Line":0},"fn_name":"test_overhangs2"},{"line":1683,"address":[4287364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1684,"address":[4287376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1685,"address":[4287388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1686,"address":[4287417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1687,"address":[4287446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1691,"address":[4287488],"length":1,"stats":{"Line":0},"fn_name":"test_overhangs3"},{"line":1692,"address":[4287492],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1693,"address":[4287504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1694,"address":[4287516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1695,"address":[4287545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1696,"address":[4287574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1700,"address":[4287616],"length":1,"stats":{"Line":0},"fn_name":"test_overhangs4"},{"line":1701,"address":[4287620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1702,"address":[4287632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1703,"address":[4287644],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1704,"address":[4287673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1705,"address":[4287702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1709,"address":[4287744],"length":1,"stats":{"Line":0},"fn_name":"test_overhangs5"},{"line":1710,"address":[4287748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1711,"address":[4287760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1713,"address":[4287772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1714,"address":[4287801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1715,"address":[4287830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1719,"address":[4287872],"length":1,"stats":{"Line":0},"fn_name":"test_band_starts_inside"},{"line":1720,"address":[4287876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1721,"address":[4287888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1722,"address":[4287900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1723,"address":[4287927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1724,"address":[4287954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1728,"address":[4288000],"length":1,"stats":{"Line":0},"fn_name":"test_band_ends_inside"},{"line":1729,"address":[4288004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1730,"address":[4288016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1731,"address":[4288028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1732,"address":[4288055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1733,"address":[4288082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1737,"address":[4288128],"length":1,"stats":{"Line":0},"fn_name":"test_band_is_fully_inside"},{"line":1738,"address":[4288132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1740,"address":[4288144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1742,"address":[4288156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1743,"address":[4288183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1744,"address":[4288210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1759,"address":[4288256,4289010],"length":1,"stats":{"Line":0},"fn_name":"test_semiglobal"},{"line":1760,"address":[4288263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1761,"address":[4288278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1762,"address":[5720422,5720400],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1763,"address":[4288293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1764,"address":[4288392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1765,"address":[4288437,4288672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1766,"address":[4288566,4288860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1767,"address":[4288916,4288951,4288764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1775,"address":[4289792,4289040],"length":1,"stats":{"Line":0},"fn_name":"test_semiglobal_gap_open_lt_mismatch"},{"line":1776,"address":[4289047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1777,"address":[4289062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1778,"address":[5720496,5720518],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1779,"address":[4289077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1780,"address":[4289174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1781,"address":[4289454,4289219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1782,"address":[4289642,4289348],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1783,"address":[4289698,4289546,4289733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1790,"address":[4289824,4290525],"length":1,"stats":{"Line":0},"fn_name":"test_global_affine_ins"},{"line":1791,"address":[4289831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1792,"address":[4289846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1793,"address":[5720614,5720592],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1794,"address":[4289861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1795,"address":[4289960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1797,"address":[4290209,4290103,4290005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1798,"address":[4290342,4290467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1805,"address":[4291484,4290560],"length":1,"stats":{"Line":0},"fn_name":"test_local_empty"},{"line":1806,"address":[4290567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1807,"address":[4290582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1808,"address":[5720710,5720688],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1809,"address":[4290597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1810,"address":[4290696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1812,"address":[4290839,4290741,4290945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1813,"address":[4291078,4291241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1814,"address":[4291420,4291204,4291297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1818,"address":[4292629,4291520],"length":1,"stats":{"Line":0},"fn_name":"test_global_affine_ins2"},{"line":1819,"address":[4291527],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1820,"address":[4291542],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1821,"address":[5720806,5720784],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1822,"address":[4291557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1823,"address":[4291659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1825,"address":[4291808,4291707,4291914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1827,"address":[4292047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1828,"address":[4292204,4292066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1829,"address":[4292211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1830,"address":[4292315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1832,"address":[4292549,4292419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1836,"address":[4292656,4293246],"length":1,"stats":{"Line":0},"fn_name":"test_local_affine_ins2"},{"line":1837,"address":[4292663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1838,"address":[4292678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1839,"address":[5720902,5720880],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1840,"address":[4292693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1841,"address":[4292792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1842,"address":[4292837,4293064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1843,"address":[4292966,4293185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1847,"address":[4294034,4293280],"length":1,"stats":{"Line":0},"fn_name":"test_local"},{"line":1848,"address":[4293287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1849,"address":[4293302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1850,"address":[5720998,5720976],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1851,"address":[4293317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1852,"address":[4293416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1853,"address":[4293696,4293461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1854,"address":[4293884,4293590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1855,"address":[4293788,4293940,4293975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1862,"address":[4295071,4294064],"length":1,"stats":{"Line":0},"fn_name":"test_global"},{"line":1863,"address":[4294071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1864,"address":[4294086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1865,"address":[5721094,5721072],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1866,"address":[4294101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1867,"address":[4294200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1869,"address":[4294245,4294449,4294343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1870,"address":[4294774,4294582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1871,"address":[4294668,4294921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1872,"address":[4294825,4294977,4295012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1879,"address":[4296026,4295104],"length":1,"stats":{"Line":0},"fn_name":"test_blosum62"},{"line":1880,"address":[4295111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1881,"address":[4295126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1882,"address":[4295141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1883,"address":[4295156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1884,"address":[4295257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1885,"address":[4295296,4295531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1886,"address":[4295728,4295425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1887,"address":[4295623,4295876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1888,"address":[4295932,4295780,4295967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1892,"address":[4296818,4296064],"length":1,"stats":{"Line":0},"fn_name":"test_issue11"},{"line":1893,"address":[4296071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1894,"address":[4296086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1895,"address":[5721200,5721222],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1896,"address":[4296101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1897,"address":[4296200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1898,"address":[4296245,4296480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1899,"address":[4296374,4296668],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1900,"address":[4296724,4296759,4296572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1907,"address":[4297602,4296848],"length":1,"stats":{"Line":0},"fn_name":"test_issue12_1"},{"line":1908,"address":[4296855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1909,"address":[4296870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1910,"address":[5721318,5721296],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1911,"address":[4296885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1912,"address":[4296984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1913,"address":[4297029,4297264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1914,"address":[4297162,4297452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1915,"address":[4297356,4297543,4297508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1922,"address":[4298386,4297632],"length":1,"stats":{"Line":0},"fn_name":"test_issue12_2"},{"line":1923,"address":[4297639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1924,"address":[4297654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1925,"address":[5721414,5721392],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1926,"address":[4297669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1927,"address":[4297768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1928,"address":[4297813,4298048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1929,"address":[4297946,4298236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1931,"address":[4298140,4298292,4298327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1938,"address":[4299629,4298416],"length":1,"stats":{"Line":0},"fn_name":"test_issue12_3"},{"line":1939,"address":[4298423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1940,"address":[4298438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1941,"address":[5721488,5721510],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1942,"address":[4298453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1943,"address":[4298558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1945,"address":[4298838,4298606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1946,"address":[4298934,4298981,4298742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1954,"address":[4298940,4299028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1955,"address":[4299121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1957,"address":[4299169,4299401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1958,"address":[4299498,4299533,4299305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1965,"address":[4300671,4299664],"length":1,"stats":{"Line":0},"fn_name":"test_left_aligned_del"},{"line":1966,"address":[4299671],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1967,"address":[4299686],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1968,"address":[5721606,5721584],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1969,"address":[4299701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1970,"address":[4299800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1971,"address":[4300049,4299845,4299943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1973,"address":[4300182,4300374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1974,"address":[4300268,4300521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1975,"address":[4300612,4300577,4300425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1987,"address":[4302047,4300704],"length":1,"stats":{"Line":0},"fn_name":"test_global_right_del"},{"line":1988,"address":[4300711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1989,"address":[4300726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1991,"address":[5721702,5721680],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1992,"address":[4300741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1993,"address":[4300858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1995,"address":[4301007,4301113,4300906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1997,"address":[4301246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1998,"address":[4301398,4301589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1999,"address":[4301487,4301746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2000,"address":[4301894,4301640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2001,"address":[4301798,4301950,4301985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2011,"address":[4302080,4303087],"length":1,"stats":{"Line":0},"fn_name":"test_left_aligned_ins"},{"line":2012,"address":[4302087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2013,"address":[4302102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2014,"address":[5721798,5721776],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":2015,"address":[4302117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2016,"address":[4302216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2017,"address":[4302359,4302465,4302261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2019,"address":[4302790,4302598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2020,"address":[4302937,4302684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2021,"address":[4303028,4302841,4302993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2031,"address":[4304994,4303120],"length":1,"stats":{"Line":0},"fn_name":"test_aligner_new"},{"line":2032,"address":[4303127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2033,"address":[4303142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2034,"address":[5721894,5721872],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":2035,"address":[4303157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2037,"address":[4303197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2038,"address":[4303501,4303245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2039,"address":[4303383,4303701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2040,"address":[4303593,4303760,4303827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2045,"address":[4303766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2046,"address":[4303874,4304066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2047,"address":[4304255,4303960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2048,"address":[4304375,4304159,4304311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2053,"address":[4304317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2054,"address":[4304614,4304422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2055,"address":[4304803,4304508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2056,"address":[4304894,4304859,4304707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2063,"address":[4305024,4305400],"length":1,"stats":{"Line":0},"fn_name":"test_semiglobal_simple"},{"line":2064,"address":[4305031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2065,"address":[4305046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2067,"address":[5721990,5721968],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":2068,"address":[4305061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2069,"address":[4305095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2071,"address":[4305140,4305342,4305267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2078,"address":[4305424,4305798],"length":1,"stats":{"Line":0},"fn_name":"test_insert_only_semiglobal"},{"line":2079,"address":[4305431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2080,"address":[4305446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2082,"address":[5722086,5722064],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":2083,"address":[4305461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2084,"address":[4305495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2086,"address":[4305538,4305665,4305740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2090,"address":[4306200,4305824],"length":1,"stats":{"Line":0},"fn_name":"test_insert_in_between_semiglobal"},{"line":2091,"address":[4305831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2092,"address":[4305846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2094,"address":[5722182,5722160],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":2095,"address":[4305861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2096,"address":[4305895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2098,"address":[4305940,4306067,4306142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2105,"address":[4306672,4306224],"length":1,"stats":{"Line":0},"fn_name":"test_xclip_prefix_custom"},{"line":2106,"address":[4306231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2107,"address":[4306246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2109,"address":[5722278,5722256],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":2110,"address":[4306261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2112,"address":[4306306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2113,"address":[4306358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2115,"address":[4306406,4306611,4306536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2119,"address":[4307152,4306704],"length":1,"stats":{"Line":0},"fn_name":"test_yclip_prefix_custom"},{"line":2120,"address":[4306711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2121,"address":[4306726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2123,"address":[5722352,5722374],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":2124,"address":[4306741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2126,"address":[4306786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2127,"address":[4306838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2129,"address":[4307091,4306886,4307016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2133,"address":[4307184,4307655],"length":1,"stats":{"Line":0},"fn_name":"test_xclip_suffix_custom"},{"line":2134,"address":[4307191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2135,"address":[4307206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2137,"address":[5722470,5722448],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":2138,"address":[4307221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2140,"address":[4307289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2141,"address":[4307341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2143,"address":[4307519,4307594,4307389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2147,"address":[4308151,4307680],"length":1,"stats":{"Line":0},"fn_name":"test_yclip_suffix_custom"},{"line":2148,"address":[4307687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2149,"address":[4307702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2151,"address":[5722566,5722544],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":2152,"address":[4307717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2154,"address":[4307785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2155,"address":[4307837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2157,"address":[4307885,4308015,4308090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2161,"address":[4308905,4308176],"length":1,"stats":{"Line":0},"fn_name":"test_longer_string_all_operations"},{"line":2162,"address":[4308183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2163,"address":[4308198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2165,"address":[5722640,5722662],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":2166,"address":[4308213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2168,"address":[4308281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2169,"address":[4308333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2171,"address":[4308588,4308381,4308482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2172,"address":[4308721,4308839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2176,"address":[4309427,4308928],"length":1,"stats":{"Line":0},"fn_name":"test_yclip_suffix_only"},{"line":2177,"address":[4308935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2178,"address":[4308950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2179,"address":[4308965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2186,"address":[4309073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2187,"address":[4309124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2188,"address":[4309169,4309323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2192,"address":[4309456,4309966],"length":1,"stats":{"Line":0},"fn_name":"test_yclip_prefix_only"},{"line":2193,"address":[4309463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2194,"address":[4309478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2195,"address":[4309493],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2202,"address":[4309601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2203,"address":[4309652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2204,"address":[4309697,4309862],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2208,"address":[4310000,4310521],"length":1,"stats":{"Line":0},"fn_name":"test_traceback_outside_band"},{"line":2209,"address":[4310007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2210,"address":[4310022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2211,"address":[4310037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2218,"address":[4310147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2219,"address":[4310159],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2220,"address":[4310171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2221,"address":[4310220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2222,"address":[4310263,4310417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2226,"address":[4310544,4311247],"length":1,"stats":{"Line":0},"fn_name":"test_deletions_ouside_band"},{"line":2227,"address":[4310551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2228,"address":[4310566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2229,"address":[4310581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2237,"address":[4310700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2238,"address":[4310712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2239,"address":[4310724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2240,"address":[4310778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2241,"address":[4310826,4311057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2242,"address":[4311153,4310961,4311188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2269,"address":[4311983,4311280],"length":1,"stats":{"Line":0},"fn_name":"test_insertion_ouside_band"},{"line":2270,"address":[4311287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2271,"address":[4311302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2273,"address":[4311317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2282,"address":[4311436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2283,"address":[4311448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2284,"address":[4311460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2285,"address":[4311514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2286,"address":[4311562,4311793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2287,"address":[4311889,4311924,4311697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2318,"address":[4312016,4312544],"length":1,"stats":{"Line":0},"fn_name":"test_insertion_after_clip"},{"line":2319,"address":[4312023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2320,"address":[4312038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2322,"address":[4312053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2330,"address":[4312163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2331,"address":[4312175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2332,"address":[4312187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2333,"address":[4312238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2334,"address":[4312440,4312283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2338,"address":[4313103,4312576],"length":1,"stats":{"Line":0},"fn_name":"test_only_clips"},{"line":2339,"address":[4312583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2340,"address":[4312598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2341,"address":[4312613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2349,"address":[4312724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2350,"address":[4312736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2351,"address":[4312748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2352,"address":[4312797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2353,"address":[4312999,4312842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2357,"address":[4313136,4313737],"length":1,"stats":{"Line":0},"fn_name":"test_zero_score_clips"},{"line":2358,"address":[4313143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2359,"address":[4313158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2360,"address":[4313173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2361,"address":[4313185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2363,"address":[4313197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2370,"address":[4313372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2371,"address":[4313424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2372,"address":[4313630,4313470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2381,"address":[4313906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2382,"address":[4313961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2383,"address":[4314167,4314007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2392,"address":[4314427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2393,"address":[4314482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2394,"address":[4314528,4314688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2403,"address":[4314906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2404,"address":[4314961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2405,"address":[4315167,4315007],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":1096},{"path":["/","home","todd","rust-bio","src","alignment","pairwise","mod.rs"],"content":"// Copyright 2014-2015 Johannes Köster, Vadim Nazarov, Patrick Marks\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Calculate alignments with a generalized variant of the Smith Waterman algorithm.\n//! Complexity: O(n * m) for strings of length m and n.\n//!\n//! For quick computation of alignments and alignment scores there are 6 simple functions.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::alignment::pairwise::*;\n//! use bio::alignment::AlignmentOperation::*;\n//! use bio::scores::blosum62;\n//!\n//! let x = b\"ACCGTGGAT\";\n//! let y = b\"AAAAACCGTTGAT\";\n//! let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n//! // gap open score: -5, gap extension score: -1\n//! let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n//! let alignment = aligner.semiglobal(x, y);\n//! // x is global (target sequence) and y is local (reference sequence)\n//! assert_eq!(alignment.ystart, 4);\n//! assert_eq!(alignment.xstart, 0);\n//! assert_eq!(\n//!     alignment.operations,\n//!     [Match, Match, Match, Match, Match, Subst, Match, Match, Match]\n//! );\n//!\n//! // You can use predefined scoring matrices such as BLOSUM62\n//! let x = b\"LSPADKTNVKAA\";\n//! let y = b\"PEEKSAV\";\n//! // gap open score: -10, gap extension score: -1\n//! let mut aligner = Aligner::with_capacity(x.len(), y.len(), -10, -1, \u0026blosum62);\n//! let alignment = aligner.local(x, y);\n//! assert_eq!(alignment.xstart, 2);\n//! assert_eq!(alignment.xend, 9);\n//! assert_eq!(alignment.ystart, 0);\n//! assert_eq!(alignment.yend, 7);\n//! assert_eq!(\n//!     alignment.operations,\n//!     [Match, Subst, Subst, Match, Subst, Subst, Match]\n//! );\n//! assert_eq!(alignment.score, 16);\n//!\n//! // If you don't know sizes of future sequences, you could\n//! // use Aligner::new().\n//! // Global alignment:\n//! let mut aligner = Aligner::new(-5, -1, \u0026score);\n//! let x = b\"ACCGTGGAT\";\n//! let y = b\"AAAAACCGTTGAT\";\n//! let alignment = aligner.global(x, y);\n//! assert_eq!(alignment.ystart, 0);\n//! assert_eq!(alignment.xstart, 0);\n//! assert_eq!(aligner.local(x, y).score, 7);\n//!\n//! // In addition to the standard modes (Global, Semiglobal and Local), a custom alignment\n//! // mode is supported which supports a user-specified clipping penalty. Clipping is a\n//! // special boundary condition where you are allowed to clip off the beginning/end of\n//! // the sequence for a fixed penalty. As a starting example, we can use the custom mode\n//! // for achieving the three standard modes as follows.\n//!\n//! // scoring for semiglobal mode\n//! let scoring = Scoring::new(-5, -1, \u0026score) // Gap open, gap extend and match score function\n//!     .xclip(MIN_SCORE) // Clipping penalty for x set to 'negative infinity', hence global in x\n//!     .yclip(0); // Clipping penalty for y set to 0, hence local in y\n//! let mut aligner = Aligner::with_scoring(scoring);\n//! let alignment = aligner.custom(x, y); // The custom aligner invocation\n//! assert_eq!(alignment.ystart, 4);\n//! assert_eq!(alignment.xstart, 0);\n//! // Note that in the custom mode, the clips are explicitly mentioned in the operations\n//! assert_eq!(\n//!     alignment.operations,\n//!     [\n//!         Yclip(4),\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Subst,\n//!         Match,\n//!         Match,\n//!         Match\n//!     ]\n//! );\n//!\n//! // scoring for global mode\n//! // scoring can also be created using from_scores if the match and mismatch scores are constants\n//! let scoring = Scoring::from_scores(-5, -1, 1, -1) // Gap open, extend, match, mismatch score\n//!     .xclip(MIN_SCORE) // Clipping penalty for x set to 'negative infinity', hence global in x\n//!     .yclip(MIN_SCORE); // Clipping penalty for y set to 'negative infinity', hence global in y\n//! let mut aligner = Aligner::with_scoring(scoring);\n//! let alignment = aligner.custom(x, y); // The custom aligner invocation\n//! assert_eq!(alignment.ystart, 0);\n//! assert_eq!(alignment.xstart, 0);\n//! // Note that in the custom mode, the clips are explicitly mentioned in the operations\n//! assert_eq!(\n//!     alignment.operations,\n//!     [Del, Del, Del, Del, Match, Match, Match, Match, Match, Subst, Match, Match, Match]\n//! );\n//!\n//! // Similarly if the clip penalties are both set to 0, we have local alignment mode. The scoring\n//! // struct also lets users set different penalties for prefix/suffix clipping, thereby letting\n//! // users have the flexibility to create a wide variety of boundary conditions. The xclip() and\n//! // yclip() methods sets the prefix and suffix penalties to be equal. The scoring struct can be\n//! // explicitly constructed for full flexibility.\n//!\n//! // The following example considers a modification of the semiglobal mode where you are allowed\n//! // to skip a prefix of the target sequence x, for a penalty of -10, but you have to consume\n//! // the rest of the string in the alignment\n//!\n//! let scoring = Scoring {\n//!     gap_open: -5,\n//!     gap_extend: -1,\n//!     match_fn: |a: u8, b: u8| if a == b { 1i32 } else { -3i32 },\n//!     match_scores: Some((1, -3)),\n//!     xclip_prefix: -10,\n//!     xclip_suffix: MIN_SCORE,\n//!     yclip_prefix: 0,\n//!     yclip_suffix: 0,\n//! };\n//! let x = b\"GGGGGGACGTACGTACGT\";\n//! let y = b\"AAAAACGTACGTACGTAAAA\";\n//! let mut aligner = Aligner::with_capacity_and_scoring(x.len(), y.len(), scoring);\n//! let alignment = aligner.custom(x, y);\n//! println!(\"{}\", alignment.pretty(x, y));\n//! assert_eq!(alignment.score, 2);\n//! assert_eq!(\n//!     alignment.operations,\n//!     [\n//!         Yclip(4),\n//!         Xclip(6),\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Match,\n//!         Yclip(4)\n//!     ]\n//! );\n//! ```\n\nuse std::cmp::max;\nuse std::i32;\nuse std::iter::repeat;\n\nuse crate::alignment::{Alignment, AlignmentMode, AlignmentOperation};\nuse crate::utils::TextSlice;\n\npub mod banded;\n\n/// Value to use as a 'negative infinity' score. Should be close to `i32::MIN`,\n/// but avoid underflow when used with reasonable scoring parameters or even\n/// adding two negative infinities. Use ~ `0.4 * i32::MIN`\npub const MIN_SCORE: i32 = -858_993_459;\n\n/// Trait required to instantiate a Scoring instance\npub trait MatchFunc {\n    fn score(\u0026self, a: u8, b: u8) -\u003e i32;\n}\n\n/// A concrete data structure which implements trait MatchFunc with constant\n/// match and mismatch scores\n#[derive(Debug, Clone)]\npub struct MatchParams {\n    pub match_score: i32,\n    pub mismatch_score: i32,\n}\n\nimpl MatchParams {\n    /// Create new MatchParams instance with given match and mismatch scores\n    ///\n    /// # Arguments\n    ///\n    /// * `match_score` - the score for a match (should not be negative)\n    /// * `mismatch_score` - the score for a mismatch (should not be positive)\n    pub fn new(match_score: i32, mismatch_score: i32) -\u003e Self {\n        assert!(match_score \u003e= 0, \"match_score can't be negative\");\n        assert!(mismatch_score \u003c= 0, \"mismatch_score can't be positive\");\n        MatchParams {\n            match_score,\n            mismatch_score,\n        }\n    }\n}\n\nimpl MatchFunc for MatchParams {\n    #[inline]\n    fn score(\u0026self, a: u8, b: u8) -\u003e i32 {\n        if a == b {\n            self.match_score\n        } else {\n            self.mismatch_score\n        }\n    }\n}\n\n/// The trait Matchfunc is also implemented for Fn(u8, u8) -\u003e i32 so that Scoring\n/// can be instantiated using closures and custom user defined functions\nimpl\u003cF\u003e MatchFunc for F\nwhere\n    F: Fn(u8, u8) -\u003e i32,\n{\n    fn score(\u0026self, a: u8, b: u8) -\u003e i32 {\n        (self)(a, b)\n    }\n}\n\n/// Details of scoring are encapsulated in this structure.\n///\n/// An [affine gap score model](https://en.wikipedia.org/wiki/Gap_penalty#Affine)\n/// is used so that the gap score for a length `k` is:\n/// `GapScore(k) = gap_open + gap_extend * k`\n#[derive(Debug, Clone)]\npub struct Scoring\u003cF: MatchFunc\u003e {\n    pub gap_open: i32,\n    pub gap_extend: i32,\n    pub match_fn: F,\n    pub match_scores: Option\u003c(i32, i32)\u003e,\n    pub xclip_prefix: i32,\n    pub xclip_suffix: i32,\n    pub yclip_prefix: i32,\n    pub yclip_suffix: i32,\n}\n\nimpl Scoring\u003cMatchParams\u003e {\n    /// Create new Scoring instance with given gap open, gap extend penalties\n    /// match and mismatch scores. The clip penalties are set to `MIN_SCORE` by default\n    ///\n    /// # Arguments\n    ///\n    /// * `gap_open` - the score for opening a gap (should not be positive)\n    /// * `gap_extend` - the score for extending a gap (should not be positive)\n    /// * `match_score` - the score for a match\n    /// * `mismatch_score` - the score for a mismatch\n    pub fn from_scores(\n        gap_open: i32,\n        gap_extend: i32,\n        match_score: i32,\n        mismatch_score: i32,\n    ) -\u003e Self {\n        assert!(gap_open \u003c= 0, \"gap_open can't be positive\");\n        assert!(gap_extend \u003c= 0, \"gap_extend can't be positive\");\n\n        Scoring {\n            gap_open,\n            gap_extend,\n            match_fn: MatchParams::new(match_score, mismatch_score),\n            match_scores: Some((match_score, mismatch_score)),\n            xclip_prefix: MIN_SCORE,\n            xclip_suffix: MIN_SCORE,\n            yclip_prefix: MIN_SCORE,\n            yclip_suffix: MIN_SCORE,\n        }\n    }\n}\n\nimpl\u003cF: MatchFunc\u003e Scoring\u003cF\u003e {\n    /// Create new Scoring instance with given gap open, gap extend penalties\n    /// and the score function. The clip penalties are set to [`MIN_SCORE`](constant.MIN_SCORE.html) by default\n    ///\n    /// # Arguments\n    ///\n    /// * `gap_open` - the score for opening a gap (should not be positive)\n    /// * `gap_extend` - the score for extending a gap (should not be positive)\n    /// * `match_fn` - function that returns the score for substitutions\n    ///    (see also [`bio::alignment::pairwise::Scoring`](struct.Scoring.html))\n    pub fn new(gap_open: i32, gap_extend: i32, match_fn: F) -\u003e Self {\n        assert!(gap_open \u003c= 0, \"gap_open can't be positive\");\n        assert!(gap_extend \u003c= 0, \"gap_extend can't be positive\");\n\n        Scoring {\n            gap_open,\n            gap_extend,\n            match_fn,\n            match_scores: None,\n            xclip_prefix: MIN_SCORE,\n            xclip_suffix: MIN_SCORE,\n            yclip_prefix: MIN_SCORE,\n            yclip_suffix: MIN_SCORE,\n        }\n    }\n\n    /// Sets the prefix and suffix clipping penalties for x to the input value\n    ///\n    /// # Arguments\n    ///\n    /// * `penalty` - Clipping penalty for x (both prefix and suffix, should not be positive)\n    ///\n    /// ```rust\n    /// use bio::alignment::pairwise::{Scoring, MIN_SCORE};\n    /// let scoring = Scoring::from_scores(0, -2, 1, -2).xclip(-5);\n    /// assert!(scoring.xclip_prefix == -5);\n    /// assert!(scoring.yclip_prefix == MIN_SCORE);\n    /// assert!(scoring.xclip_suffix == -5);\n    /// assert!(scoring.yclip_suffix == MIN_SCORE);\n    /// ```\n    pub fn xclip(mut self, penalty: i32) -\u003e Self {\n        assert!(penalty \u003c= 0, \"Clipping penalty can't be positive\");\n        self.xclip_prefix = penalty;\n        self.xclip_suffix = penalty;\n        self\n    }\n\n    /// Sets the prefix clipping penalty for x to the input value\n    ///\n    /// # Arguments\n    ///\n    /// * `penalty` - Prefix clipping penalty for x (should not be positive)\n    ///\n    /// # Example\n    /// ```rust\n    /// use bio::alignment::pairwise::{Scoring, MIN_SCORE};\n    /// let scoring = Scoring::from_scores(0, -2, 1, -2).xclip_prefix(-5);\n    /// assert!(scoring.xclip_prefix == -5);\n    /// assert!(scoring.yclip_prefix == MIN_SCORE);\n    /// assert!(scoring.xclip_suffix == MIN_SCORE);\n    /// assert!(scoring.yclip_suffix == MIN_SCORE);\n    /// ```\n    pub fn xclip_prefix(mut self, penalty: i32) -\u003e Self {\n        assert!(penalty \u003c= 0, \"Clipping penalty can't be positive\");\n        self.xclip_prefix = penalty;\n        self\n    }\n\n    /// Sets the suffix clipping penalty for x to the input value\n    ///\n    /// # Arguments\n    ///\n    /// * `penalty` - Suffix clipping penalty for x (should not be positive)\n    ///\n    /// ```rust\n    /// use bio::alignment::pairwise::{Scoring, MIN_SCORE};\n    /// let scoring = Scoring::from_scores(0, -2, 1, -2).xclip_suffix(-5);\n    /// assert!(scoring.xclip_prefix == MIN_SCORE);\n    /// assert!(scoring.yclip_prefix == MIN_SCORE);\n    /// assert!(scoring.xclip_suffix == -5);\n    /// assert!(scoring.yclip_suffix == MIN_SCORE);\n    /// ```\n    pub fn xclip_suffix(mut self, penalty: i32) -\u003e Self {\n        assert!(penalty \u003c= 0, \"Clipping penalty can't be positive\");\n        self.xclip_suffix = penalty;\n        self\n    }\n\n    /// Sets the prefix and suffix clipping penalties for y to the input value\n    ///\n    /// # Arguments\n    ///\n    /// * `penalty` - Clipping penalty for y (both prefix and suffix, should not be positive)\n    ///\n    /// ```rust\n    /// use bio::alignment::pairwise::{Scoring, MIN_SCORE};\n    /// let scoring = Scoring::from_scores(0, -2, 1, -2).yclip(-5);\n    /// assert!(scoring.xclip_prefix == MIN_SCORE);\n    /// assert!(scoring.yclip_prefix == -5);\n    /// assert!(scoring.xclip_suffix == MIN_SCORE);\n    /// assert!(scoring.yclip_suffix == -5);\n    /// ```\n    pub fn yclip(mut self, penalty: i32) -\u003e Self {\n        assert!(penalty \u003c= 0, \"Clipping penalty can't be positive\");\n        self.yclip_prefix = penalty;\n        self.yclip_suffix = penalty;\n        self\n    }\n\n    /// Sets the prefix clipping penalty for y to the input value\n    ///\n    /// # Arguments\n    ///\n    /// * `penalty` - Prefix clipping penalty for y (should not be positive)\n    ///\n    /// ```rust\n    /// use bio::alignment::pairwise::{Scoring, MIN_SCORE};\n    /// let scoring = Scoring::from_scores(0, -2, 1, -2).yclip_prefix(-5);\n    /// assert!(scoring.xclip_prefix == MIN_SCORE);\n    /// assert!(scoring.yclip_prefix == -5);\n    /// assert!(scoring.xclip_suffix == MIN_SCORE);\n    /// assert!(scoring.yclip_suffix == MIN_SCORE);\n    /// ```\n    pub fn yclip_prefix(mut self, penalty: i32) -\u003e Self {\n        assert!(penalty \u003c= 0, \"Clipping penalty can't be positive\");\n        self.yclip_prefix = penalty;\n        self\n    }\n\n    /// Sets the suffix clipping penalty for y to the input value\n    ///\n    /// # Arguments\n    ///\n    /// * `penalty` - Suffix clipping penalty for y (should not be positive)\n    ///\n    /// ```rust\n    /// use bio::alignment::pairwise::{Scoring, MIN_SCORE};\n    /// let scoring = Scoring::from_scores(0, -2, 1, -2).yclip_suffix(-5);\n    /// assert!(scoring.xclip_prefix == MIN_SCORE);\n    /// assert!(scoring.yclip_prefix == MIN_SCORE);\n    /// assert!(scoring.xclip_suffix == MIN_SCORE);\n    /// assert!(scoring.yclip_suffix == -5);\n    /// ```\n    pub fn yclip_suffix(mut self, penalty: i32) -\u003e Self {\n        assert!(penalty \u003c= 0, \"Clipping penalty can't be positive\");\n        self.yclip_suffix = penalty;\n        self\n    }\n}\n\n/// A generalized Smith-Waterman aligner.\n///\n/// `M(i,j)` is the best score such that `x[i]` and `y[j]` ends in a match (or substitution)\n/// ```ignore\n///              .... A   G  x_i\n///              .... C   G  y_j\n/// ```\n/// `I(i,j)` is the best score such that `x[i]` is aligned with a gap\n/// ```ignore\n///              .... A   G  x_i\n///              .... G  y_j  -\n/// ```\n/// This is interpreted as an insertion into `x` w.r.t reference `y`\n///\n/// `D(i,j)` is the best score such that `y[j]` is aligned with a gap\n/// ```ignore\n///              .... A  x_i  -\n///              .... G   G  y_j\n/// ```\n/// This is interpreted as a deletion from `x` w.r.t reference `y`\n///\n/// `S(i,j)` is the best score for prefixes `x[0..i]`, `y[0..j]`\n///\n/// To save space, only two columns of these matrices are stored at\n/// any point - the current column and the previous one. Moreover\n/// `M(i,j)` is not explicitly stored\n///\n/// `Lx` is the optimal x suffix clipping lengths from each position of the\n/// sequence y\n///\n/// `Ly` is the optimal y suffix clipping lengths from each position of the\n/// sequence x\n///\n/// `Sn` is the last column of the matrix. This is needed to keep track of\n/// suffix clipping scores\n///\n/// `traceback` - see [`bio::alignment::pairwise::TracebackCell`](struct.TracebackCell.html)\n///\n/// `scoring` - see [`bio::alignment::pairwise::Scoring`](struct.Scoring.html)\n#[allow(non_snake_case)]\npub struct Aligner\u003cF: MatchFunc\u003e {\n    I: [Vec\u003ci32\u003e; 2],\n    D: [Vec\u003ci32\u003e; 2],\n    S: [Vec\u003ci32\u003e; 2],\n    Lx: Vec\u003cusize\u003e,\n    Ly: Vec\u003cusize\u003e,\n    Sn: Vec\u003ci32\u003e,\n    traceback: Traceback,\n    scoring: Scoring\u003cF\u003e,\n}\n\nconst DEFAULT_ALIGNER_CAPACITY: usize = 200;\n\nimpl\u003cF: MatchFunc\u003e Aligner\u003cF\u003e {\n    /// Create new aligner instance with given gap open and gap extend penalties\n    /// and the score function.\n    ///\n    /// # Arguments\n    ///\n    /// * `gap_open` - the score for opening a gap (should be negative)\n    /// * `gap_extend` - the score for extending a gap (should be negative)\n    /// * `match_fn` - function that returns the score for substitutions\n    ///    (see also [`bio::alignment::pairwise::Scoring`](struct.Scoring.html))\n    pub fn new(gap_open: i32, gap_extend: i32, match_fn: F) -\u003e Self {\n        Aligner::with_capacity(\n            DEFAULT_ALIGNER_CAPACITY,\n            DEFAULT_ALIGNER_CAPACITY,\n            gap_open,\n            gap_extend,\n            match_fn,\n        )\n    }\n\n    /// Create new aligner instance. The size hints help to\n    /// avoid unnecessary memory allocations.\n    ///\n    /// # Arguments\n    ///\n    /// * `m` - the expected size of x\n    /// * `n` - the expected size of y\n    /// * `gap_open` - the score for opening a gap (should be negative)\n    /// * `gap_extend` - the score for extending a gap (should be negative)\n    /// * `match_fn` - function that returns the score for substitutions\n    ///    (see also [`bio::alignment::pairwise::Scoring`](struct.Scoring.html))\n    pub fn with_capacity(m: usize, n: usize, gap_open: i32, gap_extend: i32, match_fn: F) -\u003e Self {\n        assert!(gap_open \u003c= 0, \"gap_open can't be positive\");\n        assert!(gap_extend \u003c= 0, \"gap_extend can't be positive\");\n\n        Aligner {\n            I: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            D: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            S: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            Lx: Vec::with_capacity(n + 1),\n            Ly: Vec::with_capacity(m + 1),\n            Sn: Vec::with_capacity(m + 1),\n            traceback: Traceback::with_capacity(m, n),\n            scoring: Scoring::new(gap_open, gap_extend, match_fn),\n        }\n    }\n\n    /// Create new aligner instance with given the scoring struct\n    ///\n    /// # Arguments\n    ///\n    /// * `scoring` - the scoring struct (see bio::alignment::pairwise::Scoring)\n    pub fn with_scoring(scoring: Scoring\u003cF\u003e) -\u003e Self {\n        Aligner::with_capacity_and_scoring(\n            DEFAULT_ALIGNER_CAPACITY,\n            DEFAULT_ALIGNER_CAPACITY,\n            scoring,\n        )\n    }\n\n    /// Create new aligner instance with scoring and size hint. The size hints help to\n    /// avoid unnecessary memory allocations.\n    ///\n    /// # Arguments\n    ///\n    /// * `m` - the expected size of x\n    /// * `n` - the expected size of y\n    /// * `scoring` - the scoring struct\n    pub fn with_capacity_and_scoring(m: usize, n: usize, scoring: Scoring\u003cF\u003e) -\u003e Self {\n        assert!(scoring.gap_open \u003c= 0, \"gap_open can't be positive\");\n        assert!(scoring.gap_extend \u003c= 0, \"gap_extend can't be positive\");\n        assert!(\n            scoring.xclip_prefix \u003c= 0,\n            \"Clipping penalty (x prefix) can't be positive\"\n        );\n        assert!(\n            scoring.xclip_suffix \u003c= 0,\n            \"Clipping penalty (x suffix) can't be positive\"\n        );\n        assert!(\n            scoring.yclip_prefix \u003c= 0,\n            \"Clipping penalty (y prefix) can't be positive\"\n        );\n        assert!(\n            scoring.yclip_suffix \u003c= 0,\n            \"Clipping penalty (y suffix) can't be positive\"\n        );\n\n        Aligner {\n            I: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            D: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            S: [Vec::with_capacity(m + 1), Vec::with_capacity(m + 1)],\n            Lx: Vec::with_capacity(n + 1),\n            Ly: Vec::with_capacity(m + 1),\n            Sn: Vec::with_capacity(m + 1),\n            traceback: Traceback::with_capacity(m, n),\n            scoring,\n        }\n    }\n\n    /// The core function to compute the alignment\n    ///\n    /// # Arguments\n    ///\n    /// * `x` - Textslice\n    /// * `y` - Textslice\n    pub fn custom(\u0026mut self, x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) -\u003e Alignment {\n        let (m, n) = (x.len(), y.len());\n        self.traceback.init(m, n);\n\n        // Set the initial conditions\n        // We are repeating some work, but that's okay!\n        for k in 0..2 {\n            self.I[k].clear();\n            self.D[k].clear();\n            self.S[k].clear();\n\n            self.D[k].extend(repeat(MIN_SCORE).take(m + 1));\n            self.I[k].extend(repeat(MIN_SCORE).take(m + 1));\n            self.S[k].extend(repeat(MIN_SCORE).take(m + 1));\n\n            self.S[k][0] = 0;\n\n            if k == 0 {\n                let mut tb = TracebackCell::new();\n                tb.set_all(TB_START);\n                self.traceback.set(0, 0, tb);\n                self.Lx.clear();\n                self.Lx.extend(repeat(0usize).take(n + 1));\n                self.Ly.clear();\n                self.Ly.extend(repeat(0usize).take(m + 1));\n                self.Sn.clear();\n                self.Sn.extend(repeat(MIN_SCORE).take(m + 1));\n                self.Sn[0] = self.scoring.yclip_suffix;\n                self.Ly[0] = n;\n            }\n\n            for i in 1..=m {\n                let mut tb = TracebackCell::new();\n                tb.set_all(TB_START);\n                if i == 1 {\n                    self.I[k][i] = self.scoring.gap_open + self.scoring.gap_extend;\n                    tb.set_i_bits(TB_START);\n                } else {\n                    // Insert all i characters\n                    let i_score = self.scoring.gap_open + self.scoring.gap_extend * (i as i32);\n                    let c_score =\n                        self.scoring.xclip_prefix + self.scoring.gap_open + self.scoring.gap_extend; // Clip then insert\n                    if i_score \u003e c_score {\n                        self.I[k][i] = i_score;\n                        tb.set_i_bits(TB_INS);\n                    } else {\n                        self.I[k][i] = c_score;\n                        tb.set_i_bits(TB_XCLIP_PREFIX);\n                    }\n                }\n\n                if i == m {\n                    tb.set_s_bits(TB_XCLIP_SUFFIX);\n                } else {\n                    self.S[k][i] = MIN_SCORE;\n                }\n\n                if self.I[k][i] \u003e self.S[k][i] {\n                    self.S[k][i] = self.I[k][i];\n                    tb.set_s_bits(TB_INS);\n                }\n\n                if self.scoring.xclip_prefix \u003e self.S[k][i] {\n                    self.S[k][i] = self.scoring.xclip_prefix;\n                    tb.set_s_bits(TB_XCLIP_PREFIX);\n                }\n\n                // Track the score if we do a suffix clip (x) after this character\n                if i != m \u0026\u0026 self.S[k][i] + self.scoring.xclip_suffix \u003e self.S[k][m] {\n                    self.S[k][m] = self.S[k][i] + self.scoring.xclip_suffix;\n                    self.Lx[0] = m - i;\n                }\n\n                if k == 0 {\n                    self.traceback.set(i, 0, tb);\n                }\n                // Track the score if we do suffix clip (y) from here\n                if self.S[k][i] + self.scoring.yclip_suffix \u003e self.Sn[i] {\n                    self.Sn[i] = self.S[k][i] + self.scoring.yclip_suffix;\n                    self.Ly[i] = n;\n                }\n            }\n        }\n\n        for j in 1..=n {\n            let curr = j % 2;\n            let prev = 1 - curr;\n\n            {\n                // Handle i = 0 case\n                let mut tb = TracebackCell::new();\n                self.I[curr][0] = MIN_SCORE;\n\n                if j == 1 {\n                    self.D[curr][0] = self.scoring.gap_open + self.scoring.gap_extend;\n                    tb.set_d_bits(TB_START);\n                } else {\n                    // Delete all j characters\n                    let d_score = self.scoring.gap_open + self.scoring.gap_extend * (j as i32);\n                    let c_score =\n                        self.scoring.yclip_prefix + self.scoring.gap_open + self.scoring.gap_extend;\n                    if d_score \u003e c_score {\n                        self.D[curr][0] = d_score;\n                        tb.set_d_bits(TB_DEL);\n                    } else {\n                        self.D[curr][0] = c_score;\n                        tb.set_d_bits(TB_YCLIP_PREFIX);\n                    }\n                }\n                if self.D[curr][0] \u003e self.scoring.yclip_prefix {\n                    self.S[curr][0] = self.D[curr][0];\n                    tb.set_s_bits(TB_DEL);\n                } else {\n                    self.S[curr][0] = self.scoring.yclip_prefix;\n                    tb.set_s_bits(TB_YCLIP_PREFIX);\n                }\n\n                if j == n \u0026\u0026 self.Sn[0] \u003e self.S[curr][0] {\n                    // Check if the suffix clip score is better\n                    self.S[curr][0] = self.Sn[0];\n                    tb.set_s_bits(TB_YCLIP_SUFFIX);\n                // Track the score if we do suffix clip (y) from here\n                } else if self.S[curr][0] + self.scoring.yclip_suffix \u003e self.Sn[0] {\n                    self.Sn[0] = self.S[curr][0] + self.scoring.yclip_suffix;\n                    self.Ly[0] = n - j;\n                }\n\n                self.traceback.set(0, j, tb);\n            }\n\n            for i in 1..=m {\n                self.S[curr][i] = MIN_SCORE;\n            }\n\n            let q = y[j - 1];\n            let xclip_score = self.scoring.xclip_prefix\n                + max(\n                    self.scoring.yclip_prefix,\n                    self.scoring.gap_open + self.scoring.gap_extend * (j as i32),\n                );\n            for i in 1..m + 1 {\n                let p = x[i - 1];\n                let mut tb = TracebackCell::new();\n\n                let m_score = self.S[prev][i - 1] + self.scoring.match_fn.score(p, q);\n\n                let i_score = self.I[curr][i - 1] + self.scoring.gap_extend;\n                let s_score = self.S[curr][i - 1] + self.scoring.gap_open + self.scoring.gap_extend;\n                let best_i_score;\n                if i_score \u003e s_score {\n                    best_i_score = i_score;\n                    tb.set_i_bits(TB_INS);\n                } else {\n                    best_i_score = s_score;\n                    tb.set_i_bits(self.traceback.get(i - 1, j).get_s_bits());\n                }\n\n                let d_score = self.D[prev][i] + self.scoring.gap_extend;\n                let s_score = self.S[prev][i] + self.scoring.gap_open + self.scoring.gap_extend;\n                let best_d_score;\n                if d_score \u003e s_score {\n                    best_d_score = d_score;\n                    tb.set_d_bits(TB_DEL);\n                } else {\n                    best_d_score = s_score;\n                    tb.set_d_bits(self.traceback.get(i, j - 1).get_s_bits());\n                }\n\n                tb.set_s_bits(TB_XCLIP_SUFFIX);\n                let mut best_s_score = self.S[curr][i];\n\n                if m_score \u003e best_s_score {\n                    best_s_score = m_score;\n                    tb.set_s_bits(if p == q { TB_MATCH } else { TB_SUBST });\n                }\n\n                if best_i_score \u003e best_s_score {\n                    best_s_score = best_i_score;\n                    tb.set_s_bits(TB_INS);\n                }\n\n                if best_d_score \u003e best_s_score {\n                    best_s_score = best_d_score;\n                    tb.set_s_bits(TB_DEL);\n                }\n\n                if xclip_score \u003e best_s_score {\n                    best_s_score = xclip_score;\n                    tb.set_s_bits(TB_XCLIP_PREFIX);\n                }\n\n                let yclip_score = self.scoring.yclip_prefix\n                    + self.scoring.gap_open\n                    + self.scoring.gap_extend * (i as i32);\n                if yclip_score \u003e best_s_score {\n                    best_s_score = yclip_score;\n                    tb.set_s_bits(TB_YCLIP_PREFIX);\n                }\n\n                self.S[curr][i] = best_s_score;\n                self.I[curr][i] = best_i_score;\n                self.D[curr][i] = best_d_score;\n\n                // Track the score if we do suffix clip (x) from here\n                if self.S[curr][i] + self.scoring.xclip_suffix \u003e self.S[curr][m] {\n                    self.S[curr][m] = self.S[curr][i] + self.scoring.xclip_suffix;\n                    self.Lx[j] = m - i;\n                }\n\n                // Track the score if we do suffix clip (y) from here\n                if self.S[curr][i] + self.scoring.yclip_suffix \u003e self.Sn[i] {\n                    self.Sn[i] = self.S[curr][i] + self.scoring.yclip_suffix;\n                    self.Ly[i] = n - j;\n                }\n\n                self.traceback.set(i, j, tb);\n            }\n        }\n\n        // Handle suffix clipping in the j=n case\n        for i in 0..=m {\n            let j = n;\n            let curr = j % 2;\n            if self.Sn[i] \u003e self.S[curr][i] {\n                self.S[curr][i] = self.Sn[i];\n                self.traceback.get_mut(i, j).set_s_bits(TB_YCLIP_SUFFIX);\n            }\n            if self.S[curr][i] + self.scoring.xclip_suffix \u003e self.S[curr][m] {\n                self.S[curr][m] = self.S[curr][i] + self.scoring.xclip_suffix;\n                self.Lx[j] = m - i;\n                self.traceback.get_mut(m, j).set_s_bits(TB_XCLIP_SUFFIX);\n            }\n        }\n\n        // Since there could be a change in the last column of S,\n        // recompute the last column of I as this could also change\n        for i in 1..=m {\n            let j = n;\n            let curr = j % 2;\n            let s_score = self.S[curr][i - 1] + self.scoring.gap_open + self.scoring.gap_extend;\n            if s_score \u003e self.I[curr][i] {\n                self.I[curr][i] = s_score;\n                let s_bit = self.traceback.get(i - 1, j).get_s_bits();\n                self.traceback.get_mut(i, j).set_i_bits(s_bit);\n            }\n            if s_score \u003e self.S[curr][i] {\n                self.S[curr][i] = s_score;\n                self.traceback.get_mut(i, j).set_s_bits(TB_INS);\n                if self.S[curr][i] + self.scoring.xclip_suffix \u003e self.S[curr][m] {\n                    self.S[curr][m] = self.S[curr][i] + self.scoring.xclip_suffix;\n                    self.Lx[j] = m - i;\n                    self.traceback.get_mut(m, j).set_s_bits(TB_XCLIP_SUFFIX);\n                }\n            }\n        }\n\n        let mut i = m;\n        let mut j = n;\n        let mut operations = Vec::with_capacity(x.len());\n        let mut xstart: usize = 0usize;\n        let mut ystart: usize = 0usize;\n        let mut xend = m;\n        let mut yend = n;\n\n        let mut last_layer = self.traceback.get(i, j).get_s_bits();\n\n        loop {\n            let next_layer: u16;\n            match last_layer {\n                TB_START =\u003e break,\n                TB_INS =\u003e {\n                    operations.push(AlignmentOperation::Ins);\n                    next_layer = self.traceback.get(i, j).get_i_bits();\n                    i -= 1;\n                }\n                TB_DEL =\u003e {\n                    operations.push(AlignmentOperation::Del);\n                    next_layer = self.traceback.get(i, j).get_d_bits();\n                    j -= 1;\n                }\n                TB_MATCH =\u003e {\n                    operations.push(AlignmentOperation::Match);\n                    next_layer = self.traceback.get(i - 1, j - 1).get_s_bits();\n                    i -= 1;\n                    j -= 1;\n                }\n                TB_SUBST =\u003e {\n                    operations.push(AlignmentOperation::Subst);\n                    next_layer = self.traceback.get(i - 1, j - 1).get_s_bits();\n                    i -= 1;\n                    j -= 1;\n                }\n                TB_XCLIP_PREFIX =\u003e {\n                    operations.push(AlignmentOperation::Xclip(i));\n                    xstart = i;\n                    i = 0;\n                    next_layer = self.traceback.get(0, j).get_s_bits();\n                }\n                TB_XCLIP_SUFFIX =\u003e {\n                    operations.push(AlignmentOperation::Xclip(self.Lx[j]));\n                    i -= self.Lx[j];\n                    xend = i;\n                    next_layer = self.traceback.get(i, j).get_s_bits();\n                }\n                TB_YCLIP_PREFIX =\u003e {\n                    operations.push(AlignmentOperation::Yclip(j));\n                    ystart = j;\n                    j = 0;\n                    next_layer = self.traceback.get(i, 0).get_s_bits();\n                }\n                TB_YCLIP_SUFFIX =\u003e {\n                    operations.push(AlignmentOperation::Yclip(self.Ly[i]));\n                    j -= self.Ly[i];\n                    yend = j;\n                    next_layer = self.traceback.get(i, j).get_s_bits();\n                }\n                _ =\u003e panic!(\"Dint expect this!\"),\n            }\n            last_layer = next_layer;\n        }\n\n        operations.reverse();\n        Alignment {\n            score: self.S[n % 2][m],\n            ystart,\n            xstart,\n            yend,\n            xend,\n            ylen: n,\n            xlen: m,\n            operations,\n            mode: AlignmentMode::Custom,\n        }\n    }\n\n    /// Calculate global alignment of x against y.\n    pub fn global(\u0026mut self, x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) -\u003e Alignment {\n        // Store the current clip penalties\n        let clip_penalties = [\n            self.scoring.xclip_prefix,\n            self.scoring.xclip_suffix,\n            self.scoring.yclip_prefix,\n            self.scoring.yclip_suffix,\n        ];\n\n        // Temporarily Over-write the clip penalties\n        self.scoring.xclip_prefix = MIN_SCORE;\n        self.scoring.xclip_suffix = MIN_SCORE;\n        self.scoring.yclip_prefix = MIN_SCORE;\n        self.scoring.yclip_suffix = MIN_SCORE;\n\n        // Compute the alignment\n        let mut alignment = self.custom(x, y);\n        alignment.mode = AlignmentMode::Global;\n\n        // Set the clip penalties to the original values\n        self.scoring.xclip_prefix = clip_penalties[0];\n        self.scoring.xclip_suffix = clip_penalties[1];\n        self.scoring.yclip_prefix = clip_penalties[2];\n        self.scoring.yclip_suffix = clip_penalties[3];\n\n        alignment\n    }\n\n    /// Calculate semiglobal alignment of x against y (x is global, y is local).\n    pub fn semiglobal(\u0026mut self, x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) -\u003e Alignment {\n        // Store the current clip penalties\n        let clip_penalties = [\n            self.scoring.xclip_prefix,\n            self.scoring.xclip_suffix,\n            self.scoring.yclip_prefix,\n            self.scoring.yclip_suffix,\n        ];\n\n        // Temporarily Over-write the clip penalties\n        self.scoring.xclip_prefix = MIN_SCORE;\n        self.scoring.xclip_suffix = MIN_SCORE;\n        self.scoring.yclip_prefix = 0;\n        self.scoring.yclip_suffix = 0;\n\n        // Compute the alignment\n        let mut alignment = self.custom(x, y);\n        alignment.mode = AlignmentMode::Semiglobal;\n\n        // Filter out Xclip and Yclip from alignment.operations\n        alignment.filter_clip_operations();\n\n        // Set the clip penalties to the original values\n        self.scoring.xclip_prefix = clip_penalties[0];\n        self.scoring.xclip_suffix = clip_penalties[1];\n        self.scoring.yclip_prefix = clip_penalties[2];\n        self.scoring.yclip_suffix = clip_penalties[3];\n\n        alignment\n    }\n\n    /// Calculate local alignment of x against y.\n    pub fn local(\u0026mut self, x: TextSlice\u003c'_\u003e, y: TextSlice\u003c'_\u003e) -\u003e Alignment {\n        // Store the current clip penalties\n        let clip_penalties = [\n            self.scoring.xclip_prefix,\n            self.scoring.xclip_suffix,\n            self.scoring.yclip_prefix,\n            self.scoring.yclip_suffix,\n        ];\n\n        // Temporarily Over-write the clip penalties\n        self.scoring.xclip_prefix = 0;\n        self.scoring.xclip_suffix = 0;\n        self.scoring.yclip_prefix = 0;\n        self.scoring.yclip_suffix = 0;\n\n        // Compute the alignment\n        let mut alignment = self.custom(x, y);\n        alignment.mode = AlignmentMode::Local;\n\n        // Filter out Xclip and Yclip from alignment.operations\n        alignment.filter_clip_operations();\n\n        // Set the clip penalties to the original values\n        self.scoring.xclip_prefix = clip_penalties[0];\n        self.scoring.xclip_suffix = clip_penalties[1];\n        self.scoring.yclip_prefix = clip_penalties[2];\n        self.scoring.yclip_suffix = clip_penalties[3];\n\n        alignment\n    }\n}\n\n/// Packed representation of one cell of a Smith-Waterman traceback matrix.\n/// Stores the I, D and S traceback matrix values in two bytes.\n/// Possible traceback moves include : start, insert, delete, match, substitute,\n/// prefix clip and suffix clip for x \u0026 y. So we need 4 bits each for matrices I, D, S\n/// to keep track of these 9 moves.\n#[derive(Copy, Clone)]\npub struct TracebackCell {\n    v: u16,\n}\n\nimpl Default for TracebackCell {\n    fn default() -\u003e Self {\n        TracebackCell { v: 0 }\n    }\n}\n\n// Traceback bit positions (LSB)\nconst I_POS: u8 = 0; // Meaning bits 0,1,2,3 corresponds to I and so on\nconst D_POS: u8 = 4;\nconst S_POS: u8 = 8;\n\n// Traceback moves\nconst TB_START: u16 = 0b0000;\nconst TB_INS: u16 = 0b0001;\nconst TB_DEL: u16 = 0b0010;\nconst TB_SUBST: u16 = 0b0011;\nconst TB_MATCH: u16 = 0b0100;\n\nconst TB_XCLIP_PREFIX: u16 = 0b0101; // prefix clip of x\nconst TB_XCLIP_SUFFIX: u16 = 0b0110; // suffix clip of x\nconst TB_YCLIP_PREFIX: u16 = 0b0111; // prefix clip of y\nconst TB_YCLIP_SUFFIX: u16 = 0b1000; // suffix clip of y\n\nconst TB_MAX: u16 = 0b1000; // Useful in checking that the\n                            // TB value we got is a valid one\n\nimpl TracebackCell {\n    /// Initialize a blank traceback cell\n    #[inline(always)]\n    pub fn new() -\u003e TracebackCell {\n        Default::default()\n    }\n\n    /// Sets 4 bits [pos, pos+4) with the 4 LSBs of value\n    #[inline(always)]\n    fn set_bits(\u0026mut self, pos: u8, value: u16) {\n        let bits: u16 = (0b1111) \u003c\u003c pos;\n        assert!(\n            value \u003c= TB_MAX,\n            \"Expected a value \u003c= TB_MAX while setting traceback bits\"\n        );\n        self.v = (self.v \u0026 !bits) // First clear the bits\n            | (value \u003c\u003c pos) // And set the bits\n    }\n\n    #[inline(always)]\n    pub fn set_i_bits(\u0026mut self, value: u16) {\n        // Traceback corresponding to matrix I\n        self.set_bits(I_POS, value);\n    }\n\n    #[inline(always)]\n    pub fn set_d_bits(\u0026mut self, value: u16) {\n        // Traceback corresponding to matrix D\n        self.set_bits(D_POS, value);\n    }\n\n    #[inline(always)]\n    pub fn set_s_bits(\u0026mut self, value: u16) {\n        // Traceback corresponding to matrix S\n        self.set_bits(S_POS, value);\n    }\n\n    // Gets 4 bits [pos, pos+4) of v\n    #[inline(always)]\n    fn get_bits(self, pos: u8) -\u003e u16 {\n        (self.v \u003e\u003e pos) \u0026 (0b1111)\n    }\n\n    #[inline(always)]\n    pub fn get_i_bits(self) -\u003e u16 {\n        self.get_bits(I_POS)\n    }\n\n    #[inline(always)]\n    pub fn get_d_bits(self) -\u003e u16 {\n        self.get_bits(D_POS)\n    }\n\n    #[inline(always)]\n    pub fn get_s_bits(self) -\u003e u16 {\n        self.get_bits(S_POS)\n    }\n\n    /// Set all matrices to the same value.\n    pub fn set_all(\u0026mut self, value: u16) {\n        self.set_i_bits(value);\n        self.set_d_bits(value);\n        self.set_s_bits(value);\n    }\n}\n\n/// Internal traceback.\nstruct Traceback {\n    rows: usize,\n    cols: usize,\n    matrix: Vec\u003cTracebackCell\u003e,\n}\n\nimpl Traceback {\n    fn with_capacity(m: usize, n: usize) -\u003e Self {\n        let rows = m + 1;\n        let cols = n + 1;\n        Traceback {\n            rows,\n            cols,\n            matrix: Vec::with_capacity(rows * cols),\n        }\n    }\n\n    fn init(\u0026mut self, m: usize, n: usize) {\n        self.matrix.clear();\n        let mut start = TracebackCell::new();\n        start.set_all(TB_START);\n        // set every cell to start\n        self.resize(m, n, start);\n    }\n\n    #[inline(always)]\n    fn set(\u0026mut self, i: usize, j: usize, v: TracebackCell) {\n        debug_assert!(i \u003c self.rows);\n        debug_assert!(j \u003c self.cols);\n        self.matrix[i * self.cols + j] = v;\n    }\n\n    #[inline(always)]\n    fn get(\u0026self, i: usize, j: usize) -\u003e \u0026TracebackCell {\n        debug_assert!(i \u003c self.rows);\n        debug_assert!(j \u003c self.cols);\n        \u0026self.matrix[i * self.cols + j]\n    }\n\n    fn get_mut(\u0026mut self, i: usize, j: usize) -\u003e \u0026mut TracebackCell {\n        debug_assert!(i \u003c self.rows);\n        debug_assert!(j \u003c self.cols);\n        \u0026mut self.matrix[i * self.cols + j]\n    }\n\n    fn resize(\u0026mut self, m: usize, n: usize, v: TracebackCell) {\n        self.rows = m + 1;\n        self.cols = n + 1;\n        self.matrix.resize(self.rows * self.cols, v);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::alignment::AlignmentOperation::*;\n    use crate::scores::blosum62;\n\n    #[test]\n    fn traceback_cell() {\n        let mut tb = TracebackCell::new();\n\n        tb.set_all(TB_SUBST);\n        assert_eq!(tb.get_i_bits(), TB_SUBST);\n        assert_eq!(tb.get_d_bits(), TB_SUBST);\n        assert_eq!(tb.get_s_bits(), TB_SUBST);\n\n        tb.set_d_bits(TB_INS);\n        assert_eq!(tb.get_d_bits(), TB_INS);\n\n        tb.set_i_bits(TB_XCLIP_PREFIX);\n        assert_eq!(tb.get_d_bits(), TB_INS);\n        assert_eq!(tb.get_i_bits(), TB_XCLIP_PREFIX);\n\n        tb.set_d_bits(TB_DEL);\n        assert_eq!(tb.get_d_bits(), TB_DEL);\n        assert_eq!(tb.get_i_bits(), TB_XCLIP_PREFIX);\n\n        tb.set_s_bits(TB_YCLIP_SUFFIX);\n        assert_eq!(tb.get_d_bits(), TB_DEL);\n        assert_eq!(tb.get_i_bits(), TB_XCLIP_PREFIX);\n        assert_eq!(tb.get_s_bits(), TB_YCLIP_SUFFIX);\n    }\n\n    #[test]\n    fn test_semiglobal() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, score);\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    // Test case for underflow of the SW score.\n    #[test]\n    fn test_semiglobal_gap_open_lt_mismatch() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -5i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -1, -1, score);\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Del, Match, Ins, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_global_affine_ins() {\n        let x = b\"ACGAGAACA\";\n        let y = b\"ACGACA\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, score);\n        let alignment = aligner.global(x, y);\n\n        println!(\"aln:\\n{}\", alignment.pretty(x, y));\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Ins, Ins, Ins, Match, Match, Match]\n        );\n    }\n\n    #[test]\n    fn test_global_affine_ins2() {\n        let x = b\"AGATAGATAGATAGGGAGTTGTGTAGATGATCCACAGT\";\n        let y = b\"AGATAGATAGATGTAGATGATCCACAGT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, score);\n        let alignment = aligner.global(x, y);\n\n        println!(\"aln:\\n{}\", alignment.pretty(x, y));\n\n        let mut correct = Vec::new();\n        correct.extend(repeat(Match).take(11));\n        correct.extend(repeat(Ins).take(10));\n        correct.extend(repeat(Match).take(17));\n\n        assert_eq!(alignment.operations, correct);\n    }\n\n    #[test]\n    fn test_local_affine_ins2() {\n        let x = b\"ACGTATCATAGATAGATAGGGTTGTGTAGATGATCCACAG\";\n        let y = b\"CGTATCATAGATAGATGTAGATGATCCACAGT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, score);\n        let alignment = aligner.local(x, y);\n        assert_eq!(alignment.xstart, 1);\n        assert_eq!(alignment.ystart, 0);\n    }\n\n    #[test]\n    fn test_local() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, score);\n        let alignment = aligner.local(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_global() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, score);\n        let alignment = aligner.global(x, y);\n\n        println!(\"\\naln:\\n{}\", alignment.pretty(x, y));\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Del, Del, Del, Del, Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_blosum62() {\n        let x = b\"AAAA\";\n        let y = b\"AAAA\";\n        let score = \u0026blosum62;\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, score);\n        let alignment = aligner.global(x, y);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.score, 16);\n        assert_eq!(alignment.operations, [Match, Match, Match, Match]);\n    }\n\n    #[test]\n    fn test_blosum62_local() {\n        let x = b\"LSPADKTNVKAA\";\n        let y = b\"PEEKSAV\";\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -10, -1, \u0026blosum62);\n        let alignment = aligner.local(x, y);\n        assert_eq!(alignment.xstart, 2);\n        assert_eq!(alignment.xend, 9);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.yend, 7);\n        assert_eq!(\n            alignment.operations,\n            [Match, Subst, Subst, Match, Subst, Subst, Match]\n        );\n        assert_eq!(alignment.score, 16);\n    }\n\n    #[test]\n    fn test_issue11() {\n        let y = b\"TACC\"; //GTGGAC\";\n        let x = b\"AAAAACC\"; //GTTGACGCAA\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let alignment = aligner.global(x, y);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Ins, Ins, Ins, Subst, Match, Match, Match]\n        );\n    }\n\n    #[test]\n    fn test_issue12_1() {\n        let x = b\"CCGGCA\";\n        let y = b\"ACCGTTGACGC\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.ystart, 1);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Subst, Subst, Subst]\n        );\n    }\n\n    #[test]\n    fn test_issue12_2() {\n        let y = b\"CCGGCA\";\n        let x = b\"ACCGTTGACGC\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.ystart, 0);\n\n        assert_eq!(\n            alignment.operations,\n            [Subst, Match, Ins, Ins, Ins, Ins, Ins, Ins, Subst, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_issue12_3() {\n        let y = b\"CCGTCCGGCAA\";\n        let x = b\"AAAAACCGTTGACGCAA\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let alignment = aligner.semiglobal(x, y);\n\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [\n                Ins, Ins, Ins, Ins, Ins, Ins, Match, Subst, Subst, Match, Subst, Subst, Subst,\n                Match, Match, Match, Match,\n            ]\n        );\n\n        let mut aligner = Aligner::with_capacity(y.len(), x.len(), -5, -1, \u0026score);\n        let alignment = aligner.semiglobal(y, x);\n\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Subst, Subst, Match, Subst, Subst, Subst, Match, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_left_aligned_del() {\n        let x = b\"GTGCATCATGTG\";\n        let y = b\"GTGCATCATCATGTG\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let alignment = aligner.global(x, y);\n        println!(\"\\naln:\\n{}\", alignment.pretty(x, y));\n\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [\n                Match, Match, Match, Del, Del, Del, Match, Match, Match, Match, Match, Match,\n                Match, Match, Match,\n            ]\n        );\n    }\n\n    // Test that trailing deletions are correctly handled\n    // in global mode\n    #[test]\n    fn test_global_right_del() {\n        let x = b\"AACCACGTACGTGGGGGGA\";\n        let y = b\"CCACGTACGT\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let alignment = aligner.global(x, y);\n\n        println!(\"\\naln:\\n{}\", alignment.pretty(x, y));\n\n        println!(\"score:{}\", alignment.score);\n        assert_eq!(alignment.score, -9);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [\n                Ins, Ins, Match, Match, Match, Match, Match, Match, Match, Match, Match, Match,\n                Ins, Ins, Ins, Ins, Ins, Ins, Ins,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_left_aligned_ins() {\n        let x = b\"GTGCATCATCATGTG\";\n        let y = b\"GTGCATCATGTG\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::with_capacity(x.len(), y.len(), -5, -1, \u0026score);\n        let alignment = aligner.global(x, y);\n        println!(\"\\naln:\\n{}\", alignment.pretty(x, y));\n\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [\n                Match, Match, Match, Ins, Ins, Ins, Match, Match, Match, Match, Match, Match,\n                Match, Match, Match,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_aligner_new() {\n        let x = b\"ACCGTGGAT\";\n        let y = b\"AAAAACCGTTGAT\";\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::new(-5, -1, \u0026score);\n\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n\n        let alignment = aligner.local(x, y);\n        assert_eq!(alignment.ystart, 4);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n\n        let alignment = aligner.global(x, y);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(\n            alignment.operations,\n            [Del, Del, Del, Del, Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_semiglobal_simple() {\n        let x = b\"GAAAACCGTTGAT\";\n        let y = b\"ACCGTGGATGGG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let mut aligner = Aligner::new(-5, -1, \u0026score);\n        let alignment = aligner.semiglobal(x, y);\n\n        assert_eq!(\n            alignment.operations,\n            [Ins, Ins, Ins, Ins, Match, Match, Match, Match, Match, Subst, Match, Match, Match,]\n        );\n    }\n\n    #[test]\n    fn test_insert_only_semiglobal() {\n        let x = b\"TTTT\";\n        let y = b\"AAAA\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let mut aligner = Aligner::new(-5, -1, \u0026score);\n        let alignment = aligner.semiglobal(x, y);\n\n        assert_eq!(alignment.operations, [Ins, Ins, Ins, Ins]);\n    }\n\n    #[test]\n    fn test_insert_in_between_semiglobal() {\n        let x = b\"GGGGG\";\n        let y = b\"GGTAGGG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let mut aligner = Aligner::new(-5, -1, \u0026score);\n        let alignment = aligner.semiglobal(x, y);\n\n        assert_eq!(\n            alignment.operations,\n            [Match, Match, Del, Del, Match, Match, Match]\n        );\n    }\n\n    #[test]\n    fn test_xclip_prefix_custom() {\n        let x = b\"GGGGGGATG\";\n        let y = b\"ATG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).xclip(-5);\n\n        let mut aligner = Aligner::with_scoring(scoring);\n        let alignment = aligner.custom(x, y);\n\n        assert_eq!(alignment.operations, [Xclip(6), Match, Match, Match]);\n    }\n\n    #[test]\n    fn test_yclip_prefix_custom() {\n        let y = b\"GGGGGGATG\";\n        let x = b\"ATG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).yclip(-5);\n\n        let mut aligner = Aligner::with_scoring(scoring);\n        let alignment = aligner.custom(x, y);\n\n        assert_eq!(alignment.operations, [Yclip(6), Match, Match, Match]);\n    }\n\n    #[test]\n    fn test_xclip_suffix_custom() {\n        let x = b\"GAAAA\";\n        let y = b\"CG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).xclip(-5).yclip(0);\n\n        let mut aligner = Aligner::with_scoring(scoring);\n        let alignment = aligner.custom(x, y);\n\n        assert_eq!(alignment.operations, [Yclip(1), Match, Xclip(4)]);\n    }\n\n    #[test]\n    fn test_yclip_suffix_custom() {\n        let y = b\"GAAAA\";\n        let x = b\"CG\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).yclip(-5).xclip(0);\n\n        let mut aligner = Aligner::with_scoring(scoring);\n        let alignment = aligner.custom(x, y);\n\n        assert_eq!(alignment.operations, [Xclip(1), Match, Yclip(4)]);\n    }\n\n    #[test]\n    fn test_xclip_prefix_suffix() {\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let scoring1 = Scoring::new(-5, -1, \u0026score).xclip(-5);\n        let scoring2 = Scoring::new(-5, -1, \u0026score)\n            .xclip_prefix(-5)\n            .xclip_suffix(-5);\n\n        assert_eq!(scoring1.xclip_prefix, scoring2.xclip_prefix);\n        assert_eq!(scoring1.xclip_suffix, scoring2.xclip_suffix);\n    }\n\n    #[test]\n    fn test_yclip_prefix_suffix() {\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -1i32 };\n        let scoring1 = Scoring::new(-5, -1, \u0026score).yclip(-5);\n        let scoring2 = Scoring::new(-5, -1, \u0026score)\n            .yclip_prefix(-5)\n            .yclip_suffix(-5);\n\n        assert_eq!(scoring1.yclip_prefix, scoring2.yclip_prefix);\n        assert_eq!(scoring1.yclip_suffix, scoring2.yclip_suffix);\n    }\n\n    #[test]\n    fn test_longer_string_all_operations() {\n        let x = b\"TTTTTGGGGGGATGGCCCCCCTTTTTTTTTTGGGAAAAAAAAAGGGGGG\";\n        let y = b\"GGGGGGATTTCCCCCCCCCTTTTTTTTTTAAAAAAAAA\";\n\n        let score = |a: u8, b: u8| if a == b { 1i32 } else { -3i32 };\n        let scoring = Scoring::new(-5, -1, \u0026score).xclip(-5).yclip(0);\n\n        let mut aligner = Aligner::with_scoring(scoring);\n        let alignment = aligner.custom(x, y);\n\n        println!(\"{}\", alignment.pretty(x, y));\n        assert_eq!(alignment.score, 7);\n    }\n\n    #[test]\n    fn test_scoring_from_scores() {\n        let y = b\"GGGGGGATG\";\n        let x = b\"ATG\";\n\n        let scoring = Scoring::from_scores(-5, -1, 1, -1).yclip(-5);\n\n        let mut aligner = Aligner::with_scoring(scoring);\n        let alignment = aligner.custom(x, y);\n\n        assert_eq!(alignment.operations, [Yclip(6), Match, Match, Match]);\n    }\n\n    #[test]\n    fn test_only_clips() {\n        let x = b\"GGAAAAAAAAAAAAA\";\n        let y = b\"TTTTAATTTGTGTAAAAAATAATA\";\n        let base_score = Scoring::from_scores(-4, -4, 4, -7);\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            xclip_suffix: 0,\n            yclip_suffix: 0,\n            ..base_score\n        };\n        let mut al = Aligner::with_scoring(scoring);\n        let alignment = al.custom(x, y);\n        assert_eq!(alignment.score, 0);\n    }\n\n    #[test]\n    fn test_zero_score_clips() {\n        let x = b\"AA\";\n        let y = b\"CC\";\n        let base_score = Scoring::from_scores(-1, -1, 1, -1);\n        {\n            let scoring = Scoring {\n                xclip_prefix: 0,\n                yclip_prefix: 0,\n                ..base_score.clone()\n            };\n            let mut al = Aligner::with_scoring(scoring);\n            let alignment = al.custom(x, y);\n            assert_eq!(alignment.score, 0);\n        }\n\n        {\n            let scoring = Scoring {\n                xclip_prefix: 0,\n                yclip_suffix: 0,\n                ..base_score.clone()\n            };\n            let mut al = Aligner::with_scoring(scoring);\n            let alignment = al.custom(x, y);\n            assert_eq!(alignment.score, 0);\n        }\n\n        {\n            let scoring = Scoring {\n                xclip_suffix: 0,\n                yclip_prefix: 0,\n                ..base_score.clone()\n            };\n            let mut al = Aligner::with_scoring(scoring);\n            let alignment = al.custom(x, y);\n            assert_eq!(alignment.score, 0);\n        }\n\n        {\n            let scoring = Scoring {\n                xclip_suffix: 0,\n                yclip_suffix: 0,\n                ..base_score\n            };\n            let mut al = Aligner::with_scoring(scoring);\n            let alignment = al.custom(x, y);\n            assert_eq!(alignment.score, 0);\n        }\n    }\n}\n","traces":[{"line":187,"address":[6297376],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":188,"address":[6297425,6297395],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[6297411,6297483,6297513],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[6297520],"length":1,"stats":{"Line":0},"fn_name":"score"},{"line":200,"address":[6297546,6297561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[6297567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[6297554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[4610736,4610608,4610480,4610544,4610672],"length":1,"stats":{"Line":0},"fn_name":"score\u003cclosure-0\u003e"},{"line":215,"address":[4610630,4610566,4610502,4610694,4610758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[6297584],"length":1,"stats":{"Line":0},"fn_name":"from_scores"},{"line":252,"address":[6297632,6297662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[6297648,6297715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[6297700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[6297782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[6511589,6512384,6520656,6525152,6514496,6519273,6518479,6515824,6525401,6522777,6514757,6519557,6523040,6524857,6518741,6524345,6513461,6523039,6515552,6523801,6521961,6525129,6516617,6515813,6511577,6526176,6520112,6523824,6511328,6514995,6510816,6519545,6522505,6517968,6521701,6522256,6525664,6512905,6517728,6525925,6523813,6524357,6515280,6523529,6513189,6513177,6524880,6512361,6517717,6526175,6521439,6519840,6521189,6511827,6523552,6525413,6516368,6517161,6511065,6512101,6512656,6511600,6520928,6515541,6519817,6519296,6523280,6515008,6513449,6521689,6521200,6525936,6520089,6516085,6524368,6522789,6512112,6512917,6515257,6521973,6511840,6524608,6515801,6516912,6517456,6521712,6520101,6517967,6512089,6518240,6517433,6525651,6524595,6515529,6524073,6526163,6512373,6513984,6515007,6520633,6522233,6518480,6524096,6521440,6513200,6511077,6526425,6514224,6523027,6522800,6525424,6521427,6512928,6519024,6523541,6518467,6511315,6525141,6519568,6514211,6511088,6522245,6522517,6513472,6517173,6516889,6519013,6524085,6524869,6516096,6520361,6513971,6513744,6517955,6519001,6522528,6516357,6523279,6516629,6516901,6515269,6513733,6520384,6516640,6524607,6513721,6514223,6513983,6520917,6518729,6514745,6514768,6521177,6526437,6520645,6525913,6511327,6525663,6511839,6519829,6518752,6517705,6516073,6512633,6520905,6512645,6517184,6518229,6520373,6514485,6514473,6518217,6516345,6523267,6519285,6517445,6521984],"length":1,"stats":{"Line":0},"fn_name":"new\u003c\u0026closure-0\u003e"},{"line":279,"address":[6524954,6512968,6515082,6516986,6516952,6516714,6525738,6520424,6522058,6511402,6517530,6522862,6520968,6514298,6518269,6520730,6516136,6525486,6513240,6515626,6520458,6523354,6519608,6520696,6511914,6518792,6521002,6526250,6513773,6523320,6516442,6517790,6525998,6514264,6514830,6519064,6522024,6524397,6525453,6519914,6523102,6511662,6522829,6518008,6522330,6521480,6515864,6521514,6523592,6524682,6519880,6511629,6524170,6524648,6524430,6515048,6518042,6518554,6523898,6526216,6523864,6521262,6516408,6522568,6524136,6511117,6518520,6519336,6517258,6515354,6522296,6521229,6521786,6510856,6512152,6524920,6514013,6512730,6523626,6525192,6517224,6525226,6521752,6523069,6512696,6511880,6514536,6515592,6513002,6518826,6515320,6518302,6525704,6514797,6514046,6519370,6513512,6512424,6520186,6515898,6522602,6520152,6513806,6511368,6519098,6514570,6517496,6513274,6517757,6525965,6510890,6512186,6512458,6516680,6513546,6516170,6511150,6519642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[6519512,6513416,6513144,6525720,6520440,6526232,6520168,6518536,6519784,6511544,6521244,6511132,6514028,6523336,6525980,6511644,6516856,6512872,6524562,6525468,6518696,6525368,6520056,6522040,6516424,6526392,6521144,6516152,6521496,6512600,6512056,6523608,6524412,6513256,6519240,6512984,6518284,6514812,6526130,6515064,6521394,6520600,6519080,6525618,6522844,6520984,6522584,6519352,6524312,6513938,6511282,6511384,6518968,6514440,6515496,6520712,6517922,6523496,6512328,6515768,6514712,6524936,6517240,6512168,6518808,6515224,6522472,6514552,6518434,6518184,6519896,6521768,6511896,6521656,6512712,6520328,6522312,6523084,6523880,6524824,6525208,6511794,6522200,6516696,6517512,6513528,6515608,6522744,6511032,6517772,6519624,6525880,6520872,6524664,6523234,6517400,6512440,6518024,6516584,6514280,6514178,6523768,6516312,6513688,6525096,6517672,6524040,6515336,6515880,6516040,6521928,6513788,6516968,6517128,6514962,6510872,6524152,6522994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[6526592,6526577,6527456,6526721,6526733,6526880,6527297,6526865,6527021,6527009,6527741,6526448,6527585,6527453,6527309,6526877,6527312,6527168,6527024,6526736,6527153,6527597,6527729,6527441,6526589,6527165,6527600],"length":1,"stats":{"Line":0},"fn_name":"xclip\u003c\u0026closure-0\u003e"},{"line":309,"address":[6527627,6526671,6527391,6527679,6526907,6526527,6526763,6526815,6527103,6527535,6526959,6527195,6526475,6526619,6527247,6527339,6527483,6527051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[6526645,6527221,6527365,6526501,6527509,6527077,6527653,6526933,6526789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[6527656,6526504,6527080,6526936,6527368,6527512,6527224,6526792,6526648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[6526651,6527515,6526507,6527371,6526795,6526939,6527083,6527227,6527659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[6527744,6527882,6527870],"length":1,"stats":{"Line":0},"fn_name":"xclip_prefix\u003c\u0026closure-0\u003e"},{"line":331,"address":[6527820,6527771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[6527797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[6527800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[6528014,6527888,6528026],"length":1,"stats":{"Line":0},"fn_name":"xclip_suffix\u003c\u0026closure-0\u003e"},{"line":351,"address":[6527915,6527964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[6527941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[6527944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[6528749,6528161,6528461,6528896,6529037,6529313,6529469,6528881,6528893,6528032,6528176,6529325,6529328,6529457,6529181,6529040,6528737,6528605,6529184,6529169,6528173,6528449,6529025,6528593,6528305,6528608,6528320,6528464,6528317,6528752],"length":1,"stats":{"Line":0},"fn_name":"yclip\u003c\u0026closure-0\u003e"},{"line":371,"address":[6528923,6529067,6529263,6528203,6528255,6528399,6528543,6528779,6529407,6529119,6528975,6528635,6528491,6528111,6528059,6529355,6528687,6528347,6529211,6528831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[6529237,6528805,6528949,6528373,6528661,6528085,6529093,6529381,6528229,6528517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[6528664,6528808,6528232,6529384,6528952,6529240,6528376,6528088,6528520,6529096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[6528379,6529099,6528667,6529387,6528811,6529243,6528955,6528235,6528523,6528091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[6529610,6529472,6529598],"length":1,"stats":{"Line":0},"fn_name":"yclip_prefix\u003c\u0026closure-0\u003e"},{"line":392,"address":[6529499,6529548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[6529525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[6529528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[6529754,6529616,6529742],"length":1,"stats":{"Line":0},"fn_name":"yclip_suffix\u003c\u0026closure-0\u003e"},{"line":412,"address":[6529643,6529692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[6529669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[6529672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[6529760,6529824,6529952,6529888],"length":1,"stats":{"Line":0},"fn_name":"new\u003c\u0026closure-0\u003e"},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[6541663,6531954,6531984,6545551,6553327,6559200,6572946,6553344,6563106,6533952,6557250,6547536,6530016,6567072,6565074,6547506,6537810,6551407,6555282,6571008,6551424,6533922,6539760,6569010,6567042,6561168,6543648,6559183,6555312,6541680,6561138,6537840,6535855,6543618,6569040,6545568,6563136,6549504,6549474,6535872,6565104,6570978,6557280,6539743],"length":1,"stats":{"Line":0},"fn_name":"with_capacity\u003c\u0026closure-0\u003e"},{"line":503,"address":[6530096,6561294,6565184,6569120,6537953,6539827,6559280,6547616,6555392,6545648,6537907,6563216,6535952,6565230,6532110,6571134,6539873,6549571,6567198,6567152,6541760,6553470,6557347,6571088,6534019,6557393,6563262,6545694,6561248,6549617,6555438,6569166,6530142,6532064,6543715,6551491,6551537,6534065,6547662,6553424,6543761,6535998,6541806,6559326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[6549603,6539969,6530238,6538049,6539859,6555534,6571120,6536094,6571230,6541902,6545680,6547648,6547758,6553566,6543747,6553456,6569262,6530128,6537939,6565326,6545790,6561390,6567184,6543857,6532096,6535984,6559422,6551633,6534051,6567294,6561280,6551523,6559312,6555424,6563358,6541792,6563248,6549713,6569152,6557489,6557379,6532206,6534161,6565216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[6561372,6536137,6555577,6532188,6547801,6534143,6541945,6565369,6549695,6530281,6547740,6551676,6543839,6569305,6571212,6532249,6551615,6565308,6559465,6553548,6534204,6563340,6563401,6567276,6530220,6555516,6538092,6549756,6541884,6561433,6539951,6571273,6559404,6557532,6538031,6536076,6567337,6540012,6545833,6569244,6553609,6545772,6543900,6557471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[6532618,6553864,6548056,6569560,6565624,6571642,6552036,6571528,6538341,6540261,6565738,6540372,6555946,6557892,6546202,6551925,6530650,6569674,6542314,6546088,6538452,6534564,6561688,6557781,6559834,6567592,6530536,6563770,6553978,6532504,6536506,6544149,6550005,6544260,6542200,6550116,6555832,6559720,6536392,6563656,6567706,6534453,6548170,6561802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[6542524,6568030,6538659,6563980,6569998,6562012,6536830,6560158,6556156,6534771,6564094,6552357,6554188,6532942,6540579,6550323,6562126,6571966,6558099,6565948,6532828,6544467,6558213,6550437,6567916,6542638,6548380,6544581,6552243,6569884,6530974,6566062,6538773,6540693,6546526,6560044,6530860,6534885,6554302,6546412,6536716,6571852,6556270,6548494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[6552567,6550647,6564304,6558423,6556480,6533152,6531184,6566272,6542848,6544791,6538983,6570208,6535095,6562336,6568240,6537040,6546736,6554512,6540903,6560368,6548704,6572176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[6558541,6568358,6554630,6548822,6537158,6546854,6556598,6539101,6562454,6570326,6566390,6531302,6542966,6552685,6550765,6535213,6572294,6544909,6533270,6560486,6541021,6564422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[6572413,6564541,6543085,6556717,6545028,6550884,6537277,6566509,6558660,6560605,6554749,6568477,6552804,6570445,6546973,6562573,6535332,6548941,6539220,6531421,6533389,6541140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[6545154,6537405,6572541,6535458,6533517,6543213,6554877,6564669,6556845,6562701,6558786,6549069,6568605,6539346,6570573,6541266,6551010,6552930,6547101,6566637,6531549,6560733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[6556865,6543233,6558801,6552945,6533537,6572561,6551025,6539361,6554897,6541281,6562721,6537425,6535473,6560753,6566657,6531569,6545169,6564689,6568625,6547121,6570593,6549089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[6573232,6573296,6573040,6573104,6573168,6572976],"length":1,"stats":{"Line":0},"fn_name":"with_scoring\u003cbio::alignment::pairwise::MatchParams\u003e"},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[6573182,6573310,6572990,6573054,6573118,6573246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[6583596,6577456,6579500,6577452,6583600,6585629,6577437,6581547,6575404,6581532,6579504,6583581,6575389,6575408,6585644,6573360,6581552,6579485],"length":1,"stats":{"Line":0},"fn_name":"with_capacity_and_scoring\u003c\u0026closure-0\u003e"},{"line":540,"address":[6577504,6583648,6581633,6575489,6579584,6575456,6577537,6579552,6583681,6581600,6573408,6573441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[6575474,6583760,6579569,6573520,6573426,6583666,6575568,6579663,6581712,6581618,6577522,6577616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[6581704,6575560,6577608,6573570,6583752,6581762,6575618,6579655,6573512,6579713,6577666,6583810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[6579648,6575553,6581697,6573505,6577601,6583745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[6581815,6573562,6579766,6573623,6581754,6577719,6583802,6575610,6577658,6583863,6579705,6575671],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[6579698,6577651,6583795,6581747,6573555,6575603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[6577772,6579758,6573676,6573615,6575724,6575663,6577711,6581868,6579819,6583855,6583916,6581807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[6575656,6579751,6573608,6583848,6577704,6581800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[6577764,6579875,6583972,6581924,6583908,6573732,6573668,6575780,6575716,6581860,6577828,6579811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[6583901,6573661,6579804,6575709,6581853,6577757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[6581906,6575826,6573778,6583954,6577810,6581970,6584018,6573714,6579857,6577874,6575762,6579921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[6582333,6576078,6574141,6584270,6584381,6578237,6582222,6580284,6576189,6578126,6574030,6580173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[6578558,6576396,6580491,6574462,6574348,6582540,6584702,6582654,6578444,6580605,6576510,6584588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[6574672,6580815,6578768,6576720,6584912,6582864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[6580933,6578886,6582982,6576838,6585030,6574790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[6574909,6581052,6585149,6576957,6579005,6583101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[6575037,6581180,6583229,6577085,6579133,6585277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[7474909,7474924,6649164,7316128,6807964,6934989,7252608,6839728,7189084,7220848,7252604,6935008,6680909,6966749,7284364,7411404,6649149,7443164,7157309,6871488,7030288,7379648,7284349,6617404,7189088,7093808,6744444,6871473,6680924,6935004,7411389,6712688,7347869,7157324,7093789,6966768,6839709,6744448,6712669,6903248,7443149,7030269,7347888,7125568,6712684,7093804,6998528,6617408,7157328,7284368,6807949,7125564,7220844,7347884,7379644,6744429,6776204,7062044,6903229,7379629,6998509,7316124,7443168,6776208,6807968,6776189,7062048,6903244,7062029,6585648,7189069,6649168,6998524,7411408,6617389,7030284,6839724,6680928,6966764,7252589,7220829,7125549,7316109],"length":1,"stats":{"Line":0},"fn_name":"custom\u003cclosure-0\u003e"},{"line":578,"address":[7284500,7030420,7443300,6585780,6681060,6935140,7411540,6839860,7220980,6744580,6998660,7125700,7348020,7379780,7252740,7157460,6712820,7189220,6903380,6808100,6776340,7316260,6871620,7093940,6966900,7062180,6617540,6649300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[6839992,7062312,6776472,6744712,6808232,6585912,6998792,7221112,6712952,7284632,7379912,7252872,7348152,6617672,7443432,6649432,7030552,7157592,6681192,7316392,6935272,6903512,6967032,7189352,7411672,7125832,6871752,7094072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[6935462,6713142,6744724,6937747,7189364,7062502,6586102,7414147,7096547,7287107,6903524,7255347,7030742,6967044,6840182,6840004,6998982,7348164,7160067,7157782,6617862,7221302,6649444,7380102,6808422,7443444,7348342,6683667,6715427,6712964,7316404,6871764,6967222,6776484,7318867,7284644,6935284,7128307,6808244,6620147,6681382,7284822,7094262,7445907,6681204,7316582,6905987,6903702,7064787,6871942,6998804,6810707,6874227,6969507,7379924,6776662,6778947,7062324,7126022,7252884,7001267,7443622,7191827,7157604,7382387,7411862,7411684,6842467,7350627,7033027,6651907,6747187,7223587,6588387,7125844,7221124,6649622,6585924,7253062,7189542,7094084,6617684,6744902,7030564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[6681422,7411902,7316622,7348382,6967262,6935502,6999022,7253102,7062542,6808462,6617902,7443662,7126062,7284862,6840222,6649662,7030782,7094302,6776702,7189582,7380142,7157822,7221342,6744942,6713182,6586142,6903742,6871982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[7284944,6713264,6872064,6999104,6935584,6903824,7030864,7316704,7062624,7157904,7411984,7189664,7443744,6681504,7348464,7221424,7253184,7380224,6586224,7126144,6617984,6840304,7094384,6808544,6745024,6649744,6776784,6967344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[6872150,6776870,7285030,7189750,7126230,7316790,6713350,6745110,6808630,7380310,7221510,6903910,6618070,6999190,7030950,7348550,6681590,7443830,7094470,6935670,6840390,7412070,6967430,7062710,6649830,6586310,7253270,7157990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[6935756,6872236,7158076,6649916,7189836,6840476,6776956,6903996,6713436,7221596,7094556,7380396,6967516,6808716,7126316,6681676,7348636,7412156,7316876,7285116,7443916,6618156,7062796,6745196,7253356,6586396,7031036,6999276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[7031264,7094784,7158304,6967744,7317104,7221824,7380624,6777184,7063024,6840704,7285344,6999504,7126544,6650144,7348864,7253584,6618384,6713664,6904224,6745424,6586624,6681904,7412384,6935984,6808944,7444144,7190064,6872464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[7349088,6586848,7317328,6618608,7126768,7158528,7285568,6745648,7380848,6840928,6809168,6682128,7444368,6650368,7253808,7412608,6777408,7222048,6904448,6713888,7190288,7095008,7063248,6872688,6967968,6999728,6936208,7031488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[7381076,7412836,7063476,7317556,6682356,6650596,6618836,7349316,6745876,6777636,6841156,6872916,7222276,6936436,7254036,7285796,7031716,6714116,7126996,6968196,7158756,7190516,7444596,6587076,7095236,6999956,6809396,6904676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[7000075,7031835,6905860,7158896,7190635,6588260,6842340,7095355,6682475,7317675,7096420,6809515,6810580,6841275,6618955,6714256,7349456,6778820,7381195,6651780,7095376,6620020,6841296,6714235,7382260,6873056,6746016,7127136,7001140,7254155,7159940,6874100,7190656,6650715,7032900,6650736,6904795,6777755,7445780,7128180,7127115,6873035,7285915,6936555,6968336,7412955,7414020,6968315,6936576,7031856,6777776,7064660,7349435,7350500,6682496,6904816,6809536,7063616,6747060,6937620,7191700,7158875,7063595,7000096,7222395,7381216,7285936,7223460,7286980,6587216,6587195,7254176,7444736,6618976,6969380,7444715,6683540,7412976,7317696,6715300,7318740,6745995,7222416,7255220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[7412966,7444726,6587206,7031846,7222406,7254166,6650726,7349446,6618966,6714246,6841286,7095366,7190646,7317686,6873046,7158886,6904806,6777766,7063606,6936566,7285926,7381206,6682486,7127126,6968326,6809526,7000086,6746006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[6777810,6682530,7063650,7349490,6904850,6587250,7254210,7190690,6841330,7000130,6650770,7095410,6746050,6873090,7222450,7381250,7317730,6714290,6936610,6809570,6968370,7158930,7031890,7127170,7413010,7285970,7444770,6619010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[6904873,7095433,7222473,7254233,7285993,7190713,6968393,6587273,7317753,6777833,7158953,7031913,6650793,7349513,6809593,7127193,7381273,6873113,7413033,6682553,7444793,6714313,7063673,6936633,7000153,6841353,6746073,6619033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[6778149,7032229,6651109,7445109,6682869,6714629,6746389,6873429,6936949,7159269,6587589,7191029,7286309,7349829,7413349,6809909,6905189,6968709,7222789,7063989,7127509,6619349,7000469,7318069,7095749,7254549,6841669,7381589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[7318090,6714650,6778170,6619370,6936970,7286330,6841690,7000490,7381610,7127530,6587610,7254570,7222810,6651130,7413370,6905210,6809930,7032250,7191050,7445130,6968730,7349850,7064010,7159290,6682890,7095770,6873450,6746410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[7064174,7286494,6683054,6937134,7191214,6968894,6810094,7127694,7350014,7445294,6778334,7032414,7095934,6873614,7222974,6619534,7159454,7254734,6587774,7381774,6714814,6651294,6841854,6746574,7318254,7000654,6905374,7413534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":601,"address":[6810115,6683075,6841875,7000675,6778355,6968915,7191235,7222995,7254755,7381795,6619555,7413555,6937155,6587795,7286515,7064195,7127715,6905395,7318275,7095955,6714835,7445315,7159475,6746595,6651315,7350035,7032435,6873635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[6842039,6714999,6587959,6619719,7064359,7350199,7254919,7445479,7413719,6651479,6810279,7096119,6937319,7381959,7286679,6873799,7223159,7191399,6746759,7000839,6683239,6969079,6905559,7127879,7159639,6778519,7318439,7032599],"length":1,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[6810299,7191419,7223179,7318459,6683259,6842059,7064379,7254939,7032619,7127899,7286699,6651499,7000859,7350219,6619739,6969099,7445499,6905579,6873819,7413739,6746779,7096139,6937339,6587979,6715019,7381979,7159659,6778539],"length":1,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[6873980,7350380,7255100,7223340,6715180,6905740,7032780,6810460,7413900,7382140,6683420,7159820,6651660,6969260,7096300,7445660,6937500,6746940,6619900,7128060,7286860,6778700,6588140,7191580,7064540,6842220,7318620,7001020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[7001089,7032849,6905809,6778769,6810529,7223409,6651729,7445729,6683489,7318689,7255169,7064609,6969329,7350449,7128129,6937569,6874049,6715249,6619969,7159889,7096369,6842289,7191649,7382209,6747009,7286929,6588209,7413969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[7064665,7190666,7286985,6809546,7255225,7096425,7387056,7158906,6682506,6936586,7095386,7031866,7285946,7101216,7191705,7350505,7128312,6874105,6588265,7414025,6968346,7445912,6905865,6841306,6969512,6587226,7318872,7001272,7254186,6746026,7132976,6618986,7096552,7287112,6974176,6715432,6720096,7382392,6651785,6904826,6650746,7291776,7255352,6937625,7444746,7260016,6620152,7128185,7418816,7160072,6778825,7191832,7063626,7355296,7445785,7223465,6783616,7032905,6683672,7000106,6810712,7069456,6815376,7064792,6588392,6878896,6842345,7318745,6688336,7033032,7159945,6937752,7349466,6873066,6715305,7222426,6810585,7001145,6778952,7381226,6683545,7323536,7450576,7382265,7350632,7127146,6714266,7037696,6842472,7223592,7414152,6593056,6910656,6747065,6847136,7164736,6651912,7412986,6905992,6777786,7228256,6942416,7317706,7196496,6751856,6969385,6747192,7005936,6874232,6656576,6624816,6620025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[7445957,7223637,6651957,6874277,7160117,6715477,6906037,6810757,7255397,7414197,7033077,6778997,7382437,7318917,6969557,6747237,6683717,6842517,7350677,7064837,6937797,7128357,6620197,6588437,7191877,7287157,7001317,7096597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[6842525,7350685,7128365,7255405,6937805,6620205,6747245,6810765,7318925,6683725,6969565,7287165,7033085,7001325,6651965,7191885,7096605,7160125,6779005,7223645,6715485,7414205,7064845,7445965,6906045,6588445,7382445,6874285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[6875663,7161503,6621583,6683748,7191908,6810788,7160148,7318948,7350708,6653343,7066223,7288543,7096628,7064868,7225023,7001348,7445988,7382468,6843903,7255428,7383823,7034463,7415583,7097983,7129743,6588468,7002703,7128388,6842548,6780383,6715508,6747268,7414228,6685103,6970943,7193263,6939183,7447343,7223668,6937828,7352063,6589823,6779028,6620228,6812143,7033108,6906068,6716863,6748623,6874308,6651988,6969588,7320303,6907423,7287188,7256783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[6843579,7319979,7128402,7383499,6652002,7097659,6937842,7191922,6969602,7065899,6874322,7414242,7446002,7350722,6970619,7033122,6938859,6779042,7192939,6780059,7160162,7064882,6748299,7447019,7001362,7318962,7161179,7382482,7129419,6747282,6716539,6810802,7034139,6842562,7288219,7415259,6683762,7096642,6684779,6588482,6875339,6715522,6620242,7224699,6906082,6589499,6621259,7223682,7287202,7002379,6907099,7256459,6811819,6653019,7255442,7351739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[6652053,7319013,7255641,7096693,6747333,7033321,7350773,7287253,7191973,7382681,7414293,6588533,7160213,7160361,7223881,7223733,7192121,6683961,6906133,6620293,7065081,6715721,6779241,6969801,6779093,7446053,6842761,7001561,6874521,7001413,7128453,6652201,7128601,6588681,7414441,7064933,7319161,7287401,7382533,6620441,6747481,6937893,7350921,6810853,7446201,6811001,6842613,6683813,6874373,7096841,6969653,6938041,7033173,6906281,7255493,6715573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":617,"address":[7033366,7160406,7382805,6938165,7319206,7319285,7446325,7319133,7414413,6747453,7414486,6747526,7033293,6747605,7446173,6652325,7001606,6874566,7446246,6588653,7065053,7350893,6715766,7096965,6652173,6969773,7223926,6715693,6779286,6906253,6874645,7351045,6906326,7065126,6684006,7255686,6683933,7065205,7223853,7096813,7255765,7287525,6779213,7128725,6938013,7128646,7192245,6842806,7414565,6652246,7096886,7001685,7224005,6715845,6969925,6969846,6620486,7160485,6842733,7160333,6811125,7128573,7255613,6842885,6810973,7192166,7350966,6588805,7287373,6811046,6620565,6684085,6779365,6620413,7382653,6938086,6588726,7001533,7382726,6874493,7287446,7033445,7192093,6906405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[7096959,6969919,6747969,7192609,7129089,7446689,7033439,6906769,7224369,7351726,7447006,7256129,6589169,6589486,6684449,6779729,7129406,6906399,6621246,7002366,7160479,7255759,7351039,7414929,6620559,7446319,6748286,6684766,6875326,6938846,6716526,7192926,7415246,7319649,7065886,7382799,6811489,6715839,7192239,7097646,6716209,6653006,6652689,6842879,7256446,7287889,7160849,6875009,6684079,6779359,7033809,6970289,6970606,7287519,7065569,7319966,6620929,7351409,7319279,6811119,6938159,7288206,6811806,7383486,6907086,7002049,6874639,6588799,6938529,7097329,7065199,6652319,7161166,7001679,6747599,7223999,6780046,7414559,7128719,6843566,7224686,6843249,7383169,7034126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[7446391,7414631,7382871,7192311,7033511,6620631,6747671,6938231,6652391,7097031,6779431,7001751,6906471,6684151,7224071,7160551,7319351,7128791,7351111,6811191,6715911,6874711,6842951,7287591,6588871,7255831,7065271,6969991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[7001723,6906443,6842923,7414985,7192665,6970345,7414603,6843305,6684123,6716265,7097003,7033483,7160905,7033865,6652363,6620603,6588843,7319705,7192283,6620985,6938585,6684505,7382843,6938203,6969963,7160523,6811545,7351465,7002105,6906825,7255803,7128763,7351083,6715883,7319323,6652745,6874683,7446745,7097385,7224043,6747643,7129145,6589225,7065243,6748025,7224425,7256185,7383225,6779785,7065625,6779403,6875065,6811163,7287945,7446363,7287563],"length":1,"stats":{"Line":0},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[7033827,7351427,6971160,7446707,7225240,7193608,7288888,7192627,6875027,7257128,6717080,6747987,7352408,6716227,6907640,6812360,7034680,6653688,6844248,7034808,6589187,7003048,7288760,6939528,7002067,7352280,7193480,6684467,6653560,6875880,7098200,6685448,7257000,7066440,6844120,7129960,6621800,7097347,6652707,7319667,6780600,7320520,7415800,7384168,7225368,6685320,7383187,7224387,6779747,6811507,6938547,7256147,6590168,6590040,7129107,6748968,6843267,6971288,7098328,7065587,6748840,7447560,6780728,7002920,6970307,7447688,7066568,6621928,7414947,6620947,7384040,7287907,6812488,7415928,6907768,7161848,6906787,7160867,7320648,7161720,6939400,6717208,7130088,6876008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[6685116,6717130,7256796,6907436,7320316,7352330,7225036,6716876,6843916,7288810,7097996,7225290,7098250,7034730,6685370,7288556,6780396,7193530,6844170,6589836,7161516,7257050,7383836,6748890,7034476,6875676,7066490,6812410,6812156,6780650,6621850,7161770,6653610,7066236,6590090,7320570,7002970,6653356,6970956,6939450,7193276,6748636,7415850,7384090,7447610,6971210,6875930,7352076,7130010,7447356,6939196,6907690,7129756,7002716,7415596,6621596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[6813156,6748850,6907794,7288770,7130114,7257796,6749636,6812514,7193634,7448356,6717090,6876034,6748994,6685330,7288914,7225394,6844274,7321316,7257010,7067236,7320530,7129970,7415810,7384050,7034690,7447714,7098210,7161730,7161874,6590194,7098996,6781396,6590050,6621954,7352290,7003074,7066450,6653570,6590836,7035476,6876676,7098354,6939410,6812370,6907650,7352434,7353076,6844916,6717876,6971314,6622596,7066594,7447570,6686116,6971956,7320674,6685474,6908436,7415954,7384194,6717234,7034834,7130756,7257154,6780754,6780610,6844130,7225250,6621810,7289556,6875890,7226036,7194276,6653714,6971170,6939554,7003716,7002930,7162516,7193490,7384836,7416596,6940196,6654356],"length":1,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[7193852,7320892,6876252,6971532,7130332,7257372,6812732,6622172,7416172,7352652,7066812,6717452,7384412,6939772,6908012,7098572,6590412,7003292,7289132,6653932,6844492,7225612,7162092,6685692,7447932,6780972,6749212,7035052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[6940683,7290043,6940214,6845403,6971974,7099483,6876694,6718363,7384854,6686134,7258283,6781883,7131243,7130774,6590854,7321803,7099014,6654374,7194763,6654843,7035494,7321334,6622614,7257814,6972443,7035963,7004203,7067723,6877163,7353094,7353563,7067254,7163003,7448843,6686603,7417083,6591323,6717894,6749654,7448374,6844934,6813643,7194294,7416614,7162534,6908454,6623083,7003734,6781414,7385323,6908923,7226523,7226054,6750123,6813174,7289574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[6718048,7289728,7416768,6749808,6781568,6940368,7385008,7194448,7162688,7448528,6845088,6591008,6686288,7257968,6654528,7226208,6622768,6876848,7099168,7067408,6813328,7321488,7353248,7035648,6908608,7130928,6972128,7003888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":645,"address":[6781901,7417101,7194781,7353581,7226541,6686621,6972461,7163021,6750141,6591341,7385341,7067741,7290061,6908941,7099501,7035981,6623101,7321821,6877181,6718381,7448861,7004221,6845421,6940701,7131261,6654861,7258301,6813661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[7099857,7449217,6877537,6655217,6623457,7385697,7417457,6972817,7195137,7131617,7068097,7036337,6686977,7163377,7290417,6845777,7322177,6591697,7353937,6909297,7258657,6750497,7004577,6718737,6941057,6814017,6782257,7226897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[7449528,6782568,6750808,7036648,7004888,6687288,6623768,6846088,7354248,6719048,6909608,7290728,7195448,6973128,7100168,7163688,7068408,6941368,6592008,6877848,6814328,7417768,6655528,7386008,7322488,7131928,7227208,7258968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":650,"address":[6973647,6941864,6719165,6719544,7386527,7418287,7354365,7322605,7449645,6592527,7259085,6878344,6687807,6814847,6783064,6910104,7417885,7322984,7291224,6878367,6910127,7195944,7291247,7418264,6941887,7100687,7132447,7132045,7227727,6624287,7164207,6846205,7100285,7290845,6973245,7323007,7037144,7259487,6624264,6814824,7227704,6814445,6750925,6877965,6783087,7132424,6656024,6751304,6687784,7227325,7354767,7195967,7068525,7005005,6656047,7450047,7036765,7005384,7354744,6623885,7195565,7037167,6751327,7100664,6973624,6655645,6941485,6592125,6719567,6846584,6846607,7005407,6592504,7164184,7386125,7163805,6782685,7386504,7259464,6687405,7450024,6909725,7068927,7068904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":651,"address":[6750951,7100662,7068902,6719191,6973271,6814822,7291222,6846231,6782711,7164182,6592502,6624262,6783062,7354742,6941511,6751302,7418262,6592151,6655671,6941862,7449671,7227351,7290871,7450022,7195942,7259111,7322631,7005031,7163831,6973622,7259462,7386151,7354391,7227702,6909751,6878342,7068551,7132422,7386502,7005382,6877991,7322982,6814471,6623911,6719542,6656022,6687431,7195591,6687782,6910102,7036791,6846582,7037142,7417911,7100311,7132071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[6878354,7195954,6687794,7005394,6941874,7132434,6624313,7418274,7068953,7386553,6973634,6941913,6751314,7100713,6846594,7450034,6719554,6910114,7195993,7005433,7164233,6910153,7418313,7450073,6656073,7227753,6846633,6624274,7164194,7037154,6592514,7322994,6751353,7291273,7100674,6656034,6783113,6592553,7132473,6719593,7386514,7068914,7259513,6687833,7354793,7354754,6814834,6878393,6814873,7227714,7291234,6973673,6783074,7259474,7037193,7323033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":655,"address":[6815082,7037402,7227962,7259722,7291482,6910362,6624522,6656282,7196202,6719802,6751562,7355002,6846842,7132682,6942122,6783322,7450282,7386762,6592762,6688042,7069162,7323242,7100922,7164442,6973882,7005642,6878602,7418522],"length":1,"stats":{"Line":0},"fn_name":null},{"line":656,"address":[6783569,6974129,7355249,6815329,7418769,6910609,6751809,6656529,7005889,6688289,7259969,7450529,6942369,7387009,7164689,6624769,7132929,7101169,7037649,6720049,7069409,6593009,6878849,7228209,7291729,7323489,7196449,6847089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":661,"address":[6847294,7196654,6815381,6935438,7328733,7169933,7316558,6783774,7348318,7296973,6947613,6903678,6751861,7221278,7418974,6713118,7030718,7101221,6624974,6617838,6942421,6757053,7323541,6688341,7011133,7006094,7291781,7037701,6624821,7265213,6693533,6847141,6593214,7233453,7443598,7387214,6656734,7260021,6649598,7355301,6840158,7196501,7450581,7074653,6884093,7355454,6720101,7323694,6586078,7133134,6752014,7132981,6979373,7360493,7411838,7387061,6744878,6808398,6852333,7253038,6915853,6783621,6878901,6910661,6942574,7062478,6871918,7228414,6661773,6788813,7005941,6998958,6681358,7189518,6910814,7418821,6967198,7157758,6776638,7284798,6656581,6598253,7450734,7042893,6974181,6688494,7392253,6820573,6725293,7260174,6815534,6593061,6879054,7106413,7291934,7455773,7164741,7069461,7380078,7164894,6630013,7228261,7201693,7125998,7037854,7424013,7069614,7101374,6720254,7094238,6974334,7138173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":662,"address":[6974374,6847334,6879094,6720294,7228454,6942614,6656774,7355494,7037894,7419014,7133174,7260214,6783814,7196694,7006134,7291974,6910854,6688534,7387254,7069654,6815574,6752054,7450774,7164934,6625014,6593254,7323734,7101414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":663,"address":[7196768,7291994,6910928,7228528,7069728,6847408,7228474,6720368,6815648,7292048,6815594,7006154,6752074,7165008,6688608,7101434,7387328,7037968,7355514,7006208,7419088,6656848,6625088,7323808,7037914,7419034,6879114,7355568,6625034,6656794,6847354,6783834,6720314,6593274,6783888,7323754,7069674,6942688,6974394,7260234,7260288,6593328,7196714,7133248,6910874,6752128,6879168,7387274,6974448,6942634,7450848,6688554,7164954,7101488,7133194,7450794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[6752118,7133238,6974438,7228518,6656838,7069718,7419078,7101478,7196758,6783878,6720358,6942678,6625078,7260278,7355558,6688598,7006198,7323798,7292038,6593318,7387318,7164998,6910918,6815638,6847398,7450838,7037958,6879158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[7260326,6942726,7006246,7323846,7069766,6974486,7419126,6910966,6752166,7196806,7292086,6720406,7228566,6847446,6688646,7101526,6625126,6783926,7038006,6879206,6815686,6656886,7387366,7133286,7355606,7450886,6593366,7165046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[7228681,7323961,6847561,7452354,7069881,6688761,7006361,7007714,7293554,6848914,6911081,6784041,7388834,7357074,6879321,7451001,7039474,6657001,6753634,7133401,6625241,6721874,6785394,6944194,7261794,6912434,7102994,7260441,6626594,7325314,6975954,7196921,6817154,7387481,6594834,6720521,6942841,7071234,6658354,7198274,6815801,7134754,7230034,7292201,6690114,7166514,7419241,7420594,7101641,6752281,6880674,6593481,7165161,6974601,7355721,7038121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":671,"address":[6625255,7039150,7356750,7007390,6942855,7229710,6657015,6753310,6626270,7228695,6974615,6689790,7323975,7420270,6721550,7292215,7101655,6816830,7293230,7324990,6848590,7038135,7069895,6593495,6943870,6784055,7387495,7451015,6911095,7355735,7165175,7102670,7134430,6785070,6688775,7166190,7006375,6912110,7452030,6658030,6815815,7197950,6752295,6975630,6594510,6880350,6720535,7260455,6847575,7070910,7419255,7261470,7133415,7388510,6879335,7196935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":672,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":675,"address":[6974666,6943054,7197134,7324026,7355934,7228894,6593546,6784106,7101706,7355786,7387546,7038334,7451066,6625454,6625306,6688826,6911294,7006574,7419454,6879534,6720734,6816014,6752346,7260506,6720586,6815866,7292266,7228746,7133614,7165226,7196986,6688974,7101854,7260654,7070094,6847626,7006426,6911146,6657214,6879386,7324174,6847774,7069946,6752494,6657066,6942906,7451214,7038186,7419306,7165374,6974814,7292414,7133466,7387694,6784254,6593694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[7165498,6752466,6752618,7101826,6593739,6720706,7260699,7006546,6784226,6847819,6593666,7387666,7260626,6911418,7229018,6815986,6879506,7101899,6911266,6625578,6657338,7451259,7133659,7006619,7070139,7292538,7038458,6625499,6593818,6974859,6911339,6879579,6943178,6974786,6784378,7292459,6879658,7419426,7387739,7355979,7451186,6720779,7038306,7197106,6943099,6625426,7356058,6847746,6688946,6847898,6784299,7070066,7133586,7133738,7228866,7419578,7197179,7419499,6689098,6974938,6720858,7355906,7165419,7006698,7197258,6657259,7451338,7070218,7101978,6943026,6816059,7038379,7324219,6657186,7324298,7387818,6752539,7165346,7324146,7260778,6816138,7228939,6689019,7292386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":677,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[7133732,7292532,7007377,7197252,6721537,6880022,7292902,6911782,6974932,6911412,7197622,6626257,7039137,7134417,6816817,7260772,7387812,7388497,6816502,6594182,6943857,7038452,7007062,6689092,6848262,7102342,7261457,6816132,7420257,7229382,6657332,7452017,6720852,7070212,6879652,7356737,6593812,7101972,6943172,6625572,6975617,7229697,7134102,6912097,7388182,7006692,7356422,7324662,7451702,7038822,6721222,7419942,6847892,6752982,6657702,7229012,7166177,6785057,7293217,6784372,6848577,7261142,6943542,6689462,6594497,6784742,6689777,6975302,7197937,7356052,7165862,7165492,7102657,7070582,6625942,6658017,7324977,7070897,6880337,7451332,7419572,6752612,7324292,6753297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":679,"address":[6911484,6689164,6752684,7006764,7292604,6784444,7165564,6625644,6975004,7197324,6720924,6847964,6943244,7133804,7324364,7102044,6816204,6657404,7070284,6593884,7260844,7387884,7356124,7229084,7038524,7451404,6879724,7419644],"length":1,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[6721268,6943588,6974976,7419616,7102388,6880068,7324708,6911456,6752656,7388228,6594228,7292576,6784416,7292948,6593856,7133776,6720896,7006736,7451376,7356096,6943216,7038496,6816176,6753028,6625616,6657748,7134148,7197668,7261188,7165908,6784788,6847936,7356468,7070256,6625988,6657376,7197296,7102016,7007108,6975348,7165536,7229428,6816548,7419988,7451748,7229056,7324336,7038868,6911828,7387856,7070628,6848308,7260816,6689136,6879696,6689508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[7134112,7292912,6975975,7070592,7167423,7103586,7197632,6881266,6594192,6880032,6976863,6912455,7262703,7261152,7134775,6849506,6785986,6880695,7293575,6657712,6944215,7262386,7198866,7357983,7389743,6595426,6722783,7451712,7039495,7229392,7167106,7103903,7452375,6658375,6786303,7008623,7421186,6976546,6817175,7420615,6913343,6943552,7007735,7102352,7230943,7230055,6721895,6848272,6944786,7294463,7103015,7389426,6754226,6752992,6848935,6658946,7326223,6691023,7040383,6913026,6817746,6911792,6626615,7040066,6721232,6627186,7198295,7419952,7007072,6816512,7388192,7325335,7261815,7038832,6625952,7008306,6689472,7421503,7072143,7071255,7135663,6945103,7325906,7357666,6784752,6595743,6818063,6690706,6753655,7165872,6594855,7357095,6722466,6627503,7071826,6881583,7388855,6975312,7166535,6659263,6849823,7452946,7135346,7199183,6785415,7356432,6690135,7294146,7453263,7230626,7324672,6754543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[6849086,6817326,7134926,6976126,6944366,6753806,7198446,7261966,7166686,6626766,7357246,7230206,7007886,7103166,6912606,7293726,6722046,6785566,7452526,6880846,7420766,6690286,7389006,6658526,7325486,6595006,7071406,7039646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[7039605,6722005,7071365,7071874,6849045,6817285,7293685,7166645,6880805,7103634,6944325,6944834,7388965,6626725,7294194,6627234,7008354,7007845,6595474,7103125,7261925,6754274,6785525,6976085,7421234,7198405,7262434,7325954,6690245,7325445,7040114,6658994,7135394,7452994,6881314,7452485,6913074,7230165,6976594,6786034,6753765,6722514,7357714,6817794,7230674,7389474,7167154,7134885,7420725,6658485,6912565,7357205,7198914,6690754,6594965,6849554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[6786911,6913951,7357684,6596351,7262708,6976564,6849524,7389444,6945108,6850431,6977471,7072751,6627508,6881588,7230644,6659268,7389748,6944804,7040388,6658964,7294468,7104511,6976868,7199791,6628111,7295071,7452964,7040991,6595748,7262404,6786004,6818068,7167428,7326228,7453871,7421508,7167124,7136271,7072148,7009231,6755151,7135364,6659871,7358591,6722788,6690724,6849828,6818671,6754548,7421204,7390351,6881284,6691028,7263311,6913044,7040084,7230948,7103604,7326831,7199188,6945711,6786308,6722484,7325924,6882191,6913348,7453268,6723391,6817764,7103908,7294164,7135668,6595444,7008628,7198884,7008324,6627204,7357988,7071844,6691631,6754244,7231551,7422111,7168031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[6881837,7453517,7008877,6723037,6691277,7199437,7135917,7262957,6913597,7231197,6754797,6977117,7326477,6945357,7072397,7167677,7358237,7389997,7104157,6818317,7421757,6850077,7294717,6659517,6786557,6627757,6595997,7040637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[6882565,7136645,7454245,7358965,6659489,7199409,6881809,6755525,6945329,6850049,7263685,7137202,7421729,6596725,6786529,6754769,7041922,6628485,6787842,7041365,6850805,7390725,7135889,7040609,6597282,7296002,6977845,7423042,7358209,6660802,7105442,7453489,6692005,7327205,6818289,6819045,7262929,7072369,7391282,7231925,7327762,6883122,6914882,6978402,7232482,7231169,6723765,6595969,7359522,6629042,7104129,7073125,7422485,6851362,7294689,6627729,7104885,7326449,7168405,7009605,6913569,6692562,7010162,7200165,6787285,6946642,7008849,7295445,7200722,7454802,6756082,6819602,7167649,7389969,6660245,6946085,6977089,6691249,7264242,6723009,7073682,6914325,6724322,7168962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":700,"address":[6914534,7390934,6755734,6787494,6946294,7263894,7041574,7105094,6723974,7327414,7232134,7422694,6660454,6596934,6692214,6628694,7295654,7454454,7009814,7073334,6851014,7136854,6882774,7168614,7200374,7359174,6978054,6819254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[6851253,7422933,6819493,6628933,6724213,7295893,7391173,7041813,7359413,6692453,7010053,6883013,7232373,7264133,6660693,7168853,6946533,7454693,7073573,7105333,6787733,7137093,6597173,6914773,7327653,7200613,6755973,6978293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[7009249,7263664,6818689,7358944,6946064,7422129,7104864,6914304,6723409,6755504,7326849,6596704,7231904,6850449,7327184,6660224,6755169,7041344,6882209,6659889,6596369,6787264,6977489,7295089,7009584,7168049,6977824,7200144,7041009,6945729,6850784,6882544,7073104,7422464,7454224,7136289,7263329,6691649,6691984,6819024,7390704,6786929,7199809,7072769,7104529,7136624,7168384,7390369,7295424,7231569,6913969,6723744,6628129,7358609,6628464,7453889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[6788195,7327960,6819800,6946655,7137215,7391480,7200920,6724335,6883135,7137555,6978755,7359535,7137400,6883475,7232495,6597295,6851715,7296355,6629055,6914895,7423240,6661155,7168975,7042120,7454815,6661000,7105795,7391635,6629395,7041935,6946840,7327775,6883320,7010175,7264255,7105455,7074035,6756435,7010360,6915235,6788040,6978600,7232680,6851560,6597480,7328115,6597635,6629240,6756095,7169315,7296015,7264595,7073880,6692760,7042275,7169160,7200735,6946995,6724520,6724675,7455000,7201075,7359875,7391295,7423055,6851375,6915080,7010515,7455155,6660815,6692575,7264440,7073695,7423395,7232835,6756280,7105640,6692915,6819615,7296200,7359720,6819955,6787855,6978415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[7296240,7455040,6629280,7264480,7073920,7232720,6724560,6819840,6883360,6692800,7359760,7423280,7328000,6788080,7391520,7105680,7137440,7169200,6946880,6915120,7042160,7010400,7200960,6661040,6851600,6756320,6597520,6978640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[7010710,7296550,6788390,7010324,7328136,6947016,6978950,7296164,7201096,6915430,6756244,6724696,7423204,7137364,6629204,7328310,7232644,6756456,7074230,7137576,7327924,7264790,7391444,6788004,6661176,7454964,7105816,7105604,6851910,7074056,6597830,6597444,7042084,6724870,6819976,6883284,7169510,6946804,6851524,7359896,7042296,7264404,6915044,6692724,7296376,7233030,7423590,7200884,7042470,6692936,6820150,6629590,7137750,6819764,7073844,7455176,7360070,6756630,7169124,7423416,7169336,6693110,6724484,6978776,6883670,6660964,6788216,7455350,7201270,6851736,7232856,7391656,7010536,7359684,6661350,7391830,6629416,6947190,6883496,7105990,7264616,6597656,6978564,6915256],"length":1,"stats":{"Line":0},"fn_name":null},{"line":712,"address":[7423742,6693030,7264942,6724790,6947401,6661502,7042681,7455270,7423801,7137961,7137902,7328521,7074150,7169721,6629510,6820302,7328230,7296470,6725081,7233182,6978870,6725022,6883881,7106201,7010630,7169430,6661270,7233241,7392041,7391750,7423510,6693262,7106142,6756841,6979161,7455561,7391982,6788310,7360222,7328462,6883590,6788542,6979102,6947342,7296702,6820361,7074382,6597750,7042390,7010862,7201481,7360281,6597982,7201190,6693321,6756782,6851830,6629801,7265001,7232950,7137670,6852121,6788601,7264710,7296761,6756550,6915350,7169662,6852062,7010921,6947110,7074441,6915641,6661561,7042622,6820070,6598041,7359990,7455502,6883822,6915582,6629742,7105910,7201422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":713,"address":[7042564,7201364,7010804,6979044,7169604,6597924,7360164,7137844,7233124,7455444,7296644,7391924,6820244,6724964,6788484,6947284,7106084,6915524,6852004,6629684,7074324,7328404,6883764,6756724,6693204,7264884,6661444,7423684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":714,"address":[6629523,6724803,6661283,6820083,6947123,6756563,6693043,7391763,6883603,6851843,6788323,6597763,6978883,6915363,7264723,7232963,7201203,7010643,7296483,7423523,7074163,7137683,7455283,7169443,7328243,7042403,7360003,7105923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":715,"address":[6788498,7042578,6947298,7074338,6629536,6947222,6852018,7391776,6978896,7328418,7360178,7169456,6979058,7455382,6724902,6915462,7010656,7137858,7201378,6820096,6883702,7328342,7010818,6851856,6661296,6756576,7232976,7423536,6915538,6820182,6915376,6756662,6693218,7106098,7455296,7105936,7169618,7264822,6693056,6788336,7233062,7042416,7328256,7360102,7137696,6661382,7423622,7201302,6597862,7201216,6629622,7391938,6693142,7106022,7233138,6978982,7455458,6756738,6788422,7296582,6820258,6597776,7360016,7074262,7010742,7264736,6724978,6597938,6883778,7391862,7169542,6724816,7296496,6851942,6661458,7296658,6947136,6883616,7074176,7042502,6629698,7264898,7137782,7423698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[7042660,6693300,7296740,6661599,6629839,7018668,7082188,7463308,7296978,7169759,6884098,6955148,7137999,6852100,7074479,7106418,7011138,7137940,6669308,6852338,7265039,7201698,6979140,7360498,6915679,7201519,6725298,7169700,7328559,7423780,7106180,7399788,7328738,6701068,7424018,6923388,6788818,6630018,6979378,6693538,6788639,7392079,7201460,7360319,6828108,6661778,7138178,6820340,6598258,7010959,6598020,7368028,6764588,7360260,6891628,7233458,7265218,6947439,7177468,7264980,6598079,7423839,6637548,6820578,7050428,6947380,6732828,7113948,7455778,7455599,6986908,7042719,6629780,7074658,6605788,6883860,7233220,7145708,6796348,6820399,7455540,7074420,7328500,6661540,7272748,6788580,7106239,6979199,6757058,7169938,7233279,6859872,7010900,7240988,6915858,6756879,7392020,6915620,7431548,6693359,7296799,7042898,6725119,7392258,7336268,6883919,7304508,7209228,6756820,6852159,6947618,6725060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[6979559,7233498,7297018,6725338,7138359,6947799,7455959,6630058,6693719,6820759,7011319,6788858,6916039,7424058,6979418,7328778,6725479,7455818,6820618,7170119,7360538,7043079,7201738,6884138,6661959,7265258,6693578,7328919,7106599,6630199,7106458,7138218,7011178,6598439,6661818,6884279,6852519,6757098,6852378,7424199,7169978,6757239,7201879,7074839,7042938,6598298,7360679,7392439,7392298,7265399,6947658,7074698,6788999,7233639,7297159,6915898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[7138333,6788973,7455933,6725453,6916013,7424173,7265373,6947773,7043053,7360653,7392413,7201853,6852493,6598413,7074813,6979533,7297133,6630173,7233613,7106573,6820733,7328893,6693693,6661933,6884253,6757213,7011293,7170093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[7202210,7424530,7455985,7170450,6979585,6598770,6630225,7075170,6884610,6598465,7011345,6789330,7392770,6725505,7424225,7011650,7138385,7043105,7138690,6916370,7233665,6662290,6852545,7456290,6947825,7329250,6757265,7233970,6757570,6694050,6725810,7043410,6630530,7361010,7360705,6884305,6661985,7297490,7106930,6693745,7201905,7265425,6916065,7106625,7328945,6852854,7074865,7265730,6789025,6948130,6979890,6821090,6820785,7297185,7392465,7170145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":723,"address":[6916632,7075224,7361272,7456277,6662277,6948184,6979944,7138677,6599032,7106984,7297477,6884664,7107192,7202264,7424792,7011912,6662344,7424517,7138744,6916357,6694312,6852841,7106917,7075157,7456344,6630584,7170712,7011704,6694104,7329512,6598824,7392824,6598757,6725797,6821352,7075432,7234024,7360997,6884597,7297752,7297544,6757832,7170437,6948392,7265784,7202472,7202197,6821144,6789317,6853116,7011637,6884872,6948117,7393032,7392757,7043672,6852908,6630517,6789592,7424584,6979877,7043464,7233957,7265717,7456552,6821077,6757624,7234232,6726072,7361064,6725864,7170504,6694037,7138952,6662552,6980152,7265992,7329237,6789384,6757557,6916424,6630792,7329304,7043397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":724,"address":[6980139,7424779,7202526,7075486,6662877,7329837,7107246,6789579,7393019,7361597,6948379,7138939,6948446,6916686,7107179,7107517,7297806,6821339,6757886,6726059,7075419,6916619,7043659,6885197,6726397,7202797,7202459,7075757,6630779,6757819,6916957,6630846,7297739,7266317,7393086,6631117,7139006,7043726,7456877,6789917,7171037,7139277,6853103,7361259,7425117,7170699,6662606,7329499,6599019,6884926,6694366,7012237,7043997,7234286,6599086,6789646,7170766,6853441,7011899,7234219,6853170,6821406,7298077,7424846,6694637,7329566,6726126,7456606,7234557,7265979,7361326,6599357,6884859,7266046,7456539,6948717,6694299,6980206,6980477,7393357,7011966,6662539,6821677,6758157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":726,"address":[6759208,6980778,6821978,7299128,6631111,7107511,7203098,7457178,6758151,7456871,7425418,7012231,6980471,7203848,7107818,7426168,6822728,6949018,7013288,7139271,6727448,6821671,7266618,7329831,7361591,7330888,6916951,6694938,6632168,7234858,7171338,6726698,7330138,7140328,7393658,7075751,6631418,7393351,7012538,7045048,7076808,7267368,6917258,6853435,6853742,6948711,6790968,7362648,7425111,6599351,6600408,6663928,7108568,6662871,7266311,6854492,7457928,6981528,6758458,7139578,7172088,6918008,6694631,7235608,6726391,7202791,6695688,6599658,7394408,6949768,6790218,7298071,7076058,6886248,6885498,7171031,6663178,6789911,6885191,7361898,7234551,7044298,7043991,7298378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":727,"address":[7202907,6758267,7012347,6821787,7456987,7266427,6980587,6631227,7329947,7044107,6726507,7234667,6885307,7107627,6790027,6948827,7075867,6917067,7139387,6853551,7298187,7393467,6694747,6662987,7425227,6599467,7171147,7361707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":730,"address":[7425170,6948770,6662930,7075810,6821730,6789970,6885250,7107570,6758210,6980530,6726450,7361650,6694690,7234610,7266370,7171090,7044050,7393410,6853494,6599410,6631170,7456930,7329890,6917010,7202850,7012290,7139330,7298130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":731,"address":[6663543,7171097,6662937,7394023,7456937,6917017,7108183,6980537,6949383,6694697,7203463,7107577,6727063,7457543,6853501,7139943,7298743,6822343,6758217,6790583,7044663,6948777,6631783,7012297,7425783,6854107,7266377,6600023,7234617,6758823,6821737,7425177,7044057,6789977,7171703,6917623,6726457,7202857,7329897,7139337,6981143,7393417,6885863,6885257,7330503,7362263,6631177,6599417,7361657,6695303,7298137,7012903,7075817,7235223,7076423,7266983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":734,"address":[7266628,7108734,7330148,7076837,7299157,7330917,6853752,7426197,6949028,6791134,7394574,7203877,7172254,7013317,6727477,6949934,6790997,7203108,7234868,6726708,7361908,6790228,6822757,7204014,7140357,6759237,7362677,6854521,6695717,6759374,7107828,6981557,6885508,6918037,6600574,7426334,6980788,6918174,7394437,7458094,7457957,6694948,7299294,7140494,7013454,6854658,7235637,6949797,7362814,6632197,6981694,6664094,6695854,6821988,7045077,7298388,7108597,7235774,6631428,7139588,6886414,7425428,6727614,7044308,7171348,7045214,6599668,6758468,6600437,7172117,6917268,7076068,7267397,7076974,6822894,6663188,6886277,6632334,6663957,7331054,7267534,7393668,7012548,7457188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[6632388,7204264,7426388,7108721,7140744,7426584,7140481,6918161,6791384,6823144,7045464,7458081,7362868,6886468,7458148,7458344,7236024,7299544,6791121,7394561,6727668,6600824,6695908,7299348,6600628,6727864,6950184,6695841,6854645,6854712,6664148,7045268,6791188,6949921,6632584,7108984,6981681,6981944,7362801,6600561,6759361,7394824,6696104,7331041,6822881,7267784,7045201,7331108,6981748,6886664,7108788,7204001,6759624,6886401,7077028,6822948,7172308,7140548,7172241,6918424,7076961,6918228,7394628,6759428,7235761,7077224,7426321,6949988,7363064,7331304,7013441,7172504,6632321,7267521,6727601,6664344,7204068,7267588,7235828,6664081,7013704,7299281,6854908,7013508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[6728165,7077218,7045458,7140738,6792617,7172805,7205497,6791685,7426578,7204258,6664338,7013698,7141977,6602057,7300777,6601125,7299538,7110217,6950178,6759925,6918418,6729097,7331605,7426885,7363365,7394818,7396057,6855209,7236325,6919657,7204565,7077525,6887897,6664645,6696405,7109285,6632578,6665577,7014937,7299845,6982245,6918725,6633817,7269017,7045765,7237257,6854902,7141045,7014005,7331298,7108978,7395125,6856141,6951417,6983177,7332537,6886965,6886658,6632885,7427817,6823445,6824377,7364297,6600818,6727858,7267778,7173737,7363058,6697337,6759618,7268085,6791378,7459577,7046697,6823138,6950485,7458338,6981938,7458645,7078457,7236018,6760857,7172498,6696098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":738,"address":[7331414,7236134,7109094,6886774,7172614,7299654,7426694,7045574,7013814,6855018,6600934,7363174,6950294,7077334,7204374,6823254,7267894,6982054,6759734,7394934,6664454,6727974,7140854,7458454,6696214,6632694,6918534,6791494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":741,"address":[7363117,7331357,7172557,6886717,7267837,6600877,6854961,6664397,6823197,6918477,6950237,7109037,7013757,7236077,7458397,6981997,7045517,7140797,7426637,7077277,6727917,7204317,6759677,6791437,6632637,7394877,7299597,6696157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":742,"address":[7109044,7300371,7205091,6886724,7299604,7046291,6728691,7014531,7268611,6982771,6919251,7140804,6855735,6918484,6823204,7013764,6950244,7077284,7045524,7363891,7172564,7459171,6887491,7426644,7173331,7204324,6633411,6600884,6982004,6696931,7394884,7267844,6792211,7332131,6759684,6727924,7236851,6823971,7427411,6665171,7078051,6951011,7109811,7458404,7141571,7331364,7363124,6601651,7395651,6854968,6664404,6791444,6632644,7236084,6760451,6696164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":745,"address":[6633071,7014191,6791871,7236511,7077711,7141231,7363551,6950671,7109471,6887151,6601311,7427071,6664831,7172991,7045951,6823631,7395311,6918911,7331791,7458831,6760111,6982431,7268271,6696591,6728351,7300031,6855395,7204751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":746,"address":[7046710,6824390,7173750,6729110,7014950,6919670,6665590,6792630,7332550,7396070,7459590,7110230,7141990,6633830,6697350,7269030,6951430,7078470,7205510,7300790,6602070,6760870,7364310,6856154,6983190,6887910,7427830,7237270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":748,"address":[7364435,6634300,7332675,6729235,7110700,7301260,7269500,6761340,7300915,6665715,6729580,7205980,7078940,7015075,6951555,6697475,7047180,6920140,7205635,7046835,6983660,6824515,7396195,6602195,7269155,6633955,7078595,6824860,6760995,7396540,7142115,7237395,6666060,7142460,7460060,6983315,7459715,6793100,6792755,7428300,6919795,7364780,6888380,6697820,6856279,7237740,7427955,7173875,6888035,6951900,7015420,6602540,7110355,7174220,7333020,6856624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":749,"address":[6856314,7237430,7300950,7396230,6951590,7364470,7015110,6633990,7269190,6888070,7142150,6761030,7205670,6792790,6602230,6729270,7332710,7110390,7459750,6665750,7046870,6983350,7078630,7427990,6919830,6697510,6824550,7173910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":750,"address":[6761037,6983357,6665757,6888077,6633997,7015117,7205677,6697517,6919837,6602237,7237437,7078637,7396237,7300957,7427997,7142157,7173917,6824557,7046877,6951597,6792797,7459757,7110397,7269197,6856321,7364477,7332717,6729277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[6634521,7015422,7237961,7015641,7269721,6888382,6825081,7047182,6920142,7142462,7460281,7110702,7301262,6920361,7396761,7460062,7237742,7333241,6729582,6634302,7079161,6793321,7428521,6888601,7047401,7301481,6983662,7365001,7364782,6793102,7333022,6761342,6698041,7269502,6856845,6602542,6666281,6666062,6761561,7206201,6602761,7205982,7078942,6697822,7428302,6729801,6952121,7110921,7396542,6824862,7142681,6856626,7174222,7174441,6951902,6983881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":754,"address":[7015443,7078963,6920163,6602563,6824883,6793123,7110723,6729603,6983683,7269523,7206003,7396563,7428323,6856647,6697843,7047203,6761363,6666083,7174243,7301283,7333043,7364803,6634323,7142483,7237763,6888403,6951923,7460083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":755,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":758,"address":[7206422,7396763,6983883,7174443,6920582,7238182,6825302,7142902,6729803,7269942,6888603,6825083,6602763,7079163,7174662,7110923,6793542,7269723,6952123,6857066,6888822,7142683,7079382,7047622,7428742,7396982,7333243,7237963,6793323,6634742,7206203,7365003,6761782,7015862,6602982,6698262,7460283,6920363,7047403,6698043,6634523,6952342,7015643,7301483,7111142,6730022,6666502,7428523,6666283,7460502,7365222,6761563,6984102,7301702,7333462,6856847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":759,"address":[6602784,6920384,7396784,7269744,7047424,6634544,6793344,6698064,6666304,6761584,6856868,7301504,6952144,7206224,7015664,7174464,7365024,7110944,6983904,7428544,7142704,7079184,6825104,6888624,7237984,7460304,6729824,7333264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":763,"address":[6698271,7428751,7460511,7111151,6698483,6666511,6984111,6602991,7269951,6920803,7206431,7206643,7079391,7365231,7016083,7174671,6793551,6889043,6730031,7015871,6603203,6762003,7143123,6888831,6634751,6984323,6793763,7333471,6825311,7365443,7270163,6761791,6730243,7396991,7079603,7428963,6952563,7460723,7238191,7111363,7174883,6857075,7047843,7301711,7047631,6825523,7333683,7397203,7301923,6920591,7142911,6634963,6857287,7238403,6666723,6952351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":764,"address":[6666532,7428772,6730052,7460532,7142932,7079412,7015892,7269972,6952372,7047652,6634772,7333492,6984132,7111172,6888852,6825332,7301732,6857096,7238212,7365252,6920612,6698292,7397012,7206452,6761812,6603012,7174692,6793572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":765,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":768,"address":[7111539,6793840,6762080,7048019,6952640,6889120,7365619,7111440,6635157,6952739,6603379,7397379,7397397,7016093,6984499,6920880,7174960,6793957,7460899,7048037,7397213,6857297,7333693,6825717,6825600,7206819,6666800,6984517,7429139,7016160,6762179,6762197,7302000,7333877,6730437,7079613,7079797,6793939,7238597,6730253,7270339,6698493,7333859,7397280,7365453,7143200,6857463,6762013,6857481,7175059,7206653,6634973,6920979,7429040,7460917,7143133,6857364,7047920,6603213,6698659,6730320,6984400,6920997,7238579,6666917,7175077,7238480,7429157,7270357,6635040,7365637,6603397,6889237,6889053,6698677,7111373,6984333,7270240,7079779,6698560,7111557,6730419,6603280,7460800,7206837,6793773,7143299,7333760,6666733,7302117,6889219,7238413,7079680,7174893,6825699,7016277,6920813,6952573,7016259,7302099,6952757,7428973,6635139,6666899,7365520,6825533,7270173,7460733,7047853,7206720,7301933,7143317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":769,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":770,"address":[7333735,7206782,7143262,7397342,7238455,6603255,7397255,7143175,7079655,7238542,6825662,6793815,7079742,7429102,6920855,6857339,7270215,6635102,7206695,6730295,7302062,6762142,6666775,7016222,6603342,7365495,6635015,7175022,7333822,6889095,6730382,7047982,7301975,6952702,6666862,7429015,6984462,6698622,6762055,6952615,6920942,7460862,7174935,7460775,6825575,6984375,6857426,6698535,6889182,7270302,7365582,7111502,6793902,7047895,7016135,7111415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":771,"address":[7111546,7365667,7048270,6984547,6825747,7175107,6698910,6603386,6635146,6920986,6857714,7302350,6730426,7270590,6952746,7016307,6635187,6762186,7111790,7429390,7397630,7143347,7048026,6762227,7302106,7270387,6984506,7175310,7048067,6698707,6857470,7365870,6603630,7238830,7016510,6730670,7079827,7270346,7461150,7238627,6666906,7429146,7016266,6635390,6889226,7175066,6921027,6952787,6762430,6921230,6984750,7302147,7143306,6730467,6794190,6889470,7238586,7206867,7334110,6793987,6857511,7333866,7143550,6952990,7080030,7111587,7206826,7460906,7460947,7207070,7079786,6667150,6825706,6825950,7397386,7397427,6889267,7429187,7365626,6666947,6698666,6793946,6603427,7333907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":772,"address":[6889279,7397439,6793999,7143359,7333919,6921039,6698719,7302159,6603439,6952799,6635199,7460959,7429199,6857523,6730479,7048079,6762239,6825759,7206879,7270399,7175119,7238639,7016319,7079839,7365679,7111599,6984559,6666959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":776,"address":[6794200,6857724,7143560,6984760,7302360,6603640,6921240,7334120,6635400,7111800,6889480,7238840,7461160,6698920,7270600,7016520,6730680,7175320,7397640,6667160,6953000,7429400,7048280,7207080,7365880,6762440,6825960,7080040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[7238980,6730820,7461300,7048420,7334260,6889620,6762580,7143700,7302500,7080180,6794340,6984900,6953140,7016660,7207220,7429540,7111940,6921380,7175460,6857864,7270740,6667300,7366020,6699060,6826100,7397780,6603780,6635540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":778,"address":[7016796,7302636,6603916,7143836,7366156,6921516,7207356,7429676,6762716,7461436,6889756,7270876,7239116,7112076,7334396,6730956,6858000,6953276,7397916,7048556,6667436,6699196,6794476,7080316,7175596,6826236,6985036,6635676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":781,"address":[7461576,6604056,7429816,7334536,6826376,7080456,7398056,7271016,6858140,7175736,7366296,7048696,7112216,7016936,6731096,6985176,6667576,6953416,6794616,6889896,7143976,6921656,7207496,6635816,7239256,6762856,6699336,7302776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":782,"address":[7207806,7303086,7271326,7430126,6858450,6953726,6604366,7144286,6699646,6826686,7176046,6794926,6667886,7461886,6731406,6985486,7017246,7049006,7112526,7239566,7080766,7334846,6763166,7366606,6890206,6636126,7398366,6921966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":783,"address":[7176357,6890517,7462197,6985797,7081077,7271637,6922277,7430437,6668197,6731717,7049317,7335157,7398677,6763477,6826997,7208117,7366917,7017557,6795237,6858761,6604677,7112837,7144597,6954037,7303397,6699957,7239877,6636437],"length":1,"stats":{"Line":0},"fn_name":null},{"line":787,"address":[7367038,7112958,7049438,6763598,7303518,7335278,6731838,6636558,7462318,6922398,6890638,6668318,7239998,6604798,7430558,6954158,6985918,7398798,7271758,7208238,7017678,7081198,6827118,6700078,6795358,6858882,7144718,7176478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":788,"address":[6922644,7144964,6827364,7240244,6954404,6763844,6859128,7081444,6605044,7049684,7176724,7272004,7462564,7017924,7113204,6668564,7335524,7399044,7208484,7367284,6890884,7430804,6795604,6700324,6986164,6636804,7303764,6732084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":789,"address":[6954651,6764091,6986411,7367531,7049931,6637051,7335771,7018171,7145211,7176971,6605291,6827611,6700571,7208731,6732331,7431051,7240491,7272251,7462811,6922891,7081691,7304011,6795851,6668811,6891131,7399291,7113451,6859375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":792,"address":[7272388,7304148,6637188,6986548,6700708,7431188,7208868,6923028,6954788,7177108,6795988,6764228,7145348,7367668,6859512,6827748,7081828,6605428,7050068,7462948,7240628,6891268,6668948,6732468,7113588,7335908,7399428,7018308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[7037831,6796523,6798154,7355431,7177473,7101351,7272753,7338074,7431553,7368203,6624951,7115754,7164871,7018673,6847271,6879031,7082363,7368033,6986913,7209233,7069591,6669483,6734634,7463483,6910791,6974311,7114123,7177643,6671114,7291911,6893434,6860047,6593191,7304683,7211034,7052234,6796353,7260151,6923563,7306314,7050433,7006071,6956954,7050603,6828113,6637553,7272923,6605963,6942551,7369834,6987083,7145713,6688471,7242794,6720231,6955153,7083994,7179274,6815511,6732833,6829914,6766394,6828283,6639354,7274554,7336273,7209403,6891803,6656711,6764593,7387191,7196631,6637723,7450711,6702874,7463313,7399793,6861678,6751991,6733003,6764763,7418951,6783751,6605793,7323671,7018843,7399963,6955323,6701073,7145883,7228391,7082193,7433354,6923393,7020474,7147514,7241163,6859877,6607594,7133111,7465114,7240993,7304513,7113953,7336443,6701243,6925194,7431723,6891633,7401594,6669313,6988714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":798,"address":[7114163,7272963,7018883,6669523,7209443,6764803,7304723,6860087,6891843,7463523,6828323,6701283,7368243,7145923,7431763,6796563,6606003,7336483,6955363,7082403,7177683,7241203,6923603,7050643,6733043,6987123,6637763,7400003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[6606011,7114171,6860095,6733051,7336491,6701291,7209451,7368251,7018891,6891851,6764811,7463531,7304731,6955371,6796571,7272971,7241211,6669531,6923611,7050651,7400011,7145931,7431771,7177691,6828331,7082411,6987131,6637771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":800,"address":[6765421,7273581,7114781,7114191,7210061,7082431,7431791,6638381,6892461,6701901,6670141,6637791,7209471,6891871,7019501,6606621,6860115,6923631,7241821,7464141,7305341,6733661,6701311,7368861,7400031,7336511,7051261,6606031,7463551,6828941,6828351,6924221,7018911,7368271,6669551,7337101,7083021,7177711,6764831,7241231,7272991,7304751,6797181,7432381,7400621,6860705,6987741,7146541,6955981,6987151,6955391,7050671,6796591,6733071,7145951,7178301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[6828544,7177904,6765024,6987344,7273184,6637984,6892064,7082624,7050864,6606224,6701504,6860308,7114384,7463744,6796784,7304944,7019104,6669744,7400224,6923824,7336704,7241424,6955584,7146144,7368464,6733264,7431984,7209664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[6860502,7273378,7368658,6987538,7114578,6669938,6606418,7241618,7463938,7051058,6765218,6924018,6892258,6796978,7178098,7400418,6828738,7146338,6733458,6701698,7082818,6955778,7432178,7305138,7019298,7209858,7336898,6638178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":804,"address":[6987751,6860715,6734632,6956952,6829912,7019511,7337111,7241831,6639352,6766392,7020472,7052232,6607592,7401592,6701911,7433352,7083031,7242792,6606631,7369832,6797191,7051271,7368871,6765431,6638391,7338072,7305351,6955991,7211032,7464151,7400631,6925192,7115752,6828951,6702872,7179272,7083992,7178311,7147512,6733671,6861676,7273591,7432391,7146551,6798152,6671112,7274552,6892471,7306312,6988712,7114791,6893432,6670151,7210071,7465112,6924231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":805,"address":[7178621,7083341,6829261,7400941,6956301,6861025,6606941,6797501,6733981,7464461,7019821,7273901,6702221,7210381,7051581,7337421,6670461,7115101,7369181,6924541,6892781,7242141,6988061,6638701,7146861,6765741,7432701,7305661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":806,"address":[6734292,7051892,6893092,7020132,6988372,7115412,7433012,7337732,6861336,7147172,7178932,7274212,6670772,6956612,6607252,6829572,7401252,7083652,7210692,6766052,6639012,7369492,6924852,6797812,7464772,7305972,7242452,6702532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[6797949,6702669,7179069,6956749,6607389,7274349,7052029,7242589,7337869,7020269,7147309,6924989,7464909,7210829,6861473,7083789,6639149,7433149,6829709,6734429,7115549,7306109,6766189,6988509,6670909,7401389,7369629,6893229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":813,"address":[6896563,6607599,6925199,6925396,7118883,7241123,6923523,6766596,6893439,7272883,7336403,7401796,7052239,6669443,6737763,7145843,6955283,7368163,7052436,6610723,7465119,6674243,7338276,6706003,7463443,7370036,7369839,6639556,7274559,7306319,6639359,6893636,7436483,7404723,6991843,6798356,7115759,7179279,7401599,7055363,7433359,6928323,6830116,6988916,6798159,7274756,7309443,7277683,7082323,6637683,6861880,6764723,6956959,6732963,7431683,7147716,7306516,7433556,7087123,7341203,6801283,7114083,6988719,7211236,7050563,6607796,6891763,7150643,6960083,7338079,7147519,7083999,7209363,7023603,6671119,7018803,7468243,6671316,7020479,7245923,6860007,6642483,6833043,7465316,6796483,7242799,7304643,6987043,6861683,7214163,7242996,6734639,7177603,7020676,6605923,7399923,7084196,6957156,6734836,6702879,6864807,6766399,7179476,6769523,6703076,7115956,6701203,6828243,7182403,7211039,7372963,6829919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":814,"address":[7370076,6861920,7052476,6957196,7084236,6798396,7465356,7243036,6988956,7306556,6607836,6639596,6925436,7115996,7433596,7179516,6830156,6766636,7338316,7401836,6671356,7020716,6734876,7211276,7274796,6893676,6703116,7147756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[6671364,7401844,6925444,7116004,6703124,6957204,7243044,7306564,7147764,6830164,7084244,7338324,6734884,6607844,6798404,7052484,7465364,7433604,7370084,6639604,6766644,7179524,6893684,7211284,7020724,6988964,7274804,6861928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[6798424,7306900,7084264,6798740,7116340,6608180,7275140,7084580,6894020,6703460,7116024,7211620,6957224,7338344,6957540,7020744,7052504,7370104,6703144,6734904,6607864,7465384,7243064,6861948,7306584,6862264,6671700,6735220,7243380,7211304,7148100,7433940,7433624,6925780,7465700,7370420,7021060,6639624,6639940,7401864,7274824,6766980,7402180,6830184,6893704,6989300,6988984,7147784,6830500,7179860,6671384,7179544,7052820,6766664,6925464,7338660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[6735207,6639994,6608234,7465754,6862251,7116394,6957527,6894007,6703514,7370474,6831584,6989354,7433994,7403264,6639927,6830487,6926864,6990384,7084567,7117424,6799824,7021114,6704544,7052874,7179847,7465687,7338714,6671754,6736304,7211674,7180944,7306954,6925834,6925767,7211607,7307984,7370407,7276224,6608167,7148154,6798727,6768064,7052807,7084634,6703447,6894074,7243434,7306887,7338647,7339744,7402234,6989287,7371504,7022144,7275194,6863348,7116327,6735274,6767034,7243367,6672784,6862318,7466784,7085664,7053904,6798794,7212704,7148087,6641024,7275127,6830554,7433927,6671687,7179914,6957594,6958624,6895104,7402167,6609264,7244464,7149184,7435024,6766967,7021047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[7338806,6767126,7052966,7180006,6608326,7084726,6894166,6798886,6703606,6830646,6671846,6989446,7211766,7243526,6640086,7434086,6925926,7148246,7116486,7307046,7021206,6735366,6862410,7465846,7370566,7275286,7402326,6957686],"length":1,"stats":{"Line":0},"fn_name":null},{"line":819,"address":[7212406,6704246,7148749,7402966,7148376,7466349,6799016,6799526,7371206,6799389,7180136,7244166,7084856,6672486,7148886,7434216,7307686,6640726,7339446,7212269,6704109,6608829,6926056,6767256,7053469,6608966,7053606,6989949,7085229,7021846,7053096,6863050,7465976,7434726,7116989,7211896,6735496,6767629,7434589,6957816,7244029,7307176,7275926,6703736,7117126,6831286,6640216,6926566,7466486,6736006,7307549,6862540,6672349,6671976,6894296,7180646,7371069,7243656,7116616,6990086,7021336,6894806,6989576,7370696,6767766,7339309,7402456,6735869,6926429,7275416,6958326,7021709,6608456,7085366,6640589,7338936,6830776,6862913,6831149,7180509,6958189,6894669,7402829,7275789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":820,"address":[7244198,7148918,7402998,6799558,6672518,6831318,6736038,7307718,6767798,7466518,7275958,6608998,6926598,7085398,6894838,6990118,6863082,6640758,7117158,6958358,7212438,7021878,7339478,6704278,7371238,7434758,7053638,7180678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":822,"address":[7307994,7403274,7276234,7212714,6863358,7435034,6672794,6704554,6990394,7180954,7053914,6641034,6736314,7466794,7085674,7149194,6926874,6768074,6895114,7022154,7371514,7244474,6958634,6609274,6799834,7339754,7117434,6831594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[7149327,7244607,7212847,6927007,7117567,6609407,7085807,7022287,6704687,6958767,6863491,6768207,6672927,7466927,7181087,6736447,6641167,7339887,6990527,7308127,7276367,6831727,7371647,6799967,7403407,7435167,7054047,6895247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":824,"address":[6673069,7085949,7054189,6863633,6736589,6704829,7149469,7403549,7435309,6990669,6895389,7181229,7340029,7371789,7022429,7212989,7117709,7276509,6831869,7308269,7467069,6958909,6641309,6927149,6768349,6609549,7244749,6800109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":825,"address":[6737761,7372000,7054400,7245921,6863844,6736800,6705040,7341201,7087121,6928321,7277681,7214161,6991841,7308480,6641520,6674241,7309441,6609760,7276720,7468241,6927360,7436481,7022640,6768560,6896561,7403760,7435520,6800320,6706001,6610721,7150641,7181440,6833041,7055361,7372961,7404721,7467280,6895600,7340240,6960081,6801281,6832080,6864805,6990880,7118881,6959120,6673280,7117920,7149680,7086160,7182401,7213200,6642481,6769521,7244960,7023601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[7467590,7022950,7149990,6895910,7213510,7308790,7435830,6927670,7054710,7340550,7118230,7277030,6832390,6705350,6610070,7404070,7181750,7245270,6737110,6641830,6673590,7086470,6768870,6800630,6864154,6959430,6991190,7372310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[7436141,7213821,7467901,6705661,6800941,7182061,6991501,6832701,7245581,7309101,7118541,7340861,7277341,7055021,6610381,6896221,6673901,7086781,7372621,7023261,6769181,6864465,7404381,7150301,6927981,6642141,6737421,6959741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":828,"address":[6801078,6737558,6642278,6610518,6705798,7404518,7309238,7182198,7468038,7023398,6674038,6991638,7340998,7372758,7213958,7150438,6928118,7436278,6864602,6896358,7055158,6959878,7086918,6769318,7277478,7245718,6832838,7118678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":833,"address":[7052393,7084153,6861837,6830073,7401753,7274713,6639513,6957113,7465273,7338233,7306473,6734793,6798313,6988873,7115913,7242953,6893593,6703033,7369993,6766553,6925353,7433513,6671273,7211193,7179433,7147673,6607753,7020633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":834,"address":[6734801,7465281,7020641,6766561,7242961,6639521,6671281,6830081,7274721,7401761,7115921,6988881,6861845,6893601,6798321,6607761,7052401,6957121,6925361,7211201,7370001,7084161,7147681,7433521,7306481,7179441,7338241,6703041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":835,"address":[7211209,7306489,6642496,6706016,7274729,6925369,7465289,6674256,7245936,7179449,7084169,6893609,7150656,7023616,6703049,7118896,6928336,7182416,7242969,7087136,7020649,7147689,6766569,6610736,7372976,6988889,6830089,6991856,7436496,7433529,7468256,7370009,7401769,7214176,7309456,6798329,6957129,6639529,7404736,6896576,7055376,6861853,6737776,7277696,7338249,7052409,6960096,6607769,6833056,7115929,6801296,6671289,6734809,6864820,7341216,6769536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":836,"address":[6769573,7468293,6801333,7341253,7404773,7087173,6833093,6896613,7118933,6737813,7055413,7373013,6960133,7277733,6706053,6610773,7150693,6674293,7214213,7245973,6928373,7309493,6642533,7436533,6991893,6864857,7023653,7182453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":837,"address":[7468305,7118945,6610785,7182465,7214225,7277745,6928385,6896625,6706065,7436545,6833105,7341265,6769585,7150705,6801345,6642545,6991905,7373025,6960145,6864869,7245985,7309505,7087185,7023665,6674305,6737825,7404785,7055425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":838,"address":[6960157,6737837,6706077,6610797,7277757,6674317,6928397,7214237,6864881,7023677,6833117,7309517,7055437,7436557,7245997,6801357,6896637,7404797,7468317,7150717,6769597,6642557,7341277,7373037,7087197,7118957,7182477,6991917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[7150725,6833125,6991925,6737845,7341285,6928405,7277765,7309525,7118965,7436565,7055445,7023685,6864889,6610805,6642565,6674325,6706085,6896645,7087205,7373045,7468325,6801365,7404805,6960165,7214245,7182485,6769605,7246005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[6801373,7055453,7214791,6865435,6769613,7024081,6611351,7119361,6991933,7341681,6706481,7278161,7278311,7182493,7437111,7277773,6833671,6992321,7214253,6770001,7436961,6738241,7341831,6960561,6897041,7055841,6770151,6611201,7405351,7246551,7119511,7309921,7118973,6928951,6897191,6896653,6801911,7468333,7468871,7087751,6928413,7055991,6960711,7182881,7087213,7373441,7023693,7246013,7436573,7150733,6738391,6737853,7373053,6960173,6674333,7468721,7214641,7151271,6642573,6801761,7183031,7246401,6674721,6706631,6833133,7310071,6865285,7151121,6864897,7309533,7087601,6610813,7404813,7024231,6643111,6674871,7341293,6706093,7405201,6833521,7373591,6992471,6928801,6642961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":843,"address":[6612646,6644406,7311366,7406646,6930246,7247846,7216086,7438406,6866730,7184326,7152566,6771446,6993766,7374886,7025526,7343126,7089046,6739686,6898486,6803206,6707926,6834966,6962006,7470166,7279606,7057286,6676166,7120806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":844,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":845,"address":[7090301,6741444,7472671,6933531,7377391,7376141,6740205,7091551,6867249,6711211,6964511,6709181,6870015,6647691,6807575,7347495,7439661,6998135,6740941,6997051,6900244,7315213,7156413,6615151,6646911,6995021,7282111,6966375,6869235,6806491,7471421,6773951,7089565,6836724,6932004,6867985,7156935,6838813,7282891,7059791,7188173,7346411,6678671,6804964,7026045,7379255,6803725,7028031,6963764,7346973,7441691,7470685,6744055,6645661,7061655,6902333,7283975,6997613,6837471,6613901,6931501,6804461,6836221,7059044,6711773,6775815,7217341,7187611,7188695,7407165,7250351,7153821,7186084,7281364,7376644,6932751,6934615,6616493,6774731,7186831,7249101,7124091,6677421,7093415,7029373,7345631,7216605,6677924,7029895,6996271,7314651,6899741,7311885,6742971,7061133,6712295,6965291,6743533,7027284,6772701,7184845,7249604,7280125,6930765,6773204,7313871,6965853,6871099,6644925,7344381,6615931,7028811,7122061,7125175,7410493,7185581,6709684,6995524,7124653,6679451,6680013,6648775,6710431,7344884,7408404,7283453,7343645,6900991,6648253,7473451,7312621,6901771,6835485,6742191,7092331,7057805,7155071,7474013,6807053,7280861,7122564,6839335,7378171,7442253,6838251,6680535,7411015,7220455,6868488,7375405,7315735,7092893,7123311,7121325,7153085,6614404,7217844,6934093,6899005,6902855,7378733,7154324,6994285,7155851,7313124,6771965,7218591,7058541,7026781,6805711,7219371,7438925,7219933,7252215,6775293,7248365,7440911,7442775,7251131,7474535,6963261,7471924,7407901,6613165,7409931,7440164,6646164,7409151,7060571,7251693,7090804,6708445,6676685,6962525,6870577,6617015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":846,"address":[7214799,7183039,6897199,6960719,6865443,7278319,7468879,7055999,7087759,7373599,7405359,6801919,7341839,7024239,6611359,7310079,6992479,6706639,6643119,7246559,6770159,7119519,6928959,6833679,7437119,6674879,7151279,6738399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":847,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":848,"address":[6802042,7341962,7214922,7151402,6929082,6992602,7310202,7405482,7373722,7183162,7087882,6675002,7024362,7469002,6960842,7278442,6738522,6643242,6770282,7246682,6897322,6833802,7119642,7056122,6706762,7437242,6611482,6865566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":849,"address":[6838859,6902810,6648730,6680399,6680059,6997659,7474059,6965899,6902379,7474399,6934570,6744010,7061610,6870623,6807439,7220319,7315690,7029419,7029759,7125130,7125039,6775770,7379119,6998090,7093370,6934139,7061179,6839290,6616879,7379210,7092939,7156799,7188219,6775339,7252079,6839199,6966330,6616970,7252170,7188559,7283930,6902719,7188650,7219979,6648639,7442299,7156459,6997999,7251739,7410970,7029850,6775679,6807099,7442639,7474490,6712159,7442730,6807530,7156890,7347019,7283499,7283839,7124699,7347450,6616539,7315599,6934479,7315259,7410879,6680490,6711819,7347359,7410539,7061519,6743919,6966239,7378779,6870963,6648299,7093279,7220410,6871054,6743579,6712250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":850,"address":[6966338,6617020,7061618,7442738,6648780,7220418,6839298,6648738,6680540,6712258,7125138,6744018,7188700,7220460,7188658,7379218,6934620,7252178,6616978,7347458,6807580,6807538,7283938,7315698,7156898,6871104,6902860,6871062,7093378,6775820,7379260,6775778,6998098,7156940,7315740,7093420,7411020,7442780,7029858,6839340,7125180,7283980,7474540,7410978,6712300,6998140,6680498,6966380,7061660,6934578,7347500,7029900,7474498,6902818,6744060,7252220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":852,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":853,"address":[7087928,7056168,7469048,6992648,7246728,6929128,7119688,6897368,7214968,6643288,6706808,6611528,7310248,7024408,7183208,6738568,6770328,6960888,7278488,7342008,7405528,7437288,7151448,6802088,7373768,6865612,6833848,6675048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":854,"address":[6902288,6870061,6711633,7378217,7092377,6870437,7219888,7346457,6838673,7410353,7346928,6679968,7441737,6743017,7346833,7124608,6648113,6775153,7251177,6711728,7060993,7156368,7061088,6616353,6997473,6743393,7092753,6616448,7060617,6933953,7251648,7473968,6711257,7282937,6997568,6965808,6965337,6806913,7219793,6615977,6997097,7124513,7156273,6838297,6965713,7029233,6807008,7251553,6679873,7188128,6902193,7409977,7029328,7315073,7283313,7187657,6870532,7378593,7028857,6775248,6933577,6838768,6774777,7442113,7124137,6743488,7315168,7155897,6806537,6934048,7188033,7442208,6648208,7092848,7219417,6679497,7283408,7473873,7378688,7410448,7314697,7473497,6901817,6647737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":855,"address":[6965858,6934098,7410456,6775256,6711778,6965816,7410498,7346978,6902338,6902296,6648216,7124658,7061096,6807058,6870582,7378696,6997576,7473976,6616456,7315218,6743496,7219896,7283458,7474018,6743538,7092856,6775298,7378738,6648258,6934056,7283416,7315176,7156418,6679976,6838776,7188136,7442258,6807016,7219938,7251698,6838818,6711736,7156376,6680018,7092898,6997618,7061138,7346936,7029336,7442216,7251656,7188178,6870540,7124616,6616498,7029378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":857,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":858,"address":[7469094,7373814,6929174,7151494,6960934,7310294,7278534,7119734,7056214,6992694,7437334,6738614,6675094,7246774,6770374,6643334,7405574,7087974,6865658,6833894,6897414,7024454,6706854,7215014,7342054,6611574,7183254,6802134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":859,"address":[7092054,7473322,6965162,6806214,7059837,7346282,6679322,7440957,6678717,7155722,7346134,7092202,7472717,6710934,7155117,6932797,6711082,6773997,6996922,7378042,6933402,6774602,6647562,6742694,6774454,6869738,7282157,6901037,7219242,7187482,6869886,7314374,7028534,7377437,7251002,6996317,7091597,7123357,7282762,6806362,7409802,7060442,7123962,7250397,7155574,7473174,7409197,7314522,6996774,7060294,6869281,7028682,6742237,6647414,6965014,7282614,7187334,6710477,7186877,6933254,7123814,7441562,7028077,6901494,6742842,6679174,7409654,6805757,6838122,7219094,6964557,7218637,7250854,7441414,6901642,6615802,7345677,6837974,6646957,6615197,7313917,7377894,6615654,6837517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":860,"address":[6679330,7409882,7282770,7092282,7378122,7441570,7092210,7219322,7251010,6711090,6806442,7187562,6901722,6742922,6615882,6965170,6774610,6711162,7314530,6869966,6965242,7155802,6933482,7473330,6742850,7251082,6996930,6838202,7028762,7219250,7346290,6838130,7155730,7123970,7060522,7282842,6679402,6647642,7124042,7441642,6615810,7473402,6997002,6647570,6869894,7314602,7187490,6774682,6901650,7409810,7060450,6933410,7346362,6806370,7378050,7028690],"length":1,"stats":{"Line":0},"fn_name":null},{"line":861,"address":[7124083,7346403,6647696,7060576,6647683,6965296,6838173,6711133,6711203,6838243,7409923,6933453,6679443,7346416,7441696,7314643,7219363,6806496,7378163,7187616,7155773,6679373,6679456,7251123,7378176,6901693,7441683,6615923,6870020,7282883,7441613,6806413,6933536,6965213,6997056,7187603,7409936,7187533,6711216,7314656,6997043,6869937,6901763,6965283,7314573,7092323,7028816,7219293,7251136,7060563,7155856,6742976,7124013,6742963,7251053,6615936,6615853,7282896,7060493,6774736,7092336,7473373,7346333,6933523,7028803,6901776,6806483,7282813,6647613,7378093,6774653,6742893,7028733,7219376,6996973,7092253,7409853,7155843,6774723,7473456,7124096,7473443,6838256,6870007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":863,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":864,"address":[7024500,7310340,6897460,7119780,7437380,7088020,6770420,7373860,7246820,6706900,7151540,6675140,6960980,6611620,6865704,6992740,6833940,7278580,6802180,7405620,7056260,7183300,7215060,6929220,7342100,7469140,6643380,6738660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":865,"address":[7440177,7154942,7090817,7027754,6932017,6836737,6900714,6900862,7218314,6773217,7122577,7471937,6741457,7377262,6677937,6614417,6995537,7281377,6710302,7027902,7059057,6710154,7059514,6678394,6615022,7186097,7313742,6964382,6868958,6869106,7186554,6932622,6868501,7313137,7091274,7409022,7345502,7472394,7472542,7344897,7154337,6995994,7123034,6932474,6837342,7440634,6804977,6805434,6837194,7250222,7345354,7408417,7377114,7281834,6773822,6963777,7027297,6709697,7376657,7249617,6996142,7313594,7281982,6646177,7186702,7217857,6900257,7250074,6678542,7154794,6964234,7123182,6805582,7059662,6742062,6773674,6741914,7091422,6646782,7408874,7218462,6614874,7440782,6646634],"length":1,"stats":{"Line":0},"fn_name":null},{"line":866,"address":[7250302,6837422,7154950,7027982,6964462,6742070,7345510,7313750,6869186,6900942,6932630,7472622,7218470,7123190,6964390,7281990,7377342,6773902,7091502,7091430,7059742,7123262,6615102,6932702,6805662,7440790,6996150,6646790,7186710,6773830,6837350,6678622,7155022,6710382,6996222,6742142,7186782,7409102,6615030,7377270,7440862,7472550,6869114,7409030,7345582,7282062,7218542,6805590,7027910,7313822,6710310,6900870,6646862,6678550,7059670,7250230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":867,"address":[7409073,6742196,6900996,6996193,7409156,7250356,7123303,6996276,6742113,6773873,6678593,7218583,6615073,6773956,6773943,6932756,7345623,7440916,7377313,7091473,7377396,7091543,7345553,7282116,7059796,7345636,7028036,6900983,7028023,6837463,7218596,7440833,7186753,6964433,6710423,7155063,6964516,7059783,6805633,7027953,7123233,7472663,6964503,7250343,6615143,7313863,6837393,6869227,6900913,7154993,6615156,7186823,7155076,6869240,7472593,6646833,7440903,6710436,7059713,6646903,6678676,7218513,7282033,6710353,6837476,6932743,7313793,7123316,7250273,7313876,6742183,6932673,7409143,7091556,7377383,6869157,6646916,6678663,7282103,6996263,6805703,7186836,7472676,6805716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":869,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":870,"address":[6802226,6738706,6770466,7056306,7024546,7215106,7183346,6833986,7119826,6961026,7246866,7151586,7437426,7088066,6643426,7373906,7310386,7278626,7342146,7469186,6897506,6992786,6865750,7405666,6611666,6675186,6929266,6706946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":871,"address":[6804474,6645674,7185594,6772714,7376154,7026794,6963274,7058554,6613914,7344394,7471434,7153834,7407914,6836234,7249114,6677434,6995034,7090314,6740954,6709194,7439674,7122074,7217354,7312634,6899754,6931514,7280874,6867998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":872,"address":[6772730,7376170,7280890,6709210,7122090,6677450,6613930,6899770,7344410,6836250,7471450,7090330,7217370,6645690,7312650,6740970,6804490,7058570,6995050,7407930,7439690,6868014,7153850,7249130,7026810,7185610,6963290,6931530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":873,"address":[6963756,7122556,7376636,6614289,6773089,7153862,6645702,7344876,7440156,6772742,6804849,7344422,6804956,7027169,7186076,7058582,7471462,6995516,6740982,6836716,7154209,7122102,6677916,7154316,6836609,7027276,7471916,7313009,7059036,7058929,7280902,6646049,7408289,7249142,6741329,6995062,7281249,7122449,6677809,7281356,7376182,6963302,7217836,7185622,6868373,6677462,6995409,6836262,6931542,7217729,6773196,7090342,7471809,6868026,6709676,7249489,7090689,6931889,6614396,6900236,6613942,7376529,7440049,7312662,7344769,7185969,7249596,7090796,7026822,6868480,7313116,6804502,7217382,7407942,7408396,7439702,6741436,6709569,6709222,6931996,6899782,6900129,6646156,6963649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":875,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":876,"address":[6867262,6708458,7437496,7184858,6802296,7405736,6865820,6611736,7057818,7248378,7088136,7280138,6675256,7407178,7151656,6897576,6771978,7089578,7469256,7056376,7119896,6644938,6930778,6834056,6613178,7373976,7246936,7470698,7183416,6643496,6899018,6994298,7278696,6738776,7310456,7024616,6676698,6962538,7216618,7311898,6803738,6835498,6740218,7215176,6707016,7342216,7153098,7026058,6992856,7438938,7375418,6770536,6929336,7343658,6961096,7121338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":877,"address":[6836065,7090145,6803800,7058385,7184920,6613240,7121905,7470760,7311960,7439000,7153160,6835560,7153665,6740785,6709025,7471265,6930840,6994865,7280200,6931345,7375480,6645505,7026120,7216680,6899080,7185425,6867829,6994360,7248945,7439505,6867324,7312465,7121400,6962600,7217185,7343720,6676760,7057880,7407240,6899585,6708520,6963105,7280705,6772545,6804305,7026625,7344225,7375985,7089640,6645000,6677265,6772040,6740280,7407745,7248440,6613745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":878,"address":[7280309,6708629,7026229,7057989,6867433,7470869,7185029,7248549,7375589,6740389,6899189,6772149,6994469,6645109,7153269,7216789,7343829,7407349,7439109,7089749,6962709,6835669,6930949,7121509,6803909,7312069,6613349,6676869],"length":1,"stats":{"Line":0},"fn_name":null},{"line":879,"address":[7058533,6963253,7249093,7058005,7439653,6994906,7185573,6709173,6613893,7026245,7312085,7090186,7216805,6994485,6740405,6835685,7185045,7248565,7026666,6804453,7343845,6645125,6804346,6931386,6931493,7376133,7439546,6867449,6836213,7470885,7407786,7121525,6867870,7058426,6899733,7439125,6995013,6613365,6963146,7089765,7280325,7344373,7344266,6772165,7153285,6899626,6645546,6803925,7248986,7375605,7217333,6708645,7280746,7407893,7312506,7407365,7376026,6740933,6836106,7153706,7090293,6930965,6867977,6899205,7185466,6613786,7026773,7121946,7153813,6709066,6962725,6645653,7312613,7280853,7217226,6772586,6772693,6676885,6740826,7122053,7471413,6677306,6677413,7471306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":881,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":882,"address":[6770583,7056423,6961143,6992903,7215223,7405783,7469303,7278743,7024663,6643543,7342263,6865867,6834103,7374023,6929383,6738823,7088183,6675303,6707063,7119943,7310503,6611783,6802343,7183463,7151703,6897623,7437543,7246983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":883,"address":[7311379,7470179,6930259,7247859,7057299,6962019,6739699,7374899,7184339,7216099,6898499,6993779,7152579,6866743,7089059,7025539,6803219,6707939,6612659,7343139,6834979,6676179,7279619,6644419,7406659,6771459,7438419,7120819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":884,"address":[7374915,7438435,7120835,7343155,6739715,7152595,7470195,6834995,6612675,6771475,6993795,6898515,7184355,6962035,7406675,6803235,7311395,7089075,6676195,6707955,7057315,6644435,7025555,6930275,6866759,7216115,7247875,7279635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":885,"address":[7057327,7089087,6613157,6613050,7025567,6962410,7280117,7470677,7025930,7407050,7152607,7279647,6867241,6898997,6930757,7120847,6644447,7216490,7311407,6739727,7438917,6644917,6866771,7407157,7057797,7247887,6771850,6740090,7121210,7470570,6993807,6740197,7216127,7216597,6771957,6803717,6898527,7311877,7184367,7153077,7057690,7121317,6962517,6898890,7343530,6612687,6676677,6835370,7184837,7248250,6708437,7406687,7089450,7152970,6994277,7311770,7375397,6708330,7375290,7184730,7438447,6707967,6835007,7438810,6803247,6994170,6644810,7280010,7343167,6676207,6676570,6771487,7343637,6962047,7248357,6930287,6835477,7089557,7026037,6803610,6930650,7374927,7470207,6867134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":887,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":888,"address":[6675373,6611853,7310573,7215293,6897693,6834173,7088253,6929453,7247053,7437613,7374093,6802413,7342333,6992973,7056493,7469373,6961213,7120013,7183533,7151773,7405853,6643613,6738893,7278813,6865937,6707133,6770653,7024733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":889,"address":[6897809,7437729,6644234,7279434,7120634,7120129,6898314,6770769,6993594,6612474,6675994,6834289,7278929,7342954,7184154,7469994,6739514,7405969,6739009,6961834,7374209,6866558,6707249,7406474,7342449,7152394,6834794,6675489,7310689,7024849,6930074,7247169,7215914,6803034,7057114,6611969,7088874,6643729,6993089,7247674,6929569,6802529,7374714,7183649,6866053,6771274,7056609,7215409,7469489,7311194,7151889,6707754,6961329,7025354,7088369,7438234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":890,"address":[6707358,6866162,7183758,6612078,7279038,7151998,7437838,7310798,6739118,6770878,6834398,7374318,6929678,7406078,7024958,7215518,6897918,7469598,7247278,7342558,6643838,7056718,7120238,6961438,6802638,7088478,6993198,6675598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":891,"address":[6866599,6707374,6803075,7152435,7184195,7152542,7279475,7343102,7406622,7247715,6993214,7120782,6612622,6929694,7152014,7247822,7279582,7374334,6770894,7374862,6930222,6834942,6612515,6802654,7089022,6676035,6707795,7437854,7088494,7438275,6644382,7024974,6803182,6644275,7057155,6898355,7088915,7184302,7057262,7215534,6771422,6707902,6961982,6676142,6739134,7310814,6771315,7056734,7342574,6675614,6612094,7215955,6993635,7183774,6866178,7470142,7120675,6961875,6739555,6834414,7216062,6897934,7438382,7406094,6866706,6643854,7120254,7311235,6961454,7374755,7025395,7470035,7469614,7025502,6739662,6834835,7247294,6930115,6993742,7406515,6898462,7342995,7311342,7279054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":893,"address":[7024285,6770205,7119565,6897245,6643165,6833725,6960765,7151325,7214845,6706685,7405405,7373645,6929005,6801965,7183085,6674925,7310125,7437165,7278365,6611405,6738445,7056045,6992525,6865489,7341885,7246605,7087805,7468925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":895,"address":[7311350,7247830,7120790,7374870,7216070,6803190,6866714,6644390,6930230,7025510,6739670,7438390,7152550,7343110,6612630,7470150,6676150,7279590,6707910,7057270,7089030,7184310,6771430,7406630,6898470,6961990,6834950,6993750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":898,"address":[6801998,7188749,6902909,6897278,6833758,7061709,6929038,7341918,6643198,6674958,7474589,7252269,7468958,6712349,7214878,7284029,7347549,6966429,6865522,6744109,7379309,7024318,7405438,6738478,6706718,7183118,7156989,6998189,6992558,6871153,7442829,7310158,7029949,6611438,7087838,7119598,6680589,6960798,7093469,6807629,7151358,7373678,7246638,7278398,7315789,6617069,7056078,7125229,6934669,6648829,6770238,7437198,6775869,7411069,6839389,7220509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":900,"address":[7315808,7029968,7474608,7093488,6902928,6712368,7284048,7379328,6680608,6617088,7061728,6807648,6934688,6966448,6839408,6775888,6998208,7442848,7411088,7188768,7252288,7125248,7157008,6744128,6648848,7220528,7347568,6871172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":913,"address":[7476272,7475600,7475824,7476944,7476496,7475376,7476720,7476048,7475152,7474928],"length":1,"stats":{"Line":0},"fn_name":"global\u003c\u0026closure-0\u003e"},{"line":915,"address":[7475450,7476794,7476122,7475226,7475898,7476570,7475002,7476346,7477018,7475674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":916,"address":[7476096,7475200,7476544,7475648,7475424,7475872,7476320,7476768,7474976,7476992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":917,"address":[7476102,7476326,7475654,7475878,7474982,7475430,7476550,7476998,7476774,7475206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":918,"address":[7477005,7475661,7476781,7475885,7475437,7475213,7474989,7476109,7476333,7476557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":919,"address":[7475668,7476788,7476116,7475220,7475444,7475892,7476340,7477012,7476564,7474996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":923,"address":[7475692,7476140,7476812,7475244,7475916,7475020,7476588,7477036,7476364,7475468],"length":1,"stats":{"Line":0},"fn_name":null},{"line":924,"address":[7475254,7475702,7475030,7476822,7475478,7475926,7477046,7476150,7476598,7476374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":925,"address":[7476384,7476608,7477056,7475040,7475264,7476160,7475936,7475712,7476832,7475488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":926,"address":[7475498,7477066,7476170,7476842,7476618,7475050,7476394,7475946,7475274,7475722],"length":1,"stats":{"Line":0},"fn_name":null},{"line":929,"address":[7475284,7475060,7476180,7475508,7476628,7475732,7476852,7477076,7476404,7475956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":930,"address":[7475752,7475080,7475304,7476648,7476200,7475528,7476872,7477096,7475976,7476424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":933,"address":[7476662,7475542,7475990,7475766,7475094,7475318,7477110,7476886,7476438,7476214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":934,"address":[7475104,7475776,7477120,7476000,7475328,7476448,7476224,7475552,7476896,7476672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":935,"address":[7475786,7476234,7476682,7477130,7476906,7475562,7475338,7476458,7476010,7475114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":936,"address":[7477140,7476916,7476020,7475124,7476692,7475572,7475348,7475796,7476244,7476468],"length":1,"stats":{"Line":0},"fn_name":null},{"line":938,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":942,"address":[7478506,7478528,7478256,7478790,7478246,7477702,7478800,7479878,7478518,7479606,7477712,7479344,7477984,7479062,7477430,7477690,7477440,7479050,7479616,7478234,7479072,7478778,7479594,7477962,7479322,7477168,7477418,7477974,7479866,7479334],"length":1,"stats":{"Line":0},"fn_name":"semiglobal\u003cclosure-0\u003e"},{"line":944,"address":[7478602,7478330,7477514,7479690,7478874,7479418,7479146,7478058,7477242,7477786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":945,"address":[7477760,7477488,7478576,7479120,7479392,7479664,7477216,7478304,7478848,7478032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":946,"address":[7478854,7479670,7477222,7478310,7479398,7477766,7479126,7478582,7478038,7477494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":947,"address":[7478589,7477773,7479677,7479133,7478045,7477501,7478317,7478861,7479405,7477229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":948,"address":[7479140,7478596,7478052,7478324,7478868,7479412,7477780,7477508,7479684,7477236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":952,"address":[7478348,7478076,7479164,7477804,7478620,7478892,7479436,7477532,7479708,7477260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":953,"address":[7478358,7479718,7478902,7477814,7477270,7479174,7478086,7478630,7477542,7479446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":954,"address":[7477280,7477552,7479456,7479728,7478640,7478096,7478368,7479184,7477824,7478912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":955,"address":[7477834,7479194,7479466,7478922,7479738,7478650,7478378,7477562,7477290,7478106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":958,"address":[7477300,7477844,7477572,7478388,7479748,7479476,7478660,7479204,7478932,7478116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":959,"address":[7478942,7479486,7478398,7477582,7479758,7479214,7478670,7478126,7477310,7477854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":962,"address":[7478682,7478138,7477866,7479226,7477594,7477322,7479770,7479498,7478410,7478954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":965,"address":[7478159,7478703,7478975,7479791,7479247,7479519,7477887,7477343,7478431,7477615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":966,"address":[7478169,7477897,7478713,7477353,7479529,7479801,7479257,7477625,7478441,7478985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":967,"address":[7477907,7477635,7478723,7477363,7478995,7478179,7478451,7479539,7479267,7479811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":968,"address":[7479277,7479005,7477645,7478189,7479821,7478461,7478733,7477917,7477373,7479549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":970,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":974,"address":[7480150,7480976,7480138,7480410,7481226,7480954,7480966,7480422,7479888,7480682,7480704,7481238,7480694,7480432,7480160],"length":1,"stats":{"Line":0},"fn_name":"local\u003c\u0026fn(u8, u8) -\u003e i32\u003e"},{"line":976,"address":[7480234,7479962,7480778,7481050,7480506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":977,"address":[7480752,7479936,7480208,7481024,7480480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":978,"address":[7480486,7479942,7481030,7480758,7480214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":979,"address":[7480765,7479949,7480493,7480221,7481037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":980,"address":[7480228,7480772,7481044,7479956,7480500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":984,"address":[7479980,7480796,7480252,7481068,7480524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":985,"address":[7480534,7479990,7480262,7481078,7480806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":986,"address":[7480272,7480000,7481088,7480544,7480816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":987,"address":[7480282,7480554,7481098,7480010,7480826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":990,"address":[7480564,7481108,7480836,7480292,7480020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":991,"address":[7480030,7480302,7481118,7480846,7480574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":994,"address":[7480586,7480314,7480042,7481130,7480858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":997,"address":[7481151,7480607,7480879,7480335,7480063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":998,"address":[7480889,7480345,7480073,7481161,7480617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":999,"address":[7480355,7480899,7480627,7481171,7480083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1000,"address":[7480093,7481181,7480365,7480909,7480637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1002,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1017,"address":[6297888],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":1045,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1046,"address":[6298938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1051,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1052,"address":[6298008,6298179,6298446,6298410,6297975,6298212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1053,"address":[6298516,6298063,6298282,6298438,6298000,6298204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1054,"address":[6297993,6298197,6298431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1057,"address":[6298252,6298486,6298043,6298591,6298138,6298357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1058,"address":[6298312,6298055,6298546,6298499,6298093,6298265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1062,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1064,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1068,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1070,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1074,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1076,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1081,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1082,"address":[7346860,6773742,6965740,7046358,7021776,7442140,7280037,6711660,6958256,6994197,7377182,7408316,7092780,6966271,6899653,7212336,6997500,7108250,7468748,7182908,7312533,7249013,6902220,6742762,7470062,6917690,7217756,6965082,7374782,6706508,7473242,7314442,7246428,7214668,7268678,7141638,7219162,6709596,6775180,6799456,6792278,6772613,6902751,6646702,6616911,7205158,6901562,6806282,6949450,7061020,7410380,7151148,7406542,6994933,6836133,7438837,7471836,7219820,7375317,6869026,7440702,7313036,6992348,7235290,7438302,6981210,7377962,6931413,6727130,6824038,7441482,7300438,7089477,7378620,7283871,6934511,6867897,7185493,6611228,7184222,6608896,7442671,7122476,7315631,7315100,6834862,6900782,7247742,6740117,6961902,7440076,7436988,6674748,7278188,7203530,6803102,7027822,7434656,7252111,7218382,6740853,6743420,7092122,7330570,6960588,6633478,6996842,7216517,7058956,6704176,7053536,7060362,7012970,6677836,6631850,7249516,6735936,7120702,6898917,7394090,7244096,7148816,7123882,6838042,6838700,7091342,7376053,7093311,6804373,6770028,7220351,7473900,7376556,7425850,7281902,7474431,7402896,7025957,7059582,7076490,7027196,7044730,6897068,6677333,6773116,7280773,7058453,6995436,6801788,7215982,6928828,6644302,7250142,7439573,6775711,6644837,7026693,6803637,6676062,6614942,7311797,6771877,7152997,7085296,6613077,6894736,7313662,6676597,7470597,6665238,7347391,6839231,6600090,7250922,7341708,7090213,7236918,7344293,6835397,6919318,6963173,6831216,6869806,7343557,6696998,6865312,6758890,6962437,7298810,6741982,6646076,6926496,7029260,6805502,6767696,7408942,7014598,7379151,6648671,7121237,6679900,6601718,6739582,6982838,6930142,7409722,6616380,7344796,6855802,6887558,7184757,7267050,7188060,7029791,6990016,7152462,7154236,6695370,6708357,7087628,6930677,6760518,7251580,6833548,7119388,6738268,7217253,7025422,6728758,7363958,7407077,6807471,7078118,6866626,7427478,7057717,6711002,7362330,6613813,6612542,7061551,7171770,7187402,6615722,7188591,6932542,7121973,6804876,7185996,6712191,6870995,7154862,7309948,6647482,6868400,6870464,7125071,7410911,6640656,7156300,6998031,6854174,7279502,7395718,6933322,6933980,7466416,6741356,7186622,7117056,7307616,6862980,6672416,7345422,6710222,7471333,7156831,7459238,6707822,6790650,6680431,7123102,6951078,7281276,7282682,7024108,7373468,7180576,7283340,6679242,6645573,7275856,7311262,6836636,6709093,7124540,6900156,7332198,6837262,7088942,6614316,7407813,6898382,6678462,7057182,6806940,7472462,6743951,6774522,6822410,7028602,6885930,6963676,6771342,6993662,6867161,7457610,7248277,7090716,6996062,6663610,6931916,7173398,7140010,7153733,7405228,7109878,7343022,7055868,7155642,6964302,7339376,6648140,7346202,6642988,7371136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1086,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1087,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1091,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1092,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1096,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1097,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1101,"address":[6297920],"length":1,"stats":{"Line":0},"fn_name":"set_all"},{"line":1102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1116,"address":[6298608],"length":1,"stats":{"Line":0},"fn_name":"with_capacity"},{"line":1117,"address":[6298637,6298686],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1118,"address":[6298668,6298747,6298726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1122,"address":[6298781,6298731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1126,"address":[6298896],"length":1,"stats":{"Line":0},"fn_name":"init"},{"line":1127,"address":[6298929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1128,"address":[6298943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1129,"address":[6298948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1131,"address":[6298974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1136,"address":[7113654,7354502,7050181,6973382,6755239,7095550,6796054,7444867,7349630,6914039,7317870,6818808,6873187,7449741,6909862,6628248,6723528,6850568,6827814,7159027,6891334,6751062,6941622,6624022,7063747,7381390,7050134,6841470,7304214,7326919,7463061,7000227,6859625,7386221,6623981,7322701,7453959,7449782,6777950,6977608,7227421,6850519,6700774,7349587,6777907,6878061,7386262,7463014,7127310,7454008,7199879,7431301,7005142,6977559,6723479,7032030,7104648,7417981,7240741,7231639,6637301,7367734,6755288,7104599,6592262,7177221,6954854,6669014,7263448,6764341,6628199,7068662,6746147,7000270,6691768,6719302,6691719,7335974,7326968,7322742,6891381,7272454,6904990,6751021,7358728,7136408,6945848,6596488,7199928,6986614,7068621,6878102,7163942,7399494,6650867,6605541,7195702,7113701,6605494,6700821,6818759,6650910,6687501,6945799,7295208,6882328,7413107,6923094,7063790,6732581,7272501,7295159,7431254,6596439,7041079,7136359,7367781,7036861,7168168,7095507,7100422,6682627,7159070,7081941,7163901,6782822,7381347,7100381,6619150,6859578,7418022,7081894,7290982,7208981,7413150,7422199,7336021,7132141,6637254,7195661,7227462,7072839,7177174,7018421,6936750,7036902,7127267,7222547,6809667,7317827,7132182,6968467,6587347,6719261,6809710,6714387,7390439,7009319,6746190,7240694,7145461,7259222,6954901,6764294,7231688,7444910,7286067,7072888,6882279,6968510,7005101,6904947,6714430,7304261,7041128,6923141,7190787,7208934,7168119,6846301,6787048,7390488,6846342,7018374,6796101,6619107,6655782,7259181,6909821,7286110,6827861,6687542,6682670,6941581,6973341,7222590,6655741,7254307,6587390,6986661,7009368,7399541,7031987,7422248,6873230,7354461,6814582,6914088,7290941,6592221,7145414,6786999,7254350,6659959,7190830,7358679,6841427,6669061,6782781,6936707,6732534,7263399,6660008,6814541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1137,"address":[7354584,7041113,6628306,7127368,6746248,7190813,7304343,6619133,6945906,6850553,7036984,7390546,7336006,7222648,7005125,7032013,6941704,7399526,7454066,7381448,6714488,6682728,7222573,6691753,6814565,6954886,7227544,6719285,6637383,6977666,7159053,7453993,7272583,7381373,7190888,6796183,7127293,6850626,7413208,6700903,7290965,7095608,6914073,6751045,6650893,7082023,7322725,6637286,6986743,6723513,7254408,6605623,6782904,6841528,6596473,7336103,6700806,6687624,7132165,7063773,6682653,6859610,7418104,7259205,6755346,6841453,6755273,7358713,6624104,7113686,6596546,7286168,6605526,6787033,7322824,7132264,7209063,6628233,6809768,6723586,6882313,6714413,6846424,7005224,7208966,7386344,7063848,7159128,7413133,7231673,7291064,6968568,7444893,6592245,7199913,7068744,7018503,7317928,7349613,6732566,6732663,6746173,7354485,6719384,6986646,6904973,6977593,7072873,7444968,7449864,6945833,6909845,6846325,6891366,7104633,6669143,7263506,6973464,7177303,7068645,7327026,7390473,7104706,7164024,6954983,7095533,6659993,7304246,6873213,6796086,6936733,7422306,6587448,7418005,6818793,6782805,7386245,7295193,7136466,7032088,7295266,7000328,6814664,6923126,6818866,7163925,7168153,6764423,7145543,7100504,7254333,6923223,7050263,7195784,7240823,7399623,7367766,6619208,7081926,6941605,6809693,6873288,7272486,6777933,7358786,7227445,7113783,7009353,7431286,6914146,6968493,7072946,6882386,7018406,6655864,7286093,6669046,6859707,7367863,7240726,7145446,6936808,7100405,7463143,7009426,6650968,6764326,6787106,7449765,7349688,6905048,6973365,6891463,7463046,6909944,6655765,6751144,6687525,6878085,7199986,7000253,7136393,6778008,7036885,7177206,6587373,7231746,7422233,7326953,7431383,6660066,6827943,7195685,7317853,6827846,6592344,7263433,6878184,7050166,7259304,7168226,7041186,6624005,6691826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1138,"address":[6796229,6818904,6891427,7272547,6660104,7199966,6873268,6968598,6605587,6751182,7072926,7449828,7336067,7145589,7177267,6818846,6814702,6778038,7168206,7009406,6841508,6827989,7063828,7050309,6859753,7081987,6859671,7164062,7358766,6796147,6751108,6700867,6914184,7322862,6905028,7227582,6650998,7454104,7431347,6596584,6719348,7072984,7390584,7195748,6941742,6891509,6619238,7113747,7200024,7009464,6846462,6628286,7190868,6782942,7349668,7354622,7063878,7431429,7381478,6973502,6787086,7317908,6945886,7159158,7286198,6732627,7354548,7399587,6592308,7231726,6655902,6977704,6637347,7304389,6764469,6777988,6746228,6986789,6755326,7386308,6691806,6923269,7336149,6723624,6827907,6755384,6814628,6587428,7422344,6945944,7036948,7463107,6977646,7254438,6882424,6841558,7159108,7032118,7240787,7444948,7304307,6905078,6691864,7068708,6909982,7209027,7041224,7399669,7100468,6605669,7168264,6596526,6660046,6941668,6955029,7005188,6682708,6809748,7095588,7263486,7018549,6882366,6878148,7050227,7444998,7413188,7222678,7041166,7367909,7104686,7104744,6723566,7317958,7195822,7100542,7136446,7177349,7295246,7272629,7418068,7263544,7222628,7000358,6846388,6687588,7127348,6746278,6714468,7068782,7209109,6809798,7227508,6873318,7381428,7145507,7259268,6914126,6732709,7163988,6923187,7422286,7082069,7322788,6850606,7000308,7327006,7454046,6624142,6954947,7327064,7449902,7132228,6650948,6878222,6619188,7132302,7259342,6782868,6936838,7190918,6624068,6682758,6587478,6850664,7136504,7127398,6700949,6719422,6592382,7032068,7037022,7291028,7231784,7291102,6787144,6973428,7240869,6637429,6714518,6669107,6909908,7413238,7349718,7358824,7113829,6655828,7295304,6687662,7005262,7386382,7390526,6669189,7367827,7095638,7254388,6936788,6764387,6968548,7463189,6628344,6986707,7018467,7418142,7286148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1143,"address":[7156565,7283058,7021422,6758579,7300127,6963413,7298456,7090404,7313335,6989705,6646375,6932952,6929768,6711378,6962846,6771015,7439199,7331887,7217493,7246087,6993910,6930390,7246134,6949096,6772804,6743138,7341367,7124764,6866874,6992054,7330216,7378338,6899279,7215608,6703822,7120909,7275545,7014244,7153359,7187731,6743685,7180265,6865018,6870182,7156018,7249815,6599736,7120375,7363604,7046047,7187778,7216230,6995124,7059212,7307262,7248686,6676310,7141327,7216879,7266696,7211982,6647811,6803309,7427124,7374408,6803350,7279175,6805955,7188284,6806658,7154535,6899844,7438550,7470959,6679618,7060738,7312773,7182614,6677573,7425539,7092498,7344533,7122164,7250595,6675688,6737927,6612790,7346578,7280446,7408615,7187032,7339065,7406215,7173087,7059992,6708719,7060691,7373174,7472135,7298499,7441155,6728404,7248639,6633167,6902485,7204847,6957945,7124805,7092451,6676269,7466105,6614004,7408572,6601364,7153406,7437928,6760164,6855491,6965458,7375679,7309607,7152088,6835759,6869479,6741093,7012659,7219491,6993288,7373127,7311469,7148505,7058126,6711331,6997724,7268324,7154492,6695059,6799145,7028978,6993335,6633124,6802728,7029484,7236564,7023814,7434302,7218012,6616645,6743091,7059255,7058079,7406749,6836935,7438509,7025048,6962799,7442364,6631496,6644509,6710675,6613486,7218835,7395407,7342648,7361976,7093045,7155315,7344484,6774195,7404934,7057430,7472092,6950767,7183848,7212025,6901891,6710632,6982484,6678872,7283564,7410604,6931086,7089886,6608585,7123555,7280399,7375030,7440375,7155971,6696644,6771590,6742392,6962150,7275502,6898055,6837715,6807205,7053225,7120328,6862626,6790296,6805912,7186252,6853863,7362019,6664884,6726819,6926185,6919007,6995735,6933698,6806611,6695016,6994606,6949139,6612749,7028931,6932215,6769734,7060035,7441811,6613439,6992007,6805175,6645246,7466062,6885576,6739255,6773372,7025629,7377635,6867570,6799102,6774851,6835069,6835806,7184470,7283011,6708766,6932172,7076179,6647112,7279750,6680124,6772286,7186295,6901938,6706214,7331844,7056808,7312206,6896727,7470269,7119094,7076136,6672105,7171459,6994559,7247415,7122213,6648364,6870688,7012616,7393736,6996472,7084985,7307305,6966005,6709852,7408004,7374455,7468407,7204804,7315324,6899893,7215655,7311510,7309654,7091795,6615395,7474165,7471006,6980856,7312159,6608542,7474124,6709895,7283605,6836324,7203219,7347084,7377592,7378291,7044376,7434345,6775445,7441858,7345052,6866833,7393779,7473571,6804564,6866252,6610934,7315365,6711884,6995692,7469688,7440332,7058644,6646332,6677006,6741612,6772853,6926142,7339022,7046004,6663299,7090453,6834535,6869436,7249204,7077764,6853820,7236607,7148462,7109524,7025095,6965964,7345095,6868088,7139656,7314072,7279709,6822099,6807164,6833254,7014287,6993869,7152135,6894425,6728447,7312724,7376812,6674407,7300084,7247990,6867523,7026366,6964712,6823727,6760207,7155272,6963932,6642694,6672062,7346531,6599779,7409352,7123512,6918964,7184429,6996515,7120950,7121599,6680165,6740479,7090972,6678135,6961528,7409395,6868699,7061285,7219538,6772239,7469735,6707495,7026884,7088615,7472915,6900412,7093004,7410645,6833207,7027495,6961575,6645813,6896774,7185119,7250552,6737974,7376293,7330259,6802775,7402585,7437975,6790339,6739208,6997171,6864971,6644550,6743644,6726776,6615352,7442405,6664927,7310888,7427167,7395364,6774152,7091752,6708070,7439813,7188325,6774898,7139699,6642647,7026933,6898589,7027452,7439764,7408053,6674454,6982527,6930349,6902444,6696687,7091015,7220044,7109567,7152669,7220085,7124211,6647858,7234979,7402542,6767342,6643928,6823684,6965411,7173044,7185684,7053182,6866299,6963364,7436647,6933651,7055527,7218792,7088568,7023767,6616604,6801494,6997765,7187075,7057389,6741044,6834488,7314771,6900455,7277847,7251251,7279128,7471524,6631539,7345875,6612215,6887247,6739830,7281013,7378844,7044419,7243785,6648405,6898008,6643975,7406790,7407486,7055574,7470310,7183895,6769687,7025670,6980899,7410098,7141284,7089190,6640345,6950724,6929815,7249253,7153973,6612168,6870729,6740526,6614572,7182567,7266739,7313292,6709333,6885619,7107939,7089839,6616098,7122732,7153924,6997218,7171416,7425496,6917379,6773415,7376244,6898630,6758536,6960294,6804613,7214327,7251845,7378885,7282355,6928534,7180222,7089149,6601407,6614053,7124258,6899326,6707448,6838965,7314115,6801447,6934204,6775404,7407439,7122775,6957902,7404887,7457299,7374989,7217444,7473618,7343919,6791924,7107896,7345832,6805132,6678092,6675735,6901235,7343270,6770968,6964755,6837672,6767385,7119047,7087287,6739789,7249772,6676959,7150854,7028232,7441112,7203176,7216926,7251804,6677524,6995173,7458884,7341414,7310935,6917336,7247949,7439246,6931039,6645199,6836373,6678915,6962109,6862669,7061244,7375726,7370825,6931604,6838371,7363647,7216189,7343229,7185733,7457256,7218055,7376855,6963975,7026319,7156524,6901192,6928487,7280964,6960247,6610887,7282312,6830905,6679571,7342695,6838924,6703865,7152710,7347125,7370782,6640302,6931653,7058693,6735625,6835110,7116745,6771549,7214374,7087334,6887204,6709284,7314818,7121646,6894382,7458927,6645764,7077807,6855448,7281575,7084942,6830862,7468454,6742435,6836892,7277894,6741655,6934245,7343966,7472872,6870135,7150807,6711925,7471573,7251298,6803999,7243742,6706167,6804046,7281532,7410051,7028275,6708029,7021465,6822056,6735582,7234936,7268367,6791967,6614615,7436694,6868656,6868137,6989662,6616051,7406168,7029525,7056855,7247368,6663256,6838418,6647155,7116702,6932995,7185166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1144,"address":[6928618,6674439,7300112,6792049,7025080,7021450,7363632,6995819,7236689,6805160,6775517,6900440,6887232,7187159,7120933,6695141,7410630,7187763,7183979,7058753,6962831,6980884,6995158,6835194,7408038,6835791,7471633,7204929,6931071,7438634,7152693,7314100,7123540,7152219,7120459,6706199,7470394,6949124,6615380,7091780,7472999,6996500,7188397,7154520,7311594,7087319,7216314,7218820,7309738,7025653,7171444,6894410,6599861,7471090,7376939,7185718,7148490,6926170,7376353,7314803,6830890,6804130,6608667,6930373,6633152,6804031,7060119,6772271,7046032,7219622,7154619,7345959,6645231,6709880,6869563,7280530,6932980,7376278,6646360,7058678,7473603,7410717,6868197,6775430,7184554,7124243,6648390,6760289,7156102,7203301,6772370,6709318,6950849,7330341,6803333,6898040,7347197,6769818,6837700,7404919,6822181,6964059,7251382,6601392,6678999,7405018,7059240,7378422,6772838,7402667,6898714,6982609,7279834,7026450,6853848,7121034,7021547,7378957,7029062,7425524,7315437,7279733,6957930,7280998,6707480,7313320,7121730,7214359,7457381,6791952,7184453,6868684,7057413,6703850,7060822,6830987,7116827,6648477,6672187,6961659,7077889,6735610,6616182,6835890,7312758,7155300,7119079,6643960,6855573,7468439,7026351,7091879,7282439,7122760,6902022,7090438,7156637,6728529,7218040,7313419,7473702,6738058,7373258,7466187,6772913,7246218,7186379,7122859,6958027,7472900,7440360,7470293,7122198,6737959,6647239,6836433,6771099,7339050,6676991,7150839,7409380,6933782,6726901,6758564,6997750,6917461,7346662,6929800,7183880,7061357,7053210,6989787,7375810,6711910,7057514,7331872,6663381,6865003,6933683,7012741,6708053,6608570,6674538,6610919,6919089,6743670,6931638,7441239,7248770,7089871,6711462,7091000,6696672,6758661,7216911,7395392,7156550,6834520,6663284,6997203,7344050,7314902,7468538,6679702,7084970,7185793,6678219,6696769,6901319,6675720,7277879,7275530,6997837,7378870,7124790,6961560,7472120,7345179,7374539,6805259,7055559,7203204,6806039,7046129,6902470,7058111,6867654,7076261,7248671,7283142,7343354,6965990,7116730,7343951,7029510,6866383,6833239,7055658,6631621,6862654,7058210,6917364,7362101,7089173,7279160,6774883,7217478,6931713,6822084,6760192,7234964,7247400,6899311,7375114,6677633,7124877,7153391,6645798,7406200,7378323,7339147,6837799,7087418,7470991,7342779,6646459,6994591,7249238,6679603,6709979,6672090,7141312,6742519,7139781,7281659,7471558,6823712,7280431,6703947,7216213,6835093,7029597,7187060,6645873,6739914,7279259,7438533,7407471,7077792,7028963,7249800,6964740,6707579,6994690,7459009,7185250,6806742,7044404,6837019,6963398,6926267,7408113,7281073,7121631,7250679,7139684,6774279,6633249,6992039,6898139,6996599,6836920,7044501,7109649,6767467,7215640,6642679,6950752,6966077,6962234,7410182,6771674,7217553,6836358,7014272,6833338,7243867,7249313,6963960,6928519,6773400,6932200,7180347,6993994,7307387,7027579,6640330,7088699,6932299,6771573,7154033,7122273,6804598,7173072,6899410,7107924,6839037,6741153,6995233,7312833,6805940,6933079,6870801,6993893,7298581,7028260,6799130,7310920,7155399,6870714,6885604,6838403,7474237,7275627,7247973,7434330,6601489,6710660,6642778,7344518,6989690,6640427,6965443,6612874,6708850,6614113,6709393,6647843,6739339,6612773,7469720,7370810,6631524,7150938,6742420,7374440,6614038,6995720,6799227,7085067,7023799,6865102,7023898,6773499,6900539,6647942,7026918,6931170,6769719,6743123,7406773,7251283,7251917,7186280,7406299,6615479,6614600,7153490,6896858,7345080,7345860,7469819,7247499,6962930,7185151,6644533,6741640,6887329,7441843,7277978,7215739,6739240,7123639,7119178,7092483,6801479,7458912,7281560,6807277,6774982,7266821,7373159,7375013,7437960,7346563,6804673,6963473,7410083,7092582,7156003,7427152,7093117,6614699,7282340,6901923,6899953,6838950,7120360,7171541,6902557,7402570,6611018,7406874,6930474,6929899,6823809,7060723,7439798,7298484,6869464,6728432,7212010,7148587,7472219,7060020,7182599,6708154,6801578,6726804,6612299,7141409,7028359,6767370,7363729,7249899,7090513,7246119,7076164,7309639,6834619,7012644,7220157,6677558,7283590,6675819,6993320,6743757,7218139,7408699,7026993,7341498,6934230,6885701,7377620,6680237,6644634,7375711,6741739,7307290,7409479,7312290,6894507,6964839,6868122,7214458,6695044,7315350,7300209,7466090,7088600,6960378,6899878,7268449,7089274,6982512,6806643,7408600,7108021,6613471,7219523,7436679,6676394,7362004,6896759,7347110,7330244,7204832,7187862,6741078,6790324,7393764,6678120,7182698,6965542,7407570,7370907,7393861,7014369,7152794,7440459,7341399,6802760,6862751,7243770,6711363,6790421,6807190,7377719,7250580,7251830,6771000,7438059,7091099,6616630,6855476,6740610,7173169,7395489,6838502,6645330,6867555,7153958,6870167,7441140,7283043,7344593,7342680,6960279,7311019,6901220,6866857,6868783,7436778,7027480,6708751,7427249,6870266,7441942,6934317,7061270,6612200,6647140,7442390,6962133,7218919,7124342,6739813,7283677,7314199,6866284,6997302,7109552,6866958,6992138,7266724,6676293,7053307,6678900,7311493,7248074,7236592,7442477,6680150,6677090,7439330,7474150,6665009,7025179,6735707,7235061,7093030,7434427,7188310,6613570,6710759,7439231,6706298,6644059,7457284,7376840,7220070,6980981,6774180,6664912,7425621,7212107,7059339,6802859,7056840,6803434,6743222,7025754,7056939,6853945,6918992,7089970,7180250,7331969,7343253,6949221,6616083,6711997,6599764,6898613,6993419,7217010,7152120,6740511,7439873,7312191,7268352,6616717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1145,"address":[6993958,6790467,7021593,6981027,6708194,7025143,6997807,6616146,7171587,7184027,7312254,7279307,6962978,6885747,7408747,7187826,6640391,7283106,6677613,6995867,7123687,7061327,7184594,6855537,6838550,7243913,6898103,7378470,6930514,7059303,6735753,7434391,6696815,7469783,6899993,7023862,6696733,7180393,7408663,6994738,6743799,6995783,6675867,6743727,6739303,6739387,6949185,7330305,7150902,7427295,7023946,6961707,6710723,7409443,7376987,6801542,7107985,7090018,6980945,7027543,7090553,6901283,6822227,7091147,7119142,6805307,7187910,6771063,6680279,6997266,7046175,7044465,6706262,7312813,7124919,6806706,6708814,6633213,6964887,7088663,6771638,6601453,7315479,6742567,6965590,7314163,7332015,7093159,7091843,6616230,6862715,6870771,7440507,7250727,6898754,7405066,7474279,7309702,7314247,7185298,6674586,6839079,6612263,6773463,7249353,7173133,7108067,6870843,6896822,7342743,7218967,7026414,7347239,7090493,6996647,7440423,6710027,6645853,6934287,6839007,7141455,6997879,6926313,6674502,7155363,7344573,7406347,6887293,6804178,7203265,7346626,7280494,7216974,6950895,6901986,7378999,7374587,6899933,6640473,6865066,6610982,7029110,6966047,7307351,7093087,6631585,7121778,7251887,6867618,7300173,7393907,6868747,7282487,6836413,7300255,7313383,6706346,6962198,6631667,7472267,7236653,6767513,7249863,6664973,6887375,7152183,7377683,6870230,7370871,7312873,6601535,7339111,6995213,7282403,7378927,7215787,7393825,6834667,6611066,7275591,6614153,7141373,6742483,6866347,7091063,7410230,7235025,7266785,6992102,7395535,6614747,7307433,7186343,6775487,6790385,7436826,7124390,6772334,6645378,7466233,7218187,7376393,7219670,7311067,7061399,7085113,6932263,7156066,6633295,7092630,7187207,7438023,6961623,7029026,7060167,7203347,6741787,7057478,7468586,7346710,6930438,6613618,6866922,6804653,6963513,7219586,6642742,6647906,7124306,6646423,6647203,7122907,7120423,6823773,6869527,7249947,7216354,7185214,6964803,7204975,7458973,7362065,6772893,6677673,7053271,7472963,6616759,6695105,7406263,7044547,6834583,6792013,7243831,7204893,7184518,6644674,6672233,6865150,7457427,6646507,7298545,6934359,6837847,7248818,7029567,6799191,6738106,6989833,7436742,7343318,7123603,7217593,6680207,7212071,6966119,6615527,7471054,6676434,7471673,7378386,6917425,6933830,7214422,6758707,7298627,6741193,7014333,6950813,7026498,7026973,6676358,6806087,7470434,7266867,6612347,6775559,7116873,7055622,7025227,7139745,7025718,7469867,6772953,6982573,6928582,7156607,6703993,6644107,6870314,6612914,6822145,6707627,6926231,7173215,7345143,6867702,7345923,6835938,6802907,7468502,7425667,6803474,6767431,6917507,6801626,7375078,7410759,7076225,7057554,6823855,6648519,7124847,6837067,7185773,6709433,7251346,6741703,6708118,6599907,7236735,7402713,7281623,6868177,7246266,7279874,6806003,6616687,7278026,6989751,7363693,6665055,6710807,6962274,6695187,7314866,7279798,7249293,6994034,7183943,6677138,6995273,6675783,7180311,7441203,7268495,6929863,7434473,6958073,7056903,7246182,7408153,6739878,6741133,6933043,6901367,7055706,7156679,7046093,7281053,6835234,7021511,7076307,6868237,6996563,7121694,7059387,7404982,6677054,7218103,7439294,7150986,7089934,7344098,6902070,7438107,6679047,7218883,6933746,6772418,7248114,6647287,7028323,7215703,7235107,7058733,6645913,7362147,7311558,7344633,6869611,6613534,7153538,6758625,7247463,7109695,7283647,6647990,6678183,7248734,6642826,7154667,6902527,6774327,6740658,6614663,7442519,6894471,7406838,7029639,7216278,7471138,6960426,7092546,7457345,6804713,7347167,6833386,7346007,7410687,7217058,7154073,6663427,7122823,6806790,7212153,7473666,6799273,7060870,7060083,7310983,6608631,6928666,7427213,6760253,7473047,6771714,6712039,6644023,7220199,7120998,6994654,7438598,7120507,7281707,6738022,7275673,6902599,6803398,7139827,7342827,7188367,7315407,6735671,7148633,7466151,6836473,6648447,7330387,6962894,6835854,6769782,6982655,7056987,6807247,6838466,7425585,7280578,6774946,7331933,6726865,7188439,7363775,7283190,7053353,7283719,7441990,7472183,6885665,7373222,6900587,7027627,7028407,7171505,7438674,7089238,7155447,6894553,6866998,6805223,6644598,7085031,6679666,6963453,6853909,7343394,7441287,7077935,7339193,7027033,6900503,7375154,7277942,7439378,7089314,6739954,7375858,7153454,7279223,7058174,7268413,7406914,7182662,6678963,7148551,6868831,6711510,6931134,7409527,6679750,6612838,6949267,6866431,6743186,6678267,7247547,7248038,6743270,7309786,7281113,7374503,6614093,7470358,7060786,7088747,7220127,7217533,7152834,6929947,6708898,7442447,6663345,6792095,7376333,6645294,6957991,6965506,7312338,6993467,7439853,6931693,6711426,6853991,7441906,6807319,6802823,6615443,7250643,6775030,7459055,7395453,7408093,6992186,7154583,7376903,7251959,7439913,7474207,6773547,7087466,6899374,7119226,7402631,6997350,6709943,6836983,7471613,7373306,7058793,7012787,7186427,7077853,6703911,6931218,6896906,6898187,7182746,7187123,6608713,6711967,7122313,6726947,7116791,7156150,6830951,7058258,7341546,7341462,7407534,7154013,6960342,7152758,7214506,6837763,7344014,7377767,6760335,7375774,6964023,6862797,6774243,6769866,7091927,6964107,7185833,6933127,6831033,6728493,7407618,7152267,7311634,6993383,6833302,7410146,6932347,6804094,6672151,6931753,7014415,6728575,7121074,6599825,7012705,6771147,7345227,7087382,6740574,7109613,6898678,6835158,6919053,7122253,7314950,6919135,6899458,6709373,7313467,7025794,6855619,7473750,7251430,7370953,6707543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1148,"address":[6298992],"length":1,"stats":{"Line":0},"fn_name":"get_mut"},{"line":1149,"address":[6299026,6299063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1150,"address":[6299133,6299048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1151,"address":[6299103,6299173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1154,"address":[6299296],"length":1,"stats":{"Line":0},"fn_name":"resize"},{"line":1155,"address":[6299390,6299338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1156,"address":[6299372,6299466,6299430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1157,"address":[6299434,6299510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1168,"address":[5110528,5110533],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1169,"address":[9714956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1171,"address":[9714964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1172,"address":[9715072,9715292,9714982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1173,"address":[9715266,9715552,9715172,9715340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1174,"address":[9715600,9715526,9715898,9715432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1176,"address":[9715880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1177,"address":[9716346,9715946,9716040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1179,"address":[9716328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1180,"address":[9716488,9716394,9716704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1181,"address":[9717044,9716752,9716588,9716678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1183,"address":[9717026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1184,"address":[9717378,9717092,9717180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1185,"address":[9717358,9717706,9717274,9717426],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1187,"address":[9717694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1188,"address":[9718040,9717842,9717754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1189,"address":[9718282,9718088,9717936,9718020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1190,"address":[9718330,9718262,9718434,9718174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1194,"address":[5110565,5110560],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1195,"address":[9718503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1196,"address":[9718518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1197,"address":[5110614,5110592],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1198,"address":[9718533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1199,"address":[9718610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1200,"address":[9718890,9718655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1201,"address":[9719078,9718784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1202,"address":[9718982,9719134,9719169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1210,"address":[5110661,5110656],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1211,"address":[9719271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1212,"address":[9719286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1213,"address":[5110688,5110710],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1214,"address":[9719301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1215,"address":[9719376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1216,"address":[9719656,9719421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1217,"address":[9719844,9719550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1218,"address":[9719748,9719900,9719935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1225,"address":[5110757,5110752],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1226,"address":[9720039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1227,"address":[9720054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1228,"address":[5110806,5110784],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1229,"address":[9720069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1230,"address":[9720146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1232,"address":[9720191,9720395,9720289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1233,"address":[9720651,9720528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1240,"address":[5110853,5110848],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1241,"address":[9720743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1242,"address":[9720758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1243,"address":[5110902,5110880],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1244,"address":[9720773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1245,"address":[9720850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1247,"address":[9721099,9720993,9720895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1249,"address":[9721232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1250,"address":[9721389,9721251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1251,"address":[9721396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1252,"address":[9721500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1254,"address":[9721732,9721604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1258,"address":[5110944,5110949],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1259,"address":[9721847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1260,"address":[9721862],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1261,"address":[5110976,5110998],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1262,"address":[9721877],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1263,"address":[9721954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1264,"address":[9721999,9722226],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1265,"address":[9722347,9722128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1269,"address":[5111045,5111040],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1270,"address":[9722439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1271,"address":[9722454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1272,"address":[5111094,5111072],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1273,"address":[9722469],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1274,"address":[9722546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1275,"address":[9722826,9722591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1276,"address":[9723014,9722720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1277,"address":[9722918,9723105,9723070],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1284,"address":[5111141,5111136],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1285,"address":[9723207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1286,"address":[9723222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1287,"address":[5111168,5111190],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1288,"address":[9723237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1289,"address":[9723314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1291,"address":[9723563,9723457,9723359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1292,"address":[9723888,9723696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1293,"address":[9723782,9724034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1294,"address":[9724124,9723939,9724090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1301,"address":[5111232,5111237],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1302,"address":[9724215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1303,"address":[9724230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1304,"address":[9724245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1305,"address":[9724260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1306,"address":[9724344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1307,"address":[9724618,9724383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1308,"address":[9724815,9724512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1309,"address":[9724710,9724963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1310,"address":[9725019,9724867,9725054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1314,"address":[5111264,5111269],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1315,"address":[9725143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1316,"address":[9725158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1317,"address":[9725173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1318,"address":[9725257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1319,"address":[9725302,9725541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1320,"address":[9725735,9725435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1321,"address":[9725633,9725893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1322,"address":[9725787,9726041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1323,"address":[9725945,9726097,9726203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1327,"address":[9726278,9726103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1331,"address":[5111296,5111301],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1332,"address":[9726375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1333,"address":[9726390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1334,"address":[5111350,5111328],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1335,"address":[9726405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1336,"address":[9726487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1337,"address":[9726532,9726767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1338,"address":[9726954,9726661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1339,"address":[9726859,9727010,9727044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1346,"address":[5111392,5111397],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1347,"address":[9727143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1348,"address":[9727158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1349,"address":[5111446,5111424],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1350,"address":[9727173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1351,"address":[9727255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1352,"address":[9727300,9727535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1353,"address":[9727722,9727433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1354,"address":[9727627,9727778,9727812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1361,"address":[5111488,5111493],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1362,"address":[9727911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1363,"address":[9727926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1364,"address":[5111520,5111542],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1365,"address":[9727941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1366,"address":[9728023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1367,"address":[9728303,9728068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1368,"address":[9728490,9728201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1370,"address":[9728395,9728546,9728580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1377,"address":[5111589,5111584],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1378,"address":[9728679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1379,"address":[9728694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1380,"address":[5111638,5111616],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1381,"address":[9728709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1382,"address":[9728791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1384,"address":[9729061,9728836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1385,"address":[9728965,9729157,9729204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1393,"address":[9729163,9729251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1394,"address":[9729323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1396,"address":[9729371,9729598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1397,"address":[9729695,9729503,9729729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1404,"address":[5111685,5111680],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1405,"address":[9729863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1406,"address":[9729878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1407,"address":[5111734,5111712],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1408,"address":[9729893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1409,"address":[9729975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1410,"address":[9730224,9730020,9730118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1412,"address":[9730549,9730357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1413,"address":[9730443,9730696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1414,"address":[9730787,9730752,9730600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1426,"address":[5111776,5111781],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1427,"address":[9730887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1428,"address":[9730902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1430,"address":[5111808,5111830],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1431,"address":[9730917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1432,"address":[9731002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1434,"address":[9731257,9731050,9731151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1436,"address":[9731390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1437,"address":[9731733,9731542],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1438,"address":[9731890,9731631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1439,"address":[9731784,9732037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1440,"address":[9731942,9732127,9732093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1450,"address":[5111877,5111872],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1451,"address":[9732231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1452,"address":[9732246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1453,"address":[5111904,5111926],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1454,"address":[9732261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1455,"address":[9732343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1456,"address":[9732388,9732486,9732592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1458,"address":[9732917,9732725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1459,"address":[9732811,9733064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1460,"address":[9733155,9732968,9733120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1470,"address":[5111968,5111973],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1471,"address":[9733255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1472,"address":[9733270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1473,"address":[5112022,5112000],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1474,"address":[9733285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1476,"address":[9733316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1477,"address":[9733364,9733620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1478,"address":[9733502,9733817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1479,"address":[9733712,9733876,9733940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1484,"address":[9733882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1485,"address":[9734179,9733987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1486,"address":[9734073,9734368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1487,"address":[9734424,9734488,9734272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1492,"address":[9734430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1493,"address":[9734727,9734535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1494,"address":[9734621,9734915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1495,"address":[9735005,9734820,9734971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1502,"address":[5112069,5112064],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1503,"address":[9735143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1504,"address":[9735158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1506,"address":[5112118,5112096],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1507,"address":[9735173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1508,"address":[9735198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1510,"address":[9735443,9735369,9735243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1517,"address":[5112165,5112160],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1518,"address":[9735543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1519,"address":[9735558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1521,"address":[5112214,5112192],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1522,"address":[9735573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1523,"address":[9735598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1525,"address":[9735841,9735767,9735641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1529,"address":[5112261,5112256],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1530,"address":[9735943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1531,"address":[9735958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1533,"address":[5112310,5112288],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1534,"address":[9735973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1535,"address":[9735998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1537,"address":[9736169,9736043,9736243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1544,"address":[5112357,5112352],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1545,"address":[9736343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1546,"address":[9736358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1548,"address":[5112384,5112406],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1549,"address":[9736373],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1551,"address":[9736418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1552,"address":[9736462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1554,"address":[9736713,9736639,9736510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1558,"address":[5112448,5112453],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1559,"address":[9736807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1560,"address":[9736822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1562,"address":[5112502,5112480],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1563,"address":[9736837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1565,"address":[9736882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1566,"address":[9736926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1568,"address":[9736974,9737177,9737103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1572,"address":[5112549,5112544],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1573,"address":[9737271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1574,"address":[9737286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1576,"address":[5112576,5112598],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1577,"address":[9737301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1579,"address":[9737369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1580,"address":[9737413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1582,"address":[9737461,9737590,9737664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1586,"address":[5112645,5112640],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1587,"address":[9737767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1588,"address":[9737782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1590,"address":[5112694,5112672],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1591,"address":[9737797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1593,"address":[9737865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1594,"address":[9737909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1596,"address":[9738086,9738160,9737957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1600,"address":[5112736,5112741],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1602,"address":[9738263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1603,"address":[9738308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1607,"address":[9738388,9738583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1608,"address":[9738480,9738648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1612,"address":[5112773,5112768],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1614,"address":[9738711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1615,"address":[9738756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1619,"address":[9739031,9738836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1620,"address":[9739096,9738928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1624,"address":[5112800,5112805],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1625,"address":[9739159],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1626,"address":[9739174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1628,"address":[5112854,5112832],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1629,"address":[9739189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1631,"address":[9739257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1632,"address":[9739301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1634,"address":[9739556,9739450,9739349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1635,"address":[9739689,9739805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1639,"address":[5112901,5112896],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1640,"address":[9739911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1641,"address":[9739926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1643,"address":[9739941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1645,"address":[9739990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1646,"address":[9740034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1648,"address":[9740082,9740287,9740212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1652,"address":[5112928,5112933],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1653,"address":[9740391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1654,"address":[9740406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1655,"address":[9740421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1662,"address":[9740531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1663,"address":[9740572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1664,"address":[9740772,9740617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1668,"address":[5112960,5112965],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":1669,"address":[9740919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1670,"address":[9740934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1671,"address":[9740949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1678,"address":[9741124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1679,"address":[9741168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1680,"address":[9741374,9741214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1689,"address":[9741650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1690,"address":[9741697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1691,"address":[9741743,9741903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1700,"address":[9742163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1701,"address":[9742210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1702,"address":[9742416,9742256],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1711,"address":[9742634],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1712,"address":[9742681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1713,"address":[9742727,9742887],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":698},{"path":["/","home","todd","rust-bio","src","alignment","poa.rs"],"content":"// Copyright 2017-2018 Brett Bowman, Jeff Knaggs\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Partial-Order Alignment for fast alignment and consensus of multiple homologous sequences.\n//!\n//! For the original concept and theory, see:\n//! * Lee, Christopher, Catherine Grasso, and Mark F. Sharlow. \"Multiple sequence alignment using\n//! partial order graphs.\" Bioinformatics 18.3 (2002): 452-464.\n//! * Lee, Christopher. \"Generating consensus sequences from partial order multiple sequence\n//! alignment graphs.\" Bioinformatics 19.8 (2003): 999-1008.\n//!\n//! For a modern reference implementation, see poapy:\n//! https://github.com/ljdursi/poapy\n//!\n//! # Example\n//!\n//! ```\n//! use bio::alignment::pairwise::Scoring;\n//! use bio::alignment::poa::*;\n//!\n//! let x = b\"AAAAAAA\";\n//! let y = b\"AABBBAA\";\n//! let z = b\"AABCBAA\";\n//!\n//! let scoring = Scoring::new(-1, 0, |a: u8, b: u8| if a == b { 1i32 } else { -1i32 });\n//! let mut aligner = Aligner::new(scoring, x);\n//! // z differs from x in 3 locations\n//! assert_eq!(aligner.global(z).alignment().score, 1);\n//! aligner.global(y).add_to_graph();\n//! // z differs from x and y's partial order alignment by 1 base\n//! assert_eq!(aligner.global(z).alignment().score, 5);\n//! ```\n\nuse std::cmp::{max, Ordering};\n\nuse crate::utils::TextSlice;\n\nuse crate::alignment::pairwise::{MatchFunc, Scoring};\n\nuse petgraph::graph::NodeIndex;\nuse petgraph::visit::Topo;\n\nuse petgraph::{Directed, Graph, Incoming};\n\npub const MIN_SCORE: i32 = -858_993_459; // negative infinity; see alignment/pairwise/mod.rs\npub type POAGraph = Graph\u003cu8, i32, Directed, usize\u003e;\n\n// Unlike with a total order we may have arbitrary successors in the\n// traceback matrix. I have not yet figured out what the best level of\n// detail to store is, so Match and Del operations remember In and Out\n// nodes on the reference graph.\n#[derive(Debug, Clone)]\npub enum AlignmentOperation {\n    Match(Option\u003c(usize, usize)\u003e),\n    Del(Option\u003c(usize, usize)\u003e),\n    Ins(Option\u003cusize\u003e),\n}\n\npub struct Alignment {\n    pub score: i32,\n    //    xstart: Edge,\n    operations: Vec\u003cAlignmentOperation\u003e,\n}\n\n#[derive(Debug, Clone)]\npub struct TracebackCell {\n    score: i32,\n    op: AlignmentOperation,\n}\n\nimpl Ord for TracebackCell {\n    fn cmp(\u0026self, other: \u0026TracebackCell) -\u003e Ordering {\n        self.score.cmp(\u0026other.score)\n    }\n}\n\nimpl PartialOrd for TracebackCell {\n    fn partial_cmp(\u0026self, other: \u0026TracebackCell) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\nimpl PartialEq for TracebackCell {\n    fn eq(\u0026self, other: \u0026TracebackCell) -\u003e bool {\n        self.score == other.score\n    }\n}\n\n//impl Default for TracebackCell { }\n\nimpl Eq for TracebackCell {}\n\npub struct Traceback {\n    rows: usize,\n    cols: usize,\n\n    // store the last visited node in topological order so that\n    // we can index into the end of the alignment when we backtrack\n    last: NodeIndex\u003cusize\u003e,\n    matrix: Vec\u003cVec\u003cTracebackCell\u003e\u003e,\n}\n\nimpl Traceback {\n    /// Create a Traceback matrix with given maximum sizes\n    ///\n    /// # Arguments\n    ///\n    /// * `m` - the number of nodes in the DAG\n    /// * `n` - the length of the query sequence\n    fn with_capacity(m: usize, n: usize) -\u003e Self {\n        let matrix = vec![\n            vec![\n                TracebackCell {\n                    score: 0,\n                    op: AlignmentOperation::Match(None)\n                };\n                n + 1\n            ];\n            m + 1\n        ];\n        Traceback {\n            rows: m,\n            cols: n,\n            last: NodeIndex::new(0),\n            matrix,\n        }\n    }\n\n    /// Populate the edges of the traceback matrix\n    fn initialize_scores(\u0026mut self, gap_open: i32) {\n        for (i, row) in self\n            .matrix\n            .iter_mut()\n            .enumerate()\n            .take(self.rows + 1)\n            .skip(1)\n        {\n            // TODO: these should be -1 * distance from head node\n            row[0] = TracebackCell {\n                score: (i as i32) * gap_open, // gap_open penalty\n                op: AlignmentOperation::Del(None),\n            };\n        }\n        for j in 1..=self.cols {\n            self.matrix[0][j] = TracebackCell {\n                score: (j as i32) * gap_open,\n                op: AlignmentOperation::Ins(None),\n            };\n        }\n    }\n\n    fn new() -\u003e Self {\n        Traceback {\n            rows: 0,\n            cols: 0,\n            last: NodeIndex::new(0),\n            matrix: Vec::new(),\n        }\n    }\n\n    fn set(\u0026mut self, i: usize, j: usize, cell: TracebackCell) {\n        self.matrix[i][j] = cell;\n    }\n\n    fn get(\u0026self, i: usize, j: usize) -\u003e \u0026TracebackCell {\n        \u0026self.matrix[i][j]\n    }\n\n    pub fn print(\u0026self, g: \u0026Graph\u003cu8, i32, Directed, usize\u003e, query: TextSlice) {\n        let (m, n) = (g.node_count(), query.len());\n        print!(\".\\t\");\n        for base in query.iter().take(n) {\n            print!(\"{:?}\\t\", *base);\n        }\n        for i in 0..m {\n            print!(\"\\n{:?}\\t\", g.raw_nodes()[i].weight);\n            for j in 0..n {\n                print!(\"{}.\\t\", self.get(i + 1, j + 1).score);\n            }\n        }\n        println!();\n    }\n\n    pub fn alignment(\u0026self) -\u003e Alignment {\n        // optimal AlignmentOperation path\n        let mut ops: Vec\u003cAlignmentOperation\u003e = vec![];\n\n        // Now backtrack through the matrix to construct an optimal path\n        let mut i = self.last.index() + 1;\n        let mut j = self.cols;\n\n        while i \u003e 0 \u0026\u0026 j \u003e 0 {\n            // push operation and edge corresponding to (one of the) optimal\n            // routes\n            ops.push(self.matrix[i][j].op.clone());\n            match self.matrix[i][j].op {\n                AlignmentOperation::Match(Some((p, _))) =\u003e {\n                    i = p + 1;\n                    j -= 1;\n                }\n                AlignmentOperation::Del(Some((p, _))) =\u003e {\n                    i = p + 1;\n                }\n                AlignmentOperation::Ins(Some(p)) =\u003e {\n                    i = p + 1;\n                    j -= 1;\n                }\n                AlignmentOperation::Match(None) =\u003e {\n                    break;\n                }\n                AlignmentOperation::Del(None) =\u003e {\n                    j -= 1;\n                }\n                AlignmentOperation::Ins(None) =\u003e {\n                    i -= 1;\n                }\n            }\n        }\n\n        ops.reverse();\n\n        Alignment {\n            score: self.matrix[self.last.index() + 1][self.cols].score,\n            operations: ops,\n        }\n    }\n}\n\n/// A partially ordered aligner builder\n///\n/// Uses consuming builder pattern for constructing partial order alignments with method chaining\npub struct Aligner\u003cF: MatchFunc\u003e {\n    traceback: Traceback,\n    query: Vec\u003cu8\u003e,\n    poa: Poa\u003cF\u003e,\n}\n\nimpl\u003cF: MatchFunc\u003e Aligner\u003cF\u003e {\n    /// Create new instance.\n    pub fn new(scoring: Scoring\u003cF\u003e, reference: TextSlice) -\u003e Self {\n        Aligner {\n            traceback: Traceback::new(),\n            query: reference.to_vec(),\n            poa: Poa::from_string(scoring, reference),\n        }\n    }\n\n    /// Add the alignment of the last query to the graph.\n    pub fn add_to_graph(\u0026mut self) -\u003e \u0026mut Self {\n        let alignment = self.traceback.alignment();\n        self.poa.add_alignment(\u0026alignment, \u0026self.query);\n        self\n    }\n\n    /// Return alignment of last added query against the graph.\n    pub fn alignment(\u0026self) -\u003e Alignment {\n        self.traceback.alignment()\n    }\n\n    /// Globally align a given query against the graph.\n    pub fn global(\u0026mut self, query: TextSlice) -\u003e \u0026mut Self {\n        self.query = query.to_vec();\n        self.traceback = self.poa.global(query);\n        self\n    }\n\n    /// Return alignment graph.\n    pub fn graph(\u0026self) -\u003e \u0026POAGraph {\n        \u0026self.poa.graph\n    }\n}\n\n/// A partially ordered alignment graph\n///\n/// A directed acyclic graph datastructure that represents the topology of a\n/// traceback matrix.\npub struct Poa\u003cF: MatchFunc\u003e {\n    scoring: Scoring\u003cF\u003e,\n    pub graph: POAGraph,\n}\n\nimpl\u003cF: MatchFunc\u003e Poa\u003cF\u003e {\n    /// Create a new aligner instance from the directed acyclic graph of another.\n    ///\n    /// # Arguments\n    ///\n    /// * `scoring` - the score struct\n    /// * `poa` - the partially ordered reference alignment\n    pub fn new(scoring: Scoring\u003cF\u003e, graph: POAGraph) -\u003e Self {\n        Poa { scoring, graph }\n    }\n\n    /// Create a new POA graph from an initial reference sequence and alignment penalties.\n    ///\n    /// # Arguments\n    ///\n    /// * `scoring` - the score struct\n    /// * `reference` - a reference TextSlice to populate the initial reference graph\n    pub fn from_string(scoring: Scoring\u003cF\u003e, seq: TextSlice) -\u003e Self {\n        let mut graph: Graph\u003cu8, i32, Directed, usize\u003e =\n            Graph::with_capacity(seq.len(), seq.len() - 1);\n        let mut prev: NodeIndex\u003cusize\u003e = graph.add_node(seq[0]);\n        let mut node: NodeIndex\u003cusize\u003e;\n        for base in seq.iter().skip(1) {\n            node = graph.add_node(*base);\n            graph.add_edge(prev, node, 1);\n            prev = node;\n        }\n\n        Poa { scoring, graph }\n    }\n\n    /// A global Needleman-Wunsch aligner on partially ordered graphs.\n    ///\n    /// # Arguments\n    /// * `query` - the query TextSlice to align against the internal graph member\n    pub fn global(\u0026self, query: TextSlice) -\u003e Traceback {\n        assert!(self.graph.node_count() != 0);\n\n        // dimensions of the traceback matrix\n        let (m, n) = (self.graph.node_count(), query.len());\n        let mut traceback = Traceback::with_capacity(m, n);\n        traceback.initialize_scores(self.scoring.gap_open);\n\n        traceback.set(\n            0,\n            0,\n            TracebackCell {\n                score: 0,\n                op: AlignmentOperation::Match(None),\n            },\n        );\n\n        // construct the score matrix (O(n^2) space)\n        let mut topo = Topo::new(\u0026self.graph);\n        while let Some(node) = topo.next(\u0026self.graph) {\n            // reference base and index\n            let r = self.graph.raw_nodes()[node.index()].weight; // reference base at previous index\n            let i = node.index() + 1;\n            traceback.last = node;\n            // iterate over the predecessors of this node\n            let prevs: Vec\u003cNodeIndex\u003cusize\u003e\u003e =\n                self.graph.neighbors_directed(node, Incoming).collect();\n            // query base and its index in the DAG (traceback matrix rows)\n            for (j_p, q) in query.iter().enumerate() {\n                let j = j_p + 1;\n                // match and deletion scores for the first reference base\n                let max_cell = if prevs.is_empty() {\n                    TracebackCell {\n                        score: traceback.get(0, j - 1).score + self.scoring.match_fn.score(r, *q),\n                        op: AlignmentOperation::Match(None),\n                    }\n                } else {\n                    let mut max_cell = TracebackCell {\n                        score: MIN_SCORE,\n                        op: AlignmentOperation::Match(None),\n                    };\n                    for prev_node in \u0026prevs {\n                        let i_p: usize = prev_node.index() + 1; // index of previous node\n                        max_cell = max(\n                            max_cell,\n                            max(\n                                TracebackCell {\n                                    score: traceback.get(i_p, j - 1).score\n                                        + self.scoring.match_fn.score(r, *q),\n                                    op: AlignmentOperation::Match(Some((i_p - 1, i - 1))),\n                                },\n                                TracebackCell {\n                                    score: traceback.get(i_p, j).score + self.scoring.gap_open,\n                                    op: AlignmentOperation::Del(Some((i_p - 1, i))),\n                                },\n                            ),\n                        );\n                    }\n                    max_cell\n                };\n\n                let score = max(\n                    max_cell,\n                    TracebackCell {\n                        score: traceback.get(i, j - 1).score + self.scoring.gap_open,\n                        op: AlignmentOperation::Ins(Some(i - 1)),\n                    },\n                );\n                traceback.set(i, j, score);\n            }\n        }\n\n        traceback\n    }\n\n    /// Experimental: return sequence of traversed edges\n    ///\n    /// Only supports alignments for sequences that have already been added,\n    /// so all operations must be Match.\n    pub fn edges(\u0026self, aln: Alignment) -\u003e Vec\u003cusize\u003e {\n        let mut path: Vec\u003cusize\u003e = vec![];\n        let mut prev: NodeIndex\u003cusize\u003e = NodeIndex::new(0);\n        let mut _i: usize = 0;\n        for op in aln.operations {\n            match op {\n                AlignmentOperation::Match(None) =\u003e {\n                    _i += 1;\n                }\n                AlignmentOperation::Match(Some((_, p))) =\u003e {\n                    let node = NodeIndex::new(p);\n                    let edge = self.graph.find_edge(prev, node).unwrap();\n                    path.push(edge.index());\n                    prev = NodeIndex::new(p);\n                    _i += 1;\n                }\n                AlignmentOperation::Ins(None) =\u003e {}\n                AlignmentOperation::Ins(Some(_)) =\u003e {}\n                AlignmentOperation::Del(_) =\u003e {}\n            }\n        }\n        path\n    }\n\n    /// Incorporate a new sequence into a graph from an alignment\n    ///\n    /// # Arguments\n    ///\n    /// * `aln` - The alignment of the new sequence to the graph\n    /// * `seq` - The sequence being incorporated\n    pub fn add_alignment(\u0026mut self, aln: \u0026Alignment, seq: TextSlice) {\n        let mut prev: NodeIndex\u003cusize\u003e = NodeIndex::new(0);\n        let mut i: usize = 0;\n        for op in aln.operations.iter() {\n            match op {\n                AlignmentOperation::Match(None) =\u003e {\n                    i += 1;\n                }\n                AlignmentOperation::Match(Some((_, p))) =\u003e {\n                    let node = NodeIndex::new(*p);\n                    if (seq[i] != self.graph.raw_nodes()[*p].weight) \u0026\u0026 (seq[i] != b'X') {\n                        let node = self.graph.add_node(seq[i]);\n                        self.graph.add_edge(prev, node, 1);\n                        prev = node;\n                    } else {\n                        // increment node weight\n                        match self.graph.find_edge(prev, node) {\n                            Some(edge) =\u003e {\n                                *self.graph.edge_weight_mut(edge).unwrap() += 1;\n                            }\n                            None =\u003e {\n                                // where the previous node was newly added\n                                self.graph.add_edge(prev, node, 1);\n                            }\n                        }\n                        prev = NodeIndex::new(*p);\n                    }\n                    i += 1;\n                }\n                AlignmentOperation::Ins(None) =\u003e {\n                    i += 1;\n                }\n                AlignmentOperation::Ins(Some(_)) =\u003e {\n                    let node = self.graph.add_node(seq[i]);\n                    self.graph.add_edge(prev, node, 1);\n                    prev = node;\n                    i += 1;\n                }\n                AlignmentOperation::Del(_) =\u003e {} // we should only have to skip over deleted nodes\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::alignment::pairwise::Scoring;\n    use petgraph::graph::NodeIndex;\n\n    #[test]\n    fn test_init_graph() {\n        // sanity check for String -\u003e Graph\n\n        let scoring = Scoring::new(-1, 0, |a: u8, b: u8| if a == b { 1i32 } else { -1i32 });\n        let poa = Poa::from_string(scoring, b\"123456789\");\n        assert!(poa.graph.is_directed());\n        assert_eq!(poa.graph.node_count(), 9);\n        assert_eq!(poa.graph.edge_count(), 8);\n    }\n\n    #[test]\n    fn test_alignment() {\n        let scoring = Scoring::new(-1, 0, |a: u8, b: u8| if a == b { 1i32 } else { -1i32 });\n        // examples from the POA paper\n        //let _seq1 = b\"PKMIVRPQKNETV\";\n        //let _seq2 = b\"THKMLVRNETIM\";\n        let poa = Poa::from_string(scoring, b\"GATTACA\");\n        let alignment = poa.global(b\"GCATGCU\").alignment();\n        assert_eq!(alignment.score, 0);\n\n        let alignment = poa.global(b\"GCATGCUx\").alignment();\n        assert_eq!(alignment.score, -1);\n\n        let alignment = poa.global(b\"xCATGCU\").alignment();\n        assert_eq!(alignment.score, -2);\n    }\n\n    #[test]\n    fn test_branched_alignment() {\n        let scoring = Scoring::new(-1, 0, |a: u8, b: u8| if a == b { 1i32 } else { -1i32 });\n        let seq1 = b\"TTTTT\";\n        let seq2 = b\"TTATT\";\n        let mut poa = Poa::from_string(scoring, seq1);\n        let head: NodeIndex\u003cusize\u003e = NodeIndex::new(1);\n        let tail: NodeIndex\u003cusize\u003e = NodeIndex::new(2);\n        let node1 = poa.graph.add_node(b'A');\n        let node2 = poa.graph.add_node(b'A');\n        poa.graph.add_edge(head, node1, 1);\n        poa.graph.add_edge(node1, node2, 1);\n        poa.graph.add_edge(node2, tail, 1);\n        let alignment = poa.global(seq2).alignment();\n        assert_eq!(alignment.score, 3);\n    }\n\n    #[test]\n    fn test_alt_branched_alignment() {\n        let scoring = Scoring::new(-1, 0, |a: u8, b: u8| if a == b { 1i32 } else { -1i32 });\n\n        let seq1 = b\"TTCCTTAA\";\n        let seq2 = b\"TTTTGGAA\";\n        let mut poa = Poa::from_string(scoring, seq1);\n        let head: NodeIndex\u003cusize\u003e = NodeIndex::new(1);\n        let tail: NodeIndex\u003cusize\u003e = NodeIndex::new(2);\n        let node1 = poa.graph.add_node(b'A');\n        let node2 = poa.graph.add_node(b'A');\n        poa.graph.add_edge(head, node1, 1);\n        poa.graph.add_edge(node1, node2, 1);\n        poa.graph.add_edge(node2, tail, 1);\n        let alignment = poa.global(seq2).alignment();\n        poa.add_alignment(\u0026alignment, seq2);\n        assert_eq!(poa.graph.edge_count(), 14);\n        assert!(poa\n            .graph\n            .contains_edge(NodeIndex::new(5), NodeIndex::new(10)));\n        assert!(poa\n            .graph\n            .contains_edge(NodeIndex::new(11), NodeIndex::new(6)));\n    }\n\n    #[test]\n    fn test_insertion_on_branch() {\n        let scoring = Scoring::new(-1, 0, |a: u8, b: u8| if a == b { 1i32 } else { -1i32 });\n\n        let seq1 = b\"TTCCGGTTTAA\";\n        let seq2 = b\"TTGGTATGGGAA\";\n        let seq3 = b\"TTGGTTTGCGAA\";\n        let mut poa = Poa::from_string(scoring, seq1);\n        let head: NodeIndex\u003cusize\u003e = NodeIndex::new(1);\n        let tail: NodeIndex\u003cusize\u003e = NodeIndex::new(2);\n        let node1 = poa.graph.add_node(b'C');\n        let node2 = poa.graph.add_node(b'C');\n        let node3 = poa.graph.add_node(b'C');\n        poa.graph.add_edge(head, node1, 1);\n        poa.graph.add_edge(node1, node2, 1);\n        poa.graph.add_edge(node2, node3, 1);\n        poa.graph.add_edge(node3, tail, 1);\n        let alignment = poa.global(seq2).alignment();\n        assert_eq!(alignment.score, 2);\n        poa.add_alignment(\u0026alignment, seq2);\n        let alignment2 = poa.global(seq3).alignment();\n\n        assert_eq!(alignment2.score, 10);\n    }\n\n    #[test]\n    fn test_poa_method_chaining() {\n        let scoring = Scoring::new(-1, 0, |a: u8, b: u8| if a == b { 1i32 } else { -1i32 });\n        let mut aligner = Aligner::new(scoring, b\"TTCCGGTTTAA\");\n        aligner\n            .global(b\"TTGGTATGGGAA\")\n            .add_to_graph()\n            .global(b\"TTGGTTTGCGAA\")\n            .add_to_graph();\n        assert_eq!(aligner.alignment().score, 10);\n    }\n}\n","traces":[{"line":74,"address":[5904256],"length":1,"stats":{"Line":0},"fn_name":"cmp"},{"line":75,"address":[5904270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[5904304],"length":1,"stats":{"Line":0},"fn_name":"partial_cmp"},{"line":81,"address":[5904318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[5904352],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":87,"address":[5904365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[5904792,5904384],"length":1,"stats":{"Line":0},"fn_name":"with_capacity"},{"line":113,"address":[5904427,5904807,5904732,5904675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[5904594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[5904507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[5904435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[5904573,5904619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[5904654,5904700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[5904778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[5904976],"length":1,"stats":{"Line":0},"fn_name":"initialize_scores"},{"line":133,"address":[5905103,5905314,5905629,5905156,5905007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[5905079,5905126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[5905482,5905611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[5905383,5905576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[5905410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[5906064,5905282,5905768,5906069,5905634],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[5906026,5905888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[5905986,5905805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[5905832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[5906080],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":158,"address":[5906094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[5906108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[5906192],"length":1,"stats":{"Line":0},"fn_name":"set"},{"line":164,"address":[5906239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[5906352],"length":1,"stats":{"Line":0},"fn_name":"get"},{"line":168,"address":[5906376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[5906448],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":172,"address":[5906538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[5906661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[5907131,5906973,5906728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[5907005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[5906913,5907267,5907656,5907149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[5907304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[5907526,5907965,5907666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[5907703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[5907217,5907970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[5909503,5908000,5909488],"length":1,"stats":{"Line":0},"fn_name":"alignment"},{"line":188,"address":[5908039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[5908189,5908060,5908167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[5908175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[5908221,5908187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[5908286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[5908749,5909122,5908961,5908528,5908418,5908800,5908910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[5909009,5908498,5908535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[5909021,5909076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[5909127,5909114,5909050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[5908869,5908560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[5908881,5908915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[5908636,5908585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[5908703,5908648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[5908741,5908754,5908677],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[5908953,5908966,5908838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[5908792,5908805,5908598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[5909168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[5909216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[4560549,4560160],"length":1,"stats":{"Line":0},"fn_name":"new\u003cclosure-0\u003e"},{"line":244,"address":[4560219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[4560257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[4560329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[4560576,4560716],"length":1,"stats":{"Line":0},"fn_name":"add_to_graph\u003cclosure-0\u003e"},{"line":252,"address":[4560593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[4560608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[4560752],"length":1,"stats":{"Line":0},"fn_name":"alignment\u003cclosure-0\u003e"},{"line":259,"address":[4560769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[4560959,4560784],"length":1,"stats":{"Line":0},"fn_name":"global\u003cclosure-0\u003e"},{"line":264,"address":[4560911,4560820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[4560891,4560975,4561017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[4561824,4562608,4564976,4563392,4564176,4562623,4561840,4563408,4561839,4561056,4564192,4563407,4564960,4565744,4565759,4564191,4564975,4562624],"length":1,"stats":{"Line":0},"fn_name":"from_string\u003cclosure-0\u003e"},{"line":302,"address":[4564339,4561907,4563555,4563475,4565123,4565043,4562691,4561123,4561987,4564259,4562771,4561203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[4564533,4563749,4565198,4562846,4561278,4562062,4565317,4561397,4563630,4562965,4564414,4562181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[4561819,4565636,4562603,4564852,4563284,4563757,4565325,4561405,4562189,4562973,4562500,4564541,4564068,4564955,4565739,4563387,4561716,4564171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[4564884,4565668,4562532,4564100,4563316,4561748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[4562566,4561782,4564918,4563350,4564134,4565702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[4565731,4564163,4563379,4562595,4564947,4561811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[4565760,4573376,4569524,4580948,4569568,4573332,4584756,4577184,4577140,4580992],"length":1,"stats":{"Line":0},"fn_name":"global\u003cclosure-0\u003e"},{"line":320,"address":[4573523,4581074,4573458,4569650,4565907,4577266,4569715,4581139,4577331,4565842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[4581185,4565953,4569700,4565892,4577377,4573508,4569761,4577316,4581124,4573569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[4573655,4577463,4569847,4566039,4581271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[4569876,4573684,4577492,4581300,4566068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[4570005,4573813,4581429,4566197,4577621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[4577566,4581374,4569950,4566142,4573758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[4581318,4573702,4577510,4569894,4566086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[4566264,4577688,4570072,4573880,4581496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[4581521,4566411,4566289,4577713,4574027,4581643,4570097,4570219,4577835,4573905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[4566435,4578101,4577859,4574051,4574293,4570243,4581909,4570485,4566551,4570359,4577975,4566677,4581667,4574167,4581783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[4570451,4581875,4566803,4582035,4574419,4570513,4574321,4578129,4578067,4581937,4574259,4566643,4566705,4570611,4578227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[4570572,4574380,4566764,4578188,4581996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[4566852,4574384,4578192,4566768,4582084,4574468,4570576,4578276,4570660,4582000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[4570683,4578407,4580943,4569519,4574491,4578598,4584751,4574790,4566983,4582107,4573327,4567174,4582215,4578299,4574599,4577135,4570791,4570982,4582406,4566875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[4571113,4567246,4582537,4571054,4574921,4582478,4578729,4574862,4578670,4567305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[4568056,4567843,4579267,4574905,4571651,4574961,4582577,4571153,4582521,4578769,4575672,4571097,4583075,4567289,4571864,4567345,4583288,4579480,4575459,4578713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[4571653,4578926,4582734,4575461,4571310,4575118,4579269,4567845,4583077,4567502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[4582932,4579124,4571508,4575316,4567700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[4578779,4571163,4567355,4582587,4574971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[4569091,4576707,4572899,4571761,4571869,4579485,4580515,4568061,4567462,4571270,4584323,4583185,4583293,4575569,4575078,4575677,4578886,4567953,4582694,4579377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[4572005,4579517,4571901,4583429,4575709,4583325,4568093,4579621,4575813,4568197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[4580482,4584290,4576674,4569058,4572866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[4583377,4579569,4571953,4575761,4568145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[4568994,4584226,4576610,4572802,4580418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[4580057,4568633,4572441,4583865,4576249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[4576014,4579786,4568362,4575864,4571987,4572206,4575978,4583630,4568248,4583594,4568179,4579672,4579822,4572170,4583411,4579603,4572056,4568398,4575795,4583480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[4568331,4575947,4583563,4579755,4572139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[4568380,4576303,4572188,4579804,4583671,4572495,4572247,4583919,4575996,4580111,4579863,4568439,4568687,4583612,4576055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[4584163,4568931,4576547,4572739,4580355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[4584009,4580157,4580201,4576288,4572480,4583965,4583904,4568777,4576349,4576393,4568733,4580096,4568672,4572541,4572585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[4569001,4584059,4572635,4583987,4580179,4584233,4576371,4576617,4572809,4568755,4576443,4580251,4580425,4572563,4568827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[4579454,4575646,4583262,4568030,4571838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[4579302,4571686,4567878,4575494,4583110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[4569329,4576945,4580753,4584561,4573137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[4583144,4576840,4579336,4569117,4571720,4584456,4567912,4576733,4580541,4573032,4572925,4584349,4580648,4575528,4569224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[4569265,4584631,4573207,4584497,4569399,4573011,4577015,4576819,4580627,4580823,4569203,4576881,4573073,4584435,4580689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[4584688,4573264,4577072,4580880,4569456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[4570272,4574080,4566464,4581696,4577888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[4584800,4586544,4588288],"length":1,"stats":{"Line":0},"fn_name":"add_alignment\u003cclosure-0\u003e"},{"line":429,"address":[4584871,4588359,4586615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[4586640,4588384,4584896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[4588577,4588396,4586833,4585519,4587263,4589007,4584908,4585089,4586652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[4586909,4586939,4588250,4585540,4588975,4585487,4585195,4587284,4589994,4588683,4588199,4586455,4589943,4586506,4585165,4587231,4589028,4588653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[4586919,4585175,4586873,4588617,4585129,4588663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[4585572,4589999,4589986,4588242,4586511,4586498,4588285,4587316,4586541,4590029,4588255,4589060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[4587360,4585616,4589104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[4589132,4585644,4587388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[4589925,4585677,4589165,4587421,4586437,4588181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[4587794,4586050,4589538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[4589649,4586161,4587905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[4587928,4589672,4586184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[4589483,4586370,4586422,4587986,4585995,4586242,4589730,4588114,4587739,4589858,4588166,4589910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[4588035,4587969,4586225,4589779,4586291,4589713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[4586372,4588051,4589860,4586307,4589795,4588116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[4588004,4586260,4589748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[4586407,4588173,4588151,4589895,4589917,4586429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[4587936,4589948,4586447,4589680,4586192,4588191,4589935,4588204,4586460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[4588696,4585208,4586952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[4586965,4585532,4587286,4588709,4585221,4587276,4589030,4585542,4589020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[4585281,4587025,4588769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[4587154,4588898,4585410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[4585436,4587180,4588924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[4587188,4588932,4587233,4588977,4585489,4585444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[4611408,4611413],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":482,"address":[4796423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[4796440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[4796580,4796498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[4796617,4796741,4796565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[4796716,4796798,4796914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[4611440,4611445],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":491,"address":[4611494,4611472],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":495,"address":[4797016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[4797069,4797169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[4797213,4797386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[4797453,4797344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[4797688,4797515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[4797756,4797646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[4797818,4797974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[4611536,4611541],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":508,"address":[4611590,4611568],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":509,"address":[4798120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[4798135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[4798150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[4798208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[4798298,4798241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[4798316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[4798354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[4798402],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[4798429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[4798456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[4798463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[4798729,4798573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[4611632,4611637],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":525,"address":[4611664,4611686],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":527,"address":[4798843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[4798858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[4798873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[4798937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[4799030,4798970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[4799051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[4799092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[4799143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[4799173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[4799203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[4799210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[4799323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[4799563,4799406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[4799649,4799705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[4799619,4799538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[4799770,4799808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[4799740,4799690],"length":1,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[4611733,4611728],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":550,"address":[4611782,4611760],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":552,"address":[4799912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[4799927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[4799942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[4799957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[4800015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[4800105,4800048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[4800123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[4800161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[4800199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[4800247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[4800274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[4800301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[4800328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[4800335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[4800445,4800618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[4800576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[4800669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[4800779,4800935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[4611824,4611829],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":575,"address":[4611856,4611878],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":576,"address":[4801064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[4801117,4801211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":582,"address":[4801263],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":254},{"path":["/","home","todd","rust-bio","src","alignment","sparse.rs"],"content":"// Copyright 2014-2015 Patrick Marks\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Calculate 'sparse' alignments from kmer matches. Can be much faster than\n//! Smith-Waterman for long string, when a large enough k is used.\n//! Complexity: O(n * log(n)) for a pair of strings with n k-kmer matches. This\n//! approach is useful for generating an approximate 'backbone' alignments\n//! between two long sequences, for example in long-read alignment or\n//! genome-genome alignment. The backbone alignment can be used as-is, or can serve\n//! as a guide for a banded alignment.  By tuning k so that len(query) + len(reference) \u003c 4^k,\n//! the number of false positive kmer matches is kept small, resulting in very\n//! fast run times for long strings.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::alignment::sparse::*;\n//!\n//! let s1 =   b\"ACGTACGATAGGTA\";\n//! let s2 = b\"TTACGTACGATAGGTATT\";\n//! let k = 8;\n//! let matches = find_kmer_matches(s1, s2, k);\n//! let sparse_al = lcskpp(\u0026matches, k);\n//! let match_path: Vec\u003c(u32,u32)\u003e = sparse_al.path.iter().map(|i| matches[*i]).collect();\n//! assert_eq!(match_path, vec![(0,2), (1,3), (2,4), (3,5), (4,6), (5,7), (6,8)]);\n//! assert_eq!(sparse_al.score, 14);\n\nuse crate::data_structures::bit_tree::MaxBitTree;\nuse fxhash::FxHasher;\nuse std::cmp::{max, min};\nuse std::collections::HashMap;\nuse std::hash::BuildHasherDefault;\n\npub type HashMapFx\u003cK, V\u003e = HashMap\u003cK, V, BuildHasherDefault\u003cFxHasher\u003e\u003e;\n\n/// Result of a sparse alignment\n#[derive(Debug, PartialEq, Eq)]\npub struct SparseAlignmentResult {\n    /// LCSk++ path, represented as vector of indices into the input matches vector.\n    pub path: Vec\u003cusize\u003e,\n    // Score of the path, which is the number of bases covered by the matched kmers.\n    pub score: u32,\n    // Full DP vector, which can generally be ignored. (It may be useful for testing purposes).\n    pub dp_vector: Vec\u003c(u32, i32)\u003e,\n}\n\n/// Sparse DP routine for Longest Common Subsequence in length k substrings.  Also known of LCSk++\n/// From LCSk++: Practical similarity metric for long strings. Filip Pavetić, Goran Žužić, Mile Šikić\n/// Paper here :https://arxiv.org/abs/1407.2407.  Original implementation here:\n/// https://github.com/fpavetic/lcskpp\n///\n/// # Arguments\n///\n/// * `matches` - a vector of tuples indicating the (string1 position, string2 position) kmer\n///   matches between the strings\n/// * `k` - the kmer length used for matching\n///\n/// # Return value\n///\n/// The method returns a `SparseAlignmentResult` struct with the following fields:\n/// * `path` is the LCSk++ path, represented as vector of indices into the input matches vector.\n/// * `score` is the score of the path, which is the number of bases covered by the matched kmers.\n/// * `dp_vector` is the full DP vector, which can generally be ignored. (It may be useful for\n///   testing purposes).\npub fn lcskpp(matches: \u0026[(u32, u32)], k: usize) -\u003e SparseAlignmentResult {\n    if matches.is_empty() {\n        return SparseAlignmentResult {\n            path: Vec::new(),\n            score: 0,\n            dp_vector: Vec::new(),\n        };\n    }\n\n    let k = k as u32;\n\n    // incoming matches must be sorted to let us find the predecessor kmers by binary search.\n    for i in 1..matches.len() {\n        assert!(matches[i - 1] \u003c matches[i]);\n    }\n\n    let mut events: Vec\u003c(u32, u32, u32)\u003e = Vec::new();\n    let mut n = 0;\n\n    for (idx, \u0026(x, y)) in matches.iter().enumerate() {\n        events.push((x, y, (idx + matches.len()) as u32));\n        events.push((x + k, y + k, idx as u32));\n\n        n = max(n, x + k);\n        n = max(n, y + k);\n    }\n    events.sort_unstable();\n\n    let mut max_col_dp: MaxBitTree\u003c(u32, u32)\u003e = MaxBitTree::new(n as usize);\n    let mut dp: Vec\u003c(u32, i32)\u003e = Vec::with_capacity(events.len());\n    let mut best_dp = (k, 0);\n\n    dp.resize(events.len(), (0, 0));\n\n    for ev in events {\n        let p = (ev.2 % matches.len() as u32) as usize;\n        let j = ev.1;\n        let is_start = ev.2 \u003e= (matches.len() as u32);\n\n        if is_start {\n            dp[p] = (k, -1);\n            let (best_value, best_position) = max_col_dp.get(j as usize);\n            if best_value \u003e 0 {\n                dp[p] = (k + best_value, best_position as i32);\n                best_dp = max(best_dp, (dp[p].0, p as i32));\n            }\n        } else {\n            // See if this kmer continues a different kmer\n            if ev.0 \u003e k \u0026\u0026 ev.1 \u003e k {\n                if let Ok(cont_idx) = matches.binary_search(\u0026(ev.0 - k - 1, ev.1 - k - 1)) {\n                    let prev_score = dp[cont_idx].0;\n                    let candidate = (prev_score + 1, cont_idx as i32);\n                    dp[p] = max(dp[p], candidate);\n                    best_dp = max(best_dp, (dp[p].0, p as i32));\n                }\n            }\n\n            max_col_dp.set(ev.1 as usize, (dp[p].0, p as u32));\n        }\n    }\n\n    let mut traceback = Vec::new();\n    let (best_score, mut prev_match) = best_dp;\n    while prev_match \u003e= 0 {\n        traceback.push(prev_match as usize);\n        prev_match = dp[prev_match as usize].1;\n    }\n    traceback.reverse();\n    SparseAlignmentResult {\n        path: traceback,\n        score: best_score,\n        dp_vector: dp,\n    }\n}\n\n#[derive(PartialEq, Eq, Ord, PartialOrd, Default, Copy, Clone)]\nstruct PrevPtr {\n    plane: u32,\n    score: u32,\n    d: u32,\n    id: usize,\n    x: u32,\n    y: u32,\n}\n\nimpl PrevPtr {\n    pub fn new(score: u32, x: u32, y: u32, id: usize, gap_extend: u32) -\u003e PrevPtr {\n        let d = x + y;\n        PrevPtr {\n            plane: score + (d * gap_extend),\n            score,\n            d,\n            id,\n            x,\n            y,\n        }\n    }\n}\n\n/// Sparse DP routine generalizing LCSk++ method above to penalize alignment gaps.\n/// A gap is an unknown combination of mismatch, insertion and deletions, and incurs\n/// a penalty of gap_open + d * gap_extend, where d is the distance along the diagonal of the gap.\n/// # Arguments\n///\n/// * `matches` - a vector of tuples indicating the (string1 position, string2 position) kmer\n///   matches between the strings\n/// * `k` - the kmer length used for matching\n/// * `match_score` - reward for each matched base\n/// * `gap_open` - score of opening a gap, including a mismatch gap. Must be negative.\n/// * `gap_extend` - score for extending a gap along the diagonal. Must be negative.\n///\n/// # Return value\n///\n/// The method returns a `SparseAlignmentResult` struct with the following fields:\n/// * `path` is the SDP path, represented as vector of indices into the input matches vector.\n/// * `score` is the score of the path, which is the number of bases covered by the matched kmers.\n/// * `dp_vector` is the full DP vector, which can generally be ignored. (It may be useful for\n///   testing purposes).\npub fn sdpkpp(\n    matches: \u0026[(u32, u32)],\n    k: usize,\n    match_score: u32,\n    gap_open: i32,\n    gap_extend: i32,\n) -\u003e SparseAlignmentResult {\n    if matches.is_empty() {\n        return SparseAlignmentResult {\n            path: Vec::new(),\n            score: 0,\n            dp_vector: Vec::new(),\n        };\n    }\n\n    let k = k as u32;\n    if gap_open \u003e 0 || gap_extend \u003e 0 {\n        panic!(\"gap parameters cannot be positive\")\n    }\n    let _gap_open = (-gap_open) as u32;\n    let _gap_extend = (-gap_extend) as u32;\n\n    // incoming matches must be sorted to let us find the predecessor kmers by binary search.\n    for i in 1..matches.len() {\n        assert!(matches[i - 1] \u003c matches[i]);\n    }\n\n    let mut events: Vec\u003c(u32, u32, u32)\u003e = Vec::new();\n    let mut n = 0;\n\n    for (idx, \u0026(x, y)) in matches.iter().enumerate() {\n        events.push((x, y, (idx + matches.len()) as u32));\n        events.push((x + k, y + k, idx as u32));\n\n        n = max(n, x + k);\n        n = max(n, y + k);\n    }\n    events.sort_unstable();\n\n    let mut max_col_dp: MaxBitTree\u003cPrevPtr\u003e = MaxBitTree::new(n as usize);\n    let mut dp: Vec\u003c(u32, i32)\u003e = Vec::with_capacity(events.len());\n    let mut best_dp = (k, 0);\n\n    dp.resize(events.len(), (0, 0));\n\n    for ev in events {\n        let p = (ev.2 % matches.len() as u32) as usize;\n        let j = ev.1;\n        let is_start = ev.2 \u003e= (matches.len() as u32);\n\n        if is_start {\n            // Default case -- chain starts at this node\n            dp[p] = (k * match_score, -1);\n\n            // Find best previous chain, and extend.\n            let best_prev = max_col_dp.get(j as usize);\n            if best_prev.score \u003e 0 {\n                let prev_x = best_prev.x;\n                let prev_y = best_prev.y;\n                let cur_x = ev.0;\n                let cur_y = ev.1;\n                let gap = max(cur_x - prev_x, cur_y - prev_y);\n                let gap_penalty = if gap \u003e 0 {\n                    _gap_open + gap * _gap_extend\n                } else {\n                    0\n                };\n\n                let reward = k * match_score;\n                let new_score = (best_prev.score + reward).saturating_sub(gap_penalty);\n\n                dp[p] = max(dp[p], (new_score, best_prev.id as i32));\n                best_dp = max(best_dp, (dp[p].0, p as i32));\n            }\n        } else {\n            // See if this kmer continues a different kmer\n            if ev.0 \u003e k \u0026\u0026 ev.1 \u003e k {\n                if let Ok(cont_idx) = matches.binary_search(\u0026(ev.0 - k - 1, ev.1 - k - 1)) {\n                    let prev_score = dp[cont_idx].0;\n                    let candidate = (prev_score + match_score, cont_idx as i32);\n                    dp[p] = max(dp[p], candidate);\n                    best_dp = max(best_dp, (dp[p].0, p as i32));\n                }\n            }\n\n            let prev_frag = PrevPtr::new(dp[p].0, ev.0, ev.1, p, _gap_extend);\n            max_col_dp.set(ev.1 as usize, prev_frag);\n        }\n    }\n\n    let mut traceback = Vec::new();\n    let (best_score, mut prev_match) = best_dp;\n    while prev_match \u003e= 0 {\n        traceback.push(prev_match as usize);\n        prev_match = dp[prev_match as usize].1;\n    }\n    traceback.reverse();\n    SparseAlignmentResult {\n        path: traceback,\n        score: best_score,\n        dp_vector: dp,\n    }\n}\n\npub fn sdpkpp_union_lcskpp_path(\n    matches: \u0026[(u32, u32)],\n    k: usize,\n    match_score: u32,\n    gap_open: i32,\n    gap_extend: i32,\n) -\u003e Vec\u003cusize\u003e {\n    if matches.is_empty() {\n        return Vec::new();\n    }\n    let lcskpp_al = lcskpp(matches, k);\n    let sdpkpp_al = sdpkpp(matches, k, match_score, gap_open, gap_extend);\n    let pre_lcskpp = lcskpp_al\n        .path\n        .binary_search(\u0026sdpkpp_al.path[0])\n        .unwrap_or(0);\n    let post_lcskpp = match lcskpp_al\n        .path\n        .binary_search(\u0026sdpkpp_al.path.last().unwrap())\n    {\n        Ok(ind) =\u003e ind + 1,\n        Err(_) =\u003e lcskpp_al.path.len(),\n    };\n\n    let mut path_union = Vec::new();\n    for i in 0..pre_lcskpp {\n        path_union.push(lcskpp_al.path[i]);\n    }\n    for i in 0..sdpkpp_al.path.len() {\n        path_union.push(sdpkpp_al.path[i]);\n    }\n    for i in post_lcskpp..lcskpp_al.path.len() {\n        path_union.push(lcskpp_al.path[i]);\n    }\n\n    path_union\n}\n\n/// Find all matches of length k between two strings, using a q-gram\n/// index. For very long reference strings, it may be more efficient to use and\n/// FMD index to generate the matches. Note that this method is mainly for\n/// demonstration \u0026 testing purposes.  For aligning many query sequences\n/// against the same reference, you should reuse the QGramIndex of the reference.\npub fn find_kmer_matches(seq1: \u0026[u8], seq2: \u0026[u8], k: usize) -\u003e Vec\u003c(u32, u32)\u003e {\n    if seq1.len() \u003c seq2.len() {\n        let set = hash_kmers(seq1, k);\n        find_kmer_matches_seq1_hashed(\u0026set, seq2, k)\n    } else {\n        let set = hash_kmers(\u0026seq2, k);\n        find_kmer_matches_seq2_hashed(seq1, \u0026set, k)\n    }\n}\n\n/// Creates a HashMap containing all the k-mers in the sequence. FxHasher is used\n/// as the hash function instead of the inbuilt one. A good rolling hash function\n/// should speed up the code.\npub fn hash_kmers(seq: \u0026[u8], k: usize) -\u003e HashMapFx\u003c\u0026[u8], Vec\u003cu32\u003e\u003e {\n    let slc = seq;\n    let mut set: HashMapFx\u003c\u0026[u8], Vec\u003cu32\u003e\u003e = HashMapFx::default();\n    for i in 0..(slc.len() + 1).saturating_sub(k) {\n        set.entry(\u0026slc[i..i + k])\n            .or_insert_with(Vec::new)\n            .push(i as u32);\n    }\n    set\n}\n\n// Find all matches of length k between two strings where the first string is\n// already hashed by using the function sparse::hash_kmers\npub fn find_kmer_matches_seq1_hashed(\n    seq1_set: \u0026HashMapFx\u003c\u0026[u8], Vec\u003cu32\u003e\u003e,\n    seq2: \u0026[u8],\n    k: usize,\n) -\u003e Vec\u003c(u32, u32)\u003e {\n    let mut matches = Vec::new();\n\n    for i in 0..(seq2.len() + 1).saturating_sub(k) {\n        let slc = \u0026seq2[i..i + k];\n        if let Some(matches1) = seq1_set.get(slc) {\n            for pos1 in matches1 {\n                matches.push((*pos1, i as u32));\n            }\n        }\n    }\n\n    matches.sort_unstable();\n    matches\n}\n\n// Find all matches of length k between two strings where the second string is\n// already hashed by using the function sparse::hash_kmers\npub fn find_kmer_matches_seq2_hashed(\n    seq1: \u0026[u8],\n    seq2_set: \u0026HashMapFx\u003c\u0026[u8], Vec\u003cu32\u003e\u003e,\n    k: usize,\n) -\u003e Vec\u003c(u32, u32)\u003e {\n    let mut matches = Vec::new();\n\n    for i in 0..(seq1.len() + 1).saturating_sub(k) {\n        let slc = \u0026seq1[i..i + k];\n\n        if let Some(matches1) = seq2_set.get(slc) {\n            for pos1 in matches1 {\n                matches.push((i as u32, *pos1));\n            }\n        }\n    }\n\n    matches.sort_unstable();\n    matches\n}\n\npub fn expand_kmer_matches(\n    seq1: \u0026[u8],\n    seq2: \u0026[u8],\n    k: usize,\n    sorted_matches: \u0026[(u32, u32)],\n    allowed_mismatches: usize,\n) -\u003e Vec\u003c(u32, u32)\u003e {\n    // incoming matches must be sorted.\n    for i in 1..sorted_matches.len() {\n        assert!(sorted_matches[i - 1] \u003c sorted_matches[i]);\n    }\n\n    let mut last_match_along_diagonal: HashMapFx\u003ci32, (i32, i32)\u003e = HashMapFx::default();\n    let mut left_expanded_matches: Vec\u003c(u32, u32)\u003e = sorted_matches.to_owned();\n\n    for \u0026this_match in sorted_matches.iter() {\n        let diag = (this_match.0 as i32) - (this_match.1 as i32);\n        let min_xy = min(this_match.0, this_match.1) as i32;\n        let default_last_match = (\n            this_match.0 as i32 - min_xy - 1,\n            this_match.1 as i32 - min_xy - 1,\n        );\n        let last_match = last_match_along_diagonal\n            .get(\u0026diag)\n            .cloned()\n            .unwrap_or(default_last_match);\n\n        let mut n_mismatches = 0;\n        let mut curr_pos = (this_match.0 as i32 - 1, this_match.1 as i32 - 1);\n        loop {\n            if last_match \u003e= curr_pos {\n                break;\n            }\n            n_mismatches += if seq1[curr_pos.0 as usize] == seq2[curr_pos.1 as usize] {\n                0\n            } else {\n                1\n            };\n            if n_mismatches \u003e allowed_mismatches {\n                break;\n            }\n            left_expanded_matches.push((curr_pos.0 as u32, curr_pos.1 as u32));\n            curr_pos = (curr_pos.0 - 1, curr_pos.1 - 1);\n        }\n        // We need to check until 1 position after this match, when we start our search from\n        // the next kmer match along this diagonal\n        last_match_along_diagonal.insert(diag, (this_match.0 as i32, this_match.1 as i32));\n    }\n\n    left_expanded_matches.sort_unstable();\n    let mut expanded_matches = left_expanded_matches.clone();\n    left_expanded_matches.reverse();\n\n    let mut next_match_along_diagonal: HashMapFx\u003ci32, (u32, u32)\u003e = HashMapFx::default();\n\n    for \u0026this_match in \u0026left_expanded_matches {\n        let diag = (this_match.0 as i32) - (this_match.1 as i32);\n        let max_inc = (min(\n            seq1.len() as u32 - this_match.0,\n            seq2.len() as u32 - this_match.1,\n        ) as u32)\n            .saturating_sub(k as u32 - 1);\n        let next_match = next_match_along_diagonal\n            .get(\u0026diag)\n            .cloned()\n            .unwrap_or((this_match.0 + max_inc, this_match.1 + max_inc));\n\n        let mut n_mismatches = 0;\n        let mut curr_pos = (this_match.0 + 1, this_match.1 + 1);\n        loop {\n            // println!(\" This : ({},{}), Current : ({},{}), Next : ({}, {}), Miss : {}\",\n            // this_match.0, this_match.1, curr_pos.0, curr_pos.1, next_match.0, next_match.1, n_mismatches);\n            if curr_pos \u003e= next_match {\n                break;\n            }\n            n_mismatches +=\n                if seq1[curr_pos.0 as usize + k - 1] == seq2[curr_pos.1 as usize + k - 1] {\n                    0\n                } else {\n                    1\n                };\n            if n_mismatches \u003e allowed_mismatches {\n                break;\n            }\n            expanded_matches.push(curr_pos);\n            curr_pos = (curr_pos.0 + 1, curr_pos.1 + 1);\n        }\n\n        next_match_along_diagonal.insert(diag, this_match);\n    }\n    expanded_matches.sort_unstable();\n    expanded_matches\n}\n\n#[cfg(test)]\nmod sparse_alignment {\n    use super::find_kmer_matches;\n\n    #[test]\n    pub fn test_find_kmer_matches() {\n        let s1 = b\"ACGTACGATAGATCCGTACGTAACAGTACAGTATATCAGTTATATGCGATA\";\n        let s2 = b\"TTACGTACGATAGATCCGTACGTAACATTTTTGTACAGTATATCAGTTATATGCGA\";\n        let k = 8;\n        //let s1 = \"  ACGTACGATAGATCCGTACGTAACA     GTACAGTATATCAGTTATATGCGATA\";\n        //let s2 = \"TTACGTACGATAGATCCGTACGTAACATTTTTGTACAGTATATCAGTTATATGCGA\";\n\n        let hits = find_kmer_matches(s1, s2, k);\n        assert_eq!(hits.len(), (25 - k + 1) + (24 - k + 1));\n        //println!(\"hits: {:?}\", hits);\n    }\n\n    #[test]\n    pub fn test_lcskpp0() {\n        let s1 = b\"ACGTACGATAGGTA\";\n        let s2 = b\"TTACGTACGATAGGTATT\";\n        let k = 8;\n        let matches = super::find_kmer_matches(s1, s2, k);\n        let res = super::lcskpp(\u0026matches, k);\n        let match_path: Vec\u003c(u32, u32)\u003e = res.path.iter().map(|i| matches[*i]).collect();\n        assert_eq!(\n            match_path,\n            vec![(0, 2), (1, 3), (2, 4), (3, 5), (4, 6), (5, 7), (6, 8)]\n        );\n        assert_eq!(res.score, 14);\n    }\n\n    pub fn strict_compare_lcskpp_sdpkpp(s1: \u0026[u8], s2: \u0026[u8]) {\n        let k = 8;\n        let matches = super::find_kmer_matches(s1, s2, k);\n        let res1 = super::lcskpp(\u0026matches, k);\n        let res2 = super::sdpkpp(\u0026matches, k, 1, 0, 0);\n\n        assert_eq!(res1, res2);\n    }\n\n    #[test]\n    pub fn test_sdp() {\n        let s1 = b\"ACGTACGATAGGTA\";\n        let s2 = b\"TTACGTACGATAGGTATT\";\n        strict_compare_lcskpp_sdpkpp(s1, s2);\n    }\n\n    #[test]\n    pub fn test_lcskpp1() {\n        let s1 = b\"ACGTACGATAGATCCGTACGTAACAGTACAGTATATCAGTTATATGCGATA\";\n        let s2 = b\"TTACGTACGATAGATCCGTACGTAACATTTTTGTACAGTATATCAGTTATATGCGA\";\n        let k = 8;\n\n        let matches = super::find_kmer_matches(s1, s2, k);\n        let res = super::lcskpp(\u0026matches, k);\n\n        // For debugging:\n        //for (idx, (ev, (score, prev))) in evs.iter().zip(dps.clone()).enumerate() {\n        //    println!(\"idx: {:?}\\tev: {:?}\\tscore: {:?}\\t prev: {:?}\", idx, ev, score, prev);\n        //}\n        //println!(\"tb: {:?}\", tb);\n\n        // Should have 25bp group of matches plus a 24 bp group of matches\n        assert_eq!(res.score, 25 + 24);\n    }\n\n    #[test]\n    pub fn test_sdp1() {\n        let s1 = b\"ACGTACGATAGATCCGTACGTAACAGTACAGTATATCAGTTATATGCGATA\";\n        let s2 = b\"TTACGTACGATAGATCCGTACGTAACATTTTTGTACAGTATATCAGTTATATGCGA\";\n        strict_compare_lcskpp_sdpkpp(s1, s2);\n    }\n\n    #[test]\n    pub fn test_lcskpp2() {\n        // Match the same string -- should get a diagonal traceback, despite lots of off-diagonal\n        // homology\n        let s1 = b\"ACGTACGATAGATCCGACGTACGTACGTTCAGTTATATGACGTACGTACGTAACATTTTTGTA\";\n        let k = 5;\n\n        let matches = super::find_kmer_matches(s1, s1, k);\n        let res = super::lcskpp(\u0026matches, k);\n\n        // For debugging:\n        //for (idx, (ev, (score, prev))) in evs.iter().zip(dps.clone()).enumerate() {\n        //    println!(\"idx: {:?}\\tev: {:?}\\tscore: {:?}\\t prev: {:?}\", idx, ev, score, prev);\n        //}\n        //println!(\"tb: {:?}\", tb);\n\n        assert_eq!(res.score, s1.len() as u32);\n\n        for i in 0..res.path.len() {\n            assert_eq!(matches[res.path[i] as usize], (i as u32, i as u32));\n        }\n    }\n\n    #[test]\n    pub fn test_sdp2() {\n        let s1 = b\"ACGTACGATAGATCCGACGTACGTACGTTCAGTTATATGACGTACGTACGTAACATTTTTGTA\";\n        strict_compare_lcskpp_sdpkpp(s1, s1);\n    }\n\n    // Test case from local SV caller alignments.\n    // The query sequence ends in 1-2 copies of tandem repeat element\n    // The target sequence end in \u003e2 copies of the element\n    // Without a gap penalty (i.e. LCSk++), the alignment of the\n    // TRs is arbitrary, and way the implementation breaks ties may introduce\n    // a gap while maintaining the same score.\n    // The SDP code with gap open \u0026 extend penalties should resolve this.\n    const QUERY_REPEAT: \u0026[u8] = b\"CCTCCCATCTCCACCCACCCTATCCAACCCTGGGGTGGCAGGTCATGAGTGA\\\nCAGCCCCAAGGACACCAAGGGATGAAGCTTCTCCTGTGCTGAGATCCTTCTCGGACTTTCTGAGAGGCCACGCAGAACAGGAGGCCCCATCTCC\\\nCGTTCTTACTCAGAAGCTGTCAGCAGGGCTGGGCTCAAGATGAACCCGTGGCCGGCCCCACTCCCCAGCTCTTGCTTCAGGGCCTCACGTTTCG\\\nCCCCCTGAGGCCTGGGGGCTCCGTCCTCACGGCTGGAGGGGCTCTCAGAACATCTGGTG\";\n\n    const TARGET_REPEAT: \u0026[u8] = b\"CCTCCCATCTCCACCCACCCTATCCAACCCTGGGGTGGCAG\\\nGTCATGAGTGACAGCCCCAAGGACACCAAGGGATGAAGCTTCTCCTGTGCTGAGATCCTTCTCGGACTTTCTGAGAGGCCACGC\\\nAGAACAGGAGGCCCCATCTCCCGTTCTTACTCAGAAGCTGTCAGCAGGGCTGGGCTCAAGATGAACCCGTGGCCGGCCCCACTC\\\nCCCAGCTCTTGCTTCAGGGCCTCACGTTTCGCCCCCTGAGGCCTGGGGGCTCCGTCCTCACGGCTGGAGGGGCTCTCAGAACAT\\\nCTGGTGGGCTCCGTCCTCACGGCTGGAGGGGCTCTCAGAACATCTGGTGGGCTCCGTCCTCACGGCTGGAGGGGCTCTCAGAAC\\\nATCTGGTGGGCTCCGTCCTCACGGCTGGAGGGGCTCTCAGAACATCTGGTGCACGGCTCCCAACTCTCTTCCGGCCAAGGATCC\\\nCGTGTTCCTGAAATGTCTTTCTACCAAACACAGTTGCTGTGTAACCACTCATTTCATTTTCCTAATTTGTGTTGATCCAGGACA\\\nCGGGAGGAGACCTGGGCAGCGGCGGACTCATTGCAGGTCGCTCTGCGGTGAGGACGCCACAGGCAC\";\n\n    #[test]\n    fn test_lcskpp_tandem_repeat() {\n        let k = 8;\n        let matches = super::find_kmer_matches(QUERY_REPEAT, TARGET_REPEAT, k);\n        let res = super::lcskpp(\u0026matches, k);\n\n        // For debugging:\n        //for (idx, (ev, (score, prev))) in evs.iter().zip(dps.clone()).enumerate() {\n        //    println!(\"idx: {:?}\\tev: {:?}\\tscore: {:?}\\t prev: {:?}\", idx, ev, score, prev);\n        //}\n        //println!(\"tb: {:?}\", tb);\n\n        assert_eq!(res.score, QUERY_REPEAT.len() as u32);\n\n        // NOTE -- this test will fail, because LCSk++ introduces a gap in the placement of the TR\n        // Corrected with gap scoring in SDP\n        /*\n        for i in 0..res.path.len() {\n            assert_eq!(matches[res.path[i] as usize], (i as u32, i as u32));\n        }\n        */\n    }\n\n    #[test]\n    fn test_sdpkpp_tandem_repeat() {\n        let k = 8;\n        let matches = super::find_kmer_matches(\u0026QUERY_REPEAT, \u0026TARGET_REPEAT, k);\n        let res = super::sdpkpp(\u0026matches, k, 1, -1, -1);\n\n        // For debugging:\n        /*\n        for (idx, (ev, (score, prev))) in evs.iter().zip(dps.clone()).enumerate() {\n            println!(\"idx: {:?}\\tev: {:?}\\tscore: {:?}\\t prev: {:?}\", idx, ev, score, prev);\n        }\n        println!(\"tb: {:?}\", tb);\n        */\n\n        assert_eq!(res.score, QUERY_REPEAT.len() as u32);\n\n        for i in 0..res.path.len() {\n            assert_eq!(matches[res.path[i] as usize], (i as u32, i as u32));\n        }\n    }\n\n    #[test]\n    fn test_sdpkpp_same() {\n        let x = b\"ACGTACGTAC\";\n        let y = b\"ACGTACGTAC\";\n        let matches = super::find_kmer_matches(x, y, 10);\n        let res = super::sdpkpp(\u0026matches, 10, 1, -1, -1);\n        assert_eq!(res.path, [0]);\n        assert_eq!(res.score, 10);\n\n        let x = b\"ACGTACGTACA\";\n        let y = b\"ACGTACGTACA\";\n        let matches = super::find_kmer_matches(x, y, 10);\n        let res = super::sdpkpp(\u0026matches, 10, 1, -1, -1);\n        assert_eq!(res.path, [0, 1]);\n        assert_eq!(res.score, 11);\n\n        let x = b\"ACGTACGTACACGTACGTAC\";\n        let y = b\"ACGTACGTAC\";\n        let matches = super::find_kmer_matches(x, y, 10);\n        let res = super::sdpkpp(\u0026matches, 10, 1, -1, -1);\n        assert_eq!(res.path, [0]);\n        assert_eq!(res.score, 10);\n    }\n\n    #[test]\n    fn test_lcskpp_same() {\n        let x = b\"ACGTACGTAC\";\n        let y = b\"ACGTACGTAC\";\n        let matches = super::find_kmer_matches(x, y, 10);\n        let res = super::lcskpp(\u0026matches, 10);\n        assert_eq!(res.path, [0]);\n        assert_eq!(res.score, 10);\n\n        let x = b\"ACGTACGTACA\";\n        let y = b\"ACGTACGTACA\";\n        let matches = super::find_kmer_matches(x, y, 10);\n        let res = super::lcskpp(\u0026matches, 10);\n        assert_eq!(res.path, [0, 1]);\n        assert_eq!(res.score, 11);\n\n        let x = b\"ACGTACGTACACGTACGTAC\";\n        let y = b\"ACGTACGTAC\";\n        let matches = super::find_kmer_matches(x, y, 10);\n        let res = super::lcskpp(\u0026matches, 10);\n        assert_eq!(res.path, [0]);\n        assert_eq!(res.score, 10);\n    }\n\n    #[test]\n    fn test_expanded_matches() {\n        let x = b\"GGGCAAAAAA\";\n        let y = b\"GGGGAAAAAA\";\n        let matches = super::find_kmer_matches(x, y, 6);\n        assert_eq!(matches, vec![(4, 4)]);\n\n        let expanded_matches = super::expand_kmer_matches(x, y, 6, \u0026matches, 1);\n        assert_eq!(\n            expanded_matches,\n            (0..5)\n                .into_iter()\n                .map(|x| (x, x))\n                .collect::\u003cVec\u003c(u32, u32)\u003e\u003e()\n        );\n\n        let x = b\"TTTTTTGGGCAAAAAA\";\n        let y = b\"TTTTTTGGGGAAAAAA\";\n        let matches = super::find_kmer_matches(x, y, 6);\n        assert_eq!(matches, vec![(0, 0), (1, 1), (2, 2), (3, 3), (10, 10)]);\n\n        let expanded_matches = super::expand_kmer_matches(x, y, 6, \u0026matches, 1);\n        assert_eq!(\n            expanded_matches,\n            (0..11)\n                .into_iter()\n                .map(|x| (x, x))\n                .collect::\u003cVec\u003c(u32, u32)\u003e\u003e()\n        );\n\n        let x = b\"TTTTTTCCGCAAAAAA\";\n        let y = b\"TTTTTTGGGGAAAAAA\";\n        let matches = super::find_kmer_matches(x, y, 6);\n        assert_eq!(matches, vec![(0, 0), (10, 10)]);\n\n        let expanded_matches = super::expand_kmer_matches(x, y, 6, \u0026matches, 1);\n        assert_eq!(\n            expanded_matches,\n            vec![(0, 0), (1, 1), (8, 8), (9, 9), (10, 10)]\n        );\n\n        let x = b\"TTTTTTCGGCAAAAAA\";\n        let y = b\"TTTTTTGGGGAAAAAA\";\n        let matches = super::find_kmer_matches(x, y, 6);\n        assert_eq!(matches, vec![(0, 0), (10, 10)]);\n\n        let expanded_matches = super::expand_kmer_matches(x, y, 6, \u0026matches, 1);\n        assert_eq!(\n            expanded_matches,\n            vec![\n                (0, 0),\n                (1, 1),\n                (2, 2),\n                (3, 3),\n                (7, 7),\n                (8, 8),\n                (9, 9),\n                (10, 10),\n            ]\n        );\n\n        let x = b\"AAAAAACGGG\";\n        let y = b\"AAAAAAGGGG\";\n        let matches = super::find_kmer_matches(x, y, 6);\n        assert_eq!(matches, vec![(0, 0)]);\n        let expanded_matches = super::expand_kmer_matches(x, y, 6, \u0026matches, 1);\n        assert_eq!(\n            expanded_matches,\n            (0..5)\n                .into_iter()\n                .map(|x| (x, x))\n                .collect::\u003cVec\u003c(u32, u32)\u003e\u003e()\n        );\n    }\n}\n","traces":[{"line":67,"address":[5169664,5170001],"length":1,"stats":{"Line":0},"fn_name":"lcskpp"},{"line":68,"address":[5169757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[5169883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[5169846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[5169868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[5169821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[5170040,5169828,5170208,5170510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[5170515,5170248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[5170182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[5170561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[5171603,5170572,5170689,5170894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[5170994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[5171167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[5171367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[5171492],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[5170846,5171624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[5171631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[5171663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[5171751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[5171777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[5172162,5172198,5171894,5173034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[5172480,5172318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[5172427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[5172448,5172528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[5174029,5172545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[5172582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[5172646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[5172711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[5172735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[5172860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[5173039,5172556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[5173961,5173097,5173514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[5173577,5173481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[5173586,5173661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[5173699,5173631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[5173817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[5173984,5173524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[5174034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[5174053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[5174085,5174251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[5174130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[5174157,5174241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[5174266,5174095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[5174464],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":154,"address":[5174562,5174522],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[5174709,5174600,5174547,5174739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[5174752,5175122],"length":1,"stats":{"Line":0},"fn_name":"sdpkpp"},{"line":192,"address":[5174891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[5175004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[5174967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[5174989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[5174946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[5174953,5175160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[5175216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[5175202,5175260,5175292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[5175345,5175278,5175378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[5175416,5175886,5175363,5175584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[5175891,5175624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[5175558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[5175937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[5176979,5175948,5176065,5176270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[5176370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[5176543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[5176743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[5176868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[5176222,5177000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[5177007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[5177039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[5177127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[5177153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[5179128,5177574,5177270,5177538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[5177694,5177856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[5177803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[5177824,5177904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[5180158,5177921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[5177964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[5178085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[5178112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[5178127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[5178141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[5178162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[5178176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[5178197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[5178375,5178359,5178489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[5178491,5178394],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[5178364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[5178538,5178591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[5178682,5178568,5178631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[5178737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[5178954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[5179133,5177932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[5180037,5179599,5179191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[5179569,5179654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[5179737,5179663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[5179707,5179775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[5179893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[5180063,5179609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[5180094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[5180163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[5180182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[5180378,5180214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[5180259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[5180368,5180286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[5180224,5180393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[5182666,5180576,5182651],"length":1,"stats":{"Line":0},"fn_name":"sdpkpp_union_lcskpp_path"},{"line":296,"address":[5180715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[5180787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[5180764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[5180857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[5181093,5180878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[5180991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[5181401,5181599,5181176,5181479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[5181249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[5181591,5181481,5181601,5181462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[5181518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[5181564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[5181641,5181997,5181785,5181904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[5181936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[5181877,5182007,5182309,5182216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[5182248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[5182324,5182628,5182535,5182176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[5182567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[5182497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[5182934,5182672],"length":1,"stats":{"Line":0},"fn_name":"find_kmer_matches"},{"line":333,"address":[5182754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[5182846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[5182866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[5182806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[5182987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[5183040,5183747,5183762],"length":1,"stats":{"Line":0},"fn_name":"hash_kmers"},{"line":346,"address":[5183102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[5183118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[5183270,5183497,5183133,5183742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[5183731,5183534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[5183729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[5184814,5183776,5184829],"length":1,"stats":{"Line":0},"fn_name":"find_kmer_matches_seq1_hashed"},{"line":363,"address":[5183866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[5184596,5184042,5184290,5183887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[5184327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[5184692,5184501,5184594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[5184707,5184611,5184776,5184571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[5184739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[5184256,5184791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[5185870,5184832,5185885],"length":1,"stats":{"Line":0},"fn_name":"find_kmer_matches_seq2_hashed"},{"line":385,"address":[5184922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[5185346,5185652,5185098,5184943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[5185383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[5185650,5185748,5185557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[5185627,5185763,5185667,5185832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[5185795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[5185847,5185312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[5185888,5190775],"length":1,"stats":{"Line":0},"fn_name":"expand_kmer_matches"},{"line":409,"address":[5186549,5186058,5186247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[5186287,5186554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[5186229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[5186608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[5188312,5186716,5186921,5186631,5186798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[5187042,5186978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[5187088,5187022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[5187303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[5187198,5187095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[5187238,5187180,5187351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[5187333,5187496,5187392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[5187482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[5187573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[5187689,5187585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[5188426,5187687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[5187738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[5188075,5188089,5187921,5188156,5187775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[5188077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[5188063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[5188144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[5188189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[5188431,5188317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[5188267,5187822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[5188480,5186889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[5188503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[5188526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[5188627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[5188852,5188642,5188753,5190531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[5188909,5188977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[5189157,5189333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[5188955,5189079,5189025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[5189177,5189057,5189127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[5189293,5189218],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[5189356,5189571,5189669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[5189621,5189474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[5189683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[5189789,5189695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[5190635,5189787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[5189838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[5190409,5190348],"length":1,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[5189869,5190334,5189955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[5190336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[5190322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[5190397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[5190450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[5190640,5190536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[5190486,5189909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[5190689,5188820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[5190696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[7744917,7744912],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":501,"address":[8182199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[8182214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[8182229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[8182241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[8182377,8182287,8182729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[7744944,7744949],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":514,"address":[8182823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[8182838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[8182853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[8182865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[8182911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[7744976,7744990],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":520,"address":[8183523,8183646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[8183189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[8183876,8183762],"length":1,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[8182160,8181648],"length":1,"stats":{"Line":0},"fn_name":"strict_compare_lcskpp_sdpkpp"},{"line":528,"address":[8181699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[8181711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[8181732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[8181824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[8182090,8181934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[7745045,7745040],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":538,"address":[8183988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[8184000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[8184012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[7745077,7745072],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":545,"address":[8184055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[8184070],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[8184085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[8184097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[8184143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[8184332,8184230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[7745104,7745109],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":564,"address":[8184468],"length":1,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[8184480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[8184492],"length":1,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[7745141,7745136],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":573,"address":[8184535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[8184550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[8184562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[8184608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[8184926,8184707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[8185390,8184889,8185169,8184982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[8185404,8185206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[7745168,7745173],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":594,"address":[8185505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[8185516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[7745200,7745205],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":621,"address":[8185559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[8185571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[8185617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[8185704,8185905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[7745237,7745232],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":644,"address":[8186007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":645,"address":[8186019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[8186074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":656,"address":[8186200,8186419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[8186382,8186884,8186475,8186662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":659,"address":[8186699,8186899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[7745269,7745264],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":665,"address":[8186999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[8187014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[8187029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[8187072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[8187465,8187206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[8187583,8187352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":672,"address":[8187511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":673,"address":[8187526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":674,"address":[8187554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":675,"address":[8187640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[8187997,8187762],"length":1,"stats":{"Line":0},"fn_name":null},{"line":677,"address":[8187896,8188113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":679,"address":[8188044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[8188059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":681,"address":[8188093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[8188173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[8188295,8188530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[8188429,8188602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[7745301,7745296],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":689,"address":[8188759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[8188774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[8188789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[8188832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[8189198,8188945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[8189091,8189310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[8189244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":697,"address":[8189259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[8189287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[8189367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":700,"address":[8189468,8189703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[8189602,8189819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[8189750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[8189765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":705,"address":[8189799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":706,"address":[8189879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[8190214,8189980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[8190285,8190114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":712,"address":[7745333,7745328],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":713,"address":[8190455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":714,"address":[8190470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":715,"address":[8190485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":716,"address":[8190537,8190749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[8190879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[8191167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[8191152,8190986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":723,"address":[7745373,7745360],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":727,"address":[8191388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":728,"address":[8191403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":729,"address":[8191438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":730,"address":[8191846,8191458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":732,"address":[8191977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":733,"address":[8192265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[8192250,8192084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[7745405,7745392],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":741,"address":[8192486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":742,"address":[8192501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[8192536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":744,"address":[8192556,8192810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":746,"address":[8192941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":747,"address":[8193446,8193311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":749,"address":[8193058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":752,"address":[8193569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[8193584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":754,"address":[8193619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":755,"address":[8193639,8193893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":757,"address":[8194024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":758,"address":[8194643,8194520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[8194141,8194333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":761,"address":[8194157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":762,"address":[8194179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":763,"address":[8194201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":764,"address":[8194223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":765,"address":[8194245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":766,"address":[8194267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":767,"address":[8194289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":768,"address":[8194311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":772,"address":[8194760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":773,"address":[8194775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":774,"address":[8194810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":775,"address":[8194830,8195030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":776,"address":[8195155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[8195407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":779,"address":[8195250,8195392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":781,"address":[7745424,7745437],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"}],"covered":0,"coverable":346},{"path":["/","home","todd","rust-bio","src","alphabets","dna.rs"],"content":"// Copyright 2014-2015 Johannes Köster, Peer Aramillo Irizar.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation of the DNA alphabet.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::alphabets;\n//! let alphabet = alphabets::dna::alphabet();\n//! assert!(alphabet.is_word(b\"GATTACA\"));\n//! assert!(alphabet.is_word(b\"gattaca\"));\n//! assert!(!alphabet.is_word(b\"ACGU\"));\n//! ```\n\nuse std::borrow::Borrow;\n\nuse crate::alphabets::Alphabet;\n\n/// The DNA alphabet (uppercase and lowercase).\npub fn alphabet() -\u003e Alphabet {\n    Alphabet::new(b\"ACGTacgt\")\n}\n\n/// The DNA alphabet including N (uppercase and lowercase).\npub fn n_alphabet() -\u003e Alphabet {\n    Alphabet::new(b\"ACGTNacgtn\")\n}\n\n/// The IUPAC DNA alphabet (uppercase and lowercase).\npub fn iupac_alphabet() -\u003e Alphabet {\n    Alphabet::new(b\"ACGTRYSWKMBDHVNZacgtryswkmbdhvnz\")\n}\n\nlazy_static! {\n    static ref COMPLEMENT: [u8; 256] = {\n        let mut comp = [0; 256];\n        for (v, a) in comp.iter_mut().enumerate() {\n            *a = v as u8;\n        }\n        for (\u0026a, \u0026b) in b\"AGCTYRWSKMDVHBN\".iter().zip(b\"TCGARYWSMKHBDVN\".iter()) {\n            comp[a as usize] = b;\n            comp[a as usize + 32] = b + 32;  // lowercase variants\n        }\n        comp\n    };\n}\n\n/// Return complement of given DNA alphabet character (IUPAC alphabet supported).\n///\n/// Casing of input character is preserved, e.g. `t` → `a`, but `T` → `A`.\n/// All `N`s remain as they are.\n///\n/// ```\n/// use bio::alphabets::dna;\n///\n/// assert_eq!(dna::complement(65), 84); // A → T\n/// assert_eq!(dna::complement(99), 103); // c → g\n/// assert_eq!(dna::complement(78), 78); // N → N\n/// assert_eq!(dna::complement(89), 82); // Y → R\n/// assert_eq!(dna::complement(115), 115); // s → s\n/// ```\npub fn complement(a: u8) -\u003e u8 {\n    COMPLEMENT[a as usize]\n}\n\n/// Calculate reverse complement of given text (IUPAC alphabet supported).\n///\n/// Casing of characters is preserved, e.g. `b\"NaCgT\"` → `b\"aCgTN\"`.\n/// All `N`s remain as they are.\n///\n/// ```\n/// use bio::alphabets::dna;\n///\n/// assert_eq!(dna::revcomp(b\"ACGTN\"), b\"NACGT\");\n/// assert_eq!(dna::revcomp(b\"GaTtaCA\"), b\"TGtaAtC\");\n/// assert_eq!(dna::revcomp(b\"AGCTYRWSKMDVHBN\"), b\"NVDBHKMSWYRAGCT\");\n/// ```\npub fn revcomp\u003cC, T\u003e(text: T) -\u003e Vec\u003cu8\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: IntoIterator\u003cItem = C\u003e,\n    T::IntoIter: DoubleEndedIterator,\n{\n    text.into_iter()\n        .rev()\n        .map(|a| complement(*a.borrow()))\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_word() {\n        assert!(alphabet().is_word(b\"GATTACA\"));\n    }\n\n    #[test]\n    fn is_no_word() {\n        assert!(!alphabet().is_word(b\"gaUUaca\"));\n    }\n\n    #[test]\n    fn symbol_is_no_word() {\n        assert!(!alphabet().is_word(b\"#\"));\n    }\n\n    #[test]\n    fn number_is_no_word() {\n        assert!(!alphabet().is_word(b\"42\"));\n    }\n}\n","traces":[{"line":23,"address":[4472320],"length":1,"stats":{"Line":0},"fn_name":"alphabet"},{"line":28,"address":[4472352],"length":1,"stats":{"Line":0},"fn_name":"n_alphabet"},{"line":33,"address":[4472384],"length":1,"stats":{"Line":0},"fn_name":"iupac_alphabet"},{"line":39,"address":[4489252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4489269,4489536,4489602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[4489600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[4489410,4489607,4489941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[4489796,4489743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4489776,4489951,4489823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[4472416],"length":1,"stats":{"Line":0},"fn_name":"complement"},{"line":66,"address":[4472498,4472521,4472431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[4472528],"length":1,"stats":{"Line":0},"fn_name":"revcomp\u003c\u0026u8,\u0026[u8; 10]\u003e"},{"line":87,"address":[4472560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[4472675,4472656],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003c\u0026u8,\u0026[u8; 10]\u003e"},{"line":98,"address":[7745456,7745545],"length":1,"stats":{"Line":0},"fn_name":"is_word"},{"line":99,"address":[7745572,7745561,7745460,7745602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[7729776,7729781],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":104,"address":[7745723,7745764,7745620,7745734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[7729813,7729808],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":109,"address":[7745780,7745894,7745924,7745883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[7729840,7729845],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":114,"address":[7746054,7746084,7746043,7745940],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":22},{"path":["/","home","todd","rust-bio","src","alphabets","mod.rs"],"content":"// Copyright 2014-2015 Johannes Köster, Peer Aramillo Irizar.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation of alphabets and useful utilities.\n//!\n//! # Example\n//!\n//! ```rust\n//! use bio::alphabets;\n//! let alphabet = alphabets::dna::alphabet();\n//! assert!(alphabet.is_word(b\"AACCTgga\"));\n//! assert!(!alphabet.is_word(b\"AXYZ\"));\n//! ```\n\nuse std::borrow::Borrow;\nuse std::mem;\n\nuse bit_set::BitSet;\nuse vec_map::VecMap;\n\npub mod dna;\npub mod protein;\npub mod rna;\n\npub type SymbolRanks = VecMap\u003cu8\u003e;\n\n/// Representation of an alphabet.\n#[derive(Debug, PartialEq)]\npub struct Alphabet {\n    pub symbols: BitSet,\n}\n\nimpl Alphabet {\n    /// Create new alphabet from given symbols.\n    ///\n    /// Complexity: O(n), where n is the number of symbols in the alphabet.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// // Create an alphabet (note that a DNA alphabet is already available in bio::alphabets::dna).\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"ACGTacgt\");\n    /// // Check whether a given text is a word over the alphabet.\n    /// assert!(dna_alphabet.is_word(b\"GAttACA\"));\n    /// ```\n    pub fn new\u003cC, T\u003e(symbols: T) -\u003e Self\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        let mut s = BitSet::new();\n        s.extend(symbols.into_iter().map(|c| *c.borrow() as usize));\n\n        Alphabet { symbols: s }\n    }\n\n    /// Insert symbol into alphabet.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let mut dna_alphabet = alphabets::Alphabet::new(b\"ACGTacgt\");\n    /// assert!(!dna_alphabet.is_word(b\"N\"));\n    /// dna_alphabet.insert(78);\n    /// assert!(dna_alphabet.is_word(b\"N\"));\n    /// ```\n    pub fn insert(\u0026mut self, a: u8) {\n        self.symbols.insert(a as usize);\n    }\n\n    /// Check if given text is a word over the alphabet.\n    ///\n    /// Complexity: O(n), where n is the length of the text.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"ACGTacgt\");\n    /// assert!(dna_alphabet.is_word(b\"GAttACA\"));\n    /// assert!(!dna_alphabet.is_word(b\"42\"));\n    /// ```\n    pub fn is_word\u003cC, T\u003e(\u0026self, text: T) -\u003e bool\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        text.into_iter()\n            .all(|c| self.symbols.contains(*c.borrow() as usize))\n    }\n\n    /// Return lexicographically maximal symbol.\n    ///\n    /// Complexity: O(n), where n is the number of symbols in the alphabet.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"acgtACGT\");\n    /// assert_eq!(dna_alphabet.max_symbol(), Some(116)); // max symbol is \"t\"\n    /// let empty_alphabet = alphabets::Alphabet::new(b\"\");\n    /// assert_eq!(empty_alphabet.max_symbol(), None);\n    /// ```\n    pub fn max_symbol(\u0026self) -\u003e Option\u003cu8\u003e {\n        self.symbols.iter().max().map(|a| a as u8)\n    }\n\n    /// Return size of the alphabet.\n    ///\n    /// Upper and lower case representations of the same character\n    /// are counted as distinct characters.\n    ///\n    /// Complexity: O(n), where n is the number of symbols in the alphabet.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"acgtACGT\");\n    /// assert_eq!(dna_alphabet.len(), 8);\n    /// ```\n    pub fn len(\u0026self) -\u003e usize {\n        self.symbols.len()\n    }\n\n    /// Is this alphabet empty?\n    ///\n    /// Complexity: O(n), where n is the number of symbols in the alphabet.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"acgtACGT\");\n    /// assert!(!dna_alphabet.is_empty());\n    /// let empty_alphabet = alphabets::Alphabet::new(b\"\");\n    /// assert!(empty_alphabet.is_empty());\n    /// ```\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.symbols.is_empty()\n    }\n\n    /// Return a new alphabet taking the intersect between this and other.\n    ///\n    /// # Example\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let alpha_a = alphabets::Alphabet::new(b\"acgtACGT\");\n    /// let alpha_b = alphabets::Alphabet::new(b\"atcgMVP\");\n    /// let intersect_alpha = alpha_a.intersection(\u0026alpha_b);\n    ///\n    /// assert_eq!(intersect_alpha, alphabets::Alphabet::new(b\"atcg\"));\n    /// ```\n    pub fn intersection(\u0026self, other: \u0026Alphabet) -\u003e Self {\n        return Alphabet {\n            symbols: self.symbols.intersection(\u0026other.symbols).collect(),\n        };\n    }\n\n    /// Return a new alphabet taking the difference between this and other.\n    ///\n    /// # Example\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"acgtACGT\");\n    /// let dna_alphabet_upper = alphabets::Alphabet::new(b\"ACGT\");\n    /// let dna_lower = dna_alphabet.difference(\u0026dna_alphabet_upper);\n    ///\n    /// assert_eq!(dna_lower, alphabets::Alphabet::new(b\"atcg\"));\n    /// ```\n    pub fn difference(\u0026self, other: \u0026Alphabet) -\u003e Self {\n        return Alphabet {\n            symbols: self.symbols.difference(\u0026other.symbols).collect(),\n        };\n    }\n\n    /// Return a new alphabet taking the union between this and other.\n    ///\n    /// # Example\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"ATCG\");\n    /// let tokenize_alpha = alphabets::Alphabet::new(b\"?|\");\n    /// let alpha = dna_alphabet.union(\u0026tokenize_alpha);\n    ///\n    /// assert_eq!(alpha, alphabets::Alphabet::new(b\"ATCG?|\"));\n    /// ```\n    pub fn union(\u0026self, other: \u0026Alphabet) -\u003e Self {\n        return Alphabet {\n            symbols: self.symbols.union(\u0026other.symbols).collect(),\n        };\n    }\n}\n\n/// Tools based on transforming the alphabet symbols to their lexicographical ranks.\n///\n/// Lexicographical rank is computed using `u8` representations,\n/// i.e. ASCII codes, of the input characters.\n/// For example, assuming that the alphabet consists of the symbols `A`, `C`, `G`, and `T`, this\n/// will yield ranks `0`, `1`, `2`, `3` for them, respectively.\n///\n/// `RankTransform` can be used in to perform bit encoding for texts over a\n/// given alphabet via `bio::data_structures::bitenc`.\n#[derive(Serialize, Deserialize)]\npub struct RankTransform {\n    pub ranks: SymbolRanks,\n}\n\nimpl RankTransform {\n    /// Construct a new `RankTransform`.\n    ///\n    /// Complexity: O(n), where n is the number of symbols in the alphabet.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"acgtACGT\");\n    /// let dna_ranks = alphabets::RankTransform::new(\u0026dna_alphabet);\n    /// ```\n    pub fn new(alphabet: \u0026Alphabet) -\u003e Self {\n        let mut ranks = VecMap::new();\n        for (r, c) in alphabet.symbols.iter().enumerate() {\n            ranks.insert(c, r as u8);\n        }\n\n        RankTransform { ranks }\n    }\n\n    /// Get the rank of symbol `a`.\n    ///\n    /// This method panics for characters not contained in the alphabet.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"acgtACGT\");\n    /// let dna_ranks = alphabets::RankTransform::new(\u0026dna_alphabet);\n    /// assert_eq!(dna_ranks.get(65), 0); // \"A\"\n    /// assert_eq!(dna_ranks.get(116), 7); // \"t\"\n    /// ```\n    pub fn get(\u0026self, a: u8) -\u003e u8 {\n        *self.ranks.get(a as usize).expect(\"Unexpected character.\")\n    }\n\n    /// Transform a given `text` into a vector of rank values.\n    ///\n    /// Complexity: O(n), where n is the length of the text.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"ACGTacgt\");\n    /// let dna_ranks = alphabets::RankTransform::new(\u0026dna_alphabet);\n    /// let text = b\"aAcCgGtT\";\n    /// assert_eq!(dna_ranks.transform(text), vec![4, 0, 5, 1, 6, 2, 7, 3]);\n    /// ```\n    pub fn transform\u003cC, T\u003e(\u0026self, text: T) -\u003e Vec\u003cu8\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        text.into_iter()\n            .map(|c| {\n                *self\n                    .ranks\n                    .get(*c.borrow() as usize)\n                    .expect(\"Unexpected character in text.\")\n            })\n            .collect()\n    }\n\n    /// Iterate over q-grams (substrings of length q) of given `text`. The q-grams are encoded\n    /// as `usize` by storing the symbol ranks in log2(|A|) bits (with |A| being the alphabet size).\n    ///\n    /// If q is larger than usize::BITS / log2(|A|), this method fails with an assertion.\n    ///\n    /// Complexity: O(n), where n is the length of the text.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"ACGTacgt\");\n    /// let dna_ranks = alphabets::RankTransform::new(\u0026dna_alphabet);\n    ///\n    /// let q_grams: Vec\u003cusize\u003e = dna_ranks.qgrams(2, b\"ACGT\").collect();\n    /// assert_eq!(q_grams, vec![1, 10, 19]);\n    /// ```\n    pub fn qgrams\u003cC, T\u003e(\u0026self, q: u32, text: T) -\u003e QGrams\u003c'_, C, T::IntoIter\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        let bits = (self.ranks.len() as f32).log2().ceil() as u32;\n        assert!(\n            (bits * q) as usize \u003c= mem::size_of::\u003cusize\u003e() * 8,\n            \"Expecting q to be smaller than usize / log2(|A|)\"\n        );\n\n        let mut qgrams = QGrams {\n            text: text.into_iter(),\n            ranks: self,\n            bits,\n            mask: (1 \u003c\u003c (q * bits)) - 1,\n            qgram: 0,\n        };\n\n        for _ in 0..q - 1 {\n            qgrams.next();\n        }\n\n        qgrams\n    }\n\n    /// Restore alphabet from transform.\n    ///\n    /// Complexity: O(n), where n is the number of symbols in the alphabet.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"acgtACGT\");\n    /// let dna_ranks = alphabets::RankTransform::new(\u0026dna_alphabet);\n    /// assert_eq!(dna_ranks.alphabet().symbols, dna_alphabet.symbols);\n    /// ```\n    pub fn alphabet(\u0026self) -\u003e Alphabet {\n        let mut symbols = BitSet::with_capacity(self.ranks.len());\n        symbols.extend(self.ranks.keys());\n        Alphabet { symbols }\n    }\n\n    /// Compute the number of bits required to encode the largest rank value.\n    ///\n    /// For example, the alphabet `b\"ACGT\"` with 4 symbols has the maximal rank\n    /// 3, which can be encoded in 2 bits.\n    ///\n    /// This value can be used to create a `data_structures::bitenc::BitEnc`\n    /// bit encoding tailored to the given alphabet.\n    ///\n    /// Complexity: O(n), where n is the number of symbols in the alphabet.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets;\n    ///\n    /// let dna_alphabet = alphabets::Alphabet::new(b\"ACGT\");\n    /// let dna_ranks = alphabets::RankTransform::new(\u0026dna_alphabet);\n    /// assert_eq!(dna_ranks.get_width(), 2);\n    /// let dna_n_alphabet = alphabets::Alphabet::new(b\"ACGTN\");\n    /// let dna_n_ranks = alphabets::RankTransform::new(\u0026dna_n_alphabet);\n    /// assert_eq!(dna_n_ranks.get_width(), 3);\n    /// ```\n    pub fn get_width(\u0026self) -\u003e usize {\n        (self.ranks.len() as f32).log2().ceil() as usize\n    }\n}\n\n/// Iterator over q-grams.\npub struct QGrams\u003c'a, C, T\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    text: T,\n    ranks: \u0026'a RankTransform,\n    bits: u32,\n    mask: usize,\n    qgram: usize,\n}\n\nimpl\u003c'a, C, T\u003e QGrams\u003c'a, C, T\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    /// Push a new character into the current qgram.\n    fn qgram_push(\u0026mut self, a: u8) {\n        self.qgram \u003c\u003c= self.bits;\n        self.qgram |= a as usize;\n        self.qgram \u0026= self.mask;\n    }\n}\n\nimpl\u003c'a, C, T\u003e Iterator for QGrams\u003c'a, C, T\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    type Item = usize;\n\n    fn next(\u0026mut self) -\u003e Option\u003cusize\u003e {\n        match self.text.next() {\n            Some(a) =\u003e {\n                let b = self.ranks.get(*a.borrow());\n                self.qgram_push(b);\n                Some(self.qgram)\n            }\n            None =\u003e None,\n        }\n    }\n}\n\n/// Returns the english ascii lower case alphabet.\npub fn english_ascii_lower_alphabet() -\u003e Alphabet {\n    Alphabet::new(\u0026b\"abcdefghijklmnopqrstuvwxyz\"[..])\n}\n\n/// Returns the english ascii upper case alphabet.\npub fn english_ascii_upper_alphabet() -\u003e Alphabet {\n    Alphabet::new(\u0026b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"[..])\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_alphabet_eq() {\n        assert_eq!(Alphabet::new(b\"ATCG\"), Alphabet::new(b\"ATCG\"));\n        assert_eq!(Alphabet::new(b\"ATCG\"), Alphabet::new(b\"TAGC\"));\n        assert_ne!(Alphabet::new(b\"ATCG\"), Alphabet::new(b\"ATC\"));\n    }\n}\n","traces":[{"line":50,"address":[4543988,4543631,4543311,4543328,4543648,4542368,4542991,4541728,4542688,4542031,4542048,4542671,4543008,4542351],"length":1,"stats":{"Line":0},"fn_name":"new\u003c\u0026u8,\u0026[u8; 4]\u003e"},{"line":55,"address":[4543694,4542398,4542078,4543038,4542718,4543358,4541758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[4544515,4543732,4543818,4543385,4544419,4543141,4541861,4543461,4542425,4544323,4544208,4541931,4541785,4543531,4544016,4544496,4542821,4542251,4544304,4543211,4542571,4544131,4544035,4543065,4543888,4542105,4544400,4542181,4542891,4544611,4542745,4544227,4542501,4544112,4544592],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003c\u0026u8,\u0026[u8; 3]\u003e"},{"line":75,"address":[4251792],"length":1,"stats":{"Line":0},"fn_name":"insert"},{"line":76,"address":[4251808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[4544688,4545039,4545295,4544911,4544944,4544816,4545167,4544787,4545072,4545200],"length":1,"stats":{"Line":0},"fn_name":"is_word\u003c\u0026u8,\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":97,"address":[4544868,4544744,4545227,4544996,4544715,4545124,4544843,4544971,4545099,4545252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[4544991,4545584,4545712,4545456,4545854,4544863,4545342,4545840,4545119,4545598,4545328,4544739,4545470,4545726,4545247],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003c\u0026u8,\u0026[u8; 2]\u003e"},{"line":115,"address":[4251824],"length":1,"stats":{"Line":0},"fn_name":"max_symbol"},{"line":116,"address":[4251836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[4251904],"length":1,"stats":{"Line":0},"fn_name":"len"},{"line":135,"address":[4251913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[4251936],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":153,"address":[4251945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[4251968],"length":1,"stats":{"Line":0},"fn_name":"intersection"},{"line":169,"address":[4252033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[4251998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[4252080],"length":1,"stats":{"Line":0},"fn_name":"difference"},{"line":187,"address":[4252137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[4252103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[4252192],"length":1,"stats":{"Line":0},"fn_name":"union"},{"line":205,"address":[4252249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[4252215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[4252304,4252723,4252708],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":239,"address":[4252334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[4252357,4252703,4252620,4252431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[4252684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[4252736],"length":1,"stats":{"Line":0},"fn_name":"get"},{"line":264,"address":[4252752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[4547080,4548218,4547104,4546000],"length":1,"stats":{"Line":0},"fn_name":"qgrams\u003c\u0026u8,\u0026[u8; 3]\u003e"},{"line":319,"address":[4547361,4547196,4546076,4546241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[4546407,4546481,4547530,4547613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[4546336,4547433,4547459,4547538,4546310,4546415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[4546450,4547578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[4546772,4547657,4547910,4546522,4547775,4546640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[4548070,4546932,4546756,4548179,4546809,4547041,4548213,4547075,4547894,4547947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[4547062,4548200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[4253064,4253049,4252816],"length":1,"stats":{"Line":0},"fn_name":"alphabet"},{"line":354,"address":[4252852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[4252886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[4253072],"length":1,"stats":{"Line":0},"fn_name":"get_width"},{"line":382,"address":[4253081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[4548240],"length":1,"stats":{"Line":0},"fn_name":"qgram_push\u003c\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":406,"address":[4548264,4548345,4548375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[4548317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[4548328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[4548581,4548384],"length":1,"stats":{"Line":0},"fn_name":"next\u003c\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":420,"address":[4548398,4548429,4548440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[4548450,4548409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[4548542,4548460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[4548546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[4548561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[4548431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[4253280],"length":1,"stats":{"Line":0},"fn_name":"english_ascii_lower_alphabet"},{"line":433,"address":[4253294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[4253360],"length":1,"stats":{"Line":0},"fn_name":"english_ascii_upper_alphabet"},{"line":438,"address":[4253374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[4527712,4527999],"length":1,"stats":{"Line":0},"fn_name":"test_alphabet_eq"},{"line":447,"address":[4527719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[4528014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[4528317],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":68},{"path":["/","home","todd","rust-bio","src","alphabets","protein.rs"],"content":"// Copyright 2015 Peer Aramillo Irizar.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation of the protein alphabet.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::alphabets;\n//! let alphabet = alphabets::protein::alphabet();\n//! assert!(alphabet.is_word(b\"DEQsga\"));\n//! assert!(!alphabet.is_word(b\"BzJ\"));\n//! ```\n\nuse crate::alphabets::Alphabet;\n\n/// Returns the standard protein alphabet, containing the 20 common amino acids.\npub fn alphabet() -\u003e Alphabet {\n    Alphabet::new(\u0026b\"ARNDCEQGHILKMFPSTWYVarndceqghilkmfpstwyv\"[..])\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_word() {\n        assert!(alphabet().is_word(b\"PRSkl\"));\n    }\n\n    #[test]\n    fn is_no_word() {\n        assert!(!alphabet().is_word(b\"Bb\"));\n    }\n\n    #[test]\n    fn symbol_is_no_word() {\n        assert!(!alphabet().is_word(b\"#\"));\n    }\n\n    #[test]\n    fn number_is_no_word() {\n        assert!(!alphabet().is_word(b\"42\"));\n    }\n}\n","traces":[{"line":20,"address":[4527024],"length":1,"stats":{"Line":0},"fn_name":"alphabet"},{"line":21,"address":[4527038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[7729872,7729877],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":30,"address":[7746201,7746100,7746242,7746212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[7729904,7729909],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":35,"address":[7746260,7746404,7746363,7746374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[7729936,7729941],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":40,"address":[7746564,7746523,7746534,7746420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[7729968,7729973],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":45,"address":[7746724,7746694,7746580,7746683],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","todd","rust-bio","src","alphabets","rna.rs"],"content":"// Copyright 2017 Ryan Hagenson.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation of the RNA alphabet.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::alphabets;\n//! let alphabet = alphabets::rna::alphabet();\n//! assert!(alphabet.is_word(b\"GAUUACA\"));\n//! assert!(alphabet.is_word(b\"gauuaca\"));\n//! assert!(!alphabet.is_word(b\"ACGT\"));\n//! ```\n\nuse std::borrow::Borrow;\n\nuse crate::alphabets::Alphabet;\n\n/// The RNA alphabet (uppercase and lowercase).\npub fn alphabet() -\u003e Alphabet {\n    Alphabet::new(b\"ACGUacgu\")\n}\n\n/// The RNA alphabet including N (uppercase and lowercase).\npub fn n_alphabet() -\u003e Alphabet {\n    Alphabet::new(b\"ACGUNacgun\")\n}\n\n/// The IUPAC RNA alphabet (uppercase and lowercase).\npub fn iupac_alphabet() -\u003e Alphabet {\n    Alphabet::new(b\"ACGURYSWKMBDHVNZacguryswkmbdhvnz\")\n}\n\nlazy_static! {\n    static ref COMPLEMENT: [u8; 256] = {\n        let mut comp = [0; 256];\n        for (v, a) in comp.iter_mut().enumerate() {\n            *a = v as u8;\n        }\n        for (\u0026a, \u0026b) in b\"AGCUYRWSKMDVHBNZ\".iter().zip(b\"UCGARYWSMKHBDVNZ\".iter()) {\n            comp[a as usize] = b;\n            comp[a as usize + 32] = b + 32;  // lowercase variants\n        }\n        comp\n    };\n}\n\n/// Return complement of given RNA alphabet character (IUPAC alphabet supported).\n///\n/// Casing of input character is preserved, e.g. `u` → `a`, but `U` → `A`.\n/// All `N`s and `Z`s remain as they are.\n///\n/// ```\n/// use bio::alphabets::rna;\n///\n/// assert_eq!(rna::complement(65), 85); // A → U\n/// assert_eq!(rna::complement(103), 99); // g → c\n/// assert_eq!(rna::complement(89), 82); // Y → R\n/// assert_eq!(rna::complement(115), 115); // s → s\n/// assert_eq!(rna::complement(78), 78); // N → N\n/// ```\npub fn complement(a: u8) -\u003e u8 {\n    COMPLEMENT[a as usize]\n}\n\n/// Calculate reverse complement of given text (IUPAC alphabet supported).\n///\n/// Casing of characters is preserved, e.g. `b\"uAGg\"` → `b\"cCUa\"`.\n/// All `N`s and `Z`s remain as they are.\n///\n/// ```\n/// use bio::alphabets::rna;\n///\n/// assert_eq!(rna::revcomp(b\"ACGUN\"), b\"NACGU\");\n/// assert_eq!(rna::revcomp(b\"GaUuaCA\"), b\"UGuaAuC\");\n/// assert_eq!(rna::revcomp(b\"AGCUYRWSKMDVHBNZ\"), b\"ZNVDBHKMSWYRAGCU\");\npub fn revcomp\u003cC, T\u003e(text: T) -\u003e Vec\u003cu8\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: IntoIterator\u003cItem = C\u003e,\n    T::IntoIter: DoubleEndedIterator,\n{\n    text.into_iter()\n        .rev()\n        .map(|a| complement(*a.borrow()))\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_word() {\n        assert!(alphabet().is_word(b\"GAUUACA\"));\n    }\n\n    #[test]\n    fn is_no_word() {\n        assert!(!alphabet().is_word(b\"gaTTaca\"));\n    }\n\n    #[test]\n    fn symbol_is_no_word() {\n        assert!(!alphabet().is_word(b\"#\"));\n    }\n\n    #[test]\n    fn number_is_no_word() {\n        assert!(!alphabet().is_word(b\"42\"));\n    }\n\n    #[test]\n    fn test_reverse_complement() {\n        assert_eq!(revcomp(b\"GAUUACA\"), b\"UGUAAUC\");\n    }\n}\n","traces":[{"line":23,"address":[7724064],"length":1,"stats":{"Line":0},"fn_name":"alphabet"},{"line":28,"address":[7724096],"length":1,"stats":{"Line":0},"fn_name":"n_alphabet"},{"line":33,"address":[7724128],"length":1,"stats":{"Line":0},"fn_name":"iupac_alphabet"},{"line":39,"address":[4450532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4450816,4450882,4450549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[4450880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[4450690,4450887,4451221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[4451076,4451023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4451231,4451103,4451056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[7724160],"length":1,"stats":{"Line":0},"fn_name":"complement"},{"line":66,"address":[7724175,7724265,7724242],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[4527104],"length":1,"stats":{"Line":0},"fn_name":"revcomp\u003c\u0026u8,\u0026[u8; 7]\u003e"},{"line":86,"address":[4527136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[4527251,4527232],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003c\u0026u8,\u0026[u8; 7]\u003e"},{"line":97,"address":[5949056,5949145],"length":1,"stats":{"Line":0},"fn_name":"is_word"},{"line":98,"address":[5949060,5949172,5949161,5949202],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[5949307,5949216],"length":1,"stats":{"Line":0},"fn_name":"is_no_word"},{"line":103,"address":[5949323,5949364,5949220,5949334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[5949376,5949467],"length":1,"stats":{"Line":0},"fn_name":"symbol_is_no_word"},{"line":108,"address":[5949483,5949524,5949494,5949380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[5949536,5949627],"length":1,"stats":{"Line":0},"fn_name":"number_is_no_word"},{"line":113,"address":[5949684,5949540,5949654,5949643],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[5949696,5949893],"length":1,"stats":{"Line":0},"fn_name":"test_reverse_complement"},{"line":118,"address":[5949703],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","home","todd","rust-bio","src","data_structures","annot_map.rs"],"content":"//! Efficient container for locations annotated across a set of named\n//! reference sequences.\n//!\n//! # Example\n//!\n//! ```\n//! extern crate bio_types;\n//! use bio::data_structures::annot_map::AnnotMap;\n//! use bio_types::annot::contig::Contig;\n//! use bio_types::strand::ReqStrand;\n//!\n//! // Insert a String annotation into the annotation map at a specified location.\n//! let mut genes: AnnotMap\u003cString, String\u003e = AnnotMap::new();\n//! let tma22 = Contig::new(\n//!     \"chrX\".to_owned(),\n//!     461829,\n//!     462426 - 461829,\n//!     ReqStrand::Forward,\n//! );\n//! genes.insert_at(\"TMA22\".to_owned(), \u0026tma22);\n//!\n//! // Find annotations that overlap a specific query\n//! let query = Contig::new(\"chrX\".to_owned(), 462400, 100, ReqStrand::Forward);\n//! let hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n//! assert_eq!(hits, vec![\"TMA22\"]);\n//! ```\n\nuse std::collections::HashMap;\nuse std::hash::Hash;\n\nuse crate::data_structures::interval_tree;\nuse crate::data_structures::interval_tree::{IntervalTree, IntervalTreeIterator};\nuse crate::utils::Interval;\nuse bio_types::annot::loc::Loc;\n\n/// Efficient container for querying annotations, using `HashMap` and\n/// `IntervalTree`.\n///\n/// The container is parameterized over the type of the reference\n/// sequence names `R` (which is often a `String`) and the type of the\n/// contained objects `T`.\n///\n/// The container finds annotations that overlap a specific query\n/// location. Overlaps are identified without regard for strandedness\n/// and without regard for e.g. spliced-out introns within the\n/// annotation or the query.\n///\n/// Thus, the overlapping annotations identified by querying a\n/// `AnnotMap` may need further filtering.\n#[derive(Debug, Clone)]\npub struct AnnotMap\u003cR, T\u003e\nwhere\n    R: Hash + Eq,\n{\n    refid_itrees: HashMap\u003cR, IntervalTree\u003cisize, T\u003e\u003e,\n}\n\nimpl\u003cR, T\u003e Default for AnnotMap\u003cR, T\u003e\nwhere\n    R: Eq + Hash,\n{\n    fn default() -\u003e Self {\n        AnnotMap {\n            refid_itrees: HashMap::new(),\n        }\n    }\n}\n\nimpl\u003cR, T\u003e AnnotMap\u003cR, T\u003e\nwhere\n    R: Eq + Hash,\n{\n    /// Create a new, empty `AnnotMap`. Used in conjunction with `insert_at`\n    /// or `insert_loc`.\n    pub fn new() -\u003e Self {\n        Default::default()\n    }\n\n    /// Insert an object into the container at a specified location (`Loc`).\n    ///\n    /// # Arguments\n    ///\n    /// * `data` - any type of data to be inserted at the location / region\n    /// * `location` - any object with the `Loc` trait implemented, determining\n    ///   the Range at which to insert the `data`\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// extern crate bio_types;\n    /// use bio::data_structures::annot_map::AnnotMap;\n    /// use bio_types::annot::contig::Contig;\n    /// use bio_types::strand::ReqStrand;\n    ///\n    /// let mut genes: AnnotMap\u003cString, String\u003e = AnnotMap::new();\n    /// let tma22 = Contig::new(\n    ///     \"chrX\".to_owned(),\n    ///     461829,\n    ///     462426 - 461829,\n    ///     ReqStrand::Forward,\n    /// );\n    /// genes.insert_at(\"TMA22\".to_owned(), \u0026tma22);\n    /// ```\n    pub fn insert_at\u003cL\u003e(\u0026mut self, data: T, location: \u0026L)\n    where\n        R: Eq + Hash + Clone,\n        L: Loc\u003cRefID = R\u003e,\n    {\n        let itree = self\n            .refid_itrees\n            .entry(location.refid().clone())\n            .or_insert_with(IntervalTree::new);\n        let rng = location.start()..(location.start() + (location.length() as isize));\n        itree.insert(rng, data);\n    }\n\n    /// Create an `Iterator` that will visit all entries that overlap\n    /// a query location.\n    pub fn find\u003c'a, L\u003e(\u0026'a self, location: \u0026'a L) -\u003e AnnotMapIterator\u003c'a, R, T\u003e\n    where\n        L: Loc\u003cRefID = R\u003e,\n    {\n        if let Some(itree) = self.refid_itrees.get(location.refid()) {\n            let interval = location.start()..(location.start() + (location.length() as isize));\n            let itree_iter = itree.find(interval);\n            AnnotMapIterator {\n                itree_iter: Some(itree_iter),\n                refid: location.refid(),\n            }\n        } else {\n            AnnotMapIterator {\n                itree_iter: None,\n                refid: location.refid(),\n            }\n        }\n    }\n}\n\nimpl\u003cR, T\u003e AnnotMap\u003cR, T\u003e\nwhere\n    R: Eq + Hash + Clone,\n    T: Loc\u003cRefID = R\u003e,\n{\n    /// Insert an object with the `Loc` trait into the container at\n    /// its location.\n    ///\n    /// This inserts all of `data` at the Range of length `data.length()`\n    /// that starts at `data.start()`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// extern crate bio_types;\n    /// use bio::data_structures::annot_map::AnnotMap;\n    /// use bio_types::annot::contig::Contig;\n    /// use bio_types::strand::ReqStrand;\n    ///\n    /// let mut gene_locs = AnnotMap::new();\n    /// let tma19 = Contig::new(\n    ///     String::from(\"chrXI\"),\n    ///     334412,\n    ///     (334916 - 334412),\n    ///     ReqStrand::Reverse,\n    /// );\n    /// let assert_copy = tma19.clone();\n    /// gene_locs.insert_loc(tma19);\n    /// // Find annotations that overlap a specific query\n    /// let query = Contig::new(String::from(\"chrXI\"), 334400, 100, ReqStrand::Reverse);\n    /// let hits: Vec\u003c\u0026Contig\u003cString, ReqStrand\u003e\u003e = gene_locs.find(\u0026query).map(|e| e.data()).collect();\n    /// assert_eq!(hits, vec![\u0026assert_copy]);\n    /// ```\n    pub fn insert_loc(\u0026mut self, data: T) {\n        let itree = self\n            .refid_itrees\n            .entry(data.refid().clone())\n            .or_insert_with(IntervalTree::new);\n        let rng = data.start()..(data.start() + (data.length() as isize));\n        itree.insert(rng, data);\n    }\n}\n\n/// A view of one annotation in a `AnnotMap` container.\n#[derive(Debug, Clone)]\npub struct Entry\u003c'a, R, T\u003e\nwhere\n    R: Eq + Hash,\n{\n    itree_entry: interval_tree::Entry\u003c'a, isize, T\u003e,\n    refid: \u0026'a R,\n}\n\nimpl\u003c'a, R, T\u003e Entry\u003c'a, R, T\u003e\nwhere\n    R: Eq + Hash,\n{\n    /// Return a reference to the data value in the `AnnotMap`.\n    pub fn data(\u0026self) -\u003e \u0026'a T {\n        self.itree_entry.data()\n    }\n\n    /// Return a reference to the interval spanned by the annotation.\n    pub fn interval(\u0026self) -\u003e \u0026'a Interval\u003cisize\u003e {\n        self.itree_entry.interval()\n    }\n\n    /// Return a reference to the identifier of the annotated reference sequence.\n    pub fn refid(\u0026self) -\u003e \u0026'a R {\n        self.refid\n    }\n}\n\n/// An iterator over annotation entries (of type `Entry`) in a\n/// `AnnotMap`.\n///\n/// This struct is created by the `find` function on `AnnotMap`.\npub struct AnnotMapIterator\u003c'a, R, T\u003e\nwhere\n    R: Eq + Hash,\n{\n    itree_iter: Option\u003cIntervalTreeIterator\u003c'a, isize, T\u003e\u003e,\n    refid: \u0026'a R,\n}\n\nimpl\u003c'a, R, T\u003e Iterator for AnnotMapIterator\u003c'a, R, T\u003e\nwhere\n    R: 'a + Eq + Hash,\n    T: 'a,\n{\n    type Item = Entry\u003c'a, R, T\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        match self.itree_iter {\n            Some(ref mut iter) =\u003e match iter.next() {\n                Some(next_itree) =\u003e Some(Entry {\n                    itree_entry: next_itree,\n                    refid: self.refid,\n                }),\n                None =\u003e None,\n            },\n            None =\u003e None,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use bio_types::annot::contig::Contig;\n    use bio_types::strand::ReqStrand;\n\n    #[test]\n    fn lookup() {\n        let mut genes: AnnotMap\u003cString, String\u003e = AnnotMap::new();\n        genes.insert_at(\n            \"TMA22\".to_owned(),\n            \u0026Contig::new(\n                \"chrX\".to_owned(),\n                461829,\n                462426 - 461829,\n                ReqStrand::Forward,\n            ),\n        );\n        genes.insert_at(\n            \"TMA19\".to_owned(),\n            \u0026Contig::new(\n                \"chrXI\".to_owned(),\n                334412,\n                334916 - 334412,\n                ReqStrand::Reverse,\n            ),\n        );\n\n        let query = Contig::new(\"chrX\".to_owned(), 462400, 100, ReqStrand::Forward);\n        let hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        assert_eq!(hits, vec![\"TMA22\"]);\n\n        let query = Contig::new(\"chrXI\".to_owned(), 334400, 100, ReqStrand::Forward);\n        let hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        assert_eq!(hits, vec![\"TMA19\"]);\n\n        let query = Contig::new(\"chrXI\".to_owned(), 334916, 100, ReqStrand::Forward);\n        let hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        assert!(hits.is_empty());\n\n        let query = Contig::new(\"chrX\".to_owned(), 461729, 100, ReqStrand::Forward);\n        let hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        assert!(hits.is_empty());\n\n        let query = Contig::new(\"chrXI\".to_owned(), 462400, 100, ReqStrand::Forward);\n        let hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        assert!(hits.is_empty());\n\n        let query = Contig::new(\"NotFound\".to_owned(), 0, 0, ReqStrand::Forward);\n        let hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        assert!(hits.is_empty());\n    }\n\n    #[test]\n    fn overlaps() {\n        let mut genes: AnnotMap\u003cString, String\u003e = AnnotMap::new();\n\n        genes.insert_at(\n            \"a\".to_owned(),\n            \u0026Contig::new(\"chr01\".to_owned(), 1000, 1000, ReqStrand::Forward),\n        );\n        genes.insert_at(\n            \"b\".to_owned(),\n            \u0026Contig::new(\"chr01\".to_owned(), 1300, 1000, ReqStrand::Forward),\n        );\n        genes.insert_at(\n            \"c\".to_owned(),\n            \u0026Contig::new(\"chr01\".to_owned(), 1700, 1000, ReqStrand::Forward),\n        );\n        genes.insert_at(\n            \"d\".to_owned(),\n            \u0026Contig::new(\"chr01\".to_owned(), 2200, 1000, ReqStrand::Forward),\n        );\n\n        let query = Contig::new(\"chr01\".to_owned(), 1050, 100, ReqStrand::Forward);\n        let mut hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        hits.sort();\n        assert_eq!(hits, vec![\"a\"]);\n\n        let query = Contig::new(\"chr01\".to_owned(), 1450, 100, ReqStrand::Forward);\n        let mut hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        hits.sort();\n        assert_eq!(hits, vec![\"a\", \"b\"]);\n\n        let query = Contig::new(\"chr01\".to_owned(), 1850, 100, ReqStrand::Forward);\n        let mut hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        hits.sort();\n        assert_eq!(hits, vec![\"a\", \"b\", \"c\"]);\n\n        let query = Contig::new(\"chr01\".to_owned(), 2250, 100, ReqStrand::Forward);\n        let mut hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        hits.sort();\n        assert_eq!(hits, vec![\"b\", \"c\", \"d\"]);\n\n        let query = Contig::new(\"chr01\".to_owned(), 2650, 100, ReqStrand::Forward);\n        let mut hits: Vec\u003c\u0026String\u003e = genes.find(\u0026query).map(|e| e.data()).collect();\n        hits.sort();\n        assert_eq!(hits, vec![\"c\", \"d\"]);\n    }\n}\n","traces":[{"line":62,"address":[6299568],"length":1,"stats":{"Line":0},"fn_name":"default\u003calloc::string::String,alloc::string::String\u003e"},{"line":64,"address":[6299582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[6299632],"length":1,"stats":{"Line":0},"fn_name":"new\u003calloc::string::String,alloc::string::String\u003e"},{"line":76,"address":[6299640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[6299664,6300095],"length":1,"stats":{"Line":0},"fn_name":"insert_at\u003calloc::string::String,alloc::string::String,bio_types::annot::contig::Contig\u003calloc::string::String, bio_types::strand::ReqStrand\u003e\u003e"},{"line":109,"address":[6299713,6299832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[6299734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[6300055,6299877],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[6299993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[6300378,6300128],"length":1,"stats":{"Line":0},"fn_name":"find\u003calloc::string::String,alloc::string::String,bio_types::annot::contig::Contig\u003calloc::string::String, bio_types::strand::ReqStrand\u003e\u003e"},{"line":123,"address":[6300686,6300179,6300339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[6300411,6300508,6300255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[6300486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[6300543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[6300636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[6300287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[6300736],"length":1,"stats":{"Line":0},"fn_name":"data\u003calloc::string::String,alloc::string::String\u003e"},{"line":198,"address":[6300745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[6300768],"length":1,"stats":{"Line":0},"fn_name":"next\u003calloc::string::String,alloc::string::String\u003e"},{"line":232,"address":[6300810,6300824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[6300792,6300888,6300834,6300874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[6300900,6300854,6300924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[6300920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[6300881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[6300817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[6309157,6309152],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":254,"address":[7694551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[7694792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[7694577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[7694681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[7694665,7694601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[7694673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[7695094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[7694904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[7694974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[7694931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[7694966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[7695206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[6309204,6309184],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":276,"address":[7695584,7695407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[7695705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[6309252,6309232],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":280,"address":[7696083,7695906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[7696205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[6309280,6309300],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":284,"address":[7696493,7696404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[7696466,7696526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[6309348,6309328],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":288,"address":[7696698,7696787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[7696760,7696820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[6309396,6309376],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":292,"address":[7696992,7697081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[7697114,7697054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[6309444,6309424],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":296,"address":[7697358,7697281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[6309477,6309472],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":301,"address":[7697607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[7697824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[7697620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[7697714,7697647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[7698055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[7697886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[7697913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[7698286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[7698117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[7698144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[7698517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[7698348],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[7698375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[7698579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[6309504,6309524],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":322,"address":[7698781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[7698883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[7699162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[6309572,6309552],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":327,"address":[7699364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[7699466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[7699765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[6309600,6309620],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":332,"address":[7699967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[7700054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[7700354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[6309648,6309668],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":337,"address":[7700556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[7700643],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[7700943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[6309716,6309696],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":342,"address":[7701145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[7701232],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":103},{"path":["/","home","todd","rust-bio","src","data_structures","bit_tree.rs"],"content":"// Copyright 2014-2015 Patrick Marks\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! BIT-tree (Binary Indexed Trees, aka Fenwick Tree) maintains a prefix-sum or\n//! prefix-max that can be efficiently queried and updated. From: Peter M. Fenwick (1994). \"A new data structure for cumulative frequency tables\". Software: Practice and Experience. 24 (3): 327–336.\n//! Implementation outlined here: https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/\n//!\n//! Time Complexity: O(log n) where `n = tree.len()`.\n//! Memory Complexity: O(n) where `n = tree.len()`.\n//! # Example for a max bit tree\n//!\n//! ```\n//! use bio::data_structures::bit_tree::*;\n//!\n//! let mut bit = MaxBitTree::new(10);\n//! bit.set(0, (1,0));\n//! bit.set(1, (0,1));\n//! bit.set(2, (2,2));\n//! bit.set(3, (4,3));\n//!\n//! assert_eq!(bit.get(0), (1, 0));\n//! assert_eq!(bit.get(1), (1, 0));\n//! assert_eq!(bit.get(2), (2, 2));\n//! assert_eq!(bit.get(3), (4, 3));\n//! assert_eq!(bit.get(4), (4, 3));\n\nuse std::cmp::max;\nuse std::marker::PhantomData;\nuse std::ops::Add;\n\n/// Fenwick tree prefix operator\npub trait PrefixOp\u003cT\u003e {\n    fn operation(t1: T, t2: T) -\u003e T;\n}\n\n/// In a max bit tree or Fenwick Tree, get(i) will return the largest element e that has been added\n/// to the bit tree with set(j, e), where j \u003c= i. Initially all positions have\n/// the value T::default(). Note that a set cannot be 'undone' by inserting\n/// a smaller element at the same index.\n/// Time Complexity: O(n) to build a new tree or O(log n) for get() and set() operations,\n/// where `n = tree.len()`.\npub struct FenwickTree\u003cT: Default + Ord, Op: PrefixOp\u003cT\u003e\u003e {\n    tree: Vec\u003cT\u003e,\n    phantom: PhantomData\u003cOp\u003e,\n}\n\nimpl\u003cT: Ord + Default + Copy, Op: PrefixOp\u003cT\u003e\u003e FenwickTree\u003cT, Op\u003e {\n    /// Create a new bit tree with len elements\n    pub fn new(len: usize) -\u003e FenwickTree\u003cT, Op\u003e {\n        // Pad length by one. The first element is unused.\n        // Done this way to make the tree structure work correctly.\n        FenwickTree {\n            tree: vec![T::default(); len + 1],\n            phantom: PhantomData,\n        }\n    }\n\n    /// Returns the largest element e that has been added\n    /// to the bit tree with set(j, e), where j \u003c= i.\n    pub fn get(\u0026self, idx: usize) -\u003e T {\n        let mut idx = idx + 1;\n        let mut sum = T::default();\n        while idx \u003e 0 {\n            sum = Op::operation(sum, self.tree[idx]);\n            idx -= (idx as isize \u0026 -(idx as isize)) as usize;\n        }\n\n        sum\n    }\n\n    /// Set the value `val` at position `idx`; `val` will\n    /// be returned for any get(j) where j \u003e= idx, if\n    /// it is the maximum value inserted between 0 and j.\n    /// Inserting a value val2 after inserting val1 where val1 \u003e val2\n    /// will have no effect.\n    pub fn set(\u0026mut self, idx: usize, val: T) {\n        let mut idx = idx + 1;\n        while idx \u003c self.tree.len() {\n            self.tree[idx] = Op::operation(self.tree[idx], val);\n            idx += (idx as isize \u0026 -(idx as isize)) as usize;\n        }\n    }\n}\n\npub struct MaxOp;\nimpl\u003cT: Copy + Ord\u003e PrefixOp\u003cT\u003e for MaxOp {\n    fn operation(t1: T, t2: T) -\u003e T {\n        max(t1, t2)\n    }\n}\n\n/// Fenwick tree specialized for prefix-max\npub type MaxBitTree\u003cT\u003e = FenwickTree\u003cT, MaxOp\u003e;\n\npub struct SumOp;\nimpl\u003cT: Copy + Add\u003e PrefixOp\u003cT\u003e for SumOp\nwhere\n    T: Add\u003cOutput = T\u003e,\n{\n    fn operation(t1: T, t2: T) -\u003e T {\n        t1 + t2\n    }\n}\n\n/// Fenwick tree specialized for prefix-sum\npub type SumBitTree\u003cT\u003e = FenwickTree\u003cT, SumOp\u003e;\n\n#[cfg(test)]\nmod test_bit_tree {\n    use super::MaxBitTree;\n\n    #[test]\n    pub fn test_bit_tree() {\n        let mut bit = MaxBitTree::new(10);\n\n        bit.set(0, (1, 0));\n        bit.set(1, (1, 1));\n        bit.set(2, (2, 2));\n        bit.set(3, (3, 3));\n        bit.set(4, (2, 4));\n        bit.set(5, (2, 5));\n        bit.set(6, (4, 6));\n        bit.set(7, (5, 7));\n\n        assert_eq!(bit.get(0), (1, 0));\n        assert_eq!(bit.get(1), (1, 1));\n        assert_eq!(bit.get(2), (2, 2));\n        assert_eq!(bit.get(3), (3, 3));\n        assert_eq!(bit.get(4), (3, 3));\n        assert_eq!(bit.get(5), (3, 3));\n        assert_eq!(bit.get(6), (4, 6));\n        assert_eq!(bit.get(7), (5, 7));\n    }\n}\n","traces":[{"line":51,"address":[4521984,4521664,4521824],"length":1,"stats":{"Line":0},"fn_name":"new\u003c(u32, u32),bio::data_structures::bit_tree::MaxOp\u003e"},{"line":55,"address":[5469336,5469176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[4522144,4522512,4522992],"length":1,"stats":{"Line":0},"fn_name":"get\u003c(i32, i32),bio::data_structures::bit_tree::MaxOp\u003e"},{"line":63,"address":[4522588,4522550,4523052,4523011,4522163,4522204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[4522581,4522189,4523037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[4522618,4523082,4523313,4522234,4522942,4522465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[4522649,4522260,4523108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[4522470,4522345,4522824,4522947,4522500,4522977,4523348,4523193,4523318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[4523760,4523360,4524272],"length":1,"stats":{"Line":0},"fn_name":"set\u003c(u32, u32),bio::data_structures::bit_tree::MaxOp\u003e"},{"line":79,"address":[4523423,4524335,4523821,4523793,4523395,4524307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[4523421,4523716,4524370,4523458,4524628,4523856,4523819,4524232,4524333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[4523503,4524415,4523904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[4523601,4524237,4524267,4524513,4524633,4524663,4524117,4523721,4523751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[4524672,4524720,4524832],"length":1,"stats":{"Line":0},"fn_name":"operation\u003c(i32, i32)\u003e"},{"line":90,"address":[4524731,4524692,4524852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[7730192,7730197],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":116,"address":[4320279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[4320297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[4320350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[4320446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[4320502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[4320558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[4320614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[4320670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[4320726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[4320794,4321009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[4321245,4320968,4321069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[4321306,4321204,4321482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[4321441,4321713,4321543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[4321678,4321920,4321768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[4322127,4321891,4321975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[4322334,4322098,4322182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[4322305,4322389,4322522],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":36},{"path":["/","home","todd","rust-bio","src","data_structures","bitenc.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A fixed-width bit encoding implementation. This allows to store a sequence of values over\n//! a reduced alphabet by packing them bit-encoded into a sequence of bytes.\n//!\n//! Similar behaviour can be achieved using a `PackedVec` from the [packedvec](https://docs.rs/packedvec) crate.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::data_structures::bitenc::BitEnc;\n//! let mut bitenc = BitEnc::new(2);\n//! bitenc.push(0);\n//! bitenc.push(2);\n//! bitenc.push(1);\n//! let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n//! assert_eq!(values, [0, 2, 1]);\n//! ```\n//!\n//! BitEnc can be used in combination with `alphabets::RankTransform`\n//! to generate rank-encoded values, like 2-bit encoded DNA bases,\n//! and store these using `BitEnc`.\n//!\n//! ```\n//! use bio::alphabets;\n//! use bio::data_structures::bitenc::BitEnc;\n//!\n//! let dna_alphabet = alphabets::Alphabet::new(b\"ACGT\");\n//! let dna_ranks = alphabets::RankTransform::new(\u0026dna_alphabet);\n//!\n//! // Compute the number of bits required for the largest rank\n//! let mut bit_enc = BitEnc::new(dna_ranks.get_width());\n//!\n//! let text = b\"GATTACA\";\n//! assert_eq!(dna_ranks.transform(text), [2, 0, 3, 3, 0, 1, 0]);\n//! ```\n\n/// A sequence of bitencoded values.\n///\n/// Space complexity: O(⌈(n * width) / k⌉) * 32 bit, where n is the length of the input\n/// sequence and `k = 32 - (32 % width)`  is the number of bits in each\n/// 32-bit block that can be used to store values.\n/// For values that are not a divider of 32, some bits will remain unused.\n/// For example for `width = 7` only `4 * 7 = 28` bits are used.\n/// Five 7-bit values are stored in 2 blocks.\n#[derive(Serialize, Deserialize, PartialEq, Eq, Hash)]\npub struct BitEnc {\n    storage: Vec\u003cu32\u003e,\n    width: usize,\n    mask: u32,\n    len: usize,\n    usable_bits_per_block: usize,\n}\n\n/// Create a mask with `width` 1-bits.\nfn mask(width: usize) -\u003e u32 {\n    (1 \u003c\u003c width) - 1\n}\n\nimpl BitEnc {\n    /// Create a new instance with a given encoding width (e.g. width=2 for using two bits per value).\n    /// Supports widths up to 8 bits per character, i.e. `1 \u003c= width \u003c= 8`.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    /// let bitenc = BitEnc::new(3);\n    /// ```\n    pub fn new(width: usize) -\u003e Self {\n        assert!(width \u003c= 8, \"Only encoding widths up to 8 supported\");\n        BitEnc {\n            storage: Vec::new(),\n            width,\n            mask: mask(width),\n            len: 0,\n            usable_bits_per_block: 32 - 32 % width,\n        }\n    }\n\n    /// Create a new instance with a given capacity and encoding width\n    /// (e.g. width=2 for using two bits per value).\n    /// Supports widths up to 8 bits per character, i.e. `1 \u003c= width \u003c= 8`.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let bitenc = BitEnc::with_capacity(3, 42);\n    /// ```\n    pub fn with_capacity(width: usize, n: usize) -\u003e Self {\n        assert!(width \u003c= 8, \"Only encoding widths up to 8 supported\");\n        BitEnc {\n            storage: Vec::with_capacity(n * width / 32),\n            width,\n            mask: mask(width),\n            len: 0,\n            usable_bits_per_block: 32 - 32 % width,\n        }\n    }\n\n    /// Append a character to the current bit-encoding.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let mut bitenc = BitEnc::new(4);\n    /// bitenc.push(0b0000);\n    /// bitenc.push(0b1000);\n    /// bitenc.push(0b1010);\n    /// // The three characters added above are encoded into one u32 entry.\n    /// let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n    /// assert_eq!(values, [0b0000, 0b1000, 0b1010]);\n    /// ```\n    pub fn push(\u0026mut self, value: u8) {\n        let (block, bit) = self.addr(self.len);\n        if bit == 0 {\n            self.storage.push(0);\n        }\n        self.set_by_addr(block, bit, value);\n        self.len += 1;\n    }\n\n    /// Append the given `value` to the encoding `n` times.\n    ///\n    /// The added values comprise 0 to 1 blocks that need to be filled up\n    /// from previous steps, 0 to m blocks that are\n    /// completely filled with the value and 0 to 1 blocks\n    /// that are only partially filled.\n    ///\n    /// Complexity: O(n)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let mut bitenc = BitEnc::new(8);\n    /// // Width: 8 → 4 values per block\n    /// // | __ __ __ __ | Denotes one block with 4 empty slots\n    ///\n    /// bitenc.push_values(5, 0b101010);\n    /// // This adds one full and one partial block.\n    /// // | 42 42 42 42 | __ __ __ 42 |\n    ///\n    /// let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n    /// assert_eq!(values, [42, 42, 42, 42, 42]);\n    ///\n    /// bitenc.push_values(1, 23);\n    /// // This only fills up an existing block;\n    /// // | 42 42 42 42 | __ __ 23 42 |\n    ///\n    /// let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n    /// assert_eq!(values, [42, 42, 42, 42, 42, 23]);\n    ///\n    /// bitenc.push_values(6, 17);\n    /// // Fills up the current block, adds a whole new one but does not create a partial block.\n    /// // | 42 42 42 42 | 17 17 23 42 | 17 17 17 17 |\n    ///\n    /// let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n    /// assert_eq!(values, [42, 42, 42, 42, 42, 23, 17, 17, 17, 17, 17, 17]);\n    /// ```\n    pub fn push_values(\u0026mut self, mut n: usize, value: u8) {\n        // Fill up the previous block.\n        // Example: After adding 3 values with a width\n        // of 8, 8 out out 32 bits in the first block\n        // can still be used.\n        {\n            // Check if there are remaining free slots\n            // in the current block, i.e. if the bit offset\n            // within the block is non-zero\n            let (block, bit) = self.addr(self.len);\n            if bit \u003e 0 {\n                // insert as many values as required to fill\n                // up the previous block and decrease the number\n                // left to insert accordingly\n                // The take(n) assures this iterator stops before\n                // an overflow of n can occur, if less symbols are\n                // added than open slots in the block.\n                for bit in (bit..32).step_by(self.width).take(n) {\n                    self.set_by_addr(block, bit, value);\n                    n -= 1;\n                    self.len += 1;\n                }\n            }\n        }\n\n        // If symbols remain to be inserted after\n        // filling up the current block divide them into\n        // full and partial blocks to add them.\n        if n \u003e 0 {\n            // Create a full value block containing\n            // as many copies of value as possible.\n            let mut value_block = 0;\n            {\n                let mut v = u32::from(value);\n                for _ in 0..32 / self.width {\n                    value_block |= v;\n                    v \u003c\u003c= self.width;\n                }\n            }\n\n            // Append as many full value blocks as needed\n            // to reach the last block\n            let i = self.len + n;\n            let (block, bit) = self.addr(i);\n            self.storage.resize(block, value_block);\n\n            if bit \u003e 0 {\n                // add the remaining values to a final block\n                // let shifted_block = value_block \u003e\u003e (32 - bit);\n                let shifted_block = value_block \u003e\u003e (self.usable_bits_per_block - bit);\n                self.storage.push(shifted_block);\n            }\n\n            self.len = i;\n        }\n    }\n\n    /// Replace the current value as position `i` with the given value.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let mut bitenc = BitEnc::new(4);\n    /// bitenc.push_values(4, 0b1111);\n    /// bitenc.set(2, 0b0000);\n    ///\n    /// let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n    /// assert_eq!(values, [0b1111, 0b1111, 0b0000, 0b1111]);\n    /// ```\n    pub fn set(\u0026mut self, i: usize, value: u8) {\n        let (block, bit) = self.addr(i);\n        self.set_by_addr(block, bit, value);\n    }\n\n    /// Get the value at position `i`.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let mut bitenc = BitEnc::new(4);\n    /// for value in 1..=4 {\n    ///     bitenc.push(value);\n    /// }\n    ///\n    /// let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n    /// assert_eq!(values, [0b0001, 0b0010, 0b0011, 0b0100]);\n    /// ```\n    pub fn get(\u0026self, i: usize) -\u003e Option\u003cu8\u003e {\n        if i \u003e= self.len {\n            None\n        } else {\n            let (block, bit) = self.addr(i);\n            Some(self.get_by_addr(block, bit))\n        }\n    }\n\n    /// Iterate over stored values (values will be unpacked into bytes).\n    ///\n    /// Complexity: O(n), where n is the number of encoded values\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// // Fill bitenc with 1, 2, 3, and 4.\n    /// let mut bitenc = BitEnc::new(4);\n    /// for value in 1..=4 {\n    ///     bitenc.push(value);\n    /// }\n    ///\n    /// // Collect iterator for comparison\n    /// let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n    /// assert_eq!(values, [0b0001, 0b0010, 0b0011, 0b0100]);\n    /// ```\n    pub fn iter(\u0026self) -\u003e BitEncIter\u003c'_\u003e {\n        BitEncIter { bitenc: self, i: 0 }\n    }\n\n    /// Clear the sequence.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let mut bitenc = BitEnc::new(2);\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.len(), 1);\n    /// bitenc.clear();\n    /// assert_eq!(bitenc.len(), 0);\n    /// ```\n    pub fn clear(\u0026mut self) {\n        self.storage.clear();\n        self.len = 0;\n    }\n\n    /// Get the value stored in the given `block` at `bit`.\n    fn get_by_addr(\u0026self, block: usize, bit: usize) -\u003e u8 {\n        ((self.storage[block] \u003e\u003e bit) \u0026 self.mask) as u8\n    }\n\n    /// Replace the value in the given `block` at `bit` with the given `value`.\n    fn set_by_addr(\u0026mut self, block: usize, bit: usize, value: u8) {\n        let mask = self.mask \u003c\u003c bit;\n        self.storage[block] |= mask;\n        self.storage[block] ^= mask;\n        self.storage[block] |= (u32::from(value) \u0026 self.mask) \u003c\u003c bit;\n    }\n\n    /// Get the block and start bit for the `i`th encoded value.\n    fn addr(\u0026self, i: usize) -\u003e (usize, usize) {\n        let k = i * self.width;\n        (\n            k / self.usable_bits_per_block,\n            k % self.usable_bits_per_block,\n        )\n    }\n\n    /// Get the number of symbols encoded.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let mut bitenc = BitEnc::new(8);\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.len(), 1);\n    /// bitenc.push(2);\n    /// bitenc.push(2);\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.len(), 4);\n    /// // Add another 2 to create a second block\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.len(), 5);\n    /// ```\n    #[deprecated(\n        since = \"0.33.0\",\n        note = \"Please use the more specific `nr_blocks` and `nr_symbols` functions instead.\"\n    )]\n    pub fn len(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    /// Get the number of blocks used by the encoding.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let mut bitenc = BitEnc::new(8);\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.nr_blocks(), 1);\n    /// // Add enough 2s to completely fill the first block\n    /// bitenc.push(2);\n    /// bitenc.push(2);\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.nr_blocks(), 1);\n    /// // Add another 2 to create a second block\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.nr_blocks(), 2);\n    /// ```    \n    pub fn nr_blocks(\u0026self) -\u003e usize {\n        self.storage.len()\n    }\n\n    /// Get the number of symbols encoded.\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let mut bitenc = BitEnc::new(8);\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.nr_symbols(), 1);\n    /// bitenc.push(2);\n    /// bitenc.push(2);\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.nr_symbols(), 4);\n    /// bitenc.push(2);\n    /// assert_eq!(bitenc.nr_symbols(), 5);\n    /// ```    \n    pub fn nr_symbols(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    /// Is the encoded sequence empty?\n    ///\n    /// Complexity: O(1)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::data_structures::bitenc::BitEnc;\n    ///\n    /// let mut bitenc = BitEnc::new(2);\n    /// assert!(bitenc.is_empty());\n    /// bitenc.push(2);\n    /// assert!(!bitenc.is_empty());\n    /// bitenc.clear();\n    /// assert!(bitenc.is_empty());\n    /// ```\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.len == 0\n    }\n}\n\n/// Iterator over values of a bitencoded sequence (values will be unpacked into bytes).\n/// Used to implement the `iter` method of `BitEnc`.\npub struct BitEncIter\u003c'a\u003e {\n    bitenc: \u0026'a BitEnc,\n    i: usize,\n}\n\nimpl\u003c'a\u003e Iterator for BitEncIter\u003c'a\u003e {\n    type Item = u8;\n\n    fn next(\u0026mut self) -\u003e Option\u003cu8\u003e {\n        let value = self.bitenc.get(self.i);\n        self.i += 1;\n        value\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::BitEnc;\n\n    #[test]\n    fn test_bitenc() {\n        let mut bitenc = BitEnc::new(2);\n        bitenc.push(0);\n        bitenc.push(2);\n        bitenc.push(1);\n        let mut values: Vec\u003cu8\u003e = bitenc.iter().collect();\n        assert_eq!(values, [0, 2, 1]);\n        bitenc.set(1, 3);\n        values = bitenc.iter().collect();\n        assert_eq!(values, [0, 3, 1]);\n    }\n\n    #[test]\n    fn test_push_values() {\n        let mut bitenc = BitEnc::new(2);\n        bitenc.push_values(32, 0);\n        assert_eq!(bitenc.storage, [0, 0]);\n    }\n\n    #[test]\n    fn test_push_values_edge_cases() {\n        //! This is a slight variation of the methods doc test,\n        //! which also creates a new partial block in the last step\n        //! and an additonal full block of 17s.\n        //! As this bloats the result vectors, this was not included\n        //! in the doc test.\n        //! Additionally, this test uses a width of 7 bits, which leave\n        //! some bits unused.\n\n        let mut bitenc = BitEnc::new(7);\n        // Width: 7 → 4 values per block\n        // | __ __ __ __ | Denotes one block with 4 empty slots and 4 leftover bits\n\n        bitenc.push_values(5, 0b101010);\n        // This adds one full and one partial block.\n        // | 42 42 42 42 | __ __ __ 42 |\n\n        let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n        assert_eq!(values, [42, 42, 42, 42, 42]);\n        assert_eq!(bitenc.nr_blocks(), 2);\n        assert_eq!(bitenc.nr_symbols(), 5);\n\n        bitenc.push_values(1, 23);\n        // This only fills up an existing block;\n        // | 42 42 42 42 | __ __ 23 42 |\n        let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n        assert_eq!(values, [42, 42, 42, 42, 42, 23]);\n        assert_eq!(bitenc.nr_blocks(), 2);\n        assert_eq!(bitenc.nr_symbols(), 6);\n\n        bitenc.push_values(12, 17);\n        // Fills up the current block, adds a whole new one AND create a partial block.\n        // | 42 42 42 42 | 17 17 23 42 | 17 17 17 17 | 17 17 17 17 | __ __ 17 17 |\n\n        let values: Vec\u003cu8\u003e = bitenc.iter().collect();\n        assert_eq!(\n            values,\n            [42, 42, 42, 42, 42, 23, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17]\n        );\n        assert_eq!(bitenc.nr_blocks(), 5);\n        assert_eq!(bitenc.nr_symbols(), 18);\n    }\n\n    #[test]\n    fn test_issue29() {\n        for w in 2..9 {\n            let mut vec = BitEnc::with_capacity(w, 1000);\n            for i in 0..1000 {\n                println!(\"Push {}\", i);\n                vec.push(1);\n            }\n        }\n    }\n}\n","traces":[{"line":59,"address":[8072368],"length":1,"stats":{"Line":0},"fn_name":"mask"},{"line":60,"address":[8072377,8072500,8072470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[8072512,8072843,8072831],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":76,"address":[8072536,8072562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[8072549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[8072597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[8072801,8072665,8072615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[8073245,8072848,8073257],"length":1,"stats":{"Line":0},"fn_name":"with_capacity"},{"line":100,"address":[8072922,8072882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[8072905,8072957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[8073009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[8073215,8073027,8073077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[8073264],"length":1,"stats":{"Line":0},"fn_name":"push"},{"line":128,"address":[8073289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[8073328,8073349,8073380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[8073339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[8073370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[8073424,8073387,8073454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[8073456],"length":1,"stats":{"Line":0},"fn_name":"push_values"},{"line":184,"address":[8073497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[8073741,8073542],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[8073563,8073760,8073908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[8073792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[8073864,8073800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[8073913,8073842,8073904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[8073943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[8073963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[8073974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[8073994,8074328,8074234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[8074258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[8074279,8074333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[8074373,8074398,8074196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[8074381,8074443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[8074459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[8074477,8074650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[8074498,8074620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[8074612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[8074662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[8074688],"length":1,"stats":{"Line":0},"fn_name":"set"},{"line":247,"address":[8074716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[8074759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[8074784],"length":1,"stats":{"Line":0},"fn_name":"get"},{"line":267,"address":[8074908,8074808,8074906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[8074841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[8074824,8074874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[8074884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[8074912],"length":1,"stats":{"Line":0},"fn_name":"iter"},{"line":313,"address":[8074960],"length":1,"stats":{"Line":0},"fn_name":"clear"},{"line":314,"address":[8074974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[8074985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[8075008],"length":1,"stats":{"Line":0},"fn_name":"get_by_addr"},{"line":320,"address":[8075037,8075141,8075111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[8075152],"length":1,"stats":{"Line":0},"fn_name":"set_by_addr"},{"line":325,"address":[8075199,8075267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[8075316,8075247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[8075320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[8075355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[8075504],"length":1,"stats":{"Line":0},"fn_name":"addr"},{"line":333,"address":[8075579,8075526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[8075557,8075619,8075659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[8075699,8075734,8075764,8075637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[8075776],"length":1,"stats":{"Line":0},"fn_name":"len"},{"line":365,"address":[8075781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[8075792],"length":1,"stats":{"Line":0},"fn_name":"nr_blocks"},{"line":390,"address":[8075801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[8075824],"length":1,"stats":{"Line":0},"fn_name":"nr_symbols"},{"line":413,"address":[8075829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[8075840],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":433,"address":[8075845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[8075872],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":448,"address":[8075889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[8076001,8075971,8075924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[5118464,5117696],"length":1,"stats":{"Line":0},"fn_name":"test_bitenc"},{"line":460,"address":[5117703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[5117725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[5117742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[5117796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[5117808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[5117864,5118027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[5118010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[5118269,5118078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[5118389,5118348,5118185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[5118496,5118709],"length":1,"stats":{"Line":0},"fn_name":"test_push_values"},{"line":473,"address":[5118503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[5118530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[5118542,5118645,5118672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[5118736,5120915],"length":1,"stats":{"Line":0},"fn_name":"test_push_values_edge_cases"},{"line":488,"address":[5118743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[5118779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[5118887,5118794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[5119087,5118902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[5119053,5119141,5119283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[5119484,5119343,5119249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[5119461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[5119544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[5119797,5119612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[5119852,5119985,5119763],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[5120042,5119957,5120171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[5120154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[5120231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[5120287,5120451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[5120630,5120426,5120503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[5120687,5120810,5120605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[5121513,5120944],"length":1,"stats":{"Line":0},"fn_name":"test_issue29"},{"line":524,"address":[5121063,5120951,5121528,5121533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[5121092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[5121508,5121227,5121313,5121107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[5121349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[5121501],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":110},{"path":["/","home","todd","rust-bio","src","data_structures","bwt.rs"],"content":"// Copyright 2014-2016 Johannes Köster, Taylor Cramer.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! The [Burrows-Wheeler-Transform](https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.6774) and related data structures.\n//! The implementation is based on the lecture notes\n//! \"Algorithmen auf Sequenzen\", Kopczynski, Marschall, Martin and Rahmann, 2008 - 2015.\n\nuse std::iter::repeat;\n\nuse crate::alphabets::Alphabet;\nuse crate::data_structures::suffix_array::RawSuffixArraySlice;\nuse crate::utils::prescan;\n\npub type BWT = Vec\u003cu8\u003e;\npub type BWTSlice = [u8];\npub type Less = Vec\u003cusize\u003e;\npub type BWTFind = Vec\u003cusize\u003e;\n\n/// Calculate Burrows-Wheeler-Transform of the given text of length n.\n/// Complexity: O(n).\n///\n/// # Arguments\n///\n/// * `text` - the text ended by sentinel symbol (being lexicographically smallest)\n/// * `pos` - the suffix array for the text\n///\n/// # Example\n///\n/// ```\n/// use bio::data_structures::bwt::bwt;\n/// use bio::data_structures::suffix_array::suffix_array;\n/// let text = b\"GCCTTAACATTATTACGCCTA$\";\n/// let pos = suffix_array(text);\n/// let bwt = bwt(text, \u0026pos);\n/// assert_eq!(bwt, b\"ATTATTCAGGACCC$CTTTCAA\");\n/// ```\npub fn bwt(text: \u0026[u8], pos: RawSuffixArraySlice) -\u003e BWT {\n    assert_eq!(text.len(), pos.len());\n    let n = text.len();\n    let mut bwt: BWT = repeat(0).take(n).collect();\n    for r in 0..n {\n        let p = pos[r];\n        bwt[r] = if p \u003e 0 { text[p - 1] } else { text[n - 1] };\n    }\n\n    bwt\n}\n\n/// Calculate the inverse of a BWT of length n, which is the original text.\n/// Complexity: O(n).\n///\n/// This only works if the last sentinel in the original text is unique\n/// and lexicographically the smallest.\n///\n/// # Arguments\n///\n/// * `bwt` - the BWT\npub fn invert_bwt(bwt: \u0026BWTSlice) -\u003e Vec\u003cu8\u003e {\n    let alphabet = Alphabet::new(bwt);\n    let n = bwt.len();\n    let bwtfind = bwtfind(bwt, \u0026alphabet);\n    let mut inverse = Vec::with_capacity(n);\n\n    let mut r = bwtfind[0];\n    for _ in 0..n {\n        r = bwtfind[r];\n        inverse.push(bwt[r]);\n    }\n\n    inverse\n}\n\n/// An occurrence array implementation.\n#[derive(Serialize, Deserialize)]\npub struct Occ {\n    occ: Vec\u003cVec\u003cusize\u003e\u003e,\n    k: u32,\n}\n\nimpl Occ {\n    /// Calculate occ array with sampling from BWT of length n.\n    /// Time complexity: O(n).\n    /// Space complexity: O(n / k * A) with A being the alphabet size.\n    /// Alphabet size is determined on the fly from the BWT.\n    /// For large texts, it is therefore advisable to transform\n    /// the text before calculating the BWT (see alphabets::rank_transform).\n    ///\n    /// # Arguments\n    ///\n    /// * `bwt` - the BWT\n    /// * `k` - the sampling rate: every k-th entry will be stored\n    pub fn new(bwt: \u0026BWTSlice, k: u32, alphabet: \u0026Alphabet) -\u003e Self {\n        let n = bwt.len();\n        let m = alphabet\n            .max_symbol()\n            .expect(\"Expecting non-empty alphabet.\") as usize\n            + 1;\n        let mut occ = Vec::with_capacity(n / k as usize);\n        let mut curr_occ: Vec\u003cusize\u003e = repeat(0).take(m).collect();\n        for (i, \u0026c) in bwt.iter().enumerate() {\n            curr_occ[c as usize] += 1;\n            if i % k as usize == 0 {\n                occ.push(curr_occ.clone());\n            }\n        }\n\n        Occ { occ, k }\n    }\n\n    /// Get occurrence count of symbol a in BWT[..r+1].\n    /// Complexity: O(k).\n    pub fn get(\u0026self, bwt: \u0026BWTSlice, r: usize, a: u8) -\u003e usize {\n        // NOTE:\n        //\n        // Retrieving byte match counts in this function is critical to the performance of FM Index.\n        //\n        // The below manual count code is roughly equivalent to:\n        // ```\n        // let count = bwt[(i * self.k) + 1..r + 1]\n        //     .iter()\n        //     .filter(|\u0026\u0026c| c == a)\n        //     .count();\n        // self.occ[i][a as usize] + count\n        // ```\n        //\n        // But there are a couple of reasons to do this manually:\n        // 1) As of 2016, versions of rustc/LLVM vectorize this manual loop more reliably\n        //    than the iterator adapter version.\n        // 2) Manually accumulating the byte match count in a single chunk can allows\n        //    us to use a `u32` for that count, which has faster arithmetic on common arches.\n        //    This does necessitate storing `k` as a u32.\n        //\n        // See the conversation in these issues for some of the history here:\n        //\n        // https://github.com/rust-bio/rust-bio/pull/74\n        // https://github.com/rust-bio/rust-bio/pull/76\n\n        // self.k is our sampling rate, so find the checkpoints either side of r.\n        let lo_checkpoint = r / self.k as usize;\n        // Get the occurences at the low checkpoint\n        let lo_occ = self.occ[lo_checkpoint][a as usize];\n\n        // If the sampling rate is infrequent it is worth checking if there is a closer\n        // hi checkpoint.\n        if self.k \u003e 64 {\n            let hi_checkpoint = lo_checkpoint + 1;\n            if let Some(hi_occs) = self.occ.get(hi_checkpoint) {\n                let hi_occ = hi_occs[a as usize];\n\n                // Its possible that there are no occurences between the low and high\n                // checkpoint in which case we bail early.\n                if lo_occ == hi_occ {\n                    return lo_occ;\n                }\n\n                // If r is closer to the high checkpoint, count backwards from there.\n                let hi_idx = hi_checkpoint * self.k as usize;\n                if (hi_idx - r) \u003c (self.k as usize / 2) {\n                    let hi_occ = hi_occs[a as usize];\n                    return hi_occ - bytecount::count(\u0026bwt[r + 1..=hi_idx], a) as usize;\n                }\n            }\n        }\n\n        // Otherwise the default case is to count from the low checkpoint.\n        let lo_idx = lo_checkpoint * self.k as usize;\n        bytecount::count(\u0026bwt[lo_idx + 1..=r], a) as usize + lo_occ\n    }\n}\n\n/// Calculate the less array for a given BWT. Complexity O(n).\npub fn less(bwt: \u0026BWTSlice, alphabet: \u0026Alphabet) -\u003e Less {\n    let m = alphabet\n        .max_symbol()\n        .expect(\"Expecting non-empty alphabet.\") as usize\n        + 2;\n    let mut less: Less = repeat(0).take(m).collect();\n    for \u0026c in bwt.iter() {\n        less[c as usize] += 1;\n    }\n    // calculate +-prescan\n    prescan(\u0026mut less[..], 0, |a, b| a + b);\n\n    less\n}\n\n/// Calculate the bwtfind array needed for inverting the BWT. Complexity O(n).\npub fn bwtfind(bwt: \u0026BWTSlice, alphabet: \u0026Alphabet) -\u003e BWTFind {\n    let n = bwt.len();\n    let mut less = less(bwt, alphabet);\n\n    let mut bwtfind: BWTFind = repeat(0).take(n).collect();\n    for (r, \u0026c) in bwt.iter().enumerate() {\n        bwtfind[less[c as usize]] = r;\n        less[c as usize] += 1;\n    }\n\n    bwtfind\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{bwt, bwtfind, invert_bwt, Occ};\n    use crate::alphabets::dna;\n    use crate::alphabets::Alphabet;\n    use crate::data_structures::suffix_array::suffix_array;\n    use crate::data_structures::wavelet_matrix::WaveletMatrix;\n\n    #[test]\n    fn test_bwtfind() {\n        let text = b\"cabca$\";\n        let alphabet = Alphabet::new(b\"abc$\");\n        let pos = suffix_array(text);\n        let bwt = bwt(text, \u0026pos);\n        let bwtfind = bwtfind(\u0026bwt, \u0026alphabet);\n        assert_eq!(bwtfind, vec![5, 0, 3, 4, 1, 2]);\n    }\n\n    #[test]\n    fn test_invert_bwt() {\n        let text = b\"cabca$\";\n        let pos = suffix_array(text);\n        let bwt = bwt(text, \u0026pos);\n        let inverse = invert_bwt(\u0026bwt);\n        assert_eq!(inverse, text);\n    }\n\n    #[test]\n    fn test_occ() {\n        let bwt = vec![1u8, 3u8, 3u8, 1u8, 2u8, 0u8];\n        let alphabet = Alphabet::new(\u0026[0u8, 1u8, 2u8, 3u8]);\n        let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n        assert_eq!(occ.occ, [[0, 1, 0, 0], [0, 2, 0, 2]]);\n        assert_eq!(occ.get(\u0026bwt, 4, 2u8), 1);\n        assert_eq!(occ.get(\u0026bwt, 4, 3u8), 2);\n    }\n\n    #[test]\n    fn test_occwm() {\n        let text = b\"GCCTTAACATTATTACGCCTA$\";\n        let alphabet = dna::n_alphabet();\n        let sa = suffix_array(text);\n        let bwt = bwt(text, \u0026sa);\n        let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n        let wm = WaveletMatrix::new(\u0026bwt);\n\n        for c in vec![b'A', b'C', b'G', b'T', b'$'] {\n            for p in 0..text.len() {\n                assert_eq!(occ.get(\u0026bwt, p, c) as u64, wm.rank(c, p as u64));\n            }\n        }\n    }\n}\n","traces":[{"line":39,"address":[4246500,4245408,4246485],"length":1,"stats":{"Line":0},"fn_name":"bwt"},{"line":40,"address":[4245685,4245511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[4245654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[4245733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[4246480,4245800,4246033,4245932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[4246070,4246127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4246109,4246152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[4246512,4247207],"length":1,"stats":{"Line":0},"fn_name":"invert_bwt"},{"line":61,"address":[4246555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[4246575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[4246630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[4246684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[4246781,4246695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[4246903,4247190,4246792,4247021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[4247045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[4247108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[4248449,4247248],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":95,"address":[4247352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[4247387,4247508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[4247488,4247551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[4247723,4247616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[4247746,4248107,4248395,4247843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[4248281,4248183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[4248423,4248261,4248323,4248393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[4248416,4248366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[4248480],"length":1,"stats":{"Line":0},"fn_name":"get"},{"line":141,"address":[4248568,4248660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[4248638,4248705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[4248766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[4248851,4248785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[4248828,4249000,4248905,4249270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[4249061,4248972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[4249072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[4249121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[4249093,4249158,4249183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[4249166,4249226],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[4249287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[4249339,4249532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[4249567,4249593,4249018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[4249575,4249636,4249804,4249834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[4250568,4250553,4249840],"length":1,"stats":{"Line":0},"fn_name":"less"},{"line":175,"address":[4249919,4250041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[4250025,4250081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[4250377,4250479,4250132,4250247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[4250484,4250416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[4250336,4250530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[4250576,4251395],"length":1,"stats":{"Line":0},"fn_name":"bwtfind"},{"line":191,"address":[4250654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[4250691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[4250818,4250708],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[4250835,4250932,4251358,4251112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[4251186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[4251363,4251284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[5041392,5042097],"length":1,"stats":{"Line":0},"fn_name":"test_bwtfind"},{"line":213,"address":[5041399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[5041414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[5041431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[5041534,5041455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[5041593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[5041700,5041914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[5042128,5042598],"length":1,"stats":{"Line":0},"fn_name":"test_invert_bwt"},{"line":223,"address":[5042135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[5042147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[5042167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[5042279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[5042373,5042523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[5042624,5043563],"length":1,"stats":{"Line":0},"fn_name":"test_occ"},{"line":232,"address":[5042631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[5042687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[5042810,5042709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[5042862,5043034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[5043265,5043109,5042992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[5043483,5043346,5043223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[5045039,5043600],"length":1,"stats":{"Line":0},"fn_name":"test_occwm"},{"line":242,"address":[5043607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[5043622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[5043635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[5043662,5043759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[5043824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[5043950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[5044068,5044619,5044182,5044358,5044382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[5044414,5044891,5044624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[5044905,5044661],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":86},{"path":["/","home","todd","rust-bio","src","data_structures","fmindex.rs"],"content":"// Copyright 2014-2016 Johannes Köster, Taylor Cramer.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! The [Full-text index in Minute space index (FM-index)](https://doi.org/10.1109/SFCS.2000.892127) and\n//! the FMD-Index for finding suffix array intervals matching a given pattern in linear time.\n//!\n//! # Examples\n//!\n//! ## Generate\n//!\n//! ```\n//! use bio::alphabets::dna;\n//! use bio::data_structures::bwt::{bwt, less, Occ};\n//! use bio::data_structures::fmindex::{FMIndex, FMIndexable};\n//! use bio::data_structures::suffix_array::suffix_array;\n//!\n//! let text = b\"GCCTTAACATTATTACGCCTA$\";\n//! let alphabet = dna::n_alphabet();\n//! let sa = suffix_array(text);\n//! let bwt = bwt(text, \u0026sa);\n//! let less = less(\u0026bwt, \u0026alphabet);\n//! let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n//! let fm = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n//! ```\n//!\n//! ## Enclose in struct\n//!\n//! `FMIndex` was designed to not forcibly own the BWT and auxiliary data structures.\n//! It can take a reference (`\u0026`), owned structs or any of the more complex pointer types.\n//!\n//! ```\n//! use bio::alphabets::dna;\n//! use bio::data_structures::bwt::{bwt, less, Less, Occ, BWT};\n//! use bio::data_structures::fmindex::{FMIndex, FMIndexable};\n//! use bio::data_structures::suffix_array::suffix_array;\n//! use bio::utils::TextSlice;\n//!\n//! pub struct Example {\n//!     fmindex: FMIndex\u003cBWT, Less, Occ\u003e,\n//! }\n//!\n//! impl Example {\n//!     pub fn new(text: TextSlice) -\u003e Self {\n//!         let alphabet = dna::n_alphabet();\n//!         let sa = suffix_array(text);\n//!         let bwt = bwt(text, \u0026sa);\n//!         let less = less(\u0026bwt, \u0026alphabet);\n//!         let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n//!         let fm = FMIndex::new(bwt, less, occ);\n//!         Example { fmindex: fm }\n//!     }\n//! }\n//! ```\n\nuse std::borrow::Borrow;\nuse std::iter::DoubleEndedIterator;\n\nuse crate::alphabets::dna;\nuse crate::data_structures::bwt::{Less, Occ, BWT};\nuse crate::data_structures::suffix_array::SuffixArray;\nuse std::mem::swap;\n\n/// A suffix array interval.\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\npub struct Interval {\n    pub lower: usize,\n    pub upper: usize,\n}\n\nimpl Interval {\n    pub fn occ\u003cSA: SuffixArray\u003e(\u0026self, sa: \u0026SA) -\u003e Vec\u003cusize\u003e {\n        (self.lower..self.upper)\n            .map(|pos| sa.get(pos).expect(\"Interval out of range of suffix array\"))\n            .collect()\n    }\n}\n\npub trait FMIndexable {\n    /// Get occurrence count of symbol a in BWT[..r+1].\n    fn occ(\u0026self, r: usize, a: u8) -\u003e usize;\n    /// Also known as\n    fn less(\u0026self, a: u8) -\u003e usize;\n    fn bwt(\u0026self) -\u003e \u0026BWT;\n\n    /// Perform backward search, yielding suffix array\n    /// interval denoting exact occurrences of the given pattern of length m in the text.\n    /// Complexity: O(m).\n    ///\n    /// # Arguments\n    ///\n    /// * `pattern` - the pattern to search\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets::dna;\n    /// use bio::data_structures::bwt::{bwt, less, Occ};\n    /// use bio::data_structures::fmindex::{FMIndex, FMIndexable};\n    /// use bio::data_structures::suffix_array::suffix_array;\n    ///\n    /// let text = b\"GCCTTAACATTATTACGCCTA$\";\n    /// let alphabet = dna::n_alphabet();\n    /// let sa = suffix_array(text);\n    /// let bwt = bwt(text, \u0026sa);\n    /// let less = less(\u0026bwt, \u0026alphabet);\n    /// let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n    /// let fm = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n    ///\n    /// let pattern = b\"TTA\";\n    /// let sai = fm.backward_search(pattern.iter());\n    ///\n    /// let positions = sai.occ(\u0026sa);\n    ///\n    /// assert_eq!(positions, [3, 12, 9]);\n    /// ```\n    fn backward_search\u003c'b, P: Iterator\u003cItem = \u0026'b u8\u003e + DoubleEndedIterator\u003e(\n        \u0026self,\n        pattern: P,\n    ) -\u003e Interval {\n        let (mut l, mut r) = (0, self.bwt().len() - 1);\n        for \u0026a in pattern.rev() {\n            let less = self.less(a);\n            l = less + if l \u003e 0 { self.occ(l - 1, a) } else { 0 };\n            r = less + self.occ(r, a) - 1;\n\n            // The symbol was not found if we end up with an empty interval.\n            // Terminate the LF-mapping process.\n            if l == r {\n                break;\n            }\n        }\n\n        Interval {\n            lower: l,\n            upper: r + 1,\n        }\n    }\n}\n\n/// The Fast Index in Minute space (FM-Index, Ferragina and Manzini, 2000) for finding suffix array\n/// intervals matching a given pattern.\n#[derive(Serialize, Deserialize)]\npub struct FMIndex\u003cDBWT: Borrow\u003cBWT\u003e, DLess: Borrow\u003cLess\u003e, DOcc: Borrow\u003cOcc\u003e\u003e {\n    bwt: DBWT,\n    less: DLess,\n    occ: DOcc,\n}\n\nimpl\u003cDBWT: Borrow\u003cBWT\u003e, DLess: Borrow\u003cLess\u003e, DOcc: Borrow\u003cOcc\u003e\u003e FMIndexable\n    for FMIndex\u003cDBWT, DLess, DOcc\u003e\n{\n    fn occ(\u0026self, r: usize, a: u8) -\u003e usize {\n        self.occ.borrow().get(self.bwt.borrow(), r, a)\n    }\n    fn less(\u0026self, a: u8) -\u003e usize {\n        self.less.borrow()[a as usize]\n    }\n    /// Provide a reference to the underlying BWT.\n    fn bwt(\u0026self) -\u003e \u0026BWT {\n        self.bwt.borrow()\n    }\n}\n\nimpl\u003cDBWT: Borrow\u003cBWT\u003e, DLess: Borrow\u003cLess\u003e, DOcc: Borrow\u003cOcc\u003e\u003e FMIndex\u003cDBWT, DLess, DOcc\u003e {\n    /// Construct a new instance of the FM index.\n    ///\n    /// # Arguments\n    ///\n    /// * `bwt` - the BWT\n    /// * `less` - the less array of the BWT\n    /// * `occ` - the occurence array of the BWT\n    pub fn new(bwt: DBWT, less: DLess, occ: DOcc) -\u003e Self {\n        FMIndex { bwt, less, occ }\n    }\n}\n\n/// A bi-interval on suffix array of the forward and reverse strand of a DNA text.\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\npub struct BiInterval {\n    lower: usize,\n    lower_rev: usize,\n    size: usize,\n    match_size: usize,\n}\n\nimpl BiInterval {\n    pub fn forward(\u0026self) -\u003e Interval {\n        Interval {\n            upper: self.lower + self.size,\n            lower: self.lower,\n        }\n    }\n    pub fn revcomp(\u0026self) -\u003e Interval {\n        Interval {\n            upper: self.lower_rev + self.size,\n            lower: self.lower_rev,\n        }\n    }\n\n    fn swapped(\u0026self) -\u003e BiInterval {\n        BiInterval {\n            lower: self.lower_rev,\n            lower_rev: self.lower,\n            size: self.size,\n            match_size: self.match_size,\n        }\n    }\n}\n\n/// The FMD-Index for linear time search of supermaximal exact matches on forward and reverse\n/// strand of DNA texts (Li, 2012).\n#[derive(Serialize, Deserialize)]\npub struct FMDIndex\u003cDBWT: Borrow\u003cBWT\u003e, DLess: Borrow\u003cLess\u003e, DOcc: Borrow\u003cOcc\u003e\u003e {\n    fmindex: FMIndex\u003cDBWT, DLess, DOcc\u003e,\n}\n\nimpl\u003cDBWT: Borrow\u003cBWT\u003e, DLess: Borrow\u003cLess\u003e, DOcc: Borrow\u003cOcc\u003e\u003e FMIndexable\n    for FMDIndex\u003cDBWT, DLess, DOcc\u003e\n{\n    fn occ(\u0026self, r: usize, a: u8) -\u003e usize {\n        self.fmindex.occ(r, a)\n    }\n\n    fn less(\u0026self, a: u8) -\u003e usize {\n        self.fmindex.less(a)\n    }\n\n    /// Provide a reference to the underlying BWT.\n    fn bwt(\u0026self) -\u003e \u0026BWT {\n        self.fmindex.bwt()\n    }\n}\n\nimpl\u003cDBWT: Borrow\u003cBWT\u003e, DLess: Borrow\u003cLess\u003e, DOcc: Borrow\u003cOcc\u003e\u003e From\u003cFMIndex\u003cDBWT, DLess, DOcc\u003e\u003e\n    for FMDIndex\u003cDBWT, DLess, DOcc\u003e\n{\n    /// Construct a new instance of the FMD index (see Heng Li (2012) Bioinformatics).\n    /// This expects a BWT that was created from a text over the DNA alphabet with N\n    /// (`alphabets::dna::n_alphabet()`) consisting of the\n    /// concatenation with its reverse complement, separated by the sentinel symbol `$`.\n    /// I.e., let T be the original text and R be its reverse complement.\n    /// Then, the expected text is T$R$. Further, multiple concatenated texts are allowed, e.g.\n    /// T1$R1$T2$R2$T3$R3$.\n    fn from(fmindex: FMIndex\u003cDBWT, DLess, DOcc\u003e) -\u003e FMDIndex\u003cDBWT, DLess, DOcc\u003e {\n        let mut alphabet = dna::n_alphabet();\n        alphabet.insert(b'$');\n        assert!(\n            alphabet.is_word(fmindex.bwt()),\n            \"Expecting BWT over the DNA alphabet (including N) with the sentinel $.\"\n        );\n\n        FMDIndex { fmindex }\n    }\n}\n\nimpl\u003cDBWT: Borrow\u003cBWT\u003e, DLess: Borrow\u003cLess\u003e, DOcc: Borrow\u003cOcc\u003e\u003e FMDIndex\u003cDBWT, DLess, DOcc\u003e {\n    /// Find supermaximal exact matches (of length \u003e= l) of given pattern that overlap position i in the pattern.\n    /// Complexity O(m) with pattern of length m.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets::dna;\n    /// use bio::data_structures::bwt::{bwt, less, Occ};\n    /// use bio::data_structures::fmindex::{FMDIndex, FMIndex};\n    /// use bio::data_structures::suffix_array::suffix_array;\n    ///\n    /// let text = b\"ATTC$GAAT$\";\n    /// let alphabet = dna::n_alphabet();\n    /// let sa = suffix_array(text);\n    /// let bwt = bwt(text, \u0026sa);\n    /// let less = less(\u0026bwt, \u0026alphabet);\n    /// let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n    /// let fm = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n    /// let fmdindex = FMDIndex::from(fm);\n    ///\n    /// let pattern = b\"ATT\";\n    /// let intervals = fmdindex.smems(pattern, 2, 0);\n    ///\n    /// let forward_positions = intervals[0].0.forward().occ(\u0026sa);\n    /// let revcomp_positions = intervals[0].0.revcomp().occ(\u0026sa);\n    /// let pattern_position = intervals[0].1;\n    /// let smem_len = intervals[0].2;\n    ///\n    /// assert_eq!(forward_positions, [0]);\n    /// assert_eq!(revcomp_positions, [6]);\n    /// assert_eq!(pattern_position, 0);\n    /// assert_eq!(smem_len, 3);\n    /// ```\n    pub fn smems(\u0026self, pattern: \u0026[u8], i: usize, l: usize) -\u003e Vec\u003c(BiInterval, usize, usize)\u003e {\n        let curr = \u0026mut Vec::new(); // pairs (biinterval, current match length)\n        let prev = \u0026mut Vec::new(); // \"\"\"\n        let mut matches = Vec::new(); // triples (biinterval, position on pattern, smem length)\n\n        let mut match_len = 0;\n        let mut interval = self.init_interval_with(pattern[i]);\n        if interval.size != 0 {\n            match_len += 1;\n        }\n\n        for \u0026a in pattern[i + 1..].iter() {\n            // forward extend interval\n            let forward_interval = self.forward_ext(\u0026interval, a);\n\n            // if size changed, add last interval to list\n            if interval.size != forward_interval.size {\n                curr.push((interval, match_len));\n            }\n            // if new interval size is zero, stop, as no further forward extension is possible\n            if forward_interval.size == 0 {\n                break;\n            }\n            interval = forward_interval;\n            match_len += 1;\n        }\n        // add the last non-zero interval\n        curr.push((interval, match_len));\n        // reverse intervals such that longest comes first\n        curr.reverse();\n\n        swap(curr, prev);\n        let mut j = pattern.len() as isize;\n\n        for k in (-1..i as isize).rev() {\n            let a = if k == -1 { b'$' } else { pattern[k as usize] };\n            curr.clear();\n            // size of the last confirmed interval\n            let mut last_size = -1;\n\n            for (interval, match_len) in prev.iter() {\n                // backward extend interval\n                let forward_interval = self.backward_ext(interval, a);\n\n                if (forward_interval.size == 0 || k == -1) \u0026\u0026\n                        // interval could not be extended further\n                        // if no interval has been extended this iteration,\n                        // interval is maximal and can be added to the matches\n                        curr.is_empty() \u0026\u0026 k \u003c j \u0026\u0026\n                        match_len \u003e= \u0026l\n                {\n                    j = k;\n                    matches.push((*interval, (k + 1) as usize, *match_len));\n                }\n                // add _interval to curr (will be further extended next iteration)\n                if forward_interval.size != 0 \u0026\u0026 forward_interval.size as isize != last_size {\n                    last_size = forward_interval.size as isize;\n                    curr.push((forward_interval, match_len + 1));\n                }\n            }\n            if curr.is_empty() {\n                break;\n            }\n            swap(curr, prev);\n        }\n\n        matches\n    }\n\n    /// Find all supermaximal exact matches (of length \u003e= l) of given pattern.\n    /// Complexity O(m^2) with pattern of length m.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::alphabets::dna;\n    /// use bio::data_structures::bwt::{bwt, less, Occ};\n    /// use bio::data_structures::fmindex::{FMDIndex, FMIndex};\n    /// use bio::data_structures::suffix_array::suffix_array;\n    ///\n    /// let text = b\"ATTCGGGG$CCCCGAAT$\";\n    /// let alphabet = dna::n_alphabet();\n    /// let sa = suffix_array(text);\n    /// let bwt = bwt(text, \u0026sa);\n    /// let less = less(\u0026bwt, \u0026alphabet);\n    /// let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n    /// let fm = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n    /// let fmdindex = FMDIndex::from(fm);\n    ///\n    /// let pattern = b\"ATTGGGG\";\n    /// let intervals = fmdindex.all_smems(pattern, 0);\n    /// assert_eq!(intervals.len(), 2);\n    ///\n    /// let solutions = vec![[0,14,0,3], [4,9,3,4]];\n    /// for (i, interval) in intervals.iter().enumerate() {\n    ///     let forward_positions = interval.0.forward().occ(\u0026sa);\n    ///     let revcomp_positions = interval.0.revcomp().occ(\u0026sa);\n    ///     let pattern_position = interval.1;\n    ///     let smem_len = interval.2;\n    ///     assert_eq!([forward_positions[0], revcomp_positions[0], pattern_position, smem_len], solutions[i]);\n    /// }\n    /// ```\n    pub fn all_smems(\u0026self, pattern: \u0026[u8], l: usize) -\u003e Vec\u003c(BiInterval, usize, usize)\u003e {\n        let mut smems = Vec::new();\n        let mut i0 = 0;\n        while i0 \u003c pattern.len() {\n            let mut curr_smems = self.smems(pattern, i0, l);\n            let mut next_i0 = i0 + 1; // this always works since:\n                                      // if we have a SMEM overlapping i0, it is at least 1bp long.\n                                      // If we don't have a smem, then we'll reiterate from i0+1\n            for (_, p, l) in curr_smems.iter() {\n                if p + l \u003e next_i0 {\n                    next_i0 = p + l;\n                }\n            }\n            i0 = next_i0;\n            smems.append(\u0026mut curr_smems);\n        }\n        smems\n    }\n\n    /// Initialize interval with given start character.\n    pub fn init_interval_with(\u0026self, a: u8) -\u003e BiInterval {\n        let comp_a = dna::complement(a);\n        let lower = self.fmindex.less(a);\n\n        BiInterval {\n            lower,\n            lower_rev: self.fmindex.less(comp_a),\n            size: self.fmindex.less(a + 1) - lower,\n            match_size: 1,\n        }\n    }\n\n    /// Initialize interval for empty pattern. The interval points at the whole suffix array.\n    pub fn init_interval(\u0026self) -\u003e BiInterval {\n        BiInterval {\n            lower: 0,\n            lower_rev: 0,\n            size: self.fmindex.bwt.borrow().len(),\n            match_size: 0,\n        }\n    }\n\n    /// Backward extension of given interval with given character.\n    pub fn backward_ext(\u0026self, interval: \u0026BiInterval, a: u8) -\u003e BiInterval {\n        let mut s = 0;\n        let mut o = 0;\n        let mut l = interval.lower_rev;\n        // Interval [l(c(aP)), u(c(aP))] is a subinterval of [l(c(P)), u(c(P))] for each a,\n        // starting with the lexicographically smallest ($),\n        // then c(T) = A, c(G) = C, c(C) = G, N, c(A) = T, ...\n        // Hence, we calculate lower revcomp bounds by iterating over\n        // symbols and updating from previous one.\n        for \u0026b in b\"$TGCNAtgcna\".iter() {\n            l += s;\n            o = if interval.lower == 0 {\n                0\n            } else {\n                self.fmindex.occ(interval.lower - 1, b)\n            };\n            // calculate size\n            s = self.fmindex.occ(interval.lower + interval.size - 1, b) - o;\n            if b == a {\n                break;\n            }\n        }\n        // calculate lower bound\n        let k = self.fmindex.less(a) + o;\n\n        BiInterval {\n            lower: k,\n            lower_rev: l,\n            size: s,\n            match_size: interval.match_size + 1,\n        }\n    }\n\n    pub fn forward_ext(\u0026self, interval: \u0026BiInterval, a: u8) -\u003e BiInterval {\n        let comp_a = dna::complement(a);\n\n        self.backward_ext(\u0026interval.swapped(), comp_a).swapped()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::alphabets::dna;\n    use crate::data_structures::bwt::{bwt, less, Occ};\n    use crate::data_structures::suffix_array::suffix_array;\n\n    #[test]\n    fn test_fmindex() {\n        let text = b\"GCCTTAACATTATTACGCCTA$\";\n        let alphabet = dna::n_alphabet();\n        let sa = suffix_array(text);\n        let bwt = bwt(text, \u0026sa);\n        let less = less(\u0026bwt, \u0026alphabet);\n        let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n        let fm = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n\n        let pattern = b\"TTA\";\n        let sai = fm.backward_search(pattern.iter());\n\n        let positions = sai.occ(\u0026sa);\n\n        assert_eq!(positions, [3, 12, 9]);\n    }\n\n    #[test]\n    fn test_fmindex_not_found() {\n        let text = b\"GCCTTAACATTATTACGCCTA$\";\n        let alphabet = dna::n_alphabet();\n        let sa = suffix_array(text);\n        let bwt = bwt(text, \u0026sa);\n        let less = less(\u0026bwt, \u0026alphabet);\n        let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n        let fm = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n\n        let pattern = b\"TTT\";\n        let sai = fm.backward_search(pattern.iter());\n\n        let positions = sai.occ(\u0026sa);\n\n        assert_eq!(positions, []);\n    }\n\n    #[test]\n    fn test_smems() {\n        let orig_text = b\"GCCTTAACAT\";\n        let revcomp_text = dna::revcomp(orig_text);\n        let text_builder: Vec\u003c\u0026[u8]\u003e = vec![orig_text, b\"$\", \u0026revcomp_text[..], b\"$\"];\n        let text = text_builder.concat();\n\n        let alphabet = dna::n_alphabet();\n        let sa = suffix_array(\u0026text);\n        let bwt = bwt(\u0026text, \u0026sa);\n        let less = less(\u0026bwt, \u0026alphabet);\n        let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n\n        let fmindex = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n        let fmdindex = FMDIndex::from(fmindex);\n        {\n            let pattern = b\"AA\";\n            let intervals = fmdindex.smems(pattern, 0, 0);\n            let forward = intervals[0].0.forward();\n            let revcomp = intervals[0].0.revcomp();\n            let pattern_position = intervals[0].1;\n            let smem_len = intervals[0].2;\n            assert_eq!(forward.occ(\u0026sa), [5, 16]);\n            assert_eq!(revcomp.occ(\u0026sa), [3, 14]);\n            assert_eq!(pattern_position, 0);\n            assert_eq!(smem_len, 2);\n        }\n        {\n            let pattern = b\"CTTAA\";\n            let intervals = fmdindex.smems(pattern, 1, 0);\n            assert_eq!(intervals[0].0.forward().occ(\u0026sa), [2]);\n            assert_eq!(intervals[0].0.revcomp().occ(\u0026sa), [14]);\n            assert_eq!(intervals[0].1, 0);\n            assert_eq!(intervals[0].2, 5);\n            assert_eq!(intervals[0].0.match_size, 5);\n        }\n        {\n            let pattern = b\"CTTAA\";\n            let intervals = fmdindex.smems(pattern, 1, 7);\n            assert!(intervals.is_empty());\n        }\n    }\n\n    #[test]\n    fn test_all_smems() {\n        let text = b\"ATTCGGGG$CCCCGAAT$\";\n        let alphabet = dna::n_alphabet();\n        let sa = suffix_array(text);\n        let bwt = bwt(text, \u0026sa);\n        let less = less(\u0026bwt, \u0026alphabet);\n        let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n        let fm = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n        let fmdindex = FMDIndex::from(fm);\n\n        {\n            let pattern = b\"ATTGGGG\";\n            let intervals = fmdindex.all_smems(pattern, 0);\n            assert_eq!(intervals.len(), 2);\n            let solutions = vec![[0, 14, 0, 3], [4, 9, 3, 4]];\n            for (i, interval) in intervals.iter().enumerate() {\n                let forward_positions = interval.0.forward().occ(\u0026sa);\n                let revcomp_positions = interval.0.revcomp().occ(\u0026sa);\n                let pattern_position = interval.1;\n                let smem_len = interval.2;\n                assert_eq!(\n                    [\n                        forward_positions[0],\n                        revcomp_positions[0],\n                        pattern_position,\n                        smem_len\n                    ],\n                    solutions[i]\n                );\n            }\n        }\n    }\n\n    #[test]\n    fn test_init_interval() {\n        let text = b\"ACGT$TGCA$\";\n\n        let alphabet = dna::n_alphabet();\n        let sa = suffix_array(text);\n        let bwt = bwt(text, \u0026sa);\n        let less = less(\u0026bwt, \u0026alphabet);\n        let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n\n        let fmindex = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n        let fmdindex = FMDIndex::from(fmindex);\n        let pattern = b\"T\";\n        let interval = fmdindex.init_interval_with(pattern[0]);\n\n        assert_eq!(interval.forward().occ(\u0026sa), [3, 5]);\n        assert_eq!(interval.revcomp().occ(\u0026sa), [8, 0]);\n\n        let empty = fmdindex.init_interval();\n        let extended = fmdindex.backward_ext(\u0026empty, pattern[0]);\n        assert_eq!(extended, interval);\n        let extended = fmdindex.forward_ext(\u0026empty, pattern[0]);\n        assert_eq!(extended, interval);\n    }\n\n    #[test]\n    fn test_issue39() {\n        let reads = b\"GGCGTGGTGGCTTATGCCTGTAATCCCAGCACTTTGGGAGGTCGAAGTGGGCGG$CCGC\\\n                       CCACTTCGACCTCCCAAAGTGCTGGGATTACAGGCATAAGCCACCACGCC$CGAAGTGG\\\n                       GCGGATCACTTGAGGTCAGGAGTTGGAGACTAGCCTGGCCAACACGATGAAACCCCGTC\\\n                       TCTAATA$TATTAGAGACGGGGTTTCATCGTGTTGGCCAGGCTAGTCTCCAACTCCTGA\\\n                       CCTCAAGTGATCCGCCCACTTCG$AGCTCGAAAAATGTTTGCTTATTTTGGTAAAATTA\\\n                       TTCATTGACTATGCTCAGAAATCAAGCAAACTGTCCATATTTCATTTTTTG$CAAAAAA\\\n                       TGAAATATGGACAGTTTGCTTGATTTCTGAGCATAGTCAATGAATAATTTTACCAAAAT\\\n                       AAGCAAACATTTTTCGAGCT$AGCTCGAAAAATGTTTGCTTATTTTGGTAAAATTATTC\\\n                       ATTGACTATGCTCAGAAATCAAGCAAACTGTCCATATTTCATTTTTTGAAATTACATAT\\\n                       $ATATGTAATTTCAAAAAATGAAATATGGACAGTTTGCTTGATTTCTGAGCATAGTCAA\\\n                       TGAATAATTTTACCAAAATAAGCAAACATTTTTCGAGCT$TAAAATTTCCTCTGACAGT\\\n                       GTAAAAGAGATCTTCATACAAAAATCAGAATTTATATAGTCTCTTTCCAAAAGACCATA\\\n                       AAACCAATCAGTTAATAGTTGAT$ATCAACTATTAACTGATTGGTTTTATGGTCTTTTG\\\n                       GAAAGAGACTATATAAATTCTGATTTTTGTATGAAGATCTCTTTTACACTGTCAGAGGA\\\n                       AATTTTA$CACCTATCTACCCTGAATCTAAGTGCTAACAGGAAAGGATGCCAGATTGCA\\\n                       TGCCTGCTGATAAAGCCACAGTTTGGACTGTCACTCAATCACCATCGTTC$GAACGATG\\\n                       GTGATTGAGTGACAGTCCAAACTGTGGCTTTATCAGCAGGCATGCAATCTGGCATCCTT\\\n                       TCCTGTTAGCACTTAGATTCAGGGTAGATAGGTG$CATCGTTCCTCCTGTGACTCAGTA\\\n                       TAACAAGATTGGGAGAATACTCTACAGTTCCTGATTCCCCCACAG$CTGTGGGGGAATC\\\n                       AGGAACTGTAGAGTATTCTCCCAATCTTGTTATACTGAGTCACAGGAGGAACGATG$TG\\\n                       TAAATTCTGAGAAAAATTTGCAGGTCTTTCTTCAGGAGCATGTAATCTCTTGCTCTCTT\\\n                       TGTTATCTATCTATAGTACTGTAGGTTATCTGGAGTTGCT$AGCAACTCCAGATAACCT\\\n                       ACAGTACTATAGATAGATAACAAAGAGAGCAAGAGATTACATGCTCCTGAAGAAAGACC\\\n                       TGCAAATTTTTCTCAGAATTTACA$CACTTCTCCTTGTCTTTACAGACTGGTTTTGCAC\\\n                       TGGGAAATCCTTTCACCAGTCAGCCCAGTTAGAGATTCTG$CAGAATCTCTAACTGGGC\\\n                       TGACTGGTGAAAGGATTTCCCAGTGCAAAACCAGTCTGTAAAGACAAGGAGAAGTG$AA\\\n                       TGGAGGTATATAAATTATCTGGCAAAGTGACATATCCTGACACATTCTCCAGGATAGAT\\\n                       CAAATGTTAGGTCACAAAGAGAGTCTTAACAAAATT$AATTTTGTTAAGACTCTCTTTG\\\n                       TGACCTAACATTTGATCTATCCTGGAGAATGTGTCAGGATATGTCACTTTGCCAGATAA\\\n                       TTTATATACCTCCATT$TTAATTTTGTTAAGACTCTCTTTGTGACCTAACATTTGATCT\\\n                       ATCCTGGAGAATGTGTCAGGATATGTCACTTTGCCAGATAATTTATATACCTCCATTTT\\\n                       $AAAATGGAGGTATATAAATTATCTGGCAAAGTGACATATCCTGACACATTCTCCAGGA\\\n                       TAGATCAAATGTTAGGTCACAAAGAGAGTCTTAACAAAATTAA$TTCTTCTTTGACTCA\\\n                       TTGGTTGTTCAATAGTATGTTGTTTAATTTCCATATATTTGTAAATGTTTCCGTTTTCC\\\n                       TTCTACTATTGAATTTTTGCTTCATC$GATGAAGCAAAAATTCAATAGTAGAAGGAAAA\\\n                       CGGAAACATTTACAAATATATGGAAATTAAACAACATACTATTGAACAACCAATGAGTC\\\n                       AAAGAAGAA$AGGAAAACGGAAACATTTACAAATATATGGAAATTAAACAACATACTAT\\\n                       TGAACAACCAATGAGTCAAAGAAGAAATCAAAAAGAATATTAGAAAAC$GTTTTCTAAT\\\n                       ATTCTTTTTGATTTCTTCTTTGACTCATTGGTTGTTCAATAGTATGTTGTTTAATTTCC\\\n                       ATATATTTGTAAATGTTTCCGTTTTCCT$TTAGAAAACAAGCTGACAAAAAAATAAAAA\\\n                       AACACAACATAGCAAAACTTAGAAATGCAGCAAAGGCAGTACTAAAGAGGGAAATTTAT\\\n                       AGCAATAAATGC$GCATTTATTGCTATAAATTTCCCTCTTTAGTACTGCCTTTGCTGCA\\\n                       TTTCTAAGTTTTGCTATGTTGTGTTTTTTTATTTTTTTGTCAGCTTGTTTTCTAA$TTT\\\n                       ATTGCTATAAATTTCCCTCTTTAGTACTGCCTTTGCTGCATTTCTAAGTTTTGCTATGT\\\n                       TGTGTTTTTTTATTTTTTTGTCAGCTTGTTTTCTA$TAGAAAACAAGCTGACAAAAAAA\\\n                       TAAAAAAACACAACATAGCAAAACTTAGAAATGCAGCAAAGGCAGTACTAAAGAGGGAA\\\n                       ATTTATAGCAATAAA$TCTTTCTTCTTTTTTAAGGTAGGCATTTATTGCTATAAATTTC\\\n                       CCTCTTTAGTACTGCCTTTG$CAAAGGCAGTACTAAAGAGGGAAATTTATAGCAATAAA\\\n                       TGCCTACCTTAAAAAAGAAGAAAGA$\";\n\n        let alphabet = dna::n_alphabet();\n        let sa = suffix_array(reads);\n        let bwt = bwt(reads, \u0026sa);\n        let less = less(\u0026bwt, \u0026alphabet);\n        let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n\n        let fmindex = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n        let fmdindex = FMDIndex::from(fmindex);\n\n        let read = b\"GGCGTGGTGGCTTATGCCTGTAATCCCAGCACTTTGGGAGGTCGAAGTGGGCGG\";\n        let read_pos = 0;\n\n        for i in 0..read.len() {\n            println!(\"i {}\", i);\n            let intervals = fmdindex.smems(read, i, 0);\n            println!(\"{:?}\", intervals);\n            let matches = intervals\n                .iter()\n                .flat_map(|interval| interval.0.forward().occ(\u0026sa))\n                .collect::\u003cVec\u003cusize\u003e\u003e();\n            assert_eq!(matches, vec![read_pos]);\n        }\n    }\n}\n","traces":[{"line":73,"address":[8121760],"length":1,"stats":{"Line":0},"fn_name":"occ\u003calloc::vec::Vec\u003cusize, alloc::alloc::Global\u003e\u003e"},{"line":74,"address":[8121784,8121811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[8121886,8121872,8121801],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003calloc::vec::Vec\u003cusize, alloc::alloc::Global\u003e\u003e"},{"line":118,"address":[8121968,8123044],"length":1,"stats":{"Line":0},"fn_name":"backward_search\u003cbio::data_structures::fmindex::FMIndex\u003c\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, \u0026alloc::vec::Vec\u003cusize, alloc::alloc::Global\u003e, \u0026bio::data_structures::bwt::Occ\u003e,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":122,"address":[8122263,8122139,8122026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[8122463,8122228,8122448,8122917,8122305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[8122500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[8122531,8122737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[8122884,8122780,8122711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[8122864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[8122971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[8122926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[8123011,8122938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[8123072],"length":1,"stats":{"Line":0},"fn_name":"occ\u003c\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e,\u0026alloc::vec::Vec\u003cusize, alloc::alloc::Global\u003e,\u0026bio::data_structures::bwt::Occ\u003e"},{"line":155,"address":[8123106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[8123216],"length":1,"stats":{"Line":0},"fn_name":"less\u003c\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e,\u0026alloc::vec::Vec\u003cusize, alloc::alloc::Global\u003e,\u0026bio::data_structures::bwt::Occ\u003e"},{"line":158,"address":[8123236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[8123296],"length":1,"stats":{"Line":0},"fn_name":"bwt\u003c\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e,\u0026alloc::vec::Vec\u003cusize, alloc::alloc::Global\u003e,\u0026bio::data_structures::bwt::Occ\u003e"},{"line":162,"address":[8123305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[8123328],"length":1,"stats":{"Line":0},"fn_name":"new\u003c\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e,\u0026alloc::vec::Vec\u003cusize, alloc::alloc::Global\u003e,\u0026bio::data_structures::bwt::Occ\u003e"},{"line":189,"address":[4275392],"length":1,"stats":{"Line":0},"fn_name":"forward"},{"line":191,"address":[4275405,4275461,4275491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[4275433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[4275504],"length":1,"stats":{"Line":0},"fn_name":"revcomp"},{"line":197,"address":[4275605,4275517,4275575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[4275546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[4275616],"length":1,"stats":{"Line":0},"fn_name":"swapped"},{"line":204,"address":[4275627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[4275631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[4275634],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[4275638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[8123376,8123662],"length":1,"stats":{"Line":0},"fn_name":"from\u003c\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e,\u0026alloc::vec::Vec\u003cusize, alloc::alloc::Global\u003e,\u0026bio::data_structures::bwt::Occ\u003e"},{"line":247,"address":[8123398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[8123430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[8123617,8123550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[8123477,8123533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[8126579,8123680],"length":1,"stats":{"Line":0},"fn_name":"smems\u003c\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e,\u0026alloc::vec::Vec\u003cusize, alloc::alloc::Global\u003e,\u0026bio::data_structures::bwt::Occ\u003e"},{"line":293,"address":[8123775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[8123812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[8123843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[8123906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[8123918,8123991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[8124086,8124142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[8124099,8124144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[8124902,8124558,8124531,8124185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[8124555,8124583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[8124713,8124590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[8124610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[8124715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[8124731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[8124859,8124907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[8124940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[8125051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[8125119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[8125142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[8125405,8126559,8125188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[8125442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[8125550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[8125557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[8125577,8125785,8126504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[8125837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[8126294,8125860,8125992,8126070,8125947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[8125981,8125930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[8126029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[8126104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[8126112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[8126296,8126502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[8126360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[8126376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[8125761,8126513],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[8126535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[8127390,8127405,8126624],"length":1,"stats":{"Line":0},"fn_name":"all_smems\u003c\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e,\u0026alloc::vec::Vec\u003cusize, alloc::alloc::Global\u003e,\u0026bio::data_structures::bwt::Occ\u003e"},{"line":395,"address":[8126711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[8126716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[8126744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[8126878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[8126969,8126901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[8127051,8126946,8127236,8127367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[8127297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[8127339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[8127202],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[8127226],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[8127408],"length":1,"stats":{"Line":0},"fn_name":"init_interval_with\u003c\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e,\u0026alloc::vec::Vec\u003cusize, alloc::alloc::Global\u003e,\u0026bio::data_structures::bwt::Occ\u003e"},{"line":415,"address":[8127442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[8127467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[8127494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[8127521,8127692,8127662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[8127696],"length":1,"stats":{"Line":0},"fn_name":"init_interval\u003c\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e,\u0026alloc::vec::Vec\u003cusize, alloc::alloc::Global\u003e,\u0026bio::data_structures::bwt::Occ\u003e"},{"line":431,"address":[8127728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[8127808],"length":1,"stats":{"Line":0},"fn_name":"backward_ext\u003c\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e,\u0026alloc::vec::Vec\u003cusize, alloc::alloc::Global\u003e,\u0026bio::data_structures::bwt::Occ\u003e"},{"line":438,"address":[8127879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[8127891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[8127903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[8128552,8128059,8127915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[8128153,8128096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[8128315,8128195,8128145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[8128183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[8128218],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[8128522,8128336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[8128516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[8128680,8128574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[8128658,8128768,8128798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[8128800],"length":1,"stats":{"Line":0},"fn_name":"forward_ext\u003c\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e,\u0026alloc::vec::Vec\u003cusize, alloc::alloc::Global\u003e,\u0026bio::data_structures::bwt::Occ\u003e"},{"line":471,"address":[8128846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[8128870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[4317253,4317248],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":486,"address":[5632439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[5632454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[5632464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[5632491,5632573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[5632638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[5632741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[5632881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[5632888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[5632993,5632903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[5633066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[5633239,5633081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[4317280,4317285],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":504,"address":[5633399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[5633414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[5633424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[5633533,5633451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[5633598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[5633701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[5633841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[5633848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[5633953,5633863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[5634026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[5634041,5634199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[4317312,4317317],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":522,"address":[5634359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[5634374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[5634404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[5634630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[5634757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[5634867,5634764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[5635106,5634911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[5635113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[5635234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[5635392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[5635399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[5635494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[5635535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[5635545,5635675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[5635691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[5635797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[5635854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[5635935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[5636198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[5636640,5636438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[5636723,5636530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[5636775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[5636822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[5636959,5636829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[5637239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[5637579,5637744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[5637927,5637801,5637700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[5637883,5637984,5638091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[5638143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[5638191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[5638206,5638286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[4317349,4317344],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":565,"address":[5638487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[5638502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[5638515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[5638542,5638639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[5638704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[5638825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[5638983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[5638990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[5639085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[5639126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[5639510,5639141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[5639323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[5639569,5640625,5639707,5639897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[5639971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[5640056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":582,"address":[5640182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[5640199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[5640449,5640559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[5640216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[5640267,5640371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[5640406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[4317376,4317381],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":599,"address":[5640775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":601,"address":[5640790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[5640803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[5640830,5640927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[5640992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[5641113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[5641271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[5641278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[5641373],"length":1,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[5641388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[5641426],"length":1,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[5641734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[5642045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[5642052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":617,"address":[5642098,5642235],"length":1,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[5642187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[5642404,5642290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[4317413,4317408],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":624,"address":[5642567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":674,"address":[5642582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":675,"address":[5642595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[5642622,5642719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":677,"address":[5642784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[5642905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[5643063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":681,"address":[5643070],"length":1,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[5643165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[5643180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[5643414,5644308,5643192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[5643454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[5643598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":689,"address":[5643815,5643654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[5643842,5643924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[4317440,4317482],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":694,"address":[5643975,5644153],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":231},{"path":["/","home","todd","rust-bio","src","data_structures","interpolation_table.rs"],"content":"// Copyright 2018 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Fast lookup table for arbitrary floating point functions.\n//! # Examples\n//! ## Easy:\n//! ```\n//! use bio::data_structures::interpolation_table::*;\n//!\n//! let table = InterpolationTable::new(0.0, 10.0, 5, |x| x.powf(2.0));\n//! assert_eq!(table.get(3.0), 9.0);\n//! assert_eq!(table.get(5.0), 25.0);\n//! ```\n//! ## More complicated:\n//! ```\n//! extern crate approx;\n//! fn main() {\n//!     use bio::data_structures::interpolation_table::*;\n//!     use approx::assert_relative_eq;\n//!\n//!     let table = InterpolationTable::new(0.0, 10.0, 5, |x| x.ln_1p());\n//!     for \u0026x in \u0026[0.02, 0.04, 0.45678686, 0.23875, 1.45345e-6] {\n//!         assert_relative_eq!(table.get(x), x.ln_1p(), epsilon = 0.00001);\n//!     }\n//! }\n\n#[inline]\npub fn interpolate(a: f64, b: f64, fraction: f64) -\u003e f64 {\n    a * (1.0 - fraction) + b * fraction\n}\n\n/// Fast lookup table for arbitrary floating point functions.\n/// This can be used to e.g., provide fast lookups of distribution values.\n/// Input values are sampled with a given precision and results are stored in a vector.\n/// During lookup, infimum and supremum of a given value are calculated and the result is\n/// interpolated.\npub struct InterpolationTable\u003cF: Fn(f64) -\u003e f64\u003e {\n    inner: Vec\u003cf64\u003e,\n    func: F,\n    offset: usize,\n    min_x: f64,\n    max_x: f64,\n    shift: f64,\n}\n\nimpl\u003cF: Fn(f64) -\u003e f64\u003e InterpolationTable\u003cF\u003e {\n    /// Create a new `InterpolationTable`.\n    ///\n    /// # Arguments\n    ///\n    /// * `min_x` - minimum sample value\n    /// * `max_x` - maximum sample value\n    /// * `frac_digits` - number of fraction digits to store in sample\n    /// * `func` - Function to emulate.\n    ///\n    /// If given value is outside of min_x and max_x, the lookup falls back to applying the\n    /// function itself.\n    /// The table size grows with the number of fraction digits.\n    /// Space Complexity: O(m * 10^n), where `m = max_x - min_x` and `n = frac_digits`\n    pub fn new(min_x: f64, max_x: f64, frac_digits: i32, func: F) -\u003e Self {\n        let shift = 10.0_f64.powi(frac_digits);\n        let offset = (min_x * shift) as usize;\n        let mut table = InterpolationTable {\n            inner: Vec::new(),\n            func,\n            min_x,\n            max_x,\n            shift,\n            offset,\n        };\n\n        let mut i = table.index(min_x);\n        while i \u003c table.index(max_x) {\n            let x = i as f64 / shift;\n            table.inner.push((table.func)(x));\n            i += 1;\n        }\n\n        table\n    }\n\n    /// Return lower bound index for given f64.\n    #[inline]\n    fn index(\u0026self, x: f64) -\u003e usize {\n        (x * self.shift) as usize - self.offset\n    }\n\n    /// Lookup given value in table, and interpolate the result between the sampled values if\n    /// necessary. This provides an approximation that is better the more fraction digits are\n    /// used to generate this table.\n    /// Time Complexity for lookup: O(1) if `min_x \u003c= x \u003c max_x` and O(func(x)) otherwise.\n    pub fn get(\u0026self, x: f64) -\u003e f64 {\n        if x \u003c self.min_x || x \u003e= self.max_x {\n            (self.func)(x)\n        } else {\n            let i = self.index(x);\n            // interpolate\n            let fraction = (x * self.shift - i as f64) / self.shift;\n            interpolate(self.inner[i], self.inner[i + 1], fraction)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_interpolation_table() {\n        let table = InterpolationTable::new(0.0, 10.0, 5, |x| x.ln_1p());\n\n        for \u0026x in \u0026[0.02, 0.04, 0.45678686, 0.23875, 1.45345e-6] {\n            assert_relative_eq!(table.get(x), x.ln_1p(), epsilon = 0.00001);\n        }\n    }\n}\n","traces":[{"line":30,"address":[7729056],"length":1,"stats":{"Line":0},"fn_name":"interpolate"},{"line":31,"address":[4923365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[5727651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[5727707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[5727810,5727768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[5727872],"length":1,"stats":{"Line":0},"fn_name":"index\u003cclosure-0\u003e"},{"line":87,"address":[5728028,5727887,5727998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[5728032],"length":1,"stats":{"Line":0},"fn_name":"get\u003cclosure-0\u003e"},{"line":95,"address":[5728064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[5728153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[5728125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[5728206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[5728278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[5135120,5136532],"length":1,"stats":{"Line":0},"fn_name":"test_interpolation_table"},{"line":112,"address":[5135134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[5135163,5135704,5135362,5135273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[5135416,5135709],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","home","todd","rust-bio","src","data_structures","interval_tree","array_backed_interval_tree.rs"],"content":"//! Interval tree, a data structure for efficiently storing and searching intervals.\n//!\n//! This implementation is based on the sorted array version as described/given in\n//! https://github.com/lh3/cgranges / https://github.com/lh3/cgranges/blob/master/cpp/IITree.h\n//!\n//! It uses the same conventions as `crate::data_structures::interval_tree::IntervalTree`.\n//! Note that if you do not use the `ArrayBackedIntervalTree::from_iter` constructor, you have to call `index(\u0026mut self)`\n//! first before `find()`-ing overlaps.\n//!\n//! # Example\n//! ```\n//! use bio::data_structures::interval_tree::ArrayBackedIntervalTree;\n//! use bio::utils::Interval;\n//! use std::iter::FromIterator;\n//!\n//! let mut tree = ArrayBackedIntervalTree::new();\n//! tree.insert(12..34, 0);\n//! tree.insert(0..23, 1);\n//! tree.insert(34..56, 2);\n//! // since we did at least one manual insert, we have to index the tree\n//! tree.index();\n//! let i1 = \u0026tree.find(22..25)[0];\n//! assert_eq!(i1.interval().start, 0);\n//! assert_eq!(i1.interval().end, 23);\n//! assert_eq!(i1.data(), \u00261u32);\n//!\n//! let tree =\n//!     ArrayBackedIntervalTree::from_iter(vec![(12..34, 0), (0..23, 1), (34..56, 2)].into_iter());\n//! // no call to `index` needed here, since that happens in `from_iter` already\n//! let i2 = \u0026tree.find(22..25)[1];\n//! assert_eq!(i2.interval().start, 12);\n//! assert_eq!(i2.interval().end, 34);\n//! assert_eq!(i2.data(), \u00260u32);\n//! ```\n\nuse crate::utils::Interval;\nuse std::cmp::min;\nuse std::iter::FromIterator;\n\n/// A `find` query on the interval tree does not directly return references to the intervals in the\n/// tree but wraps the fields `interval` and `data` in an `Entry`.\n#[derive(PartialEq, Eq, Debug, Clone)]\nstruct InternalEntry\u003cN: Ord + Clone + Copy, D\u003e {\n    data: D,\n    interval: Interval\u003cN\u003e,\n    max: N,\n}\n\n/// A `find` query on the interval tree does not directly return references to the nodes in the tree, but\n/// wraps the fields `interval` and `data` in an `Entry`.\n#[derive(PartialEq, Eq, Debug, Clone)]\npub struct Entry\u003c'a, N: Ord + Clone, D\u003e {\n    data: \u0026'a D,\n    interval: \u0026'a Interval\u003cN\u003e,\n}\n\nimpl\u003c'a, N: Ord + Clone + 'a, D: 'a\u003e Entry\u003c'a, N, D\u003e {\n    /// Get a reference to the data for this entry\n    pub fn data(\u0026self) -\u003e \u0026'a D {\n        self.data\n    }\n\n    /// Get a reference to the interval for this entry\n    pub fn interval(\u0026self) -\u003e \u0026'a Interval\u003cN\u003e {\n        self.interval\n    }\n}\n\nimpl\u003cN: Ord + Clone + Copy, D\u003e Default for ArrayBackedIntervalTree\u003cN, D\u003e {\n    fn default() -\u003e Self {\n        ArrayBackedIntervalTree {\n            entries: vec![],\n            max_level: 0,\n            indexed: false,\n        }\n    }\n}\n\npub struct ArrayBackedIntervalTree\u003cN: Ord + Clone + Copy, D\u003e {\n    entries: Vec\u003cInternalEntry\u003cN, D\u003e\u003e,\n    max_level: usize,\n    indexed: bool,\n}\n\nimpl\u003cN, D, V\u003e FromIterator\u003c(V, D)\u003e for ArrayBackedIntervalTree\u003cN, D\u003e\nwhere\n    V: Into\u003cInterval\u003cN\u003e\u003e,\n    N: Ord + Clone + Copy,\n    D: Clone,\n{\n    fn from_iter\u003cT: IntoIterator\u003cItem = (V, D)\u003e\u003e(iter: T) -\u003e Self {\n        let mut tree = Self::new();\n        iter.into_iter()\n            .for_each(|(interval, data)| tree.insert(interval, data));\n        tree.index();\n        tree\n    }\n}\n\nimpl\u003cN: Ord + Clone + Copy, D: Clone\u003e ArrayBackedIntervalTree\u003cN, D\u003e {\n    pub fn new() -\u003e Self {\n        Default::default()\n    }\n\n    pub fn insert\u003cI: Into\u003cInterval\u003cN\u003e\u003e\u003e(\u0026mut self, interval: I, data: D) {\n        let interval = interval.into();\n        let max = interval.end;\n        self.entries.push(InternalEntry {\n            interval,\n            data,\n            max,\n        });\n        self.indexed = false;\n    }\n\n    pub fn index(\u0026mut self) {\n        if !self.indexed {\n            self.entries.sort_by_key(|e| e.interval.start);\n            self.index_core();\n            self.indexed = true;\n        }\n    }\n\n    fn index_core(\u0026mut self) {\n        let a = \u0026mut self.entries;\n        if a.is_empty() {\n            return;\n        }\n\n        let n = a.len();\n        let mut last_i = 0;\n        let mut last_value = a[0].max;\n        (0..n).step_by(2).for_each(|i| {\n            last_i = i;\n            a[i].max = a[i].interval.end;\n            last_value = a[i].max;\n        });\n        let mut k = 1;\n        while (1 \u003c\u003c k) \u003c n {\n            // process internal nodes in the bottom-up order\n            let x = 1 \u003c\u003c (k - 1);\n            let i0 = (x \u003c\u003c 1) - 1; // i0 is the first node\n            let step = x \u003c\u003c 2;\n            for i in (i0..n).step_by(step) {\n                // traverse all nodes at level k\n                let end_left = a[i - x].max; // max value of the left child\n                let end_right = if i + x \u003c n { a[i + x].max } else { last_value }; // max value of the right child\n                let end = max3(a[i].interval.end, end_left, end_right);\n                a[i].max = end;\n            }\n            last_i = if (last_i \u003e\u003e k \u0026 1) \u003e 0 {\n                last_i - x\n            } else {\n                last_i + x\n            };\n            if last_i \u003c n \u0026\u0026 a[last_i].max \u003e last_value {\n                last_value = a[last_i].max\n            }\n            k += 1;\n        }\n        self.max_level = k - 1;\n    }\n\n    /// Find overlapping intervals in the index.\n    /// Returns a vector of entries, consisting of the interval and its associated data.\n    ///\n    /// # Arguments\n    ///\n    /// * `interval` - The interval for which overlaps are to be found in the index. Can also be a `Range`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if this `IITree` instance has not been indexed yet.\n    pub fn find\u003cI: Into\u003cInterval\u003cN\u003e\u003e\u003e(\u0026self, interval: I) -\u003e Vec\u003cEntry\u003cN, D\u003e\u003e {\n        let mut buf = Vec::with_capacity(512);\n        self.find_into(interval, \u0026mut buf);\n        buf\n    }\n\n    /// Find overlapping intervals in the index\n    ///\n    /// # Arguments\n    ///\n    /// * `interval` - The interval for which overlaps are to be found in the index. Can also be a `Range`.\n    /// * `results` - A reusable buffer vector for storing the results.\n    ///\n    /// # Panics\n    ///\n    /// Panics if this `IITree` instance has not been indexed yet.\n    pub fn find_into\u003c'b, 'a: 'b, I: Into\u003cInterval\u003cN\u003e\u003e\u003e(\n        \u0026'a self,\n        interval: I,\n        results: \u0026'b mut Vec\u003cEntry\u003c'a, N, D\u003e\u003e,\n    ) {\n        if !self.indexed {\n            panic!(\"This IITree has not been indexed yet. Call `index()` first.\")\n        }\n\n        let interval = interval.into();\n        let (start, end) = (interval.start, interval.end);\n        let n = self.entries.len() as usize;\n        let a = \u0026self.entries;\n        results.clear();\n        let mut stack = [StackCell::empty(); 64];\n        // push the root; this is a top down traversal\n        stack[0].k = self.max_level;\n        stack[0].x = (1 \u003c\u003c self.max_level) - 1;\n        stack[0].w = false;\n        let mut t = 1;\n        while t \u003e 0 {\n            t -= 1;\n            let StackCell { k, x, w } = stack[t];\n            if k \u003c= 3 {\n                // we are in a small subtree; traverse every node in this subtree\n                let i0 = x \u003e\u003e k \u003c\u003c k;\n                let i1 = min(i0 + (1 \u003c\u003c (k + 1)) - 1, n);\n                for (i, node) in a.iter().enumerate().take(i1).skip(i0) {\n                    if node.interval.start \u003e= end {\n                        break;\n                    }\n                    if start \u003c node.interval.end {\n                        // if overlap, append to `results`\n                        results.push(Entry {\n                            interval: \u0026self.entries[i].interval,\n                            data: \u0026self.entries[i].data,\n                        });\n                    }\n                }\n            } else if !w {\n                // if left child not processed\n                let y = x - (1 \u003c\u003c (k - 1)); // the left child of x; NB: y may be out of range (i.e. y\u003e=n)\n                stack[t].k = k;\n                stack[t].x = x;\n                stack[t].w = true; // re-add node x, but mark the left child having been processed\n                t += 1;\n                if y \u003e= n || a[y].max \u003e start {\n                    // push the left child if y is out of range or may overlap with the query\n                    stack[t].k = k - 1;\n                    stack[t].x = y;\n                    stack[t].w = false;\n                    t += 1;\n                }\n            } else if x \u003c n \u0026\u0026 a[x].interval.start \u003c end {\n                // need to push the right child\n                if start \u003c a[x].interval.end {\n                    results.push(Entry {\n                        interval: \u0026self.entries[x].interval,\n                        data: \u0026self.entries[x].data,\n                    });\n                }\n                stack[t].k = k - 1;\n                stack[t].x = x + (1 \u003c\u003c (k - 1));\n                stack[t].w = false;\n                t += 1;\n            }\n        }\n    }\n}\n\nfn max3\u003cT: Ord\u003e(a: T, b: T, c: T) -\u003e T {\n    a.max(b.max(c))\n}\n\n#[derive(Clone, Copy)]\nstruct StackCell {\n    // node\n    x: usize,\n    // level\n    k: usize,\n    // false if left child hasn't been processed\n    w: bool,\n}\n\nimpl StackCell {\n    fn empty() -\u003e Self {\n        Self {\n            x: 0,\n            k: 0,\n            w: false,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::data_structures::interval_tree::ArrayBackedIntervalTree;\n\n    #[test]\n    fn test_example() {\n        let mut tree = ArrayBackedIntervalTree::new();\n        tree.insert(12..34, 0);\n        tree.insert(0..23, 1);\n        tree.insert(34..56, 2);\n        tree.index();\n        let overlap = tree.find(22..25);\n\n        let e1 = Entry {\n            interval: \u0026(0..23).into(),\n            data: \u00261,\n        };\n        let e2 = Entry {\n            interval: \u0026(12..34).into(),\n            data: \u00260,\n        };\n        let expected = vec![e1, e2];\n        assert_eq!(overlap, expected);\n    }\n}\n","traces":[{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[5731872],"length":1,"stats":{"Line":0},"fn_name":"default\u003ci32,i32\u003e"},{"line":72,"address":[5731885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[5731952],"length":1,"stats":{"Line":0},"fn_name":"new\u003ci32,i32\u003e"},{"line":102,"address":[5731960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[5731984,5732206],"length":1,"stats":{"Line":0},"fn_name":"insert\u003ci32,i32,core::ops::range::Range\u003ci32\u003e\u003e"},{"line":106,"address":[5732035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[5732138,5732085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[5732158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[5732145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[5732153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[5732197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[5732224],"length":1,"stats":{"Line":0},"fn_name":"index\u003ci32,i32\u003e"},{"line":117,"address":[5732238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[5732347,5732320,5732254],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003ci32,i32\u003e"},{"line":119,"address":[5732287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[5732297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[5732384],"length":1,"stats":{"Line":0},"fn_name":"index_core\u003ci32,i32\u003e"},{"line":125,"address":[5732407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[5732415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[5732448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[5732489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[5732501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[5732559,5734400],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003ci32,i32\u003e"},{"line":134,"address":[5734424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[5734430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[5734541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[5732683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[5734300,5732695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[5732830,5732965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[5733003,5732951,5733060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[5733046,5733114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[5733372,5733877,5733122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[5733412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[5733546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[5733753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[5733840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[5733890,5734091,5733306,5734050,5734010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[5734012,5733974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[5734083,5733940,5734093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[5734066,5734123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[5734217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[5734305,5734265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[5734351,5732794,5734360,5734390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[5734759,5734592],"length":1,"stats":{"Line":0},"fn_name":"find\u003ci32,i32,core::ops::range::Range\u003ci32\u003e\u003e"},{"line":175,"address":[5734645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[5734684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[5734784,5739283],"length":1,"stats":{"Line":0},"fn_name":"find_into\u003ci32,i32,core::ops::range::Range\u003ci32\u003e\u003e"},{"line":195,"address":[5734851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[5734923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[5734890,5735010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[5735032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[5735161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[5735211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[5735230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[5735245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[5735385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[5735539,5735397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[5735517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[5735525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[5735537,5735572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[5735666,5735591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[5735827,5735634,5735707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[5735811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[5736053,5735891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[5736032,5736094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[5736708,5737111,5736393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[5736788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[5737109,5736863,5736898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[5737070],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[5736960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[5737021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[5735860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[5737154,5737368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[5737473,5737339,5737417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[5737570,5737515,5737436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[5737660,5737533,5737604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[5737623,5737725,5737710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[5738268,5737718,5737774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[5737886,5738039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[5738081,5738002,5738136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[5738170,5738226,5738099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[5738273,5738260,5738189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[5737132,5738306,5739245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[5738698,5738460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[5738659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[5738567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[5738619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[5738843,5738708],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[5738874,5739125,5738820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[5739094,5739206,5739156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[5739237,5739175,5739250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[5739312,5739442],"length":1,"stats":{"Line":0},"fn_name":"max3\u003ci32\u003e"},{"line":261,"address":[5739354,5739454,5739456],"length":1,"stats":{"Line":0},"fn_name":"eq\u003ci32,i32\u003e"},{"line":275,"address":[7729120],"length":1,"stats":{"Line":0},"fn_name":"empty"},{"line":290,"address":[5753408,5754214],"length":1,"stats":{"Line":0},"fn_name":"test_example"},{"line":291,"address":[5753415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[5753425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[5753463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[5753541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[5753587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[5753594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[5753647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[5753755,5753855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[5753910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[5754144,5753990],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":119},{"path":["/","home","todd","rust-bio","src","data_structures","interval_tree","avl_interval_tree.rs"],"content":"//! Interval tree, a data structure for efficiently storing and searching intervals.\n//!\n//! This data structure uses an `Interval` type to define the intervals. It is implemented by\n//! wrapping the `std::ops::Range` in a newtype. An interval must have a positive with and the interval bounds\n//! may be specified by any type satisfies both the `std::cmp::Ord` and `Clone` trait. Because\n//! `Interval` implements `From\u003cRange\u003e` you can also uses normal `Range` arguments in the\n//! `insert` and `find` functions. This implicit conversion will panic if a negative-width range is\n//! supplied.\n//!\n//! Upon inserting an interval may be associated with a data value. The intervals are stored in\n//! an augmented AVL-tree which allows for efficient inserting and querying.\n//!\n//! # Example\n//! ```\n//! use bio::data_structures::interval_tree::IntervalTree;\n//! use bio::utils::Interval;\n//!\n//! let mut tree = IntervalTree::new();\n//! tree.insert(11..20, \"Range_1\");\n//! tree.insert(25..30, \"Range_2\");\n//! for r in tree.find(15..25) {\n//!     assert_eq!(r.interval().start, 11);\n//!     assert_eq!(r.interval().end, 20);\n//!     assert_eq!(r.interval(), \u0026(Interval::from(11..20)));\n//!     assert_eq!(r.data(), \u0026\"Range_1\");\n//! }\n//! ```\n\nuse crate::utils::Interval;\nuse std::cmp;\nuse std::iter::FromIterator;\nuse std::mem;\n/// An interval tree for storing intervals with data\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct IntervalTree\u003cN: Ord + Clone, D\u003e {\n    root: Option\u003cNode\u003cN, D\u003e\u003e,\n}\n\nimpl\u003cN: Ord + Clone, D\u003e Default for IntervalTree\u003cN, D\u003e {\n    fn default() -\u003e Self {\n        Self { root: None }\n    }\n}\n\n/// A `find` query on the interval tree does not directly return references to the nodes in the tree, but\n/// wraps the fields `interval` and `data` in an `Entry`.\n#[derive(PartialEq, Eq, Debug, Clone)]\npub struct Entry\u003c'a, N: Ord + Clone, D\u003e {\n    data: \u0026'a D,\n    interval: \u0026'a Interval\u003cN\u003e,\n}\n\nimpl\u003c'a, N: Ord + Clone + 'a, D: 'a\u003e Entry\u003c'a, N, D\u003e {\n    /// Get a reference to the data for this entry\n    pub fn data(\u0026self) -\u003e \u0026'a D {\n        self.data\n    }\n\n    /// Get a reference to the interval for this entry\n    pub fn interval(\u0026self) -\u003e \u0026'a Interval\u003cN\u003e {\n        self.interval\n    }\n}\n\n/// An `IntervalTreeIterator` is returned by `Intervaltree::find` and iterates over the entries\n/// overlapping the query\npub struct IntervalTreeIterator\u003c'a, N: Ord + Clone, D\u003e {\n    nodes: Vec\u003c\u0026'a Node\u003cN, D\u003e\u003e,\n    interval: Interval\u003cN\u003e,\n}\n\nimpl\u003c'a, N: Ord + Clone + 'a, D: 'a\u003e Iterator for IntervalTreeIterator\u003c'a, N, D\u003e {\n    type Item = Entry\u003c'a, N, D\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cEntry\u003c'a, N, D\u003e\u003e {\n        loop {\n            let candidate = match self.nodes.pop() {\n                None =\u003e return None,\n                Some(node) =\u003e node,\n            };\n\n            // stop traversal if the query interval is beyond the current node and all children\n            if self.interval.start \u003c candidate.max {\n                if let Some(ref left) = candidate.left {\n                    self.nodes.push(left);\n                }\n\n                // don't traverse right if the query interval is completely before the current\n                // interval\n                if self.interval.end \u003e candidate.interval.start {\n                    if let Some(ref right) = candidate.right {\n                        self.nodes.push(right);\n                    }\n\n                    // overlap is only possible if both tests pass\n                    if intersect(\u0026self.interval, \u0026candidate.interval) {\n                        return Some(Entry {\n                            data: \u0026candidate.value,\n                            interval: \u0026candidate.interval,\n                        });\n                    }\n                }\n            }\n        }\n    }\n}\n\n/// A `find_mut` query on the interval tree does not directly return references to the nodes in the tree, but\n/// wraps the fields `interval` and `data` in an `EntryMut`. Only the data part can be mutably accessed\n/// using the `data` method\n#[derive(PartialEq, Eq, Debug)]\npub struct EntryMut\u003c'a, N: Ord + Clone, D\u003e {\n    data: \u0026'a mut D,\n    interval: \u0026'a Interval\u003cN\u003e,\n}\n\nimpl\u003c'a, N: Ord + Clone + 'a, D: 'a\u003e EntryMut\u003c'a, N, D\u003e {\n    /// Get a mutable reference to the data for this entry\n    pub fn data(\u0026'a mut self) -\u003e \u0026'a mut D {\n        \u0026mut self.data\n    }\n\n    /// Get a reference to the interval for this entry\n    pub fn interval(\u0026self) -\u003e \u0026'a Interval\u003cN\u003e {\n        self.interval\n    }\n}\n\n/// An `IntervalTreeIteratorMut` is returned by `Intervaltree::find_mut` and iterates over the entries\n/// overlapping the query allowing mutable access to the data `D`, not the `Interval`.\npub struct IntervalTreeIteratorMut\u003c'a, N: Ord + Clone, D\u003e {\n    nodes: Vec\u003c\u0026'a mut Node\u003cN, D\u003e\u003e,\n    interval: Interval\u003cN\u003e,\n}\n\nimpl\u003c'a, N: Ord + Clone + 'a, D: 'a\u003e Iterator for IntervalTreeIteratorMut\u003c'a, N, D\u003e {\n    type Item = EntryMut\u003c'a, N, D\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cEntryMut\u003c'a, N, D\u003e\u003e {\n        loop {\n            let candidate = match self.nodes.pop() {\n                None =\u003e return None,\n                Some(node) =\u003e node,\n            };\n\n            // stop traversal if the query interval is beyond the current node and all children\n            if self.interval.start \u003c candidate.max {\n                if let Some(ref mut left) = candidate.left {\n                    self.nodes.push(left);\n                }\n\n                // don't traverse right if the query interval is completely before the current interval\n                if self.interval.end \u003e candidate.interval.start {\n                    if let Some(ref mut right) = candidate.right {\n                        self.nodes.push(right);\n                    }\n\n                    // overlap is only possible if both tests pass\n                    if intersect(\u0026self.interval, \u0026candidate.interval) {\n                        return Some(EntryMut {\n                            data: \u0026mut candidate.value,\n                            interval: \u0026candidate.interval,\n                        });\n                    }\n                }\n            }\n        }\n    }\n}\n\nimpl\u003cN: Clone + Ord, D\u003e IntervalTree\u003cN, D\u003e {\n    /// Creates a new empty `IntervalTree`\n    pub fn new() -\u003e Self {\n        Default::default()\n    }\n\n    /// Inserts an `Interval` into the tree and associates it with `data`\n    pub fn insert\u003cI: Into\u003cInterval\u003cN\u003e\u003e\u003e(\u0026mut self, interval: I, data: D) {\n        let interval = interval.into();\n        match self.root {\n            Some(ref mut n) =\u003e n.insert(interval, data),\n            None =\u003e self.root = Some(Node::new(interval, data)),\n        };\n    }\n\n    /// Uses the provided `Interval` to find overlapping intervals in the tree and returns an\n    /// `IntervalTreeIterator`\n    pub fn find\u003cI: Into\u003cInterval\u003cN\u003e\u003e\u003e(\u0026self, interval: I) -\u003e IntervalTreeIterator\u003c'_, N, D\u003e {\n        let interval = interval.into();\n        match self.root {\n            Some(ref n) =\u003e IntervalTreeIterator {\n                nodes: vec![n],\n                interval,\n            },\n            None =\u003e {\n                let nodes = vec![];\n                IntervalTreeIterator { nodes, interval }\n            }\n        }\n    }\n\n    /// Uses the provided `Interval` to find overlapping intervals in the tree and returns an\n    /// `IntervalTreeIteratorMut` that allows mutable access to the `data`\n    pub fn find_mut\u003cI: Into\u003cInterval\u003cN\u003e\u003e\u003e(\n        \u0026mut self,\n        interval: I,\n    ) -\u003e IntervalTreeIteratorMut\u003c'_, N, D\u003e {\n        let interval = interval.into();\n        match self.root {\n            Some(ref mut n) =\u003e IntervalTreeIteratorMut {\n                nodes: vec![n],\n                interval,\n            },\n            None =\u003e {\n                let nodes = vec![];\n                IntervalTreeIteratorMut { nodes, interval }\n            }\n        }\n    }\n}\n\nimpl\u003cN: Clone + Ord, D, R: Into\u003cInterval\u003cN\u003e\u003e\u003e FromIterator\u003c(R, D)\u003e for IntervalTree\u003cN, D\u003e {\n    fn from_iter\u003cI: IntoIterator\u003cItem = (R, D)\u003e\u003e(iter: I) -\u003e Self {\n        let mut tree = IntervalTree::new();\n        for r in iter {\n            tree.insert(r.0, r.1);\n        }\n        tree\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct Node\u003cN: Ord + Clone, D\u003e {\n    // actual interval data\n    interval: Interval\u003cN\u003e,\n    value: D,\n    // tree metadata\n    max: N,\n    height: i64,\n    left: Option\u003cBox\u003cNode\u003cN, D\u003e\u003e\u003e,\n    right: Option\u003cBox\u003cNode\u003cN, D\u003e\u003e\u003e,\n}\n\nimpl\u003cN: Ord + Clone, D\u003e Node\u003cN, D\u003e {\n    fn new(interval: Interval\u003cN\u003e, data: D) -\u003e Self {\n        let max = interval.end.clone();\n        Node {\n            interval,\n            max,\n            height: 1,\n            value: data,\n            left: None,\n            right: None,\n        }\n    }\n\n    fn insert(\u0026mut self, interval: Interval\u003cN\u003e, data: D) {\n        if interval.start \u003c= self.interval.start {\n            if let Some(ref mut son) = self.left {\n                son.insert(interval, data);\n            } else {\n                self.left = Some(Box::new(Node::new(interval, data)));\n            }\n        } else if let Some(ref mut son) = self.right {\n            son.insert(interval, data);\n        } else {\n            self.right = Some(Box::new(Node::new(interval, data)));\n        }\n        self.repair();\n    }\n\n    fn update_height(\u0026mut self) {\n        let left_h = self.left.as_ref().map_or(0, |n| n.height);\n        let right_h = self.right.as_ref().map_or(0, |n| n.height);\n        self.height = 1 + cmp::max(left_h, right_h);\n    }\n\n    fn update_max(\u0026mut self) {\n        self.max = self.interval.end.clone();\n        if let Some(ref n) = self.left {\n            if self.max \u003c n.max {\n                self.max = n.max.clone();\n            }\n        }\n        if let Some(ref n) = self.right {\n            if self.max \u003c n.max {\n                self.max = n.max.clone();\n            }\n        }\n    }\n\n    fn repair(\u0026mut self) {\n        let left_h = self.left.as_ref().map_or(0, |n| n.height);\n        let right_h = self.right.as_ref().map_or(0, |n| n.height);\n        // each case - update both height and max\n        if (left_h - right_h).abs() \u003c= 1 {\n            self.update_height();\n            self.update_max();\n        } else if right_h \u003e left_h {\n            {\n                let right = self\n                    .right\n                    .as_mut()\n                    .expect(\"Invalid tree: leaf is taller than its sibling.\");\n                let right_left_h = right.left.as_ref().map_or(0, |n| n.height);\n                let right_right_h = right.right.as_ref().map_or(0, |n| n.height);\n                if right_left_h \u003e right_right_h {\n                    right.rotate_right();\n                }\n            }\n            self.rotate_left();\n        } else {\n            {\n                let left = self\n                    .left\n                    .as_mut()\n                    .expect(\"Invalid tree: leaf is taller than its sibling.\");\n                let left_right_h = left.right.as_ref().map_or(0, |n| n.height);\n                let left_left_h = left.left.as_ref().map_or(0, |n| n.height);\n                if left_right_h \u003e left_left_h {\n                    left.rotate_left();\n                }\n            }\n            self.rotate_right();\n        }\n    }\n\n    fn rotate_left(\u0026mut self) {\n        let mut new_root = self.right.take().unwrap();\n        let t1 = self.left.take();\n        let t2 = new_root.left.take();\n        let t3 = new_root.right.take();\n        swap_interval_data(self, \u0026mut *new_root);\n\n        new_root.left = t1;\n        new_root.right = t2;\n        new_root.update_height();\n        new_root.update_max();\n\n        self.right = t3;\n        self.left = Some(new_root);\n        self.update_height();\n        self.update_max();\n    }\n\n    fn rotate_right(\u0026mut self) {\n        let mut new_root = self.left.take().unwrap();\n        let t1 = new_root.left.take();\n        let t2 = new_root.right.take();\n        let t3 = self.right.take();\n        swap_interval_data(self, \u0026mut *new_root);\n\n        new_root.left = t2;\n        new_root.right = t3;\n        new_root.update_height();\n        new_root.update_max();\n\n        self.left = t1;\n        self.right = Some(new_root);\n        self.update_height();\n        self.update_max();\n    }\n}\n\nfn swap_interval_data\u003cN: Ord + Clone, D\u003e(node_1: \u0026mut Node\u003cN, D\u003e, node_2: \u0026mut Node\u003cN, D\u003e) {\n    mem::swap(\u0026mut node_1.value, \u0026mut node_2.value);\n    mem::swap(\u0026mut node_1.interval, \u0026mut node_2.interval);\n}\n\nfn intersect\u003cN: Ord + Clone\u003e(range_1: \u0026Interval\u003cN\u003e, range_2: \u0026Interval\u003cN\u003e) -\u003e bool {\n    range_1.start \u003c range_1.end\n        \u0026\u0026 range_2.start \u003c range_2.end\n        \u0026\u0026 range_1.end \u003e range_2.start\n        \u0026\u0026 range_1.start \u003c range_2.end\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{Entry, IntervalTree, Node};\n    use crate::utils::Interval;\n    use std::cmp;\n    use std::cmp::{max, min};\n    use std::ops::Range;\n\n    fn validate(node: \u0026Node\u003ci64, String\u003e) {\n        validate_height(node);\n        validate_intervals(node);\n        validate_string_metadata(node);\n        if let Some(n) = node.left.as_ref() {\n            validate(n)\n        }\n        if let Some(n) = node.right.as_ref() {\n            validate(n)\n        }\n    }\n\n    fn validate_height(node: \u0026Node\u003ci64, String\u003e) {\n        let left_height = node.left.as_ref().map_or(0, |n| n.height);\n        let right_height = node.right.as_ref().map_or(0, |n| n.height);\n        assert!((left_height - right_height).abs() \u003c= 1);\n        assert_eq!(node.height, cmp::max(left_height, right_height) + 1)\n    }\n\n    fn validate_intervals(node: \u0026Node\u003ci64, String\u003e) {\n        let mut reached_maximum: bool = false;\n        if node.interval.end == node.max {\n            reached_maximum = true;\n        }\n        if let Some(ref son) = node.left {\n            assert!(\n                son.max \u003c= node.max,\n                \"left max invariant violated:\\n{:?} -\u003e {:?}\",\n                node,\n                son\n            );\n            assert!(\n                son.interval.start \u003c= node.interval.start,\n                \"left ord invariant violated\\n{:?} -\u003e {:?}\",\n                node,\n                son\n            );\n            if node.max == son.max {\n                reached_maximum = true;\n            }\n        }\n        if let Some(ref son) = node.right {\n            assert!(\n                son.max \u003c= node.max,\n                \"right max invariant violated\\n{:?} -\u003e {:?}\",\n                node,\n                son\n            );\n            assert!(\n                son.interval.start \u003e= node.interval.start,\n                \"right ord invariant violated\\n{:?} -\u003e {:?}\",\n                node,\n                son\n            );\n            if node.max == son.max {\n                reached_maximum = true;\n            }\n        }\n        assert!(reached_maximum, \"maximum invariant violated: {:?}\", node);\n    }\n\n    fn validate_string_metadata(node: \u0026Node\u003ci64, String\u003e) {\n        let mut name: String = \"\".to_string();\n        name.push_str(\u0026node.interval.start.to_string());\n        name.push(':');\n        name.push_str(\u0026node.interval.end.to_string());\n        assert_eq!(name, node.value, \"Invalid metadata for node {:?}\", node);\n    }\n\n    fn insert_and_validate(tree: \u0026mut IntervalTree\u003ci64, String\u003e, start: i64, end: i64) {\n        let mut name: String = \"\".to_string();\n        name.push_str(\u0026start.to_string());\n        name.push(':');\n        name.push_str(\u0026end.to_string());\n        tree.insert(start..end, name);\n        if let Some(ref n) = tree.root {\n            validate(n);\n        }\n    }\n\n    fn make_entry_tuples(intervals: Vec\u003cRange\u003ci64\u003e\u003e) -\u003e Vec\u003c(Interval\u003ci64\u003e, String)\u003e {\n        let mut entries = vec![];\n        for interval in intervals {\n            let mut data: String = \"\".to_string();\n            data.push_str(\u0026interval.start.to_string());\n            data.push(':');\n            data.push_str(\u0026interval.end.to_string());\n            entries.push((interval.into(), data));\n        }\n        entries.sort_by(|x1, x2| x1.1.cmp(\u0026x2.1));\n        entries\n    }\n\n    fn assert_intersections(\n        tree: \u0026IntervalTree\u003ci64, String\u003e,\n        target: Range\u003ci64\u003e,\n        expected_results: Vec\u003cRange\u003ci64\u003e\u003e,\n    ) {\n        let mut actual_entries: Vec\u003cEntry\u003c'_, i64, String\u003e\u003e = tree.find(\u0026target).collect();\n        println!(\"{:?}\", actual_entries);\n        actual_entries.sort_by(|x1, x2| x1.data.cmp(\u0026x2.data));\n        let expected_entries = make_entry_tuples(expected_results);\n        assert_eq!(actual_entries.len(), expected_entries.len());\n        for (actual, expected) in actual_entries.iter().zip(expected_entries.iter()) {\n            assert_eq!(*actual.interval, expected.0);\n            assert_eq!(actual.data, \u0026expected.1);\n        }\n    }\n\n    fn assert_not_found(tree: \u0026IntervalTree\u003ci64, String\u003e, target: Range\u003ci64\u003e) {\n        assert_intersections(tree, target, vec![]);\n    }\n\n    #[test]\n    fn test_insertion_and_intersection() {\n        let mut tree: IntervalTree\u003ci64, String\u003e = IntervalTree::new();\n        assert_eq!(tree.find(1..2).count(), 0);\n        assert_eq!(tree.find_mut(1..2).count(), 0);\n        tree.insert(50..51, \"50:51\".to_string());\n        assert_not_found(\u0026tree, 49..50);\n        assert_intersections(\u0026tree, 49..55, vec![50..51]);\n        assert_not_found(\u0026tree, 51..55);\n        assert_not_found(\u0026tree, 52..55);\n        assert_not_found(\u0026tree, 40..45);\n        insert_and_validate(\u0026mut tree, 80, 81);\n        assert_intersections(\u0026tree, 80..83, vec![80..81]);\n        assert_intersections(\u0026tree, 1..100, vec![50..51, 80..81]);\n        assert_not_found(\u0026tree, 82..83);\n        insert_and_validate(\u0026mut tree, 30, 35);\n        assert_intersections(\u0026tree, 25..33, vec![30..35]);\n        assert_intersections(\u0026tree, 1..100, vec![30..35, 50..51, 80..81]);\n        assert_not_found(\u0026tree, 42..43);\n        assert_not_found(\u0026tree, 35..36);\n        assert_not_found(\u0026tree, 22..29);\n        insert_and_validate(\u0026mut tree, 70, 77);\n        assert_intersections(\u0026tree, 75..79, vec![70..77]);\n        assert_intersections(\u0026tree, 1..100, vec![30..35, 50..51, 70..77, 80..81]);\n        assert_not_found(\u0026tree, 62..68);\n        assert_intersections(\u0026tree, 75..77, vec![70..77]);\n        assert_not_found(\u0026tree, 78..79);\n        assert_intersections(\u0026tree, 49..51, vec![50..51]);\n        assert_intersections(\u0026tree, 49..55, vec![50..51]);\n        assert_not_found(\u0026tree, 51..55);\n        assert_not_found(\u0026tree, 52..55);\n        assert_not_found(\u0026tree, 40..45);\n        insert_and_validate(\u0026mut tree, 101, 102);\n        insert_and_validate(\u0026mut tree, 103, 104);\n        insert_and_validate(\u0026mut tree, 105, 106);\n        insert_and_validate(\u0026mut tree, 107, 108);\n        insert_and_validate(\u0026mut tree, 111, 112);\n        insert_and_validate(\u0026mut tree, 113, 114);\n        insert_and_validate(\u0026mut tree, 115, 116);\n        insert_and_validate(\u0026mut tree, 117, 118);\n        insert_and_validate(\u0026mut tree, 119, 129);\n        assert_not_found(\u0026tree, 112..113);\n        assert_not_found(\u0026tree, 108..109);\n        assert_intersections(\u0026tree, 106..108, vec![107..108]);\n        assert_intersections(\u0026tree, 1..100, vec![30..35, 50..51, 70..77, 80..81]);\n        assert_intersections(\u0026tree, 1..101, vec![30..35, 50..51, 70..77, 80..81]);\n        assert_intersections(\n            \u0026tree,\n            1..102,\n            vec![30..35, 50..51, 70..77, 80..81, 101..102],\n        );\n        assert_intersections(\n            \u0026tree,\n            100..200,\n            vec![\n                101..102,\n                103..104,\n                105..106,\n                107..108,\n                111..112,\n                113..114,\n                115..116,\n                117..118,\n                119..129,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_insertion_and_intersection_2() {\n        let mut tree: IntervalTree\u003ci64, String\u003e = IntervalTree::new();\n        // interval size we'll insert into the tree\n        let k = 10;\n        for i in 100..200 {\n            insert_and_validate(\u0026mut tree, i, i + k);\n        }\n        for i in 90..210 {\n            // \"random\" interval length we'll search against.\n            // the exact formula doesn't matter; the point is\n            // it will vary from 0.5 * k to 1.5 * k\n            let l = k / 2 + i % k;\n            let lower_bound = i;\n            let upper_bound = i + l;\n            let smallest_start = max(lower_bound - k + 1, 100);\n            let largest_start = min(upper_bound, 200);\n            let mut expected_intersections = vec![];\n            for j in smallest_start..largest_start {\n                expected_intersections.push(j..j + k);\n            }\n            assert_intersections(\u0026tree, lower_bound..upper_bound, expected_intersections);\n        }\n    }\n\n    #[test]\n    fn zero_width_ranges() {\n        let mut tree: IntervalTree\u003ci64, String\u003e = IntervalTree::new();\n        tree.insert(10..10, \"10:10\".to_string());\n\n        assert_not_found(\u0026tree, 5..15);\n        assert_not_found(\u0026tree, 10..10);\n\n        insert_and_validate(\u0026mut tree, 50, 60);\n        assert_not_found(\u0026tree, 55..55);\n    }\n\n    #[test]\n    fn from_iterator() {\n        let tree: IntervalTree\u003ci64, ()\u003e = vec![(10..100, ()), (10..20, ()), (1..8, ())]\n            .into_iter()\n            .collect();\n        assert_eq!(tree.find(\u0026(0..1000)).count(), 3);\n        let tree2: IntervalTree\u003c_, _\u003e = tree\n            .find(\u0026(11..30))\n            .map(|e| (e.interval().clone(), *e.data()))\n            .collect();\n        assert_eq!(tree2.find(\u0026(0..1000)).count(), 2);\n    }\n\n    #[test]\n    fn iter_mut() {\n        let mut tree: IntervalTree\u003ci64, usize\u003e = vec![(10..100, 0), (10..20, 0), (1..8, 0)]\n            .into_iter()\n            .collect();\n        let q = Interval::new(11..30).unwrap();\n        for mut e in tree.find_mut(q.clone()) {\n            *e.data() += 1;\n        }\n        assert!(tree\n            .find(0..100)\n            .all(|e| if super::intersect(e.interval(), \u0026q) {\n                *e.data() == 1\n            } else {\n                *e.data() == 0\n            }));\n    }\n}\n","traces":[{"line":40,"address":[5199104,5199152,5199248,5199200],"length":1,"stats":{"Line":0},"fn_name":"default\u003ci64,usize\u003e"},{"line":55,"address":[5199296,5199328,5199312],"length":1,"stats":{"Line":0},"fn_name":"data\u003cisize,alloc::string::String\u003e"},{"line":56,"address":[5199301,5199317,5199333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[5199360,5199344],"length":1,"stats":{"Line":0},"fn_name":"interval\u003ci64,usize\u003e"},{"line":61,"address":[5199349,5199365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[5199376,5200304,5200768,5199840],"length":1,"stats":{"Line":0},"fn_name":"next\u003ci64,alloc::string::String\u003e"},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[5199428,5199398,5199862,5200790,5199892,5200356,5200820,5200326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[5200336,5199894,5199408,5200822,5200800,5200358,5199872,5199430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[5199913,5200377,5200841,5199449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[5199472,5200864,5200400,5199936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[5200918,5199584,5200454,5200999,5200535,5199526,5199990,5200048,5200512,5200976,5199607,5200071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[5199573,5200965,5200501,5200037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[5200702,5201166,5199774,5200238,5200083,5200519,5199591,5199619,5200983,5200055,5200547,5201011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[5199677,5200226,5201154,5200141,5200605,5201127,5199762,5200663,5199735,5201069,5200690,5200199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[5200652,5199724,5200188,5201116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[5201139,5201160,5199747,5199768,5200675,5200211,5200232,5200696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[5200255,5200715,5199791,5201183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[5200248,5199784,5201176,5200712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[5201232],"length":1,"stats":{"Line":0},"fn_name":"data\u003ci64,usize\u003e"},{"line":120,"address":[5201237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[5201248,5201712],"length":1,"stats":{"Line":0},"fn_name":"next\u003ci64,alloc::string::String\u003e"},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[5201300,5201270,5201734,5201764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[5201766,5201744,5201302,5201280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[5201785,5201321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[5201808,5201344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[5201456,5201862,5201920,5201398,5201943,5201479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[5201445,5201909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[5201463,5201927,5201491,5202110,5201646,5201955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[5201607,5202071,5201634,5201549,5202013,5202098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[5201596,5202060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[5202083,5201640,5202104,5201619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[5201663,5202127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[5202120,5201656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[5202208,5202272,5202240,5202176],"length":1,"stats":{"Line":0},"fn_name":"new\u003cisize,alloc::string::String\u003e"},{"line":174,"address":[5202216,5202280,5202184,5202248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[5204725,5204184,5202760,5202784,5203776,5203752,5202304,5203344,5203301,5204208],"length":1,"stats":{"Line":0},"fn_name":"insert\u003ci64,usize,core::ops::range::Range\u003ci64\u003e\u003e"},{"line":179,"address":[5203406,5202379,5204275,5203838,5202851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[5204421,5203703,5204676,5202518,5203544,5203252,5202711,5203976,5204135,5202997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[5204361,5204021,5203923,5202465,5202578,5203589,5203491,5203088,5204512,5202937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[5203148,5202620,5203555,5204438,5203014,5203259,5204683,5202718,5204572,5202535,5203710,5203631,5204063,5203987,5204142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[5205129,5206692,5205497,5206304,5205482,5204768,5206292,5205504,5205114,5205904,5205136,5205892,5206677,5206277,5205877],"length":1,"stats":{"Line":0},"fn_name":"find\u003ci64,alloc::string::String,\u0026core::ops::range::Range\u003ci64\u003e\u003e"},{"line":189,"address":[5205187,5205976,5206376,5205576,5204819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[5205235,5206551,5205751,5205631,5205875,5206275,5205480,5204994,5205362,5206031,5206675,5206151,5205112,5206424,5204874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[5206066,5206467,5204909,5205666,5205278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[5206431,5205242,5206038,5204881,5205638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[5206704,5207477,5207104,5207492,5207077,5207092],"length":1,"stats":{"Line":0},"fn_name":"find_mut\u003ci64,alloc::string::String,core::ops::range::Range\u003ci64\u003e\u003e"},{"line":208,"address":[5206776,5207176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[5207075,5207351,5206831,5207475,5206951,5207224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[5206866,5207267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[5206838,5207231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[5207504,5209018,5208050,5208576,5208080,5208538],"length":1,"stats":{"Line":0},"fn_name":"from_iter\u003ci64,usize,core::ops::range::Range\u003ci64\u003e,alloc::vec::into_iter::IntoIter\u003c(core::ops::range::Range\u003ci64\u003e, usize), alloc::alloc::Global\u003e\u003e"},{"line":224,"address":[5207529,5208105,5208600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[5207802,5208983,5208861,5208224,5208015,5208381,5208141,5207737,5207648,5208727,5207565,5208796,5208888,5208503,5208408,5208316,5207832,5208635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[5207976,5208488,5208968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[5209552,5210017,5209536,5209548,5210005,5209820,5209266,5209280,5209808,5209056,5209824,5209254],"length":1,"stats":{"Line":0},"fn_name":"new\u003ci64,usize\u003e"},{"line":246,"address":[5209856,5209589,5209098,5209173,5209928,5209406,5209678,5209317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[5210864,5211646,5213586,5210032,5211664,5210845,5212640,5212610],"length":1,"stats":{"Line":0},"fn_name":"insert\u003ci64,usize\u003e"},{"line":258,"address":[5210078,5212811,5211702,5210211,5212678,5211835,5210897,5211030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[5211307,5211094,5212187,5211365,5210498,5212248,5213163,5212875,5211899,5213224,5210275,5210556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[5211946,5210322,5212922,5211136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[5210367,5213127,5212151,5212013,5210505,5212194,5213170,5212989,5210468,5211277,5211314,5211176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[5212839,5212523,5211058,5211570,5212260,5210239,5210568,5213499,5213548,5213236,5211863,5211372,5210769,5212572,5211619,5210818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[5210583,5211387,5212275,5213251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[5212487,5210628,5213463,5211534,5210779,5213327,5210733,5212533,5211427,5211580,5213509,5212351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[5211355,5212238,5213214,5210546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[5214192,5213808,5213616,5214000],"length":1,"stats":{"Line":0},"fn_name":"update_height\u003cisize,alloc::string::String\u003e"},{"line":273,"address":[5214425,5214416,5214393,5214448,5213822,5214206,5214457,5214384,5213630,5214480,5214489,5214014],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003ci64,alloc::string::String\u003e"},{"line":274,"address":[5214585,5214521,5214057,5214553,5214608,5214544,5214249,5213673,5214512,5213865,5214617,5214576],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cisize,alloc::string::String\u003e"},{"line":275,"address":[5214154,5214376,5213962,5214297,5213992,5214346,5213800,5213913,5213721,5213770,5214105,5214184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[5214640,5215600,5214960,5215280],"length":1,"stats":{"Line":0},"fn_name":"update_max\u003cisize,alloc::string::String\u003e"},{"line":279,"address":[5215614,5215294,5214654,5214974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[5215089,5215339,5214699,5215729,5215659,5215409,5214769,5215019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[5215124,5215764,5215490,5215170,5215810,5215444,5215703,5215383,5214804,5215063,5214743,5214850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[5215137,5215457,5214817,5215777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[5214776,5215220,5215817,5215736,5215540,5215497,5215416,5215096,5215177,5215860,5214857,5214900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[5214911,5215917,5214957,5215595,5215194,5215275,5215551,5215871,5215277,5214874,5215597,5214955,5215231,5215514,5215915,5215834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[5215564,5215884,5215244,5214924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[5218032,5216624,5215920,5217328],"length":1,"stats":{"Line":0},"fn_name":"repair\u003ci64,alloc::string::String\u003e"},{"line":293,"address":[5215943,5218832,5218777,5218841,5218768,5216647,5218745,5218736,5218055,5218809,5218800,5217351],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003ci64,usize\u003e"},{"line":294,"address":[5218873,5218928,5218864,5217409,5218896,5218960,5218937,5218905,5216001,5218969,5216705,5218113],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003ci64,()\u003e"},{"line":296,"address":[5218286,5218167,5216759,5216174,5216878,5216055,5217463,5217582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[5218268,5217564,5216156,5216860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[5216873,5217577,5216169,5218281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[5218718,5218019,5217310,5218253,5218014,5217315,5218723,5216141,5218530,5217549,5217826,5216611,5216845,5217122,5216606,5216418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[5217627,5216923,5216219,5218331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[5216984,5219001,5218992,5219056,5216280,5217688,5219065,5219024,5219097,5218392,5219033,5219088],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003ci64,()\u003e"},{"line":306,"address":[5219152,5219193,5217033,5219184,5219161,5219129,5217737,5218441,5219225,5216329,5219216,5219120],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003ci64,alloc::string::String\u003e"},{"line":307,"address":[5217811,5216403,5218515,5217107,5218495,5217791,5216383,5217087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[5218507,5217803,5216395,5217099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[5217821,5218525,5217117,5216413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[5218540,5216428,5218304,5217836,5216896,5216192,5217132,5217600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[5219312,5219344,5219289,5217878,5218582,5219280,5216470,5219321,5219353,5217174,5219248,5219257],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cisize,alloc::string::String\u003e"},{"line":319,"address":[5217223,5219376,5219408,5216519,5218631,5219472,5219385,5219481,5219440,5219417,5217927,5219449],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003ci64,alloc::string::String\u003e"},{"line":320,"address":[5218703,5217979,5217999,5217275,5216591,5216571,5218683,5217295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[5217991,5216583,5217287,5218695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[5218713,5216601,5218009,5217305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[5221511,5219504,5222520,5223528,5220528,5220487,5222560,5221552],"length":1,"stats":{"Line":0},"fn_name":"rotate_left\u003cisize,alloc::string::String\u003e"},{"line":329,"address":[5222577,5220545,5219521,5221569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[5220649,5221673,5219625,5222681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[5222720,5222787,5219664,5219731,5220688,5220755,5221712,5221779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[5220834,5221789,5222866,5219741,5220765,5222797,5219810,5221858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[5220844,5219820,5221868,5222876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[5219983,5222994,5220962,5219867,5222923,5221986,5219938,5221007,5221915,5220891,5222031,5223039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[5223082,5220052,5223003,5223108,5221076,5221050,5222100,5221995,5219947,5220026,5220971,5222074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[5223091,5220035,5222083,5221059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[5222141,5223149,5220093,5221117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[5223161,5221129,5223252,5221220,5220196,5222153,5222244,5220105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[5222198,5220232,5223288,5223206,5222280,5220253,5221256,5221174,5220150,5222301,5221277,5223309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[5222289,5223297,5220241,5221265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[5220294,5222342,5223350,5221318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[5223568,5226583,5226624,5227592,5224551,5224592,5225600,5225560],"length":1,"stats":{"Line":0},"fn_name":"rotate_right\u003ci64,alloc::string::String\u003e"},{"line":347,"address":[5224609,5225617,5223585,5226641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[5223689,5226745,5225721,5224713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[5224819,5226784,5226851,5224752,5223728,5225827,5225760,5223795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[5225837,5223805,5226861,5224829,5226930,5223874,5224898,5225906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[5226940,5224908,5225916,5223884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[5224955,5225963,5225026,5227103,5223931,5224002,5226034,5226079,5226987,5225071,5224047,5227058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[5224090,5227146,5225114,5224011,5225140,5224116,5227172,5226122,5226148,5225035,5226043,5227067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[5226131,5225123,5224099,5227155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[5224157,5227213,5225181,5226189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[5224169,5225193,5225284,5227225,5226292,5227316,5224260,5226201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[5224317,5226246,5227373,5227270,5224296,5225320,5225238,5226328,5224214,5225341,5226349,5227352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[5226337,5225329,5227361,5224305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[5227414,5225382,5226390,5224358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[5227824,5227760,5227632,5227696],"length":1,"stats":{"Line":0},"fn_name":"swap_interval_data\u003cisize,alloc::string::String\u003e"},{"line":366,"address":[5227848,5227656,5227720,5227784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[5227743,5227872,5227679,5227799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[5228320,5227888],"length":1,"stats":{"Line":0},"fn_name":"intersect\u003cisize\u003e"},{"line":371,"address":[5228081,5228513,5228612,5228356,5228279,5228711,5227924,5228180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[5228016,5228448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[5228115,5228547],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[5228214,5228646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[5820992],"length":1,"stats":{"Line":0},"fn_name":"validate"},{"line":386,"address":[5821006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[5821016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[5821026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[5821036,5821093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[5821083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[5821100,5821157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[5821147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[5821168],"length":1,"stats":{"Line":0},"fn_name":"validate_height"},{"line":398,"address":[5821188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[5821234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[5821285,5821401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[5821580,5821436,5821380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[5821632],"length":1,"stats":{"Line":0},"fn_name":"validate_intervals"},{"line":405,"address":[5821647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[5821655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[5821704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[5821712,5821800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[5821792,5821870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[5821762],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[5822195,5822239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[5821841,5822141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[5822201,5822509,5822496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[5822501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[5822514,5822572,5821802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[5822564,5822622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[5822534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[5822902,5822946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[5822596,5822860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[5823192,5823179,5822908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[5823184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[5823205,5822574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[5824068,5823360],"length":1,"stats":{"Line":0},"fn_name":"validate_string_metadata"},{"line":447,"address":[5823372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[5823473,5823393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[5823579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[5823586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[5823854,5823743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[5824096,5824623],"length":1,"stats":{"Line":0},"fn_name":"insert_and_validate"},{"line":455,"address":[5824126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[5824173,5824264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[5824332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[5824349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[5824465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[5824561,5824603,5824621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[5824596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[5824656,5825675],"length":1,"stats":{"Line":0},"fn_name":"make_entry_tuples"},{"line":466,"address":[5824681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[5824809,5824994,5824974,5824913,5825593,5824717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[5825058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[5825205,5825108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[5825282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[5825289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[5825428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[5825622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[5825712,5827250],"length":1,"stats":{"Line":0},"fn_name":"assert_intersections"},{"line":483,"address":[5825773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[5826057,5825884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[5826084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[5826144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[5826314,5826470,5826206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[5826840,5826425,5826537,5827166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[5826914,5827109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[5827160,5827009,5827180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[5827280],"length":1,"stats":{"Line":0},"fn_name":"assert_not_found"},{"line":495,"address":[5827313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[5832402,5827360],"length":1,"stats":{"Line":0},"fn_name":"test_insertion_and_intersection"},{"line":500,"address":[5827367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[5827377,5827502,5827666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[5827596,5827900,5827725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[5827839,5827952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[5827988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[5828040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[5828185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[5828237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[5828289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[5828356],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[5828363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[5828508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[5828701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[5828768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[5828775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[5828920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[5829161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[5829213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[5829265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[5829332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[5829339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[5829484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[5829778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[5829830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[5829975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[5830027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[5830172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[5830317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[5830369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[5830421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[5830488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[5830510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[5830532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[5830554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[5830576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[5830598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[5830620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[5830642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[5830664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[5830671],"length":1,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[5830723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[5830775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[5830920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[5831214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[5831508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[5831542],"length":1,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[5831850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[5831884,5832113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[5831897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[5831921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[5831945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[5831969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[5831993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[5832017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[5832041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[5832065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[5832089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[5832432,5833986],"length":1,"stats":{"Line":0},"fn_name":"test_insertion_and_intersection_2"},{"line":568,"address":[5832439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[5832460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[5832772,5832623,5832472,5832894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[5832812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[5832915,5833025,5833963,5832703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[5833200,5833062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[5833175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[5833243,5833183,5833269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[5833307,5833251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":582,"address":[5833438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[5833474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[5833807,5833491,5833950,5833631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[5833844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[5833709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[5834016,5834323],"length":1,"stats":{"Line":0},"fn_name":"zero_width_ranges"},{"line":593,"address":[5834023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[5834033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[5834139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[5834185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[5834252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[5834259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[5835266,5834352],"length":1,"stats":{"Line":0},"fn_name":"from_iterator"},{"line":605,"address":[5834359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[5834890,5834759,5834667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[5834853,5834957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[7723555,7723536],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":613,"address":[5835085,5835202,5834987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":617,"address":[5836487,5835296],"length":1,"stats":{"Line":0},"fn_name":"iter_mut"},{"line":618,"address":[5835303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[5835694,5835834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[5836080,5836100,5835858,5836224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[5836172,5836229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":625,"address":[5836454,5836337,5836285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":626,"address":[5836261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[5836329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[7723768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[7723818,7723751],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":305},{"path":["/","home","todd","rust-bio","src","data_structures","interval_tree","mod.rs"],"content":"mod array_backed_interval_tree;\nmod avl_interval_tree;\n\npub use array_backed_interval_tree::ArrayBackedIntervalTree;\npub use avl_interval_tree::{\n    Entry, EntryMut, IntervalTree, IntervalTreeIterator, IntervalTreeIteratorMut,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","data_structures","mod.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Various useful data structures.\n\npub mod annot_map;\npub mod bit_tree;\npub mod bitenc;\npub mod bwt;\npub mod fmindex;\npub mod interpolation_table;\npub mod interval_tree;\npub mod qgram_index;\npub mod rank_select;\npub mod smallints;\npub mod suffix_array;\npub mod wavelet_matrix;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","data_structures","qgram_index.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A classical, flexible, q-gram index implementation.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::alphabets;\n//! use bio::data_structures::qgram_index;\n//!\n//! let text = b\"ACGGCTGAGATGAT\";\n//! let alphabet = alphabets::dna::alphabet();\n//! let q = 3;\n//! let qgram_index = qgram_index::QGramIndex::new(q, text, \u0026alphabet);\n//!\n//! let pattern = b\"GCTG\";\n//! let matches = qgram_index.matches(pattern, 1);\n//! assert_eq!(\n//!     matches,\n//!     [qgram_index::Match {\n//!         pattern: qgram_index::Interval { start: 0, stop: 4 },\n//!         text: qgram_index::Interval { start: 3, stop: 7 },\n//!         count: 2\n//!     }]\n//! );\n//! ```\n\nuse std::cmp;\nuse std::collections;\nuse std::collections::hash_map::Entry;\n\nuse crate::alphabets::{Alphabet, RankTransform};\nuse crate::utils;\n\n/// A classical, flexible, q-gram index implementation.\n#[derive(Serialize, Deserialize)]\npub struct QGramIndex {\n    q: u32,\n    address: Vec\u003cusize\u003e,\n    pos: Vec\u003cusize\u003e,\n    ranks: RankTransform,\n}\n\nimpl QGramIndex {\n    /// Create a new q-gram index.\n    /// The q has to be smaller than b / log2(|A|) with |A| being the alphabet size and b the number\n    /// bits with the `usize` data type.\n    pub fn new(q: u32, text: \u0026[u8], alphabet: \u0026Alphabet) -\u003e Self {\n        QGramIndex::with_max_count(q, text, alphabet, std::usize::MAX)\n    }\n\n    /// Create a new q-gram index, only considering q-grams that occur at most `max_count` times.\n    /// The q has to be smaller than b / log2(|A|) with |A| being the alphabet size and b the number\n    /// bits with the `usize` data type.\n    pub fn with_max_count(q: u32, text: \u0026[u8], alphabet: \u0026Alphabet, max_count: usize) -\u003e Self {\n        let ranks = RankTransform::new(alphabet);\n\n        let qgram_count = alphabet.len().pow(q as u32);\n        let mut address = vec![0; qgram_count + 1];\n        let mut pos = vec![0; text.len()];\n\n        for qgram in ranks.qgrams(q, text) {\n            address[qgram] += 1;\n        }\n\n        for a in address.iter_mut().skip(1) {\n            if *a \u003e max_count {\n                // mask qgram\n                *a = 0;\n            }\n        }\n\n        utils::prescan(\u0026mut address, 0, |a, b| a + b);\n\n        {\n            let mut offset = vec![0; qgram_count];\n            for (i, qgram) in ranks.qgrams(q, text).enumerate() {\n                let a = address[qgram as usize];\n                if address[qgram as usize + 1] - a != 0 {\n                    // if not masked, insert positions\n                    pos[a + offset[qgram as usize]] = i;\n                    offset[qgram as usize] += 1;\n                }\n            }\n        }\n\n        QGramIndex {\n            q,\n            address,\n            pos,\n            ranks,\n        }\n    }\n\n    /// The used q.\n    pub fn q(\u0026self) -\u003e u32 {\n        self.q\n    }\n\n    /// Return text positions with matching q-gram. Complexity O(1).\n    pub fn qgram_matches(\u0026self, qgram: usize) -\u003e \u0026[usize] {\n        \u0026self.pos[self.address[qgram]..self.address[qgram + 1]]\n    }\n\n    /// Return matches of the given pattern.\n    /// Complexity O(m + k) for pattern of length m and k being the number of matching q-grams.\n    pub fn matches(\u0026self, pattern: \u0026[u8], min_count: usize) -\u003e Vec\u003cMatch\u003e {\n        let q = self.q as usize;\n        let mut diagonals = collections::HashMap::new();\n        for (i, qgram) in self.ranks.qgrams(self.q, pattern).enumerate() {\n            for \u0026p in self.qgram_matches(qgram) {\n                let diagonal = p - i;\n                match diagonals.entry(diagonal) {\n                    Entry::Vacant(v) =\u003e {\n                        v.insert(Match {\n                            pattern: Interval {\n                                start: i,\n                                stop: i + q,\n                            },\n                            text: Interval {\n                                start: p,\n                                stop: p + q,\n                            },\n                            count: 1,\n                        });\n                    }\n                    Entry::Occupied(mut o) =\u003e {\n                        let m = o.get_mut();\n                        m.pattern.stop = i + q;\n                        m.text.stop = p + q;\n                        m.count += 1;\n                    }\n                }\n            }\n        }\n        diagonals\n            .into_iter()\n            .filter_map(|(_, m)| if m.count \u003e= min_count { Some(m) } else { None })\n            .collect()\n    }\n\n    /// Return exact matches (substrings) of the given pattern.\n    /// Complexity O(m + k) for pattern of length m and k being the number of matching q-grams.\n    pub fn exact_matches(\u0026self, pattern: \u0026[u8]) -\u003e Vec\u003cExactMatch\u003e {\n        let q = self.q as usize;\n        let mut diagonals = collections::HashMap::new();\n        let mut matches = Vec::new();\n\n        for (i, qgram) in self.ranks.qgrams(self.q, pattern).enumerate() {\n            for \u0026p in self.qgram_matches(qgram) {\n                let diagonal = p as i32 - i as i32;\n                match diagonals.entry(diagonal) {\n                    Entry::Vacant(v) =\u003e {\n                        v.insert(ExactMatch {\n                            pattern: Interval {\n                                start: i,\n                                stop: i + q,\n                            },\n                            text: Interval {\n                                start: p,\n                                stop: p + q,\n                            },\n                        });\n                    }\n                    Entry::Occupied(mut o) =\u003e {\n                        let m = o.get_mut();\n                        if m.pattern.stop - q + 1 == i {\n                            m.pattern.stop = i + q;\n                            m.text.stop = p + q;\n                        } else {\n                            // discontinue match\n                            matches.push(*m);\n                            // start new match\n                            m.pattern.start = i;\n                            m.pattern.stop = i + q;\n                            m.text.start = p;\n                            m.text.stop = p + q;\n                        }\n                    }\n                }\n            }\n        }\n        for (_, m) in diagonals {\n            matches.push(m);\n        }\n\n        matches\n    }\n}\n\n/// An interval, consisting of start and stop position (the latter exclusive).\n#[derive(PartialEq, Eq, Debug, Copy, Clone)]\npub struct Interval {\n    pub start: usize,\n    pub stop: usize,\n}\n\nimpl Interval {\n    /// Get the text within the given interval.\n    pub fn get\u003c'a\u003e(\u0026self, text: \u0026'a [u8]) -\u003e \u0026'a [u8] {\n        \u0026text[self.start..self.stop]\n    }\n}\n\n/// A match between the pattern and the text.\n#[derive(PartialEq, Eq, Debug, Copy, Clone)]\npub struct Match {\n    pub pattern: Interval,\n    pub text: Interval,\n    pub count: usize,\n}\n\nimpl cmp::Ord for Match {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e cmp::Ordering {\n        self.count.cmp(\u0026other.count)\n    }\n}\n\nimpl cmp::PartialOrd for Match {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003ccmp::Ordering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\n/// An exact match between the pattern and the text.\n#[derive(PartialEq, Debug, Copy, Clone)]\npub struct ExactMatch {\n    pub pattern: Interval,\n    pub text: Interval,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::alphabets;\n\n    fn setup() -\u003e (\u0026'static [u8], alphabets::Alphabet) {\n        let text = b\"ACGGCTGAGATGAT\";\n        let alphabet = alphabets::dna::alphabet();\n\n        (text, alphabet)\n    }\n\n    #[test]\n    fn test_qgram_matches() {\n        let (text, alphabet) = setup();\n        let q = 3;\n        let qgram_index = QGramIndex::new(q, text, \u0026alphabet);\n\n        let ranks = alphabets::RankTransform::new(\u0026alphabet);\n\n        let qgram = ranks.qgrams(q, b\"TGA\").next().unwrap();\n\n        let matches = qgram_index.qgram_matches(qgram);\n        assert_eq!(matches, [5, 10]);\n    }\n\n    #[test]\n    fn test_matches() {\n        let (text, alphabet) = setup();\n        let q = 3;\n        let qgram_index = QGramIndex::new(q, text, \u0026alphabet);\n\n        let pattern = b\"GCTG\";\n        let matches = qgram_index.matches(pattern, 1);\n        assert_eq!(\n            matches,\n            [Match {\n                pattern: Interval { start: 0, stop: 4 },\n                text: Interval { start: 3, stop: 7 },\n                count: 2,\n            }]\n        );\n    }\n\n    #[test]\n    fn test_exact_matches() {\n        let (text, alphabet) = setup();\n        let q = 3;\n        let qgram_index = QGramIndex::new(q, text, \u0026alphabet);\n\n        let pattern = b\"GCTGA\";\n        let exact_matches = qgram_index.exact_matches(pattern);\n        assert!(exact_matches.len() == 2);\n        for m in exact_matches {\n            assert_eq!(m.pattern.get(pattern), m.text.get(text));\n        }\n    }\n\n    #[test]\n    fn test_exact_matches_self() {\n        let (text, alphabet) = setup();\n        let q = 3;\n        let qgram_index = QGramIndex::new(q, text, \u0026alphabet);\n\n        let exact_matches = qgram_index.exact_matches(text);\n        assert!(!exact_matches.is_empty());\n    }\n\n    #[test]\n    #[cfg(feature = \"nightly\")]\n    fn test_serde() {\n        use serde::{Deserialize, Serialize};\n        fn impls_serde_traits\u003cS: Serialize + Deserialize\u003e() {}\n\n        impls_serde_traits::\u003cQGramIndex\u003e();\n    }\n}\n","traces":[{"line":51,"address":[5138624],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":52,"address":[5138654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[5141007,5141022,5138688],"length":1,"stats":{"Line":0},"fn_name":"with_max_count"},{"line":59,"address":[5138799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[5138820,5138919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[5138927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[5139023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[5139498,5139222,5139154,5139380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[5139503,5139412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[5139552,5139336,5139796,5139852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[5139833],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[5139845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[5139871,5139753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[5139886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[5140130,5139946,5140689,5140033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[5140204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[5140654,5140264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[5140436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[5140656,5140585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[5141024],"length":1,"stats":{"Line":0},"fn_name":"q"},{"line":100,"address":[5141029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[5141040],"length":1,"stats":{"Line":0},"fn_name":"qgram_matches"},{"line":105,"address":[5141064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[5141280,5142832],"length":1,"stats":{"Line":0},"fn_name":"matches"},{"line":111,"address":[5141353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[5141380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[5141909,5141419,5141524,5141689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[5141758,5142496,5141919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[5141959,5142010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[5142700,5142494,5142003,5142059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[5142042,5142132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[5142180,5142362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[5142266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[5142303,5142228],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[5142346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[5142282,5142461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[5142061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[5142519,5142101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[5142527,5142586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[5142654,5142569,5142629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[5142696,5142633,5142705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[5142754,5141599],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[5142746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[5145041,5142864],"length":1,"stats":{"Line":0},"fn_name":"exact_matches"},{"line":148,"address":[5142935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[5142962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[5142991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[5143104,5143555,5143329,5143022,5143164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[5143565,5144126,5143398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[5143605,5143652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[5144124,5143701,5143645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[5143684,5143774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[5143822,5144004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[5143908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[5143945,5143870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[5143988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[5144091,5143924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[5143703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[5144144,5143743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[5144450,5144152,5144617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[5144403,5144344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[5144455,5144446,5144386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[5144290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[5144506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[5144571,5144509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[5144551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[5144622,5144555,5144613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[5144789,5144761,5143239,5145012,5144655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[5144965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[5145072],"length":1,"stats":{"Line":0},"fn_name":"get"},{"line":204,"address":[5145115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[5145184],"length":1,"stats":{"Line":0},"fn_name":"cmp"},{"line":218,"address":[5145198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[5145232],"length":1,"stats":{"Line":0},"fn_name":"partial_cmp"},{"line":224,"address":[5145246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[5948752],"length":1,"stats":{"Line":0},"fn_name":"setup"},{"line":241,"address":[5948765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[5948777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[5948796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[5949920,5950517],"length":1,"stats":{"Line":0},"fn_name":"test_qgram_matches"},{"line":249,"address":[5949927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[5949986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[5950015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[5950035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[5950079,5950159,5950229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[5950276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[5950333,5950444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[5950990,5950544],"length":1,"stats":{"Line":0},"fn_name":"test_matches"},{"line":263,"address":[5950551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[5950607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[5950633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[5950640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[5950679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[5950731,5950920,5950850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[5951024,5952090],"length":1,"stats":{"Line":0},"fn_name":"test_exact_matches"},{"line":281,"address":[5951031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[5951111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[5951140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[5951147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[5951183,5951227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[5951243,5951300,5951416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[5951976,5951592,5951612,5951353,5951448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[5951740,5951990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[5952128,5952478],"length":1,"stats":{"Line":0},"fn_name":"test_exact_matches_self"},{"line":295,"address":[5952135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[5952201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[5952227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[5952257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[5952309,5952360,5952422],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":115},{"path":["/","home","todd","rust-bio","src","data_structures","rank_select.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Rank/Select data structure based on Gonzalez, Grabowski, Mäkinen, Navarro (2005).\n//! This implementation uses only a single level of blocks, and performs well for large n.\n//!\n//! Example\n//!\n//! ```\n//! extern crate bv;\n//! # extern crate bio;\n//! # fn main() {\n//! use bio::data_structures::rank_select::RankSelect;\n//! use bv::BitVec;\n//! use bv::BitsMut;\n//!\n//! let mut bits: BitVec\u003cu8\u003e = BitVec::new_fill(false, 64);\n//! bits.set_bit(5, true);\n//! bits.set_bit(32, true);\n//! let rs = RankSelect::new(bits, 1);\n//! assert!(rs.rank(6).unwrap() == 1);\n//! # }\n//! ```\n\nuse std::cmp;\nuse std::ops::Deref;\n\nuse bv::BitVec;\nuse bv::Bits;\n\n/// A rank/select data structure.\n#[derive(Serialize, Deserialize)]\npub struct RankSelect {\n    n: usize,\n    bits: BitVec\u003cu8\u003e,\n    superblocks_1: Vec\u003cSuperblockRank\u003e,\n    superblocks_0: Vec\u003cSuperblockRank\u003e,\n    /// superblock size in bits\n    s: usize,\n    /// superblock size in 32 bits\n    k: usize,\n}\n\nimpl RankSelect {\n    /// Create a new instance.\n    ///\n    /// # Arguments\n    ///\n    /// * `bits` - A bit vector.\n    /// * `k` - Determines the size (k * 32 bits) of the superblocks.\n    ///   A small k means faster rank query times at the expense of using more\n    ///   space and slower select query times.\n    ///   The data structure needs O(n + n log n / (k * 32)) bits with n being the bits of the given bitvector.\n    ///   The data structure is succinct if k is chosen as a sublinear function of n\n    ///   (e.g. k = (log n)² / 32).\n    pub fn new(bits: BitVec\u003cu8\u003e, k: usize) -\u003e RankSelect {\n        let n = bits.len() as usize;\n        let s = k * 32;\n\n        RankSelect {\n            n,\n            s,\n            k,\n            superblocks_1: superblocks(true, n, s, \u0026bits),\n            superblocks_0: superblocks(false, n, s, \u0026bits),\n            bits,\n        }\n    }\n\n    /// Return the used k (see `RankSelect::new()`).\n    pub fn k(\u0026self) -\u003e usize {\n        self.k\n    }\n\n    /// Get internal representation of bit vector.\n    pub fn bits(\u0026self) -\u003e \u0026BitVec\u003cu8\u003e {\n        \u0026self.bits\n    }\n\n    /// Return i-th bit.\n    pub fn get(\u0026self, i: u64) -\u003e bool {\n        self.bits.get_bit(i)\n    }\n\n    /// Get the 1-rank of a given bit, i.e. the number of 1-bits in the bitvector up to i (inclusive).\n    /// Complexity: O(k).\n    ///\n    /// # Arguments\n    ///\n    /// * `i` - Position of the bit to determine the rank for.\n    pub fn rank_1(\u0026self, i: u64) -\u003e Option\u003cu64\u003e {\n        if i \u003e= self.n as u64 {\n            None\n        } else {\n            let s = i / self.s as u64; // the superblock\n            let b = i / 8; // the block\n            let j = i % 8; // the bit in the block\n                           // take the superblock rank\n            let mut rank = *self.superblocks_1[s as usize];\n            // add the rank within the block\n            let mask = ((2u16 \u003c\u003c j) - 1) as u8;\n            rank += (self.bits.get_block(b as usize) \u0026 mask).count_ones() as u64;\n            // add the popcounts of blocks from the beginning of the current superblock\n            // up to the current block\n            for block in (s * self.s as u64 / 8)..b {\n                let b = self.bits.get_block(block as usize);\n                rank += b.count_ones() as u64;\n            }\n\n            Some(rank)\n        }\n    }\n\n    /// Get the 0-rank of a given bit, i.e. the number of 0-bits in the bitvector up to i (inclusive).\n    /// Complexity: O(k).\n    ///\n    /// # Arguments\n    ///\n    /// * `i` - Position of the bit to determine the rank for.\n    pub fn rank_0(\u0026self, i: u64) -\u003e Option\u003cu64\u003e {\n        self.rank_1(i).map(|r| (i + 1) - r)\n    }\n\n    /// Alias for `RankSelect::rank_1`.\n    pub fn rank(\u0026self, i: u64) -\u003e Option\u003cu64\u003e {\n        self.rank_1(i)\n    }\n\n    /// Get the smallest bit with a given 1-rank.\n    /// Complexity: O(log (n / k) + k).\n    ///\n    /// # Arguments\n    ///\n    /// * `j` - The rank to find the smallest bit for.\n    pub fn select_1(\u0026self, j: u64) -\u003e Option\u003cu64\u003e {\n        self.select_x(\n            j,\n            \u0026self.superblocks_1,\n            |bit| bit != 0,\n            |block| block.count_ones(),\n        )\n    }\n\n    /// Get the smallest bit with a given 0-rank.\n    /// Complexity: O(log (n / k) + k).\n    ///\n    /// # Arguments\n    ///\n    /// * `j` - The rank to find the smallest bit for.\n    pub fn select_0(\u0026self, j: u64) -\u003e Option\u003cu64\u003e {\n        self.select_x(\n            j,\n            \u0026self.superblocks_0,\n            |bit| bit == 0,\n            |block| block.count_zeros(),\n        )\n    }\n\n    fn select_x\u003cF: Fn(u8) -\u003e bool, C: Fn(u8) -\u003e u32\u003e(\n        \u0026self,\n        j: u64,\n        superblocks: \u0026[SuperblockRank],\n        is_match: F,\n        count_all: C,\n    ) -\u003e Option\u003cu64\u003e {\n        if j == 0 {\n            return None;\n        }\n        let mut superblock = match superblocks.binary_search(\u0026SuperblockRank::First(j)) {\n            Ok(i) | Err(i) =\u003e i, // superblock with same rank exists\n        };\n        if superblock \u003e 0 {\n            superblock -= 1;\n        }\n        let mut rank = *superblocks[superblock];\n\n        let first_block = superblock * self.s / 8;\n        for block in first_block..cmp::min(first_block + self.s / 8, self.bits.block_len()) {\n            let b = self.bits.get_block(block);\n            let p = count_all(b) as u64;\n            if rank + p \u003e= j {\n                let mut bit = 0b1;\n                // do not look at unused bits of the last block\n                let max_bit = cmp::min(8, self.bits.len() - block as u64 * 8);\n                for i in 0..max_bit {\n                    rank += is_match(b \u0026 bit) as u64;\n                    if rank == j {\n                        return Some(block as u64 * 8 + i);\n                    }\n                    bit \u003c\u003c= 1;\n                }\n            }\n            rank += p;\n        }\n\n        None\n    }\n\n    /// Alias for `RankSelect::select_1`.\n    pub fn select(\u0026self, j: u64) -\u003e Option\u003cu64\u003e {\n        self.select_1(j)\n    }\n}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum SuperblockRank {\n    First(u64),\n    Some(u64),\n}\n\nimpl Deref for SuperblockRank {\n    type Target = u64;\n\n    fn deref(\u0026self) -\u003e \u0026u64 {\n        match self {\n            SuperblockRank::First(rank) =\u003e rank,\n            SuperblockRank::Some(rank) =\u003e rank,\n        }\n    }\n}\n\nimpl PartialOrd for SuperblockRank {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003ccmp::Ordering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for SuperblockRank {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e cmp::Ordering {\n        let cmp = (**self).cmp(\u0026**other);\n        if cmp == cmp::Ordering::Equal {\n            match (self, other) {\n                (SuperblockRank::First(_), SuperblockRank::Some(_)) =\u003e cmp::Ordering::Less,\n                (SuperblockRank::Some(_), SuperblockRank::First(_)) =\u003e cmp::Ordering::Greater,\n                _ =\u003e cmp,\n            }\n        } else {\n            cmp\n        }\n    }\n}\n\n/// Create `n` superblocks of size `s` from a given bitvector.\nfn superblocks(t: bool, n: usize, s: usize, bits: \u0026BitVec\u003cu8\u003e) -\u003e Vec\u003cSuperblockRank\u003e {\n    let mut superblocks = Vec::with_capacity(n / s + 1);\n    let mut rank: u64 = 0;\n    let mut last_rank = None;\n    let mut i = 0;\n    let nblocks = (bits.len() as f64 / 8.0).ceil() as usize;\n    for block in 0..nblocks {\n        let b = bits.get_block(block);\n        if i % s == 0 {\n            superblocks.push(if Some(rank) != last_rank {\n                SuperblockRank::First(rank)\n            } else {\n                SuperblockRank::Some(rank)\n            });\n            last_rank = Some(rank);\n        }\n        rank += if t {\n            b.count_ones() as u64\n        } else {\n            b.count_zeros() as u64\n        };\n        i += 8;\n    }\n\n    superblocks\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bv::bit_vec;\n    use bv::BitVec;\n    use bv::BitsMut;\n\n    #[test]\n    fn test_select_start() {\n        let mut bits: BitVec\u003cu8\u003e = BitVec::new_fill(false, 900);\n        bits.set_bit(64, true);\n\n        let rs = RankSelect::new(bits, 1);\n\n        assert_eq!(rs.select_1(1), Some(64));\n    }\n\n    #[test]\n    fn test_select_end() {\n        let mut bits: BitVec\u003cu8\u003e = BitVec::new_fill(false, 900);\n        bits.set_bit(50, true);\n\n        let rs = RankSelect::new(bits, 1);\n        assert_eq!(rs.select_1(1).unwrap(), 50);\n    }\n\n    #[test]\n    fn test_rank_select() {\n        let mut bits: BitVec\u003cu8\u003e = BitVec::new_fill(false, 64);\n        bits.set_bit(5, true);\n        bits.set_bit(32, true);\n        let rs = RankSelect::new(bits, 1);\n        assert_eq!(rs.rank_1(1).unwrap(), 0);\n        assert_eq!(rs.rank_1(5).unwrap(), 1);\n        assert_eq!(rs.rank_1(6).unwrap(), 1);\n        assert_eq!(rs.rank_1(7).unwrap(), 1);\n        assert_eq!(rs.rank_1(32).unwrap(), 2);\n        assert_eq!(rs.rank_1(33).unwrap(), 2);\n        assert_eq!(rs.rank_1(64), None);\n        assert_eq!(rs.select_1(0), None);\n        assert_eq!(rs.select_1(1).unwrap(), 5);\n        assert_eq!(rs.select_1(2).unwrap(), 32);\n        assert_eq!(rs.rank_0(1).unwrap(), 2);\n        assert_eq!(rs.rank_0(4).unwrap(), 5);\n        assert_eq!(rs.rank_0(5).unwrap(), 5);\n        assert_eq!(rs.select_0(0), None);\n        assert_eq!(rs.select_0(1).unwrap(), 0);\n        assert_eq!(rs.get(5), true);\n        assert_eq!(rs.get(1), false);\n        assert_eq!(rs.get(32), true);\n    }\n\n    #[test]\n    fn test_rank_select2() {\n        let mut bits: BitVec\u003cu8\u003e = BitVec::new_fill(false, 64);\n        bits.set_bit(5, true);\n        bits.set_bit(32, true);\n        let rs = RankSelect::new(bits, 1);\n        assert_eq!(rs.select_1(2).unwrap(), 32);\n    }\n\n    #[test]\n    fn test_select() {\n        let bits: BitVec\u003cu8\u003e = bit_vec![true, false];\n        let rs = RankSelect::new(bits, 1);\n\n        assert_eq!(rs.select_0(0), None);\n        assert_eq!(rs.select_1(0), None);\n\n        assert_eq!(rs.select_0(1), Some(1));\n        assert_eq!(rs.select_1(1), Some(0));\n\n        assert_eq!(rs.select_0(2), None);\n        assert_eq!(rs.select_1(2), None);\n    }\n\n    #[test]\n    fn test_single_select() {\n        let bits: BitVec\u003cu8\u003e = bit_vec![true];\n        let rs = RankSelect::new(bits, 1);\n        assert_eq!(rs.select_1(0), None);\n        assert_eq!(rs.select_1(1), Some(0));\n        assert_eq!(rs.select_0(0), None);\n        assert_eq!(rs.select_0(1), None);\n\n        let bits: BitVec\u003cu8\u003e = bit_vec![false];\n        let rs = RankSelect::new(bits, 1);\n        assert_eq!(rs.select_1(1), None);\n        assert_eq!(rs.select_1(0), None);\n        assert_eq!(rs.select_0(0), None);\n        assert_eq!(rs.select_0(1), Some(0));\n        assert_eq!(rs.rank_0(0), Some(1));\n        assert_eq!(rs.rank_1(0), Some(0));\n    }\n\n    #[test]\n    fn test_rank_k() {\n        let mut bits: BitVec\u003cu8\u003e = BitVec::new_fill(false, 72);\n        bits.set_bit(63, true);\n        let rs = RankSelect::new(bits, 2);\n        assert_eq!(rs.rank_1(63), Some(1));\n        assert_eq!(rs.rank_1(64), Some(1));\n        assert_eq!(rs.rank_1(71), Some(1));\n    }\n}\n","traces":[{"line":58,"address":[9705460,9705008,9705445],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":59,"address":[9705054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[9705191,9705091,9705166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[9705184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[9705245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[9705472],"length":1,"stats":{"Line":0},"fn_name":"k"},{"line":74,"address":[9705477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[9705488],"length":1,"stats":{"Line":0},"fn_name":"bits"},{"line":79,"address":[9705496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[9705504],"length":1,"stats":{"Line":0},"fn_name":"get"},{"line":84,"address":[9705518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[9705552],"length":1,"stats":{"Line":0},"fn_name":"rank_1"},{"line":94,"address":[9706344,9705585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[9705621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[9705672,9705595,9705758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[9705698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[9705718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[9705793,9705735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[9705824,9705952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[9705990,9705937,9706114,9706051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[9706154,9706354,9706096,9706502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[9706386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[9706537,9706469,9706507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[9706316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[9706544],"length":1,"stats":{"Line":0},"fn_name":"rank_0"},{"line":123,"address":[4466656,4466675],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":127,"address":[9706640],"length":1,"stats":{"Line":0},"fn_name":"rank"},{"line":128,"address":[9706654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[9706688],"length":1,"stats":{"Line":0},"fn_name":"select_1"},{"line":138,"address":[9706751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[9706712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[4466815,4466800],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":142,"address":[4466903,4466832,4466898],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":152,"address":[9706784],"length":1,"stats":{"Line":0},"fn_name":"select_0"},{"line":153,"address":[9706847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[9706808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[4466912,4466927],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":157,"address":[4467022,4467017,4466944],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":161,"address":[4471158,4471173,4469104,4469078,4467024,4469093],"length":1,"stats":{"Line":0},"fn_name":"select_x\u003cclosure-0,closure-1\u003e"},{"line":168,"address":[4469175,4467095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[4469181,4467101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[4469373,4467293,4467275,4467142,4469222,4469355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[4467277,4469357,4467231,4467295,4469375,4469311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[4469407,4467327,4467383,4469463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[4467385,4469420,4467340,4469465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[4469505,4467425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[4469635,4467555,4467646,4469726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[4467618,4470090,4469767,4469010,4471090,4468010,4467687,4469698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[4468050,4470130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[4468084,4470164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[4468600,4468145,4470225,4470680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[4470317,4468237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[4468245,4470325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[4468969,4471049,4470511,4470692,4468431,4468612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[4468756,4468649,4470836,4470729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[4468744,4470824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[4468816,4470896,4468923,4471003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[4470869,4471042,4468789,4468962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[4471095,4469015,4468979,4471059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[4470065,4467985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[9706880],"length":1,"stats":{"Line":0},"fn_name":"select"},{"line":203,"address":[9706894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[9706928],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":217,"address":[9706953,9706973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[9706959,9706941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[9706979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[9707008],"length":1,"stats":{"Line":0},"fn_name":"partial_cmp"},{"line":226,"address":[9707022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[9707056],"length":1,"stats":{"Line":0},"fn_name":"cmp"},{"line":232,"address":[9707080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[9707163,9707124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[9707271,9707175,9707224,9707269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[9707264,9707226,9707185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[9707239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[9707216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[9707155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[9708653,9707280,9708638],"length":1,"stats":{"Line":0},"fn_name":"superblocks"},{"line":247,"address":[9707361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[9707490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[9707502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[9707514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[9707668,9707526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[9707940,9707750,9708600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[9707972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[9708141,9708001,9708322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[9708201,9708239,9708080,9708167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[9708203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[9708173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[9708262],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[9708471,9708515,9708555,9708150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[9708461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[9708505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[9708530,9708605,9708592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[5121976,5121536],"length":1,"stats":{"Line":0},"fn_name":"test_select_start"},{"line":282,"address":[5121543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[5121591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[5121598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[5121914,5121708,5121887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[5122467,5122016],"length":1,"stats":{"Line":0},"fn_name":"test_select_end"},{"line":292,"address":[5122023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[5122071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[5122078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[5122400,5122188,5122286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[5122496,5127166],"length":1,"stats":{"Line":0},"fn_name":"test_rank_select"},{"line":301,"address":[5122503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[5122557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[5122582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[5122630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[5122711,5122833,5122991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[5123058,5122946,5123253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[5123208,5123516,5123321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[5123779,5123584,5123471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[5123734,5123847,5124042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[5124305,5123997,5124110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[5124373,5124558,5124260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[5124621,5124513,5124807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[5124762,5125065,5124870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[5125328,5125020,5125133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[5125396,5125283,5125591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[5125546,5125854,5125659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[5125922,5126116,5125809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[5126071,5126184,5126358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[5126415,5126576,5126322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[5126553,5126758,5126632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[5126809,5126735,5126937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[5126914,5127103,5126988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[5127676,5127200],"length":1,"stats":{"Line":0},"fn_name":"test_rank_select2"},{"line":327,"address":[5127207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[5127255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[5127277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[5127325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[5127495,5127609,5127394],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[5127712,5127934],"length":1,"stats":{"Line":0},"fn_name":"test_select"},{"line":336,"address":[5127719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[5127858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[5128168,5128231,5127961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[5128479,5128293,5128186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[5128434,5128542,5128716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[5128680,5128773,5128935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[5128902,5129154,5128992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[5129350,5129121,5129211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[5129408,5129610],"length":1,"stats":{"Line":0},"fn_name":"test_single_select"},{"line":351,"address":[5129572,5129415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[5129496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[5129908,5129844,5129637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[5129970,5129863,5130155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[5130110,5130218,5130404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[5130467,5130359,5130626],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[5130782,5130683,5130603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[5130722],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[5130836,5131043,5131106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[5131354,5131061,5131169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[5131417,5131309,5131597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[5131654,5131558,5131815],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[5132033,5131872,5131782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[5132231,5132000,5132090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[5133197,5132304],"length":1,"stats":{"Line":0},"fn_name":"test_rank_k"},{"line":370,"address":[5132311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[5132359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[5132366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[5132720,5132668,5132485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[5132938,5132776,5132687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[5133134,5132995,5132905],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":165},{"path":["/","home","todd","rust-bio","src","data_structures","smallints.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A data structure for a sequence of small integers with a few big integers.\n//! Small ints are stored in type S (e.g. a byte), big ints are stored separately (in type B) in a BTree.\n//! The implementation provides vector-like operations on the data structure (e.g. retrieve a position,\n//! add an integer, etc.).\n//!\n//! # Example\n//!\n//! ```\n//! use bio::data_structures::smallints::SmallInts;\n//! let mut smallints: SmallInts\u003cu8, usize\u003e = SmallInts::new();\n//! smallints.push(3);\n//! smallints.push(4);\n//! smallints.push(255);\n//! smallints.push(305093);\n//! assert_eq!(smallints.get(0).unwrap(), 3);\n//! smallints.set(0, 50000);\n//! let values: Vec\u003cusize\u003e = smallints.iter().collect();\n//! assert_eq!(values, [50000, 4, 255, 305093]);\n//! ```\n\nuse std::collections::BTreeMap;\nuse std::iter::{repeat, Enumerate};\nuse std::mem::size_of;\nuse std::slice;\n\nuse num_integer::Integer;\nuse num_traits::{cast, Bounded, Num, NumCast};\n\n/// Data structure for storing a sequence of small integers with few big ones space efficiently\n/// while supporting classical vector operations.\n#[derive(Serialize, Deserialize)]\npub struct SmallInts\u003cF: Integer + Bounded + NumCast + Copy, B: Integer + NumCast + Copy\u003e {\n    smallints: Vec\u003cF\u003e,\n    bigints: BTreeMap\u003cusize, B\u003e,\n}\n\nimpl\u003cS: Integer + Bounded + NumCast + Copy, B: Integer + NumCast + Copy\u003e Default\n    for SmallInts\u003cS, B\u003e\n{\n    fn default() -\u003e Self {\n        assert!(\n            size_of::\u003cS\u003e() \u003c size_of::\u003cB\u003e(),\n            \"S has to be smaller than B\"\n        );\n        SmallInts {\n            smallints: Vec::new(),\n            bigints: BTreeMap::new(),\n        }\n    }\n}\n\nimpl\u003cS: Integer + Bounded + NumCast + Copy, B: Integer + NumCast + Copy\u003e SmallInts\u003cS, B\u003e {\n    /// Create a new instance.\n    pub fn new() -\u003e Self {\n        Default::default()\n    }\n\n    /// Create a new instance with a given capacity.\n    pub fn with_capacity(n: usize) -\u003e Self {\n        assert!(\n            size_of::\u003cS\u003e() \u003c size_of::\u003cB\u003e(),\n            \"S has to be smaller than B\"\n        );\n        SmallInts {\n            smallints: Vec::with_capacity(n),\n            bigints: BTreeMap::new(),\n        }\n    }\n\n    /// Create a new instance containing `n` times the integer `v` (and `v` is expected to be small).\n    pub fn from_elem(v: S, n: usize) -\u003e Self {\n        assert!(\n            size_of::\u003cS\u003e() \u003c size_of::\u003cB\u003e(),\n            \"S has to be smaller than B\"\n        );\n        if v \u003e cast(0).unwrap() {\n            assert!(v \u003c S::max_value(), \"v has to be smaller than maximum value\");\n        }\n\n        SmallInts {\n            smallints: repeat(v).take(n).collect(),\n            bigints: BTreeMap::new(),\n        }\n    }\n\n    /// Return the integer at position `i`.\n    pub fn get(\u0026self, i: usize) -\u003e Option\u003cB\u003e {\n        if i \u003c self.smallints.len() {\n            self.real_value(i, self.smallints[i])\n        } else {\n            None\n        }\n    }\n\n    /// Append `v` to the sequence. This will determine whether `v` is big or small and store it accordingly.\n    pub fn push(\u0026mut self, v: B) {\n        let maxv: S = S::max_value();\n        match cast(v) {\n            Some(v) if v \u003c maxv =\u003e self.smallints.push(v),\n            _ =\u003e {\n                let i = self.smallints.len();\n                self.smallints.push(maxv);\n                self.bigints.insert(i, v);\n            }\n        }\n    }\n\n    /// Set value of position `i` to `v`. This will determine whether `v` is big or small and store it accordingly.\n    pub fn set(\u0026mut self, i: usize, v: B) {\n        let maxv: S = S::max_value();\n        match cast(v) {\n            Some(v) if v \u003c maxv =\u003e self.smallints[i] = v,\n            _ =\u003e {\n                self.smallints[i] = maxv;\n                self.bigints.insert(i, v);\n            }\n        }\n    }\n\n    /// Iterate over sequence. Values will be returned in the big integer type (`B`).\n    pub fn iter(\u0026self) -\u003e Iter\u003c'_, S, B\u003e {\n        Iter {\n            smallints: self,\n            items: self.smallints.iter().enumerate(),\n        }\n    }\n\n    /// Decompress into a normal vector of big integers (type `B`).\n    pub fn decompress(\u0026self) -\u003e Vec\u003cB\u003e {\n        self.iter().collect()\n    }\n\n    /// Length of the sequence.\n    pub fn len(\u0026self) -\u003e usize {\n        self.smallints.len()\n    }\n\n    /// is the sequence empty?\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.smallints.is_empty()\n    }\n\n    fn real_value(\u0026self, i: usize, v: S) -\u003e Option\u003cB\u003e {\n        if v \u003c S::max_value() {\n            cast(v)\n        } else {\n            self.bigints.get(\u0026i).cloned()\n        }\n    }\n}\n\n/// Iterator over the elements of a `SmallInts` sequence.\npub struct Iter\u003c'a, S, B\u003e\nwhere\n    S: Integer + Bounded + NumCast + Copy,\n    B: Integer + NumCast + Copy,\n    \u003cS as Num\u003e::FromStrRadixErr: 'a,\n    \u003cB as Num\u003e::FromStrRadixErr: 'a,\n{\n    smallints: \u0026'a SmallInts\u003cS, B\u003e,\n    items: Enumerate\u003cslice::Iter\u003c'a, S\u003e\u003e,\n}\n\nimpl\u003c'a, S, B\u003e Iterator for Iter\u003c'a, S, B\u003e\nwhere\n    S: 'a + Integer + Bounded + NumCast + Copy,\n    B: 'a + Integer + NumCast + Copy,\n    \u003cS as Num\u003e::FromStrRadixErr: 'a,\n    \u003cB as Num\u003e::FromStrRadixErr: 'a,\n{\n    type Item = B;\n\n    fn next(\u0026mut self) -\u003e Option\u003cB\u003e {\n        match self.items.next() {\n            Some((i, \u0026v)) =\u003e self.smallints.real_value(i, v),\n            None =\u003e None,\n        }\n    }\n}\n\n#[cfg(tests)]\nmod tests {\n    #[test]\n    fn test_serde() {\n        use serde::{Deserialize, Serialize};\n        fn impls_serde_traits\u003cS: Serialize + Deserialize\u003e() {}\n\n        impls_serde_traits::\u003cSmallInts\u003ci8, isize\u003e\u003e();\n    }\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":54},{"path":["/","home","todd","rust-bio","src","data_structures","suffix_array.rs"],"content":"// Copyright 2014-2016 Johannes Köster, Taylor Cramer.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Suffix arrays and related algorithms.\n//! The implementation is based on the lecture notes\n//! \"Algorithmen auf Sequenzen\", Kopczynski, Marschall, Martin and Rahmann, 2008 - 2015.\n//! The original algorithm desciption can be found in:\n//! [Ge Nong, Sen Zhang, Wai Hong Chan: Two Efficient Algorithms for Linear Time Suffix Array Construction. IEEE Trans. Computers 60(10): 1471–1484 (2011)](https://doi.org/10.1109/TC.2010.188)\n//!\n//! # Examples\n//!\n//! ```\n//! use bio::data_structures::suffix_array::suffix_array;\n//! let text = b\"GCCTTAACATTATTACGCCTA$\";\n//! let pos = suffix_array(text);\n//! assert_eq!(\n//!     pos,\n//!     vec![21, 20, 5, 6, 14, 11, 8, 7, 17, 1, 15, 18, 2, 16, 0, 19, 4, 13, 10, 3, 12, 9]\n//! );\n//! ```\n\nuse std::cmp;\nuse std::fmt::Debug;\nuse std::iter;\nuse std::ops::Deref;\n\nuse num_integer::Integer;\nuse num_traits::{cast, NumCast, Unsigned};\n\nuse bv::{BitVec, Bits, BitsMut};\nuse vec_map::VecMap;\n\nuse crate::alphabets::{Alphabet, RankTransform};\nuse crate::data_structures::smallints::SmallInts;\n\npub type LCPArray = SmallInts\u003ci8, isize\u003e;\npub type RawSuffixArray = Vec\u003cusize\u003e;\npub type RawSuffixArraySlice\u003c'a\u003e = \u0026'a [usize];\n\n/// A trait exposing general functionality of suffix arrays.\npub trait SuffixArray {\n    fn get(\u0026self, index: usize) -\u003e Option\u003cusize\u003e;\n    fn len(\u0026self) -\u003e usize;\n    fn is_empty(\u0026self) -\u003e bool;\n\n    // /// Sample the suffix array with the given sample rate.\n    // ///\n    // /// # Arguments\n    // ///\n    // /// * `bwt` - the corresponding BWT\n    // /// * `less` - the corresponding less array\n    // /// * `occ` - the corresponding occ table\n    // /// * `sampling_rate` - if sampling rate is k, every k-th entry will be kept\n    // ///\n    // /// # Example\n    // ///\n    // /// ```\n    // /// use bio::data_structures::suffix_array::{suffix_array, SuffixArray};\n    // /// use bio::data_structures::bwt::{bwt, less, Occ};\n    // /// use bio::alphabets::dna;\n    // ///\n    // /// let text = b\"ACGCGAT$\";\n    // /// let alphabet = dna::n_alphabet();\n    // /// let sa = suffix_array(text);\n    // /// let bwt = bwt(text, \u0026sa);\n    // /// let less = less(\u0026bwt, \u0026alphabet);\n    // /// let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n    // /// let sampled = sa.sample(\u0026bwt, \u0026less, \u0026occ, 1);\n    // ///\n    // /// for i in 0..sa.len() {\n    // ///    assert_eq!(sa.get(i), sampled.get(i));\n    // /// }\n    // /// ```\n    // fn sample\u003cDBWT: DerefBWT, DLess: DerefLess, DOcc: DerefOcc\u003e\n    //     (\u0026self, bwt: DBWT, less: DLess, occ: DOcc, sampling_rate: usize) -\u003e\n    //     SampledSuffixArray\u003cDBWT, DLess, DOcc\u003e {\n    //\n    //     let mut sample = Vec::with_capacity((self.len() as f32 / sampling_rate as f32).ceil() as usize);\n    //     for i in 0..self.len() {\n    //         if (i % sampling_rate) == 0 {\n    //             sample.push(self.get(i).unwrap());\n    //         }\n    //     }\n    //\n    //     SampledSuffixArray {\n    //         bwt: bwt,\n    //         less: less,\n    //         occ: occ,\n    //         sample: sample,\n    //         s: sampling_rate,\n    //     }\n    // }\n}\n\n// /// A sampled suffix array.\n// pub struct SampledSuffixArray\u003cDBWT: DerefBWT, DLess: DerefLess, DOcc: DerefOcc\u003e {\n//     bwt: DBWT,\n//     less: DLess,\n//     occ: DOcc,\n//     sample: Vec\u003cusize\u003e,\n//     s: usize, // Rate of sampling\n// }\n\nimpl SuffixArray for RawSuffixArray {\n    fn get(\u0026self, index: usize) -\u003e Option\u003cusize\u003e {\n        // Explicitly written out because Vec::get(index) generates a recursion warning\n        if index \u003c self.len() {\n            Some(self[index])\n        } else {\n            None\n        }\n    }\n\n    fn len(\u0026self) -\u003e usize {\n        Vec::len(self)\n    }\n\n    fn is_empty(\u0026self) -\u003e bool {\n        Vec::is_empty(self)\n    }\n\n    // fn sample\u003cDBWT: DerefBWT, DLess: DerefLess, DOcc: DerefOcc\u003e\n    //     (\u0026self, bwt: DBWT, less: DLess, occ: DOcc, sampling_rate: usize) -\u003e\n    //     SampledSuffixArray\u003cDBWT, DLess, DOcc\u003e {\n    //     // Provide a specialized, faster implementation using iterators.\n    //\n    //     let sample = self.iter().cloned().step(sampling_rate).collect();\n    //\n    //     SampledSuffixArray {\n    //         bwt: bwt,\n    //         less: less,\n    //         occ: occ,\n    //         sample: sample,\n    //         s: sampling_rate,\n    //     }\n    // }\n}\n\n// impl\u003cDBWT: DerefBWT, DLess: DerefLess, DOcc: DerefOcc\u003e SuffixArray for SampledSuffixArray\u003cDBWT, DLess, DOcc\u003e {\n//     fn get(\u0026self, index: usize) -\u003e Option\u003cusize\u003e {\n//         if index \u003c self.len() {\n//             let mut pos = index;\n//             let mut offset = 0;\n//             loop {\n//                 if pos % self.s == 0 {\n//                     return Some(self.sample[pos / self.s] + offset);\n//                 }\n//\n//                 let c = self.bwt[pos];\n//                 pos = self.less[c as usize] + self.occ.get(\u0026self.bwt, pos - 1, c);\n//                 offset += 1;\n//             }\n//         } else {\n//             None\n//         }\n//     }\n//\n//     fn len(\u0026self) -\u003e usize {\n//         self.bwt.len()\n//     }\n\n//     fn is_empty(\u0026self) -\u003e bool {\n//         self.bwt.is_empty()\n//     }\n// }\n//\n//\n// impl\u003cDBWT: DerefBWT, DLess: DerefLess, DOcc: DerefOcc\u003e SampledSuffixArray\u003cDBWT, DLess, DOcc\u003e {\n//     pub fn sampling_rate(\u0026self) -\u003e usize {\n//         self.s\n//     }\n// }\n\n/// Construct suffix array for given text of length n.\n/// Complexity: O(n).\n/// This is an implementation of the induced sorting as presented by\n/// Ge Nong, Sen Zhang und Wai Hong Chan (2009), also known as SAIS.\n/// The implementation is based on the following lecture notes:\n/// http://ls11-www.cs.tu-dortmund.de/people/rahmann/algoseq.pdf\n///\n/// The idea is to first mark positions as L or S, with L being a position\n/// the suffix of which is lexicographically larger than that of the next position.\n/// Then, LMS-positions (leftmost S) are S-positions right to an L-position.\n/// An LMS substring is the substring from one LMS position to the next (inclusive).\n/// The algorithm works as follows:\n///\n/// 1. Sort LMS positions: first step 2 is applied to the unsorted sequence\n///    of positions. Surprisingly, this sorts the LMS substrings. If all substrings\n///    are different, LMS positions (and their suffixes) are sorted. Else, a reduced\n///    text is build (at most half the size of the original text) and we recurse into\n///    suffix array construction on the reduced text, yielding the sorted LMS positions.\n/// 2. Derive the order of the other positions/suffixes from the (sorted) LMS positions.\n///    For this, the (still empty) suffix array is partitioned into buckets.\n///    Each bucket denotes an interval of suffixes with the same first symbol.\n///    We know that the L-suffixes have to occur first in the buckets, because they\n///    have to be lexicographically smaller than the S-suffixes with the same first letter.\n///    The LMS-positions can now be used to insert the L-positions in the correct order\n///    into the buckets.\n///    Then, the S-positions can be inserted, again using the already existing entries\n///    in the array.\n///\n/// # Arguments\n///\n/// * `text` - the text, ended by sentinel symbol (being lexicographically smallest). The text may\n///   also contain multiple sentinel symbols, used to concatenate multiple sequences without mixing\n///   their suffixes together.\n///\n/// # Example\n///\n/// ```\n/// use bio::data_structures::suffix_array::suffix_array;\n/// let text = b\"GCCTTAACATTATTACGCCTA$\";\n/// let pos = suffix_array(text);\n/// assert_eq!(\n///     pos,\n///     vec![21, 20, 5, 6, 14, 11, 8, 7, 17, 1, 15, 18, 2, 16, 0, 19, 4, 13, 10, 3, 12, 9]\n/// );\n/// ```\npub fn suffix_array(text: \u0026[u8]) -\u003e RawSuffixArray {\n    let n = text.len();\n    let alphabet = Alphabet::new(text);\n    let sentinel_count = sentinel_count(text);\n    let mut sais = SAIS::new(n);\n\n    match alphabet.len() + sentinel_count {\n        a if a \u003c= std::u8::MAX as usize =\u003e {\n            sais.construct(\u0026transform_text::\u003cu8\u003e(text, \u0026alphabet, sentinel_count))\n        }\n        a if a \u003c= std::u16::MAX as usize =\u003e {\n            sais.construct(\u0026transform_text::\u003cu16\u003e(text, \u0026alphabet, sentinel_count))\n        }\n        a if a \u003c= std::u32::MAX as usize =\u003e {\n            sais.construct(\u0026transform_text::\u003cu32\u003e(text, \u0026alphabet, sentinel_count))\n        }\n        _ =\u003e sais.construct(\u0026transform_text::\u003cu64\u003e(text, \u0026alphabet, sentinel_count)),\n    }\n\n    sais.pos\n}\n\n/// Construct lcp array for given text and suffix array of length n.\n/// Complexity: O(n).\n///\n/// # Arguments\n///\n/// * `text` - the text ended by sentinel symbol (being lexicographically smallest)\n/// * `pos` - the suffix array for the text\n///\n/// # Example\n///\n/// ```\n/// use bio::data_structures::suffix_array::{lcp, suffix_array};\n/// let text = b\"GCCTTAACATTATTACGCCTA$\";\n/// let pos = suffix_array(text);\n///\n/// // obtain compressed LCP array\n/// let lcp = lcp(text, \u0026pos);\n///\n/// // get most values in O(1).\n/// assert_eq!(lcp.get(6).unwrap(), 4);\n///\n/// // obtain uncompressed LCP array.\n/// let uncompressed = lcp.decompress();\n/// assert_eq!(\n///     uncompressed,\n///     [-1, 0, 1, 1, 2, 1, 4, 0, 1, 3, 1, 1, 2, 0, 4, 0, 2, 2, 2, 1, 3, 3, -1]\n/// )\n/// ```\npub fn lcp\u003cSA: Deref\u003cTarget = RawSuffixArray\u003e\u003e(text: \u0026[u8], pos: SA) -\u003e LCPArray {\n    assert_eq!(text.len(), pos.len());\n    let n = text.len();\n\n    // provide the lexicographical rank for each suffix\n    let mut rank: Vec\u003cusize\u003e = iter::repeat(0).take(n).collect();\n    for (r, p) in pos.iter().enumerate() {\n        rank[*p] = r;\n    }\n\n    let mut lcp = SmallInts::from_elem(-1, n + 1);\n    let mut l = 0usize;\n    for (p, \u0026r) in rank.iter().enumerate().take(n - 1) {\n        // since the sentinel has rank 0 and is excluded above,\n        // we will never have a negative index below\n        let pred = pos[r - 1];\n        while pred + l \u003c n \u0026\u0026 p + l \u003c n \u0026\u0026 text[p + l] == text[pred + l] {\n            l += 1;\n        }\n        lcp.set(r, l as isize);\n        l = if l \u003e 0 { l - 1 } else { 0 };\n    }\n\n    lcp\n}\n\n/// Calculate all locally shortest unique substrings from a given suffix and lcp array\n/// (Ohlebusch (2013). \"Bioinformatics Algorithms\". ISBN 978-3-00-041316-2).\n/// Complexity: O(n)\n///\n/// # Arguments\n///\n/// * `pos` - the suffix array\n/// * `lcp` - the lcp array\n///\n/// # Returns\n///\n/// An vector of the length of the shortest unique substring for each position of the text.\n/// Suffixes are excluded. If no unique substring starts at a given position, the entry is `None`.\n///\n/// # Example\n///\n/// ```\n/// use bio::data_structures::suffix_array::{lcp, shortest_unique_substrings, suffix_array};\n/// let text = b\"GCTGCTA$\";\n/// let pos = suffix_array(text);\n///\n/// // obtain compressed LCP array\n/// let lcp = lcp(text, \u0026pos);\n///\n/// // calculate shortest unique substrings\n/// let sus = shortest_unique_substrings(\u0026pos, \u0026lcp);\n/// assert_eq!(\n///     sus,\n///     [\n///         Some(4),\n///         Some(3),\n///         Some(2),\n///         Some(4),\n///         Some(3),\n///         Some(2),\n///         Some(1),\n///         Some(1)\n///     ]\n/// );\n/// ```\npub fn shortest_unique_substrings\u003cSA: SuffixArray\u003e(pos: \u0026SA, lcp: \u0026LCPArray) -\u003e Vec\u003cOption\u003cusize\u003e\u003e {\n    let n = pos.len();\n    // Initialize array representing the length of the shortest unique substring starting at position i\n    let mut sus = vec![None; n];\n    for i in 0..n {\n        // The longest common prefixes (LCP) of suffix pos[i] with its predecessor and successor are not unique.\n        // In turn the their maximum + 1 is the length of the shortest unique substring starting at pos[i].\n        let len = 1 + cmp::max(lcp.get(i).unwrap(), lcp.get(i + 1).unwrap_or(0)) as usize;\n        let p = pos.get(i).unwrap();\n        // Check if the suffix pos[i] is a prefix of pos[i+1]. In that case, there is no unique substring\n        // at this position.\n        if n - p \u003e= len {\n            sus[p] = Some(len);\n        }\n    }\n    sus\n}\n\n/// Return last character of the text (expected to be the sentinel).\nfn sentinel(text: \u0026[u8]) -\u003e u8 {\n    text[text.len() - 1]\n}\n\n/// Count the sentinels occurring in the text given that the last character is the sentinel.\nfn sentinel_count(text: \u0026[u8]) -\u003e usize {\n    let sentinel = sentinel(text);\n    assert!(\n        text.iter().all(|\u0026a| a \u003e= sentinel),\n        \"Expecting extra sentinel symbol being lexicographically smallest at the end of the \\\n         text.\"\n    );\n\n    text.iter()\n        .fold(0, |count, \u0026a| count + (a == sentinel) as usize)\n}\n\n/// Transform the given text into integers for usage in `SAIS`.\nfn transform_text\u003cT: Integer + Unsigned + NumCast + Copy + Debug\u003e(\n    text: \u0026[u8],\n    alphabet: \u0026Alphabet,\n    sentinel_count: usize,\n) -\u003e Vec\u003cT\u003e {\n    let sentinel = sentinel(text);\n    let transform = RankTransform::new(alphabet);\n    let offset = sentinel_count - 1;\n\n    let mut transformed: Vec\u003cT\u003e = Vec::with_capacity(text.len());\n    let mut s = sentinel_count;\n    for \u0026a in text.iter() {\n        if a == sentinel {\n            s -= 1;\n            transformed.push(cast(s).unwrap());\n        } else {\n            transformed\n                .push(cast(*(transform.ranks.get(a as usize)).unwrap() as usize + offset).unwrap());\n        }\n    }\n\n    transformed\n}\n\n/// SAIS implementation (see function `suffix_array` for description).\nstruct SAIS {\n    pos: Vec\u003cusize\u003e,\n    lms_pos: Vec\u003cusize\u003e,\n    reduced_text_pos: Vec\u003cusize\u003e,\n    bucket_sizes: VecMap\u003cusize\u003e,\n    bucket_start: Vec\u003cusize\u003e,\n    bucket_end: Vec\u003cusize\u003e,\n}\n\nimpl SAIS {\n    /// Create a new instance.\n    fn new(n: usize) -\u003e Self {\n        SAIS {\n            pos: Vec::with_capacity(n),\n            lms_pos: Vec::with_capacity(n),\n            reduced_text_pos: vec![0; n],\n            bucket_sizes: VecMap::new(),\n            bucket_start: Vec::with_capacity(n),\n            bucket_end: Vec::with_capacity(n),\n        }\n    }\n\n    /// Init buckets.\n    fn init_bucket_start\u003cT: Integer + Unsigned + NumCast + Copy\u003e(\u0026mut self, text: \u0026[T]) {\n        self.bucket_sizes.clear();\n        self.bucket_start.clear();\n\n        for \u0026c in text.iter() {\n            if !self.bucket_sizes.contains_key(cast(c).unwrap()) {\n                self.bucket_sizes.insert(cast(c).unwrap(), 0);\n            }\n            *(self.bucket_sizes.get_mut(cast(c).unwrap()).unwrap()) += 1;\n        }\n\n        let mut sum = 0;\n        for \u0026size in self.bucket_sizes.values() {\n            self.bucket_start.push(sum);\n            sum += size;\n        }\n    }\n\n    /// Initialize pointers to the last element of the buckets.\n    fn init_bucket_end\u003cT: Integer + Unsigned + NumCast + Copy\u003e(\u0026mut self, text: \u0026[T]) {\n        self.bucket_end.clear();\n        for \u0026r in self.bucket_start[1..].iter() {\n            self.bucket_end.push(r - 1);\n        }\n        self.bucket_end.push(text.len() - 1);\n    }\n\n    /// Check if two LMS substrings are equal.\n    fn lms_substring_eq\u003cT: Integer + Unsigned + NumCast + Copy\u003e(\n        \u0026self,\n        text: \u0026[T],\n        pos_types: \u0026PosTypes,\n        i: usize,\n        j: usize,\n    ) -\u003e bool {\n        for k in 0.. {\n            let lmsi = pos_types.is_lms_pos(i + k);\n            let lmsj = pos_types.is_lms_pos(j + k);\n            if text[i + k] != text[j + k] {\n                // different symbols\n                return false;\n            }\n            if lmsi != lmsj {\n                // different length\n                return false;\n            }\n            if k \u003e 0 \u0026\u0026 lmsi \u0026\u0026 lmsj {\n                // same symbols and same length\n                return true;\n            }\n        }\n        false\n    }\n\n    /// Sort LMS suffixes.\n    fn sort_lms_suffixes\u003c\n        T: Integer + Unsigned + NumCast + Copy + Debug,\n        S: Integer + Unsigned + NumCast + Copy + Debug,\n    \u003e(\n        \u0026mut self,\n        text: \u0026[T],\n        pos_types: \u0026PosTypes,\n        lms_substring_count: usize,\n    ) {\n        // if less than 2 LMS substrings are present, no further sorting is needed\n        if lms_substring_count \u003e 1 {\n            // sort LMS suffixes by recursively building SA on reduced text\n            let mut reduced_text: Vec\u003cS\u003e = vec![cast(0).unwrap(); lms_substring_count];\n            let mut label = 0;\n            reduced_text[self.reduced_text_pos[self.pos[0]]] = cast(label).unwrap();\n            let mut prev = None;\n            for \u0026p in \u0026self.pos {\n                if pos_types.is_lms_pos(p) {\n                    // choose same label if substrings are equal\n                    if prev.is_some() \u0026\u0026 !self.lms_substring_eq(text, pos_types, prev.unwrap(), p) {\n                        label += 1;\n                    }\n                    reduced_text[self.reduced_text_pos[p]] = cast(label).unwrap();\n                    prev = Some(p);\n                }\n            }\n\n            // if we have less labels than substrings, we have to sort by recursion\n            // because two or more substrings are equal\n            if label + 1 \u003c lms_substring_count {\n                // backup lms_pos\n                let lms_pos = self.lms_pos.clone();\n                // recurse SA construction for reduced text\n                self.construct(\u0026reduced_text);\n                // obtain sorted lms suffixes\n                self.lms_pos.clear();\n                for \u0026p in \u0026self.pos {\n                    self.lms_pos.push(lms_pos[p]);\n                }\n            } else {\n                // otherwise, lms_pos is updated with the sorted suffixes from pos\n                // obtain sorted lms suffixes\n                self.lms_pos.clear();\n                for \u0026p in \u0026self.pos {\n                    if pos_types.is_lms_pos(p) {\n                        self.lms_pos.push(p);\n                    }\n                }\n            }\n        }\n    }\n\n    /// Construct the suffix array.\n    fn construct\u003cT: Integer + Unsigned + NumCast + Copy + Debug\u003e(\u0026mut self, text: \u0026[T]) {\n        let pos_types = PosTypes::new(text);\n        self.calc_lms_pos(text, \u0026pos_types);\n        self.calc_pos(text, \u0026pos_types);\n    }\n\n    /// Step 1 of the SAIS algorithm.\n    fn calc_lms_pos\u003cT: Integer + Unsigned + NumCast + Copy + Debug\u003e(\n        \u0026mut self,\n        text: \u0026[T],\n        pos_types: \u0026PosTypes,\n    ) {\n        let n = text.len();\n\n        // collect LMS positions\n        self.lms_pos.clear();\n        let mut i = 0;\n        for r in 0..n {\n            if pos_types.is_lms_pos(r) {\n                self.lms_pos.push(r);\n                self.reduced_text_pos[r] = i;\n                i += 1;\n            }\n        }\n\n        // sort LMS substrings by applying step 2 with unsorted LMS positions\n        self.calc_pos(text, pos_types);\n\n        let lms_substring_count = self.lms_pos.len();\n\n        if lms_substring_count \u003c= std::u8::MAX as usize {\n            self.sort_lms_suffixes::\u003cT, u8\u003e(text, pos_types, lms_substring_count);\n        } else if lms_substring_count \u003c= std::u16::MAX as usize {\n            self.sort_lms_suffixes::\u003cT, u16\u003e(text, pos_types, lms_substring_count);\n        } else if lms_substring_count \u003c= std::u32::MAX as usize {\n            self.sort_lms_suffixes::\u003cT, u32\u003e(text, pos_types, lms_substring_count);\n        } else {\n            self.sort_lms_suffixes::\u003cT, u64\u003e(text, pos_types, lms_substring_count);\n        }\n    }\n\n    /// Step 2 of the SAIS algorithm.\n    fn calc_pos\u003cT: Integer + Unsigned + NumCast + Copy\u003e(\n        \u0026mut self,\n        text: \u0026[T],\n        pos_types: \u0026PosTypes,\n    ) {\n        let n = text.len();\n        self.pos.clear();\n\n        self.init_bucket_start(text);\n        self.init_bucket_end(text);\n\n        // init all positions as unknown (n-1 is max position)\n        self.pos.resize(n, n);\n\n        // insert LMS positions to the end of their buckets\n        for \u0026p in self.lms_pos.iter().rev() {\n            let c: usize = cast(text[p]).unwrap();\n            self.pos[self.bucket_end[c]] = p;\n            // subtract without overflow: last -1 will cause overflow, but it does not matter\n            self.bucket_end[c] = self.bucket_end[c].wrapping_sub(1);\n        }\n\n        // reset bucket ends\n        self.init_bucket_end(text);\n\n        // insert L-positions into buckets\n        for r in 0..n {\n            let p = self.pos[r];\n            // ignore undefined positions and the zero since it has no predecessor\n            if p == n || p == 0 {\n                continue;\n            }\n            let pred = p - 1;\n            if pos_types.is_l_pos(pred) {\n                let c: usize = cast(text[pred]).unwrap();\n                self.pos[self.bucket_start[c]] = pred;\n                self.bucket_start[c] += 1;\n            }\n        }\n\n        // insert S-positions into buckets\n        for r in (0..n).rev() {\n            let p = self.pos[r];\n            if p == 0 {\n                continue;\n            }\n            let pred = p - 1;\n            if pos_types.is_s_pos(pred) {\n                let c: usize = cast(text[pred]).unwrap();\n                self.pos[self.bucket_end[c]] = pred;\n                // subtract without overflow: last -1 will cause overflow, but it won't be used\n                self.bucket_end[c] = self.bucket_end[c].wrapping_sub(1);\n            }\n        }\n    }\n}\n\n/// Position types (L or S).\n#[derive(Debug)]\nstruct PosTypes {\n    pos_types: BitVec,\n}\n\nimpl PosTypes {\n    /// Calculate the text position type.\n    /// L-type marks suffixes being lexicographically larger than their successor,\n    /// S-type marks the others.\n    /// This function fills a BitVec, with 1-bits denoting S-type\n    /// and 0-bits denoting L-type.\n    ///\n    /// # Arguments\n    ///\n    /// * `text` - the text, ending with a sentinel.\n    fn new\u003cT: Integer + Unsigned + NumCast + Copy\u003e(text: \u0026[T]) -\u003e Self {\n        let n = text.len();\n        let mut pos_types = BitVec::new_fill(false, n as u64);\n        pos_types.set_bit(n as u64 - 1, true);\n\n        for p in (0..n - 1).rev() {\n            if text[p] == text[p + 1] {\n                // if the characters are equal, the next position determines\n                // the lexicographical order\n                let v = pos_types.get_bit(p as u64 + 1);\n                pos_types.set_bit(p as u64, v);\n            } else {\n                pos_types.set_bit(p as u64, text[p] \u003c text[p + 1]);\n            }\n        }\n\n        PosTypes { pos_types }\n    }\n\n    /// Check if p is S-position.\n    fn is_s_pos(\u0026self, p: usize) -\u003e bool {\n        self.pos_types.get_bit(p as u64)\n    }\n\n    /// Check if p is L-position.\n    fn is_l_pos(\u0026self, p: usize) -\u003e bool {\n        !self.pos_types.get_bit(p as u64)\n    }\n\n    /// Check if p is LMS-position.\n    fn is_lms_pos(\u0026self, p: usize) -\u003e bool {\n        p != 0 \u0026\u0026 self.is_s_pos(p) \u0026\u0026 self.is_l_pos(p - 1)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    // Commented-out imports waiting on re-enabling of sampled suffix array\n    // See issue #70\n    use super::*;\n    use super::{transform_text, PosTypes, SAIS};\n    use crate::alphabets::Alphabet;\n    use bv::{BitVec, BitsPush};\n    //use data_structures::bwt::{bwt, less, Occ};\n    use std::str;\n\n    #[test]\n    fn test_pos_types() {\n        let orig_text = b\"GCCTTAACATTATTACGCCTA$\";\n        let alphabet = Alphabet::new(orig_text);\n        let text: Vec\u003cu8\u003e = transform_text(orig_text, \u0026alphabet, 1);\n        let n = text.len();\n\n        let pos_types = PosTypes::new(\u0026text);\n        //let mut test = BitSlice::from_slice(\u0026[0b01100110, 0b10010011, 0b01100100]).to_owned();\n        let mut test = BitVec::new();\n        test.push_block(0b001001101100100101100110);\n        test.truncate(n as u64);\n        assert_eq!(pos_types.pos_types, test);\n        let lms_pos: Vec\u003cusize\u003e = (0..n).filter(|\u0026p| pos_types.is_lms_pos(p)).collect();\n        assert_eq!(lms_pos, vec![1, 5, 8, 11, 14, 17, 21]);\n    }\n\n    #[test]\n    fn test_buckets() {\n        let orig_text = b\"GCCTTAACATTATTACGCCTA$\";\n        let alphabet = Alphabet::new(orig_text);\n        let text: Vec\u003cu8\u003e = transform_text(orig_text, \u0026alphabet, 1);\n        let n = text.len();\n\n        let mut sais = SAIS::new(n);\n        sais.init_bucket_start(\u0026text);\n        assert_eq!(sais.bucket_start, vec![0, 1, 7, 13, 15]);\n        sais.init_bucket_end(\u0026text);\n        assert_eq!(sais.bucket_end, vec![0, 6, 12, 14, 21]);\n    }\n\n    #[test]\n    fn test_pos() {\n        let orig_text = b\"GCCTTAACATTATTACGCCTA$\";\n        let alphabet = Alphabet::new(orig_text);\n        let text: Vec\u003cu8\u003e = transform_text(orig_text, \u0026alphabet, 1);\n        let n = text.len();\n\n        let mut sais = SAIS::new(n);\n        let pos_types = PosTypes::new(\u0026text);\n        sais.lms_pos = vec![21, 5, 14, 8, 11, 17, 1];\n        sais.calc_pos(\u0026text, \u0026pos_types);\n        assert_eq!(\n            sais.pos,\n            vec![21, 20, 5, 6, 14, 11, 8, 7, 17, 1, 15, 18, 2, 16, 0, 19, 4, 13, 10, 3, 12, 9,]\n        );\n    }\n\n    #[test]\n    fn test_lms_pos() {\n        let orig_text = b\"GCCTTAACATTATTACGCCTA$\";\n        let alphabet = Alphabet::new(orig_text);\n        let text: Vec\u003cu8\u003e = transform_text(orig_text, \u0026alphabet, 1);\n        let n = text.len();\n\n        let mut sais = SAIS::new(n);\n        let pos_types = PosTypes::new(\u0026text);\n        sais.calc_lms_pos(\u0026text, \u0026pos_types);\n    }\n\n    #[test]\n    fn test_issue10_1() {\n        let text = b\"TGTGTGTGTG$\";\n        let pos = suffix_array(text);\n        assert_eq!(pos, [10, 9, 7, 5, 3, 1, 8, 6, 4, 2, 0]);\n    }\n\n    #[test]\n    fn test_issue10_2() {\n        let text = b\"TGTGTGTG$\";\n        let pos = suffix_array(text);\n        assert_eq!(pos, [8, 7, 5, 3, 1, 6, 4, 2, 0]);\n    }\n\n    #[test]\n    fn test_handles_sentinels_properly() {\n        let reads = b\"TACTCCGCTAGGGACACCTAAATAGATACTCGCAAAGGCGACTGATATATCCTTAGGTCGAAGAGATACCAGAGAAATAGTAGGTCTTAGGCTAGTCCTT$AAGGACTAGCCTAAGACCTACTATTTCTCTGGTATCTCTTCGACCTAAGGATATATCAGTCGCCTTTGCGAGTATCTATTTAGGTGTCCCTAGCGGAGTA$TAGGGACACCTAAATAGATACTCGCAAAGGCGACTGATATATCCTTAGGTCGAAGAGATACCAGAGAAATAGTAGGTCTTAGGCTAGTCCTTGTCCAGTA$TACTGGACAAGGACTAGCCTAAGACCTACTATTTCTCTGGTATCTCTTCGACCTAAGGATATATCAGTCGCCTTTGCGAGTATCTATTTAGGTGTCCCTA$ACGCACCCCGGCATTCGTCGACTCTACACTTAGTGGAACATACAAATTCGCTCGCAGGAGCGCCTCATACATTCTAACGCAGTGATCTTCGGCTGAGACT$AGTCTCAGCCGAAGATCACTGCGTTAGAATGTATGAGGCGCTCCTGCGAGCGAATTTGTATGTTCCACTAAGTGTAGAGTCGACGAATGCCGGGGTGCGT$\";\n        suffix_array(reads);\n    }\n\n    fn str_from_pos(sa: \u0026[usize], text: \u0026[u8], index: usize) -\u003e String {\n        String::from(\n            str::from_utf8(\u0026text[sa[index]..])\n                .unwrap()\n                .split('$')\n                .next()\n                .unwrap_or(\"\"),\n        ) + \"$\"\n    }\n\n    #[test]\n    fn test_sorts_lexically() {\n        let test_cases =             [(\u0026b\"A$C$G$T$\"[..], \"simple\"),\n             (\u0026b\"A$A$T$T$\"[..], \"duplicates\"),\n             (\u0026b\"AA$GA$CA$TA$TC$TG$GT$GC$\"[..], \"two letter\"),\n             (\u0026b\"AGCCAT$\\\n                CAGCC$\"[..],\n                \"substring\"),\n             (\u0026b\"GTAGGCCTAATTATAATCAGCGGACATTTCGTATTGCTCGGGCTGCCAGGATTTTAGCATCAGTAGCCGGGTAATGGAACCTCAAGAGGTCAGCGTCGAA$\\\n                AATCAGCGGACATTTCGTATTGCTCGGGCTGCCAGGATTTTAGCATCAGTAGCCGGGTAATGGAACCTCAAGAGGTCAGCGTCGAATGGCTATTCCAATA$\"[..],\n                \"complex\"),\n             (\u0026b\"GTAGGCCTAATTATAATCAGCGGACATTTCGTATTGCTCGGGCTGCCAGGATTTTAGCATCAGTAGCCGGGTAATGGAACCTCAAGAGGTCAGCGTCGAA$\\\n                TTCGACGCTGACCTCTTGAGGTTCCATTACCCGGCTACTGATGCTAAAATCCTGGCAGCCCGAGCAATACGAAATGTCCGCTGATTATAATTAGGCCTAC$\\\n                AATCAGCGGACATTTCGTATTGCTCGGGCTGCCAGGATTTTAGCATCAGTAGCCGGGTAATGGAACCTCAAGAGGTCAGCGTCGAATGGCTATTCCAATA$\\\n                TATTGGAATAGCCATTCGACGCTGACCTCTTGAGGTTCCATTACCCGGCTACTGATGCTAAAATCCTGGCAGCCCGAGCAATACGAAATGTCCGCTGATT$\"[..],\n                \"complex with revcomps\"),\n             ];\n\n        for \u0026(text, test_name) in test_cases.iter() {\n            let pos = suffix_array(text);\n            for i in 0..(pos.len() - 2) {\n                // Check that every element in the suffix array is lexically \u003c= the next elem\n                let cur = str_from_pos(\u0026pos, \u0026text, i);\n                let next = str_from_pos(\u0026pos, \u0026text, i + 1);\n\n                assert!(\n                    cur \u003c= next,\n                    format!(\n                        \"Failed:\\n{}\\n{}\\nat positions {} and {} are out of order in \\\n                         test: {}\",\n                        cur,\n                        next,\n                        pos[i],\n                        pos[i + 1],\n                        test_name\n                    )\n                );\n            }\n        }\n    }\n\n    // #[test]\n    // fn test_sampled_matches() {\n    //     let test_cases =             [(\u0026b\"A$C$G$T$\"[..], \"simple\"),\n    //          (\u0026b\"A$A$T$T$\"[..], \"duplicates\"),\n    //          (\u0026b\"AA$GA$CA$TA$TC$TG$GT$GC$\"[..], \"two letter\"),\n    //          (\u0026b\"AGCCAT$\\\n    //             CAGCC$\"[..],\n    //             \"substring\"),\n    //          (\u0026b\"GTAGGCCTAATTATAATCAGCGGACATTTCGTATTGCTCGGGCTGCCAGGATTTTAGCATCAGTAGCCGGGTAATGGAACCTCAAGAGGTCAGCGTCGAA$\\\n    //             AATCAGCGGACATTTCGTATTGCTCGGGCTGCCAGGATTTTAGCATCAGTAGCCGGGTAATGGAACCTCAAGAGGTCAGCGTCGAATGGCTATTCCAATA$\"[..],\n    //             \"complex\"),\n    //          (\u0026b\"GTAGGCCTAATTATAATCAGCGGACATTTCGTATTGCTCGGGCTGCCAGGATTTTAGCATCAGTAGCCGGGTAATGGAACCTCAAGAGGTCAGCGTCGAA$\\\n    //             TTCGACGCTGACCTCTTGAGGTTCCATTACCCGGCTACTGATGCTAAAATCCTGGCAGCCCGAGCAATACGAAATGTCCGCTGATTATAATTAGGCCTAC$\\\n    //             AATCAGCGGACATTTCGTATTGCTCGGGCTGCCAGGATTTTAGCATCAGTAGCCGGGTAATGGAACCTCAAGAGGTCAGCGTCGAATGGCTATTCCAATA$\\\n    //             TATTGGAATAGCCATTCGACGCTGACCTCTTGAGGTTCCATTACCCGGCTACTGATGCTAAAATCCTGGCAGCCCGAGCAATACGAAATGTCCGCTGATT$\"[..],\n    //             \"complex with revcomps\"),\n    //          ];\n    //\n    //     for \u0026(text, _) in test_cases.into_iter() {\n    //         let alphabet = dna::n_alphabet();\n    //         let sa = suffix_array(text);\n    //         let bwt = bwt(text, \u0026sa);\n    //         let less = less(\u0026bwt, \u0026alphabet);\n    //         let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n    //         let sampled = sa.sample(\u0026bwt, \u0026less, \u0026occ, 2);\n    //\n    //         for i in 0..sa.len() {\n    //             assert_eq!(sa.get(i), sampled.get(i));\n    //         }\n    //     }\n    // }\n}\n","traces":[{"line":107,"address":[4472752],"length":1,"stats":{"Line":0},"fn_name":"get"},{"line":109,"address":[4472811,4472776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[4472823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[4472802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[4472880],"length":1,"stats":{"Line":0},"fn_name":"len"},{"line":117,"address":[4472889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[4472912],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":121,"address":[4472921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[4513392,4514834],"length":1,"stats":{"Line":0},"fn_name":"suffix_array"},{"line":222,"address":[4513451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[4513480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[4513503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[4513544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[4513599,4513723,4513683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[4513691,4513809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[4513841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[4514073,4513755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[4514105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[4514291,4514018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[4514323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[4514453,4514266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[4513973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[4514864],"length":1,"stats":{"Line":0},"fn_name":"sentinel"},{"line":357,"address":[4515000,4515018,4514888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[4515024],"length":1,"stats":{"Line":0},"fn_name":"sentinel_count"},{"line":362,"address":[4515048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[4515153,4515119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[4515067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[4515203,4515135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[4515193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[5759496,5757396,5755376,5757440,5756400,5756362,5758436,5758480],"length":1,"stats":{"Line":0},"fn_name":"transform_text\u003cu32\u003e"},{"line":379,"address":[5755485,5756506,5758589,5757546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[5756533,5757573,5758616,5755512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[5755533,5756615,5756551,5758637,5757655,5757591,5755603,5758710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[5758798,5755584,5758688,5756700,5756596,5755688,5757740,5757636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[5755723,5758833,5756732,5757772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[5758001,5759307,5755846,5758962,5757780,5757895,5755952,5758841,5756740,5755731,5758245,5756855,5756182,5759068,5756961,5757205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[5757203,5758243,5759105,5758431,5759491,5756998,5758038,5755989,5756357,5757391,5756180,5759305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[5758145,5757037,5758077,5756092,5756028,5759212,5759144,5757103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[5756065,5759181,5757144,5756133,5759255,5758114,5757074,5758188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[5759480,5757377,5756346,5758417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[5755997,5757006,5756192,5759113,5758046,5759317,5758255,5757215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[4515232,4515785,4515770],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":412,"address":[4515261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[4515276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[4515296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[4515357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[4515403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[4515461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[5762400,5760480,5761440,5759536],"length":1,"stats":{"Line":0},"fn_name":"init_bucket_start\u003cu32\u003e"},{"line":423,"address":[5760535,5761495,5762455,5759591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[5760552,5762472,5759608,5761512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[5762112,5762498,5760578,5759823,5760199,5760767,5759634,5761157,5761538,5761727,5762687,5763068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[5761767,5759863,5760810,5761004,5762918,5760050,5762730,5761960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[5760930,5762847,5761886,5759979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[5760204,5761977,5761162,5763073,5762936,5760067,5762117,5761022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[5760725,5759781,5762645,5761685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[5761397,5761697,5760737,5760343,5762657,5761192,5762147,5760234,5759793,5761301,5763212,5762352,5763103,5763308,5762256,5760439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[5763252,5760383,5762296,5761341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[5762387,5760406,5761364,5762357,5760474,5760444,5763343,5761432,5762319,5763313,5763275,5761402],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[5763344,5764784,5763824,5764304],"length":1,"stats":{"Line":0},"fn_name":"init_bucket_end\u003cu8\u003e"},{"line":442,"address":[5764350,5763870,5763390,5764830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[5764688,5764848,5764577,5765168,5765057,5764368,5764097,5763728,5763888,5763408,5763617,5764208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[5763652,5765092,5764132,5764612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[5764548,5763588,5765178,5764218,5763738,5765028,5764698,5764068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[5766064,5765264,5766864,5767664],"length":1,"stats":{"Line":0},"fn_name":"lms_substring_eq\u003cu32\u003e"},{"line":457,"address":[5766944,5766250,5767050,5766144,5765450,5768443,5766051,5765344,5767744,5767850,5766851,5767651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[5765487,5767887,5766287,5767087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[5765572,5766372,5767172,5767972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[5768057,5766457,5765657,5767257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[5765943,5768335,5767543,5766743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[5767532,5766732,5768324,5765932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[5767578,5768370,5765978,5766778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[5766770,5765970,5766785,5767570,5768362,5765985,5767585,5768377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[5767656,5766056,5766856,5768448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[5767035,5766235,5767835,5765435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[5768464,5778664,5780736,5770512,5788873,5786864,5799120,5784777,5797047,5790960,5772520,5788912,5801128,5786825,5774569,5793008,5792969,5778704,5799079,5784816,5780695,5782768,5772560,5774608,5770473,5776617,5790920,5797088,5795017,5782727,5795056,5776656],"length":1,"stats":{"Line":0},"fn_name":"sort_lms_suffixes\u003cu32,u16\u003e"},{"line":487,"address":[5799207,5778791,5793095,5774695,5797175,5786951,5772647,5768551,5776743,5784903,5788999,5780823,5795143,5791047,5782855,5770599],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[5795154,5776754,5774706,5782866,5784914,5791058,5770610,5799218,5768562,5778802,5789010,5772658,5780834,5797186,5786962,5793106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[5778886,5774804,5785004,5772748,5776853,5770709,5797270,5780918,5795238,5791148,5768660,5789109,5793204,5782964,5787052,5799317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[5797286,5791164,5774945,5789125,5799459,5774820,5797401,5795254,5770851,5780934,5799333,5795369,5782980,5772887,5772764,5783105,5781049,5776995,5768801,5787068,5779017,5791287,5789251,5785020,5776869,5768676,5793220,5793345,5770725,5785143,5778902,5787191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[5787358,5795538,5768968,5779186,5771020,5799628,5775112,5791454,5781218,5773054,5785310,5789420,5793512,5777164,5783272,5797570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[5771775,5785322,5771208,5795550,5781406,5779948,5777176,5784030,5771032,5796300,5797758,5781230,5781980,5799816,5773822,5800383,5798332,5775300,5775124,5791642,5789608,5786078,5791466,5793700,5797582,5777352,5777919,5787370,5793524,5779198,5787546,5775870,5799640,5788126,5779374,5769726,5773242,5783284,5768980,5769156,5795726,5783460,5773066,5789432,5790175,5785498,5792222,5794270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[5781449,5775343,5779417,5793743,5795769,5787589,5773285,5797801,5771251,5789651,5791685,5799859,5777395,5785541,5783503,5769199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[5787856,5795803,5777429,5775377,5799893,5787623,5785808,5773319,5797835,5779684,5798068,5796036,5769466,5779451,5793777,5794010,5777656,5791952,5791719,5789685,5785575,5773552,5775610,5789912,5781716,5771285,5783537,5800120,5783770,5781483,5769233,5771512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[5771475,5795993,5779641,5773554,5783727,5793967,5777658,5791909,5791954,5775567,5789875,5785765,5769423,5779686,5796038,5787813,5783772,5798070,5787858,5781718,5773509,5771514,5775612,5798025,5800122,5800083,5789914,5794012,5785810,5777619,5781673,5769468],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[5775644,5794044,5783804,5777690,5798102,5779718,5785842,5781750,5773586,5791986,5769500,5771546,5789946,5800154,5796070,5787890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[5796248,5775818,5779896,5777867,5771723,5788074,5798280,5794218,5781928,5783978,5790123,5786026,5769674,5792170,5773770,5800331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[5797714,5786717,5777940,5773198,5787502,5792861,5780587,5784669,5790196,5784051,5782619,5792243,5790814,5791598,5798971,5796321,5788765,5779330,5769112,5795682,5786099,5769747,5771796,5775256,5771164,5798353,5776509,5783416,5800404,5782001,5799772,5778558,5794291,5770365,5774461,5796939,5773843,5794909,5801022,5788147,5772414,5775891,5785454,5781362,5779969,5789564,5777308,5793656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[5794365,5796395,5771870,5788221,5782075,5800478,5775965,5773917,5769821,5784125,5792317,5778014,5798427,5790270,5780043,5786173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[5769844,5798450,5790293,5782098,5771893,5794388,5784148,5800501,5775988,5773940,5786196,5788244,5796418,5780066,5778037,5792340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[5776097,5778146,5786305,5792449,5769953,5782207,5780175,5800610,5790402,5772002,5794497,5796527,5774049,5788353,5798559,5784257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[5788517,5790425,5784421,5788619,5800774,5780198,5774072,5778169,5794520,5790668,5798582,5794661,5784523,5784280,5782473,5792613,5786469,5792472,5790566,5780441,5776261,5774315,5796691,5772166,5786571,5796550,5778310,5782371,5769976,5776120,5794763,5772268,5776363,5782230,5770117,5772025,5798825,5800876,5796793,5788376,5800633,5774213,5778412,5798723,5770219,5792715,5780339,5786328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[5772201,5796726,5790601,5770152,5776296,5798758,5792648,5782406,5794696,5780374,5784456,5786504,5800809,5778345,5788552,5774248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[5784099,5788195,5794339,5771844,5780017,5782049,5769795,5796369,5800452,5798401,5792291,5777988,5786147,5773891,5790244,5775939],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[5772535,5776522,5801143,5770378,5774474,5794922,5774347,5798984,5792747,5795032,5784682,5788888,5776395,5790935,5800908,5792984,5780473,5784792,5772427,5784555,5790700,5798857,5780600,5770488,5788651,5772300,5786840,5774584,5796952,5780710,5782742,5770251,5778444,5797062,5788778,5782632,5801035,5782505,5794795,5799094,5778571,5792874,5796825,5786603,5778679,5786730,5776632,5790827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[5778662,5792967,5790918,5770471,5801074,5801126,5776562,5780693,5799077,5799024,5776615,5795015,5786823,5784722,5780640,5772466,5774514,5782725,5788818,5770418,5782672,5784775,5786770,5797045,5794962,5778610,5788871,5772518,5796992,5774567,5792914,5790866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[5770456,5786808,5776600,5772503,5792952,5784760,5799062,5782710,5788856,5778647,5774552,5780678,5795000,5790903,5801111,5797030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[5801623,5801168,5801783,5801303,5801488,5801328,5801463,5801648],"length":1,"stats":{"Line":0},"fn_name":"construct\u003cu32\u003e"},{"line":531,"address":[5801201,5801361,5801681,5801521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[5801390,5801550,5801710,5801230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[5801256,5801576,5801736,5801416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[5802544,5803280,5804016,5801808],"length":1,"stats":{"Line":0},"fn_name":"calc_lms_pos\u003cu16\u003e"},{"line":542,"address":[5802629,5801893,5803365,5804101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[5804125,5802653,5801917,5803389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[5802668,5801932,5803404,5804140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[5802680,5802845,5803581,5802317,5803416,5803053,5803789,5804152,5801944,5804317,5802109,5804525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[5802146,5803757,5803021,5802285,5804354,5804493,5802882,5803618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[5802180,5804388,5803652,5802916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[5803672,5804408,5802936,5802200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[5802984,5803720,5804495,5802248,5803759,5803023,5802287,5804456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[5802830,5802094,5803566,5804302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[5804535,5802327,5803063,5803799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[5803880,5804563,5802408,5804616,5803091,5803144,5803827,5802355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[5804611,5803875,5802403,5803139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[5802368,5802465,5804576,5803104,5804673,5803840,5803937,5803201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[5803932,5802460,5803196,5804668],"length":1,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[5803159,5802533,5804005,5803895,5802529,5804001,5804737,5804741,5804631,5803265,5803269,5802423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[5803996,5802524,5804732,5803260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[5802492,5804700,5803228,5803964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[5812144,5807216,5809680,5804752],"length":1,"stats":{"Line":0},"fn_name":"calc_pos\u003cu32\u003e"},{"line":577,"address":[5812253,5807325,5804861,5809789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[5804891,5809819,5807355,5812283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[5809849,5804921,5812313,5807385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[5807414,5804950,5812342,5809878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[5804971,5812363,5807435,5809899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[5809916,5807452,5805689,5808154,5805249,5804988,5810177,5807713,5810618,5813082,5812380,5812641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[5810220,5807756,5805292,5812684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[5807906,5812834,5810370,5805441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[5808020,5813035,5810484,5805642,5808107,5812948,5805555,5810571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[5810159,5807695,5812623,5805231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[5809019,5810852,5813095,5810631,5813947,5808388,5805923,5806553,5805702,5811483,5813316,5808167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[5808420,5810884,5805955,5813348],"length":1,"stats":{"Line":0},"fn_name":null},{"line":601,"address":[5810940,5808476,5806011,5813404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[5808537,5806072,5813465,5813522,5811058,5811001,5808594,5806129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[5813508,5808580,5808631,5811451,5806166,5813915,5808987,5806115,5811095,5811044,5813559,5806521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[5808658,5811122,5813586,5806193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[5811272,5808808,5813736,5806342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[5813917,5811383,5808989,5808919,5811453,5806523,5813847,5806453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[5812133,5810781,5814078,5809040,5809150,5812138,5814597,5807202,5809674,5806684,5813245,5806574,5813968,5805852,5811614,5809669,5814602,5808317,5807207,5811504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[5814110,5806716,5809182,5811646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[5806755,5811685,5814149,5809221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[5811748,5809284,5814164,5811700,5806818,5809236,5814212,5806770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[5814246,5811782,5811737,5809318,5806807,5806852,5814201,5809273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[5814270,5811806,5809342,5806876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[5809468,5807001,5814396,5811932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[5807091,5814561,5814486,5809633,5809558,5812022,5812097,5807166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":645,"address":[5815910,5818550,5815936,5815925,5814608,5817264,5819878,5818565,5817238,5819893,5818576,5817253],"length":1,"stats":{"Line":0},"fn_name":"new\u003cu16\u003e"},{"line":646,"address":[5814685,5816013,5818653,5817341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[5818683,5817371,5816043,5814715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[5814738,5817394,5816066,5818706],"length":1,"stats":{"Line":0},"fn_name":null},{"line":650,"address":[5816194,5819209,5818834,5816569,5818311,5819631,5817897,5814866,5816991,5817522,5815241,5815663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":651,"address":[5816606,5817233,5817934,5816989,5818309,5815661,5815905,5819629,5818545,5819246,5819873,5815278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[5819512,5815544,5818192,5816872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":655,"address":[5816968,5818288,5815640,5819608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[5819488,5815520,5815681,5818329,5816848,5819649,5817009,5818168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":665,"address":[4515792],"length":1,"stats":{"Line":0},"fn_name":"is_s_pos"},{"line":666,"address":[4515806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[4515840],"length":1,"stats":{"Line":0},"fn_name":"is_l_pos"},{"line":671,"address":[4515854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":675,"address":[4515888],"length":1,"stats":{"Line":0},"fn_name":"is_lms_pos"},{"line":676,"address":[4515912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[5728453,5728448],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":693,"address":[5870007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[5870022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":695,"address":[5870039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[5870074,5870140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[5870233,5870148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":700,"address":[5870248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[5870255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[5870329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[5870561,5870382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[5728494,5728480],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":705,"address":[5870640,5870867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[5728533,5728528],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":710,"address":[5871111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[5871126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":712,"address":[5871143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":713,"address":[5871181,5871250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":715,"address":[5871266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":716,"address":[5871311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[5871408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[5871718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[5871778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":723,"address":[5728565,5728560],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":724,"address":[5872167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[5872182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":726,"address":[5872199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":727,"address":[5872237,5872306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":729,"address":[5872322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":730,"address":[5872367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":731,"address":[5872708,5872474,5872625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":732,"address":[5872793,5872665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":733,"address":[5873106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[5872871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":740,"address":[5728592,5728597],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":741,"address":[5873415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":742,"address":[5873430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[5873447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":744,"address":[5873482,5873548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":746,"address":[5873561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":747,"address":[5873603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":748,"address":[5873694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":752,"address":[5728629,5728624],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":753,"address":[5873879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":754,"address":[5873894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":755,"address":[5873921,5874057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":759,"address":[5728661,5728656],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":760,"address":[5874135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":761,"address":[5874150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":762,"address":[5874177,5874313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":766,"address":[5728693,5728688],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":767,"address":[5874388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":768,"address":[5874400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":771,"address":[5869600],"length":1,"stats":{"Line":0},"fn_name":"str_from_pos"},{"line":772,"address":[5869942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":773,"address":[5869682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":782,"address":[5728725,5728720],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":783,"address":[5874458,5875022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":784,"address":[5874552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[5874646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[5874740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":789,"address":[5874834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":792,"address":[5874928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[5877430,5877425,5875406,5875566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":800,"address":[5875637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[5875774,5876018,5877405,5875666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[5876058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":804,"address":[5876345,5876154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":806,"address":[5876424,5877357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[5876401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[5876669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":813,"address":[5876503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":814,"address":[5876548],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":236},{"path":["/","home","todd","rust-bio","src","data_structures","wavelet_matrix.rs"],"content":"//! Wavelet Matrix data structure for DNA alphabet.\n//! The implementation is based on the paper\n//! [Claude Francisco and Gonzalo Navarro. The wavelet matrix. SPIRE (2012)](https://doi.org/10.1007/978-3-642-34109-0_18)\n//!\n//! # Example\n//!\n//! ```\n//! use bio::data_structures::wavelet_matrix::WaveletMatrix;\n//! let text = b\"AANGGT$ACCNTT$\";\n//! let wm = WaveletMatrix::new(text);\n//! assert_eq!(wm.rank(b'A', 0), 1);\n//! assert_eq!(wm.rank(b'G', 9), 2);\n//! assert_eq!(wm.rank(b'T', 13), 3);\n//! ```\n\nuse crate::data_structures::rank_select::RankSelect;\nuse bv::BitVec;\nuse bv::BitsMut;\n\nconst DNA2INT: [u8; 128] = [\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //  0\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 10\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 20\n    0, 0, 0, 0, 0, 0, 5, 0, 0, 0, // 30\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, // 40\n    2, 3, 4, 5, 6, 7, 0, 0, 0, 0, // 50\n    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, // 60\n    0, 2, 0, 0, 0, 0, 0, 0, 4, 0, // 70\n    0, 0, 0, 0, 3, 0, 0, 0, 0, 0, // 80\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, // 90\n    0, 0, 0, 2, 0, 0, 0, 0, 0, 0, // 100\n    4, 0, 0, 0, 0, 0, 3, 0, 0, 0, // 110\n    0, 0, 0, 0, 0, 0, 0, 0,\n]; // 120\n\n#[derive(Serialize, Deserialize)]\npub struct WaveletMatrix {\n    width: usize,  // levels[0].len()\n    height: usize, // zeros.len() == levels.len()\n    zeros: Vec\u003cu64\u003e,\n    levels: Vec\u003cRankSelect\u003e,\n}\n\nfn build_partlevel(\n    vals: \u0026Vec\u003cu8\u003e,\n    shift: u8,\n    next_zeros: \u0026mut Vec\u003cu8\u003e,\n    next_ones: \u0026mut Vec\u003cu8\u003e,\n    bits: \u0026mut BitVec\u003cu8\u003e,\n    prev_bits: u64,\n) {\n    let mut p = prev_bits;\n    for val in vals {\n        let bit = ((DNA2INT[usize::from(*val)] \u003e\u003e shift) \u0026 1) == 1; // get shifted lsb\n        bits.set_bit(p, bit);\n        p += 1;\n        if bit {\n            next_ones.push(*val);\n        } else {\n            next_zeros.push(*val);\n        }\n    }\n}\n\nimpl WaveletMatrix {\n    /// Construct a new instance of the wavelet matrix of given text of length n (DNA alphabet plus sentinel symbol).\n    /// Complexity: O(n).\n    pub fn new(text: \u0026[u8]) -\u003e Self {\n        let width = text.len();\n        let height: usize = 3; // hardcoded for alphabet size \u003c= 8 (ACGTN$)\n\n        let mut curr_zeros: Vec\u003cu8\u003e = text.to_vec().clone();\n        let mut curr_ones: Vec\u003cu8\u003e = Vec::new();\n\n        let mut zeros: Vec\u003cu64\u003e = Vec::new();\n        let mut levels: Vec\u003cRankSelect\u003e = Vec::new();\n\n        for level in 0..height {\n            let mut next_zeros: Vec\u003cu8\u003e = Vec::with_capacity(width);\n            let mut next_ones: Vec\u003cu8\u003e = Vec::with_capacity(width);\n            let mut curr_bits: BitVec\u003cu8\u003e = BitVec::new_fill(false, width as u64);\n            let shift = (height - level - 1) as u8;\n            build_partlevel(\n                \u0026curr_zeros,\n                shift,\n                \u0026mut next_zeros,\n                \u0026mut next_ones,\n                \u0026mut curr_bits,\n                0,\n            );\n            build_partlevel(\n                \u0026curr_ones,\n                shift,\n                \u0026mut next_zeros,\n                \u0026mut next_ones,\n                \u0026mut curr_bits,\n                curr_zeros.len() as u64,\n            );\n\n            curr_zeros = next_zeros;\n            curr_ones = next_ones;\n\n            let level = RankSelect::new(curr_bits, 1);\n            levels.push(level);\n            zeros.push(curr_zeros.len() as u64);\n        }\n\n        WaveletMatrix {\n            width,\n            height,\n            zeros,\n            levels,\n        }\n    }\n\n    fn check_overflow(\u0026self, p: u64) -\u003e bool {\n        p \u003e= self.width as u64\n    }\n\n    fn prank(\u0026self, level: usize, p: u64, val: u8) -\u003e u64 {\n        if p == 0 {\n            0\n        } else {\n            if val == 0 {\n                self.levels[level].rank_0(p - 1).unwrap()\n            } else {\n                self.levels[level].rank_1(p - 1).unwrap()\n            }\n        }\n    }\n\n    /// Compute the number of occurrences of symbol val in the original text up to position p (inclusive).\n    /// Complexity O(1).\n    pub fn rank(\u0026self, val: u8, p: u64) -\u003e u64 {\n        if self.check_overflow(p) {\n            panic!(\"Invalid p (it must be in range 0..wm_size-1\");\n        }\n        let height = self.height as usize;\n        let mut spos = 0;\n        let mut epos = p + 1;\n        for level in 0..height {\n            let shift = height - level - 1;\n            let bit = ((DNA2INT[val as usize] \u003e\u003e shift) \u0026 1) == 1; // get shifted lsb\n            if bit {\n                spos = self.prank(level, spos, 1) + self.zeros[level];\n                epos = self.prank(level, epos, 1) + self.zeros[level];\n            } else {\n                spos = self.prank(level, spos, 0);\n                epos = self.prank(level, epos, 0);\n            }\n        }\n        epos - spos\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_wm_buildpaper() {\n        let text = b\"476532101417\";\n        let wm = WaveletMatrix::new(text);\n        let levels = vec![\n            vec![\n                true, true, true, true, false, false, false, false, false, true, false, true,\n            ],\n            vec![\n                true, true, false, false, false, false, false, true, true, false, false, true,\n            ],\n            vec![\n                true, false, true, true, false, true, false, true, false, true, false, true,\n            ],\n        ];\n        let zeros = vec![6, 7, 5];\n\n        assert_eq!(wm.height, zeros.len());\n        assert_eq!(wm.width, levels[0].len());\n        for level in 0..wm.height {\n            assert_eq!(wm.zeros[level], zeros[level]);\n            for i in 0..wm.width {\n                assert_eq!(wm.levels[level].bits().get(i as u64), levels[level][i]);\n            }\n        }\n    }\n\n    #[test]\n    fn test_wm_builddna() {\n        let text = b\"ACGTN$NAGCT$\";\n        let wm = WaveletMatrix::new(text);\n        let levels = vec![\n            vec![\n                false, false, false, false, true, true, true, false, false, false, false, true,\n            ],\n            vec![\n                false, false, true, true, false, true, false, true, false, false, false, false,\n            ],\n            vec![\n                false, true, false, true, false, true, false, true, false, true, false, true,\n            ],\n        ];\n        let zeros = vec![8, 8, 6];\n\n        assert_eq!(wm.height, zeros.len());\n        assert_eq!(wm.width, levels[0].len());\n        for level in 0..wm.height {\n            assert_eq!(wm.zeros[level], zeros[level]);\n            for i in 0..wm.width {\n                assert_eq!(wm.levels[level].bits().get(i as u64), levels[level][i]);\n            }\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_wm_rank_overflowpanic() {\n        let text = b\"476532101417\";\n        let wm = WaveletMatrix::new(text);\n        wm.rank(b'4', text.len() as u64);\n    }\n\n    #[test]\n    fn test_wm_rank_firstpos() {\n        let text = b\"476532101417\";\n        let wm = WaveletMatrix::new(text);\n        assert_eq!(wm.rank(b'4', 0), 1);\n    }\n\n    #[test]\n    fn test_wm_rank_lastpos() {\n        let text = b\"476532101417\";\n        let wm = WaveletMatrix::new(text);\n        assert_eq!(wm.rank(b'7', text.len() as u64 - 1), 2);\n    }\n\n    #[test]\n    fn test_wm_rank_1() {\n        let text = b\"476532101417\";\n        let wm = WaveletMatrix::new(text);\n        assert_eq!(wm.rank(b'0', 6), 0);\n        assert_eq!(wm.rank(b'0', 7), 1);\n        assert_eq!(wm.rank(b'0', 8), 1);\n    }\n\n    #[test]\n    fn test_wm_rank_2() {\n        let text = b\"476532101417\";\n        let wm = WaveletMatrix::new(text);\n        assert_eq!(wm.rank(b'4', 8), 1);\n        assert_eq!(wm.rank(b'4', 9), 2);\n        assert_eq!(wm.rank(b'4', 10), 2);\n    }\n\n    #[test]\n    fn test_wm_rank_all() {\n        let text = b\"476532101417\";\n        let wm = WaveletMatrix::new(text);\n\n        let ranks = vec![\n            vec![0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],\n            vec![0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 3, 3],\n            vec![0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1],\n            vec![0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2],\n            vec![0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],\n        ];\n\n        let alphabet = vec![b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7'];\n        for (i, c) in alphabet.iter().enumerate() {\n            for p in 0..text.len() {\n                assert_eq!(wm.rank(*c, p as u64), ranks[i][p]);\n            }\n        }\n    }\n\n    #[test]\n    fn test_wm_rank_alldna() {\n        let text = b\"AAGCTC$$CATTNGA\";\n        let wm = WaveletMatrix::new(text);\n\n        let ranks = vec![\n            vec![1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4],\n            vec![0, 0, 0, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3],\n            vec![0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],\n            vec![0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 3, 3, 3, 3],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1],\n            vec![0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2],\n        ];\n\n        let alphabet = vec![b'A', b'C', b'G', b'T', b'N', b'$'];\n        for (i, c) in alphabet.iter().enumerate() {\n            for p in 0..text.len() {\n                assert_eq!(wm.rank(*c, p as u64), ranks[i][p]);\n            }\n        }\n    }\n}\n","traces":[{"line":44,"address":[5001712],"length":1,"stats":{"Line":0},"fn_name":"build_partlevel"},{"line":52,"address":[5001788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[5001793,5001875,5002227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[5001909,5002084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[5002066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[5002155,5002114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[5002225,5002232,5002234,5002149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[5002216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[5002195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[5002240,5002462],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":69,"address":[5002299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[5002352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[5002364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[5002477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[5002534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[5002561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[5003019,5002776,5002606,5002721,5004117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[5003056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[5003088],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[5003130,5003183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[5003256,5003353,5003191,5003412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[5003445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[5003673,5003523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[5003848,5003614,5003748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[5003780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[5003923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[5004042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[5004208],"length":1,"stats":{"Line":0},"fn_name":"check_overflow"},{"line":117,"address":[5004221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[5004240],"length":1,"stats":{"Line":0},"fn_name":"prank"},{"line":121,"address":[5004305,5004290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[5004296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[5004314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[5004328,5004509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[5004364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[5004624],"length":1,"stats":{"Line":0},"fn_name":"rank"},{"line":135,"address":[5004687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[5004781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[5004728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[5004748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[5004892,5004827,5004760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[5005048,5004835,5004935,5005704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[5005085,5005221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[5005261,5005166,5005354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[5005768,5005348,5005672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[5005435,5005569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[5005544,5005674,5005612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[5005727,5005397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[5005735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[5005813,5005003,5005783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[4322592,4324905],"length":1,"stats":{"Line":0},"fn_name":"test_wm_buildpaper"},{"line":162,"address":[4322599],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[4322614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[4322878,4322649,4323014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[4322680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[4322784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[4322928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[4323223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[4323296,4323605,4323398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[4323552,4323890,4323664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[4323797,4324088,4324526,4323958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[4324368,4324125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[4324287,4324536,4324430,4324814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[4324828,4324573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[4324928,4327241],"length":1,"stats":{"Line":0},"fn_name":"test_wm_builddna"},{"line":189,"address":[4324935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[4324950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[4324985,4325214,4325350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[4325016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[4325120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[4325264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[4325559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[4325632,4325734,4325941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[4325888,4326000,4326226],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[4326294,4326133,4326862,4326424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[4326704,4326461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[4326623,4326766,4326872,4327150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[4326909,4327164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[4327395,4327264],"length":1,"stats":{"Line":0},"fn_name":"test_wm_rank_overflowpanic"},{"line":217,"address":[4327268],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[4327280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[4327302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[4327684,4327424],"length":1,"stats":{"Line":0},"fn_name":"test_wm_rank_firstpos"},{"line":224,"address":[4327431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[4327446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[4327636,4327482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[4328070,4327712],"length":1,"stats":{"Line":0},"fn_name":"test_wm_rank_lastpos"},{"line":231,"address":[4327719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[4327734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[4327862,4328018,4327756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[4328096,4328763],"length":1,"stats":{"Line":0},"fn_name":"test_wm_rank_1"},{"line":238,"address":[4328103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[4328118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[4328348,4328155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[4328323,4328404,4328538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[4328711,4328595,4328513],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[4328800,4329467],"length":1,"stats":{"Line":0},"fn_name":"test_wm_rank_2"},{"line":247,"address":[4328807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[4328822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[4329052,4328859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[4329242,4329027,4329108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[4329217,4329415,4329299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[4329504,4332406],"length":1,"stats":{"Line":0},"fn_name":"test_wm_rank_all"},{"line":256,"address":[4329511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[4329526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[4329569,4330230,4330958,4329875,4330776,4330048,4330594,4330412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[4329595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[4329736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[4329917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[4330099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[4330281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[4330463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[4330645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[4330827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[4331310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[4331586,4331788,4331499,4331402,4332067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[4331862,4332310,4332077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[4332325,4332114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[4335030,4332432],"length":1,"stats":{"Line":0},"fn_name":"test_wm_rank_alldna"},{"line":280,"address":[4332439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[4332454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[4333460,4333254,4332851,4333666,4333048,4332497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[4332523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[4332688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[4332893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[4333099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[4333305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[4333511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[4333958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[4334414,4334693,4334034,4334212,4334131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[4334488,4334703,4334935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[4334949,4334740],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":142},{"path":["/","home","todd","rust-bio","src","io","bed.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! BED format reading and writing.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::io::bed;\n//! let example = b\"1\\t5\\t5000\\tname1\\t0.5\";\n//! let mut reader = bed::Reader::new(\u0026example[..]);\n//! let mut writer = bed::Writer::new(vec![]);\n//! for record in reader.records() {\n//!     let rec = record.expect(\"Error reading record.\");\n//!     println!(\"{}\", rec.chrom());\n//!     writer.write(\u0026rec).expect(\"Error writing record.\");\n//! }\n//! ```\n\nuse std::convert::AsRef;\nuse std::fmt::Write;\nuse std::fs;\nuse std::io;\nuse std::marker::Copy;\nuse std::ops::Deref;\nuse std::path::Path;\n\nuse anyhow::Context;\nuse bio_types::annot;\nuse bio_types::annot::loc::Loc;\nuse bio_types::strand;\n\n/// A BED reader.\n#[derive(Debug)]\npub struct Reader\u003cR: io::Read\u003e {\n    inner: csv::Reader\u003cR\u003e,\n}\n\nimpl Reader\u003cfs::File\u003e {\n    /// Read from a given file path.\n    pub fn from_file\u003cP: AsRef\u003cPath\u003e + std::fmt::Debug\u003e(path: P) -\u003e anyhow::Result\u003cSelf\u003e {\n        fs::File::open(\u0026path)\n            .map(Reader::new)\n            .with_context(|| format!(\"Failed to read bed from {:#?}\", path))\n    }\n}\n\nimpl\u003cR: io::Read\u003e Reader\u003cR\u003e {\n    /// Read from a given reader.\n    pub fn new(reader: R) -\u003e Self {\n        Reader {\n            inner: csv::ReaderBuilder::new()\n                .delimiter(b'\\t')\n                .has_headers(false)\n                .from_reader(reader),\n        }\n    }\n\n    /// Iterate over all records.\n    pub fn records(\u0026mut self) -\u003e Records\u003c'_, R\u003e {\n        Records {\n            inner: self.inner.deserialize(),\n        }\n    }\n}\n\n/// An iterator over the records of a BED file.\npub struct Records\u003c'a, R: io::Read\u003e {\n    inner: csv::DeserializeRecordsIter\u003c'a, R, Record\u003e,\n}\n\nimpl\u003c'a, R: io::Read\u003e Iterator for Records\u003c'a, R\u003e {\n    type Item = csv::Result\u003cRecord\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003ccsv::Result\u003cRecord\u003e\u003e {\n        self.inner.next()\n    }\n}\n\n/// A BED writer.\n#[derive(Debug)]\npub struct Writer\u003cW: io::Write\u003e {\n    inner: csv::Writer\u003cW\u003e,\n}\n\nimpl Writer\u003cfs::File\u003e {\n    /// Write to a given file path.\n    #[allow(clippy::wrong_self_convention)]\n    pub fn to_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e io::Result\u003cSelf\u003e {\n        fs::File::create(path).map(Writer::new)\n    }\n}\n\nimpl\u003cW: io::Write\u003e Writer\u003cW\u003e {\n    /// Write to a given writer.\n    pub fn new(writer: W) -\u003e Self {\n        Writer {\n            inner: csv::WriterBuilder::new()\n                .delimiter(b'\\t')\n                .flexible(true)\n                .from_writer(writer),\n        }\n    }\n\n    /// Write a given BED record.\n    pub fn write(\u0026mut self, record: \u0026Record) -\u003e csv::Result\u003c()\u003e {\n        if record.aux.is_empty() {\n            self.inner\n                .serialize(\u0026(\u0026record.chrom, record.start, record.end))\n        } else {\n            self.inner\n                .serialize(\u0026(\u0026record.chrom, record.start, record.end, \u0026record.aux))\n        }\n    }\n}\n\n/// A BED record as defined by BEDtools\n/// (http://bedtools.readthedocs.org/en/latest/content/general-usage.html)\n#[derive(Debug, Serialize, Default, Deserialize, Clone)]\npub struct Record {\n    chrom: String,\n    start: u64,\n    end: u64,\n    #[serde(default)]\n    aux: Vec\u003cString\u003e,\n}\n\nimpl Record {\n    /// Create a new BED record.\n    pub fn new() -\u003e Self {\n        Record {\n            chrom: \"\".to_owned(),\n            start: 0,\n            end: 0,\n            aux: vec![],\n        }\n    }\n\n    /// Chromosome of the feature.\n    pub fn chrom(\u0026self) -\u003e \u0026str {\n        \u0026self.chrom\n    }\n\n    /// Start position of feature (0-based).\n    pub fn start(\u0026self) -\u003e u64 {\n        self.start\n    }\n\n    /// End position of feature (0-based, not included).\n    pub fn end(\u0026self) -\u003e u64 {\n        self.end\n    }\n\n    /// Name of the feature.\n    pub fn name(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.aux(3)\n    }\n\n    /// Score of the feature.\n    pub fn score(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.aux(4)\n    }\n\n    /// Strand of the feature.\n    pub fn strand(\u0026self) -\u003e Option\u003cstrand::Strand\u003e {\n        match self.aux(5) {\n            Some(\"+\") =\u003e Some(strand::Strand::Forward),\n            Some(\"-\") =\u003e Some(strand::Strand::Reverse),\n            _ =\u003e None,\n        }\n    }\n\n    /// Access auxilliary fields after the strand field by index\n    /// (counting first field (chromosome) as 0).\n    pub fn aux(\u0026self, i: usize) -\u003e Option\u003c\u0026str\u003e {\n        let j = i - 3;\n        if j \u003c self.aux.len() {\n            Some(\u0026self.aux[j])\n        } else {\n            None\n        }\n    }\n\n    /// Set chromosome.\n    pub fn set_chrom(\u0026mut self, chrom: \u0026str) {\n        self.chrom = chrom.to_owned();\n    }\n\n    /// Set start of feature.\n    pub fn set_start(\u0026mut self, start: u64) {\n        self.start = start;\n    }\n\n    /// Set end of feature.\n    pub fn set_end(\u0026mut self, end: u64) {\n        self.end = end;\n    }\n\n    /// Set name.\n    pub fn set_name(\u0026mut self, name: \u0026str) {\n        if self.aux.is_empty() {\n            self.aux.push(name.to_owned());\n        } else {\n            self.aux[0] = name.to_owned();\n        }\n    }\n\n    /// Set score.\n    pub fn set_score(\u0026mut self, score: \u0026str) {\n        if self.aux.is_empty() {\n            self.aux.push(\"\".to_owned());\n        }\n        if self.aux.len() \u003c 2 {\n            self.aux.push(score.to_owned());\n        } else {\n            self.aux[1] = score.to_owned();\n        }\n    }\n\n    /// Add auxilliary field. This has to happen after name and score have been set.\n    pub fn push_aux(\u0026mut self, field: \u0026str) {\n        self.aux.push(field.to_owned());\n    }\n}\n\nimpl\u003c'a\u003e From\u003c\u0026'a Record\u003e for annot::contig::Contig\u003cString, strand::Strand\u003e {\n    /// Returns a `Contig` annotation for the BED record.\n    ///\n    /// ```\n    /// use bio::io::bed;\n    /// use bio_types::annot::contig::Contig;\n    /// use bio_types::strand::Strand;\n    /// let example = b\"chr1\\t5\\t5000\\tname1\\t0.5\";\n    /// let mut reader = bed::Reader::new(\u0026example[..]);\n    /// let rec = reader\n    ///     .records()\n    ///     .next()\n    ///     .expect(\"Found no bed record.\")\n    ///     .expect(\"Got a csv::Error\");\n    /// let loc = Contig::from(\u0026rec);\n    /// assert_eq!(loc.to_string(), \"chr1:5-5000\");\n    /// ```\n    fn from(rec: \u0026Record) -\u003e Self {\n        annot::contig::Contig::new(\n            rec.chrom.to_string(),\n            rec.start as isize,\n            (rec.end - rec.start) as usize,\n            rec.strand().unwrap_or(strand::Strand::Unknown),\n        )\n    }\n}\n\n/// Generate a BED format `Record` for an annotation position.\n///\n/// This record will have length 1, and when created it will have an\n/// empty name.\nimpl\u003cR, S\u003e From\u003cannot::pos::Pos\u003cR, S\u003e\u003e for Record\nwhere\n    R: Deref\u003cTarget = str\u003e,\n    S: Into\u003cstrand::Strand\u003e + Copy,\n{\n    fn from(pos: annot::pos::Pos\u003cR, S\u003e) -\u003e Self {\n        let mut bed = Record::new();\n        bed.set_chrom(pos.refid());\n        bed.set_start(pos.pos() as u64);\n        bed.set_end((pos.pos() + 1) as u64);\n        bed.set_name(\"\");\n        bed.set_score(\"0\");\n        bed.push_aux(pos.strand().into().strand_symbol());\n        bed\n    }\n}\n\n/// Generate a BED format `Record` for the location.\n///\n/// As created, it will have an empty name.\nimpl\u003cR, S\u003e From\u003cannot::contig::Contig\u003cR, S\u003e\u003e for Record\nwhere\n    R: Deref\u003cTarget = str\u003e,\n    S: Into\u003cstrand::Strand\u003e + Copy,\n{\n    fn from(contig: annot::contig::Contig\u003cR, S\u003e) -\u003e Self {\n        let mut bed = Record::new();\n        bed.set_chrom(contig.refid());\n        bed.set_start(contig.start() as u64);\n        bed.set_end((contig.start() + contig.length() as isize) as u64);\n        bed.set_name(\"\");\n        bed.set_score(\"0\");\n        bed.push_aux(contig.strand().into().strand_symbol());\n        bed\n    }\n}\n\n/// Generate a BED format `Record` for the position.\n///\n/// Splicing information will be represented with the 12-column\n/// BED format, using columns 10 through 12 (blockCount,\n/// blockSizes, and blockStarts) for exons.\n///\n/// As created, it will have an empty name and default to using\n/// the overall start \u0026 end (columns 1 and 2) for the start and\n/// end of the \"thick\" region (columns 7 and 8).\n/// ```\n/// # extern crate bio;\n/// # extern crate bio_types;\n/// use bio::io::bed;\n/// use bio_types::annot::spliced::{Spliced, SplicingError};\n/// use bio_types::annot::AnnotError;\n/// use bio_types::strand::ReqStrand;\n/// # fn try_main() -\u003e Result\u003c(), Box\u003cSplicingError\u003e\u003e {\n/// let tad3 = Spliced::with_lengths_starts(\n///     \"chrXII\".to_owned(),\n///     765265,\n///     \u0026vec![808, 52, 109],\n///     \u0026vec![0, 864, 984],\n///     ReqStrand::Reverse,\n/// )\n/// .expect(\"Encountered a bio_types::annot::spliced::SplicingError.\");\n/// assert_eq!(\n///     tad3.to_string(),\n///     \"chrXII:765265-766073;766129-766181;766249-766358(-)\"\n/// );\n/// let tad3_exons = tad3.exon_contigs();\n/// assert_eq!(tad3_exons.len(), 3);\n/// assert_eq!(tad3_exons[0].to_string(), \"chrXII:766249-766358(-)\");\n/// assert_eq!(tad3_exons[1].to_string(), \"chrXII:766129-766181(-)\");\n/// assert_eq!(tad3_exons[2].to_string(), \"chrXII:765265-766073(-)\");\n/// let mut buf = Vec::new();\n/// {\n///     let mut writer = bed::Writer::new(\u0026mut buf);\n///     let mut tad3_bed = bed::Record::from(tad3);\n///     tad3_bed.set_name(\"YLR316C\");\n///     writer.write(\u0026tad3_bed).unwrap();\n/// }\n/// assert_eq!(\n///     \"chrXII\\t765265\\t766358\\tYLR316C\\t0\\t-\\t765265\\t766358\\t0\\t3\\t808,52,109,\\t0,864,984,\\n\",\n///     String::from_utf8(buf)\n///         .unwrap_or_else(|_| \"???\".to_owned())\n///         .as_str()\n/// );\n/// # Ok(())\n/// # }\n/// # fn main() { try_main().unwrap(); }\n/// ```\nimpl\u003cR, S\u003e From\u003cannot::spliced::Spliced\u003cR, S\u003e\u003e for Record\nwhere\n    R: Deref\u003cTarget = str\u003e,\n    S: Into\u003cstrand::Strand\u003e + Copy,\n{\n    fn from(spliced: annot::spliced::Spliced\u003cR, S\u003e) -\u003e Self {\n        let mut bed = Record::new();\n        bed.set_chrom(spliced.refid());\n        bed.set_start(spliced.start() as u64);\n        bed.set_end((spliced.start() + spliced.length() as isize) as u64);\n        bed.set_name(\"\");\n        bed.set_score(\"0\");\n        bed.push_aux(spliced.strand().into().strand_symbol());\n        bed.push_aux(spliced.start().to_string().as_str()); // thickStart = chromStart\n        bed.push_aux(\n            (spliced.start() + spliced.length() as isize)\n                .to_string()\n                .as_str(),\n        ); // thickEnd = chromEnd\n        bed.push_aux(\"0\"); // RGB color = black\n\n        bed.push_aux(spliced.exon_count().to_string().as_str());\n\n        let mut block_sizes = String::new();\n        for block_size in spliced.exon_lengths() {\n            write!(block_sizes, \"{},\", block_size).unwrap();\n        }\n        bed.push_aux(\u0026block_sizes);\n\n        let mut block_starts = String::new();\n        for block_start in spliced.exon_starts() {\n            write!(block_starts, \"{},\", block_start).unwrap();\n        }\n        bed.push_aux(\u0026block_starts);\n        bed\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use bio_types::annot::{contig::Contig, pos::Pos, spliced::Spliced};\n    use bio_types::strand::{ReqStrand, Strand};\n\n    const BED_FILE: \u0026[u8] = b\"1\\t5\\t5000\\tname1\\tup\n2\\t3\\t5005\\tname2\\tup\n\";\n    const BED_FILE_COMPACT: \u0026[u8] = b\"1\\t5\\t5000\\n2\\t3\\t5005\\n\";\n\n    #[test]\n    fn test_reader() {\n        let chroms = [\"1\", \"2\"];\n        let starts = [5, 3];\n        let ends = [5000, 5005];\n        let names = [\"name1\", \"name2\"];\n        let scores = [\"up\", \"up\"];\n\n        let mut reader = Reader::new(BED_FILE);\n        for (i, r) in reader.records().enumerate() {\n            let record = r.expect(\"Error reading record\");\n            assert_eq!(record.chrom(), chroms[i]);\n            assert_eq!(record.start(), starts[i]);\n            assert_eq!(record.end(), ends[i]);\n            assert_eq!(record.name().expect(\"Error reading name\"), names[i]);\n            assert_eq!(record.score().expect(\"Error reading score\"), scores[i]);\n        }\n    }\n\n    #[test]\n    fn test_reader_compact() {\n        let chroms = [\"1\", \"2\"];\n        let starts = [5, 3];\n        let ends = [5000, 5005];\n\n        let mut reader = Reader::new(BED_FILE_COMPACT);\n        for (i, r) in reader.records().enumerate() {\n            let record = r.unwrap();\n            assert_eq!(record.chrom(), chroms[i]);\n            assert_eq!(record.start(), starts[i]);\n            assert_eq!(record.end(), ends[i]);\n        }\n    }\n\n    #[test]\n    fn test_reader_from_file_path_doesnt_exist_returns_err() {\n        let path = Path::new(\"/I/dont/exist.bed\");\n        let error = Reader::from_file(path)\n            .unwrap_err()\n            .downcast::\u003cString\u003e()\n            .unwrap();\n\n        assert_eq!(\u0026error, \"Failed to read bed from \\\"/I/dont/exist.bed\\\"\")\n    }\n\n    #[test]\n    fn test_writer() {\n        let mut reader = Reader::new(BED_FILE);\n        let mut writer = Writer::new(vec![]);\n        for r in reader.records() {\n            writer\n                .write(\u0026r.expect(\"Error reading record\"))\n                .expect(\"Error writing record\");\n        }\n        assert_eq!(writer.inner.into_inner().unwrap(), BED_FILE);\n    }\n\n    #[test]\n    fn spliced_to_bed() {\n        //chrV    166236  166885  YER007C-A       0       -       166236  166885  0       2       535,11, 0,638,\n        let tma20 = Spliced::with_lengths_starts(\n            \"chrV\".to_owned(),\n            166236,\n            \u0026[535, 11],\n            \u0026[0, 638],\n            ReqStrand::Reverse,\n        )\n        .unwrap();\n        let mut buf = Vec::new();\n        {\n            let mut writer = Writer::new(\u0026mut buf);\n            let mut tma20_bed = Record::from(tma20);\n            tma20_bed.set_name(\"YER007C-A\");\n            writer.write(\u0026tma20_bed).unwrap();\n        }\n        assert_eq!(\n            \"chrV\\t166236\\t166885\\tYER007C-A\\t0\\t-\\t166236\\t166885\\t0\\t2\\t535,11,\\t0,638,\\n\",\n            String::from_utf8(buf).unwrap().as_str()\n        );\n\n        //chrXVI  173151  174702  YPL198W 0       +       173151  174702  0       3       11,94,630,      0,420,921,\n        let rpl7b = Spliced::with_lengths_starts(\n            \"chrXVI\".to_owned(),\n            173151,\n            \u0026[11, 94, 630],\n            \u0026[0, 420, 921],\n            ReqStrand::Forward,\n        )\n        .unwrap();\n        let mut buf = Vec::new();\n        {\n            let mut writer = Writer::new(\u0026mut buf);\n            let mut rpl7b_bed = Record::from(rpl7b);\n            rpl7b_bed.set_name(\"YPL198W\");\n            writer.write(\u0026rpl7b_bed).unwrap();\n        }\n        assert_eq!(\n            \"chrXVI\\t173151\\t174702\\tYPL198W\\t0\\t+\\t173151\\t174702\\t0\\t3\\t11,94,630,\\t0,420,921,\\n\",\n            String::from_utf8(buf).unwrap().as_str()\n        );\n\n        //chrXII  765265  766358  YLR316C 0       -       765265  766358  0       3       808,52,109,     0,864,984,\n        let tad3 = Spliced::with_lengths_starts(\n            \"chrXII\".to_owned(),\n            765265,\n            \u0026[808, 52, 109],\n            \u0026[0, 864, 984],\n            ReqStrand::Reverse,\n        )\n        .unwrap();\n        let mut buf = Vec::new();\n        {\n            let mut writer = Writer::new(\u0026mut buf);\n            let mut tad3_bed = Record::from(tad3);\n            tad3_bed.set_name(\"YLR316C\");\n            writer.write(\u0026tad3_bed).unwrap();\n        }\n        assert_eq!(\"chrXII\\t765265\\t766358\\tYLR316C\\t0\\t-\\t765265\\t766358\\t0\\t3\\t808,52,109,\\t0,864,984,\\n\",\n                   String::from_utf8(buf).unwrap().as_str());\n    }\n\n    #[test]\n    fn test_bed_from_contig() {\n        let contig = Contig::new(\n            \"chrXI\".to_owned(),\n            334412,\n            334916 - 334412,\n            ReqStrand::Reverse,\n        );\n\n        let record = Record::from(contig);\n\n        assert_eq!(record.chrom(), String::from(\"chrXI\"));\n        assert_eq!(record.start(), 334412);\n        assert_eq!(record.end(), 334412 + (334916 - 334412));\n        assert_eq!(record.name(), Some(\"\"));\n        assert_eq!(record.score(), Some(\"0\"));\n        assert_eq!(record.strand(), Some(Strand::Reverse));\n    }\n\n    #[test]\n    fn test_bed_from_pos() {\n        let pos = Pos::new(\"chrXI\".to_owned(), 334412, ReqStrand::Reverse);\n\n        let record = Record::from(pos);\n\n        assert_eq!(record.chrom(), String::from(\"chrXI\"));\n        assert_eq!(record.start(), 334412);\n        assert_eq!(record.end(), 334412 + 1);\n        assert_eq!(record.name(), Some(\"\"));\n        assert_eq!(record.score(), Some(\"0\"));\n        assert_eq!(record.strand(), Some(Strand::Reverse));\n    }\n}\n","traces":[{"line":43,"address":[5229956,5229824],"length":1,"stats":{"Line":0},"fn_name":"from_file\u003c\u0026std::path::Path\u003e"},{"line":44,"address":[5229934,5229866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[5229984,5230006,5229926],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003c\u0026std::path::Path\u003e"},{"line":52,"address":[5230451,5230480,5230144,5230814],"length":1,"stats":{"Line":0},"fn_name":"new\u003c\u0026[u8]\u003e"},{"line":54,"address":[5230693,5230501,5230190,5230303,5230388,5230614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[5230848],"length":1,"stats":{"Line":0},"fn_name":"records\u003c\u0026[u8]\u003e"},{"line":64,"address":[5230867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[5230928],"length":1,"stats":{"Line":0},"fn_name":"next\u003c\u0026[u8]\u003e"},{"line":78,"address":[5230945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[5231216,5231467,5231187,5230960],"length":1,"stats":{"Line":0},"fn_name":"new\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":100,"address":[5231427,5231238,5231351,5230990,5231100,5231147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[5231504,5231696],"length":1,"stats":{"Line":0},"fn_name":"write\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":109,"address":[5231733,5231541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[5231663,5231855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[5231637,5231829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[5231610,5231802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[5231767,5231575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[5133408,5133232,5133396],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":134,"address":[5133246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[5133267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[5133408],"length":1,"stats":{"Line":0},"fn_name":"chrom"},{"line":143,"address":[5133417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[5133456],"length":1,"stats":{"Line":0},"fn_name":"start"},{"line":148,"address":[5133461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[5133472],"length":1,"stats":{"Line":0},"fn_name":"end"},{"line":153,"address":[5133477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[5133488],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":158,"address":[5133497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[5133536],"length":1,"stats":{"Line":0},"fn_name":"score"},{"line":163,"address":[5133545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[5133584],"length":1,"stats":{"Line":0},"fn_name":"strand"},{"line":168,"address":[5133748,5133598,5133674,5133750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[5133613,5133680,5133719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[5133737,5133686],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[5133669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[5133760],"length":1,"stats":{"Line":0},"fn_name":"aux"},{"line":178,"address":[5133827,5133779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[5133881,5133810,5133867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[5133893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[5133872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[5134072,5133968],"length":1,"stats":{"Line":0},"fn_name":"set_chrom"},{"line":188,"address":[5133991,5134055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[5134112],"length":1,"stats":{"Line":0},"fn_name":"set_start"},{"line":193,"address":[5134125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[5134144],"length":1,"stats":{"Line":0},"fn_name":"set_end"},{"line":198,"address":[5134157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[5134176,5134515],"length":1,"stats":{"Line":0},"fn_name":"set_name"},{"line":203,"address":[5134216,5134322,5134456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[5134287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[5134465,5134337,5134255,5134530,5134543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[5135022,5134544],"length":1,"stats":{"Line":0},"fn_name":"set_score"},{"line":212,"address":[5134675,5134590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[5134629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[5134791,5134950,5134682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[5134756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[5134960,5135037,5135053,5134718,5134806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[5135056],"length":1,"stats":{"Line":0},"fn_name":"push_aux"},{"line":224,"address":[5135075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[7770608,7770847],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":247,"address":[7770632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[7770657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[7770666,7770704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[7770691,7770765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[5232332,5231888],"length":1,"stats":{"Line":0},"fn_name":"from\u003calloc::string::String,bio_types::strand::ReqStrand\u003e"},{"line":265,"address":[5231910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[5231973,5232039,5231922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[5232051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[5232088],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[5232177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[5232200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[5232224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[5232368,5232848],"length":1,"stats":{"Line":0},"fn_name":"from\u003calloc::string::String,bio_types::strand::ReqStrand\u003e"},{"line":285,"address":[5232393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[5232459,5232528,5232405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[5232540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[5232577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[5232691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[5232714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[5232738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[5235467,5232880],"length":1,"stats":{"Line":0},"fn_name":"from\u003calloc::string::String,bio_types::strand::ReqStrand\u003e"},{"line":353,"address":[5232914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[5233011,5233102,5232937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[5233117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[5233166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[5233307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[5233333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[5233360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[5233499],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[5233903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[5233692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[5233978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[5234005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[5234196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[5234477,5234501,5234219,5234723,5234294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[5234541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[5234736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[5234792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[5235319,5235097,5234890,5234815,5235073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[5235137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[5235332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[5235380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[5859780,5857120],"length":1,"stats":{"Line":0},"fn_name":"test_reader"},{"line":399,"address":[5857127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[5857189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[5857213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[5857237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[5857291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[5857345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[5857631,5859723,5857386,5857472,5857659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[5858019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[5858149,5858282,5858474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[5858534,5858440,5858743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[5858709,5859013,5858811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[5859352,5858980,5859075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[5859319,5859668,5859409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[5859808,5861581],"length":1,"stats":{"Line":0},"fn_name":"test_reader_compact"},{"line":418,"address":[5859815],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[5859865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[5859889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[5859913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[5860227,5861524,5860040,5859954,5860199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[5860584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[5860982,5860702,5860817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[5861036,5860957,5861224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[5861464,5861199,5861286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[5861616,5861960],"length":1,"stats":{"Line":0},"fn_name":"test_reader_from_file_path_doesnt_exist_returns_err"},{"line":433,"address":[5861623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[5861676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[5861914,5861750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[5861984,5863325],"length":1,"stats":{"Line":0},"fn_name":"test_writer"},{"line":444,"address":[5861991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[5862108,5862029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[5862129,5862333,5862944,5862197,5862361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[5862835],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[5862697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[5862982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[5863360,5866395],"length":1,"stats":{"Line":0},"fn_name":"spliced_to_bed"},{"line":458,"address":[5863415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[5863440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[5863554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[5863597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[5863645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[5863797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[5863877,5863940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[5864150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[5863984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[5864372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[5864399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[5864514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[5864557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[5864605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[5864757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[5864837,5864894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[5865092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[5864938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[5865309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[5865336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[5865451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[5865494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[5865542],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[5865694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[5865774,5865831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[5866029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[5865875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[5866629,5866432],"length":1,"stats":{"Line":0},"fn_name":"test_bed_from_contig"},{"line":521,"address":[5866447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[5866480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[5866546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[5866804,5866668],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[5867037,5867208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[5867268,5867406,5867174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[5867621,5867468,5867373],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[5867821,5867588,5867678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[5867798,5867872,5868000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[5868064,5869568],"length":1,"stats":{"Line":0},"fn_name":"test_bed_from_pos"},{"line":539,"address":[5868071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[5868142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[5868333,5868197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[5868734,5868566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[5868703,5868791,5868929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[5868991,5869144,5868896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[5869111,5869201,5869344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[5869321,5869521,5869395],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":190},{"path":["/","home","todd","rust-bio","src","io","fasta.rs"],"content":"// Copyright 2014-2018 Johannes Köster, Christopher Schröder, Henning Timm.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Structs and trait to read and write files in FASTA format.\n//!\n//! # Example\n//!\n//! ## Read\n//!\n//! In this example, we parse a fasta file from stdin and compute some statistics\n//!\n//! ```\n//! use bio::io::fasta;\n//! use std::io;\n//!\n//! let mut reader = fasta::Reader::new(io::stdin());\n//!\n//! let mut nb_reads = 0;\n//! let mut nb_bases = 0;\n//!\n//! for result in reader.records() {\n//!     let record = result.expect(\"Error during fasta record parsing\");\n//!     println!(\"{}\", record.id());\n//!\n//!     nb_reads += 1;\n//!     nb_bases += record.seq().len();\n//! }\n//!\n//! println!(\"Number of reads: {}\", nb_reads);\n//! println!(\"Number of bases: {}\", nb_bases);\n//! ```\n//!\n//! We can also use a `while` loop to iterate over records.\n//! This is slightly faster than the `for` loop.\n//! ```\n//! use bio::io::fasta;\n//! use std::io;\n//! let mut records = fasta::Reader::new(io::stdin()).records();\n//!\n//! let mut nb_reads = 0;\n//! let mut nb_bases = 0;\n//!\n//! while let Some(Ok(record)) = records.next() {\n//!     nb_reads += 1;\n//!     nb_bases += record.seq().len();\n//! }\n//!\n//! println!(\"Number of reads: {}\", nb_reads);\n//! println!(\"Number of bases: {}\", nb_bases);\n//! ```\n//!\n//! ## Write\n//!\n//! In this example we generate 10 random sequences with length 100 and write them to stdout.\n//!\n//! ```\n//! use std::io;\n//! use bio::io::fasta;\n//!\n//! let mut seed = 42;\n//!\n//! let nucleotides = [b'A', b'C', b'G', b'T'];\n//!\n//! let mut writer = fasta::Writer::new(io::stdout());\n//!\n//! for _ in 0..10 {\n//!     let seq = (0..100).map(|_| {\n//!         seed = ((seed ^ seed \u003c\u003c 13) ^ seed \u003e\u003e 7) ^ seed \u003c\u003c 17; // don't use this random generator\n//!         nucleotides[seed % 4]\n//!     }).collect::\u003cVec\u003cu8\u003e\u003e();\n//!\n//!    writer.write(\"random\", None, seq.as_slice()).expect(\"Error writing record.\");\n//! }\n//! ```\n//!\n//! ## Read and Write\n//!\n//! In this example we filter reads from stdin on sequence length and write them to stdout\n//!\n//! ```\n//! use bio::io::fasta;\n//! use bio::io::fasta::FastaRead;\n//! use std::io;\n//!\n//! let mut reader = fasta::Reader::new(io::stdin());\n//! let mut writer = fasta::Writer::new(io::stdout());\n//! let mut record = fasta::Record::new();\n//!\n//! while let Ok(()) = reader.read(\u0026mut record) {\n//!     if record.is_empty() {\n//!         break;\n//!     }\n//!\n//!     if record.seq().len() \u003e 100 {\n//!         writer\n//!             .write_record(\u0026record)\n//!             .ok()\n//!             .expect(\"Error writing record.\");\n//!     }\n//! }\n//! ```\n//!\n//! ## Index\n//!\n//! Random access to FASTA files is facilitated by [`Index`] and [`IndexedReader`]. The FASTA files\n//! must already be indexed with [`samtools faidx`](https://www.htslib.org/doc/faidx.html).\n//!\n//! In this example, we read in the first 10 bases of the sequence named \"chr1\".\n//!\n//! ```rust\n//! use bio::io::fasta::IndexedReader;\n//! // create dummy files\n//! const FASTA_FILE: \u0026[u8] = b\"\u003echr1\\nGTAGGCTGAAAA\\nCCCC\";\n//! const FAI_FILE: \u0026[u8] = b\"chr1\\t16\\t6\\t12\\t13\";\n//!\n//! let seq_name = \"chr1\";\n//! let start: u64 = 0;  // start is 0-based, inclusive\n//! let stop: u64 = 10;  // stop is 0-based, exclusive\n//! // load the index\n//! let mut faidx = IndexedReader::new(std::io::Cursor::new(FASTA_FILE), FAI_FILE).unwrap();\n//! // move the pointer in the index to the desired sequence and interval\n//! faidx.fetch(seq_name, start, stop).expect(\"Couldn't fetch interval\");\n//! // read the subsequence defined by the interval into a vector\n//! let mut seq = Vec::new();\n//! faidx.read(\u0026mut seq).expect(\"Couldn't read the interval\");\n//! assert_eq!(seq, b\"GTAGGCTGAA\");\n//! ```\n//!\n\nuse std::cmp::min;\nuse std::collections;\nuse std::convert::AsRef;\nuse std::fs;\nuse std::io;\nuse std::io::prelude::*;\nuse std::path::Path;\n\nuse crate::utils::{Text, TextSlice};\nuse anyhow::Context;\nuse std::fmt;\n\n/// Maximum size of temporary buffer used for reading indexed FASTA files.\nconst MAX_FASTA_BUFFER_SIZE: usize = 512;\n\n/// Trait for FASTA readers.\npub trait FastaRead {\n    fn read(\u0026mut self, record: \u0026mut Record) -\u003e io::Result\u003c()\u003e;\n}\n\n/// A FASTA reader.\n#[derive(Debug)]\npub struct Reader\u003cR: io::Read\u003e {\n    reader: io::BufReader\u003cR\u003e,\n    line: String,\n}\n\nimpl Reader\u003cfs::File\u003e {\n    /// Read FASTA from given file path.\n    pub fn from_file\u003cP: AsRef\u003cPath\u003e + std::fmt::Debug\u003e(path: P) -\u003e anyhow::Result\u003cSelf\u003e {\n        fs::File::open(\u0026path)\n            .map(Reader::new)\n            .with_context(|| format!(\"Failed to read fasta from {:#?}\", path))\n    }\n}\n\nimpl\u003cR: io::Read\u003e Reader\u003cR\u003e {\n    /// Create a new Fasta reader given an instance of `io::Read`.\n    ///\n    /// # Example\n    /// ```rust\n    /// # use std::io;\n    /// # use bio::io::fasta::Reader;\n    /// # fn main() {\n    /// # const fasta_file: \u0026'static [u8] = b\"\u003eid desc\n    /// # AAAA\n    /// # \";\n    /// let reader = Reader::new(fasta_file);\n    /// # }\n    /// ```\n    pub fn new(reader: R) -\u003e Self {\n        Reader {\n            reader: io::BufReader::new(reader),\n            line: String::new(),\n        }\n    }\n\n    /// Return an iterator over the records of this Fasta file.\n    ///\n    /// # Example\n    /// ```rust\n    /// # use std::io;\n    /// # use bio::io::fasta::Reader;\n    /// # use bio::io::fasta::Record;\n    /// # fn main() {\n    /// # const fasta_file: \u0026'static [u8] = b\"\u003eid desc\n    /// # AAAA\n    /// # \";\n    /// # let reader = Reader::new(fasta_file);\n    /// for record in reader.records() {\n    ///     let record = record.unwrap();\n    ///     assert_eq!(record.id(), \"id\");\n    ///     assert_eq!(record.desc().unwrap(), \"desc\");\n    ///     assert_eq!(record.seq().to_vec(), b\"AAAA\");\n    /// }\n    /// # }\n    /// ```\n    pub fn records(self) -\u003e Records\u003cR\u003e {\n        Records {\n            reader: self,\n            error_has_occured: false,\n        }\n    }\n\n    pub(crate) fn new_with_line(reader: io::BufReader\u003cR\u003e, line: String) -\u003e Self {\n        Reader { reader, line }\n    }\n}\n\nimpl\u003cR\u003e FastaRead for Reader\u003cR\u003e\nwhere\n    R: io::Read,\n{\n    /// Read the next FASTA record into the given `Record`.\n    /// An empty record indicates that no more records can be read.\n    ///\n    /// Use this method when you want to read records as fast as\n    /// possible because it allows the reuse of a `Record` allocation.\n    ///\n    /// The [records](Reader::records) iterator provides a more ergonomic\n    /// approach to accessing FASTA records.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the record is incomplete,\n    /// syntax is violated or any form of I/O error is encountered.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use bio::io::fasta::Record;\n    /// use bio::io::fasta::{FastaRead, Reader};\n    ///\n    /// const fasta_file: \u0026'static [u8] = b\"\u003eid desc\n    /// AAAA\n    /// \";\n    /// let mut reader = Reader::new(fasta_file);\n    /// let mut record = Record::new();\n    ///\n    /// // Check for errors parsing the record\n    /// reader\n    ///     .read(\u0026mut record)\n    ///     .expect(\"fasta reader: got an io::Error or could not read_line()\");\n    ///\n    /// assert_eq!(record.id(), \"id\");\n    /// assert_eq!(record.desc().unwrap(), \"desc\");\n    /// assert_eq!(record.seq().to_vec(), b\"AAAA\");\n    /// ```\n    fn read(\u0026mut self, record: \u0026mut Record) -\u003e io::Result\u003c()\u003e {\n        record.clear();\n        if self.line.is_empty() {\n            self.reader.read_line(\u0026mut self.line)?;\n            if self.line.is_empty() {\n                return Ok(());\n            }\n        }\n\n        if !self.line.starts_with('\u003e') {\n            return Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"Expected \u003e at record start.\",\n            ));\n        }\n        let mut header_fields = self.line[1..].trim_end().splitn(2, char::is_whitespace);\n        record.id = header_fields.next().map(|s| s.to_owned()).unwrap();\n        record.desc = header_fields.next().map(|s| s.to_owned());\n        loop {\n            self.line.clear();\n            self.reader.read_line(\u0026mut self.line)?;\n            if self.line.is_empty() || self.line.starts_with('\u003e') {\n                break;\n            }\n            record.seq.push_str(self.line.trim_end());\n        }\n\n        Ok(())\n    }\n}\n\n/// A FASTA index as created by SAMtools (.fai).\n#[derive(Debug, Clone)]\npub struct Index {\n    inner: Vec\u003cIndexRecord\u003e,\n    name_to_rid: collections::HashMap\u003cString, usize\u003e,\n}\n\nimpl Index {\n    /// Open a FASTA index from a given `io::Read` instance.\n    pub fn new\u003cR: io::Read\u003e(fai: R) -\u003e csv::Result\u003cSelf\u003e {\n        let mut inner = vec![];\n        let mut name_to_rid = collections::HashMap::new();\n\n        let mut fai_reader = csv::ReaderBuilder::new()\n            .delimiter(b'\\t')\n            .has_headers(false)\n            .from_reader(fai);\n        for (rid, row) in fai_reader.deserialize().enumerate() {\n            let record: IndexRecord = row?;\n            name_to_rid.insert(record.name.clone(), rid);\n            inner.push(record);\n        }\n        Ok(Index { inner, name_to_rid })\n    }\n\n    /// Open a FASTA index from a given file path.\n    pub fn from_file\u003cP: AsRef\u003cPath\u003e + std::fmt::Debug\u003e(path: \u0026P) -\u003e anyhow::Result\u003cSelf\u003e {\n        fs::File::open(\u0026path)\n            .map_err(csv::Error::from)\n            .and_then(Self::new)\n            .with_context(|| format!(\"Failed to read fasta index from {:#?}\", path))\n    }\n\n    /// Open a FASTA index given the corresponding FASTA file path.\n    /// That is, for ref.fasta we expect ref.fasta.fai.\n    pub fn with_fasta_file\u003cP: AsRef\u003cPath\u003e\u003e(fasta_path: \u0026P) -\u003e anyhow::Result\u003cSelf\u003e {\n        let mut fai_path = fasta_path.as_ref().as_os_str().to_owned();\n        fai_path.push(\".fai\");\n\n        Self::from_file(\u0026fai_path)\n    }\n\n    /// Return a vector of sequences described in the index.\n    pub fn sequences(\u0026self) -\u003e Vec\u003cSequence\u003e {\n        // sort kv pairs by rid to preserve order\n        self.inner\n            .iter()\n            .map(|record| Sequence {\n                name: record.name.clone(),\n                len: record.len,\n            })\n            .collect()\n    }\n}\n\n/// A FASTA reader with an index as created by SAMtools (.fai).\n#[derive(Debug)]\npub struct IndexedReader\u003cR: io::Read + io::Seek\u003e {\n    reader: io::BufReader\u003cR\u003e,\n    pub index: Index,\n    fetched_idx: Option\u003cIndexRecord\u003e,\n    start: Option\u003cu64\u003e,\n    stop: Option\u003cu64\u003e,\n}\n\nimpl IndexedReader\u003cfs::File\u003e {\n    /// Read from a given file path. This assumes the index ref.fasta.fai to be\n    /// present for FASTA ref.fasta.\n    pub fn from_file\u003cP: AsRef\u003cPath\u003e + std::fmt::Debug\u003e(path: \u0026P) -\u003e anyhow::Result\u003cSelf\u003e {\n        let index = Index::with_fasta_file(path)?;\n        fs::File::open(\u0026path)\n            .map(|f| Self::with_index(f, index))\n            .map_err(csv::Error::from)\n            .with_context(|| format!(\"Failed to read fasta from {:#?}\", path))\n    }\n}\n\nimpl\u003cR: io::Read + io::Seek\u003e IndexedReader\u003cR\u003e {\n    /// Read from a FASTA and its index, both given as `io::Read`. FASTA has to\n    /// be `io::Seek` in addition.\n    pub fn new\u003cI: io::Read\u003e(fasta: R, fai: I) -\u003e csv::Result\u003cSelf\u003e {\n        let index = Index::new(fai)?;\n        Ok(IndexedReader {\n            reader: io::BufReader::new(fasta),\n            index,\n            fetched_idx: None,\n            start: None,\n            stop: None,\n        })\n    }\n\n    /// Read from a FASTA and its index, the first given as `io::Read`, the\n    /// second given as index object.\n    pub fn with_index(fasta: R, index: Index) -\u003e Self {\n        IndexedReader {\n            reader: io::BufReader::new(fasta),\n            index,\n            fetched_idx: None,\n            start: None,\n            stop: None,\n        }\n    }\n\n    /// Fetch an interval from the sequence with the given name for reading.\n    ///\n    /// `start` and `stop` are 0-based and `stop` is exclusive - i.e. `[start, stop)`\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use bio::io::fasta::IndexedReader;\n    /// // create dummy files\n    /// const FASTA_FILE: \u0026[u8] = b\"\u003echr1\\nGTAGGCTGAAAA\\nCCCC\";\n    /// const FAI_FILE: \u0026[u8] = b\"chr1\\t16\\t6\\t12\\t13\";\n    ///\n    /// let seq_name = \"chr1\";\n    /// let start: u64 = 0;  // start is 0-based, inclusive\n    /// let stop: u64 = 10;  // stop is 0-based, exclusive\n    /// // load the index\n    /// let mut faidx = IndexedReader::new(std::io::Cursor::new(FASTA_FILE), FAI_FILE).unwrap();\n    /// // move the pointer in the index to the desired sequence and interval\n    /// faidx.fetch(seq_name, start, stop).expect(\"Couldn't fetch interval\");\n    /// // read the subsequence defined by the interval into a vector\n    /// let mut seq = Vec::new();\n    /// faidx.read(\u0026mut seq).expect(\"Couldn't read the interval\");\n    /// assert_eq!(seq, b\"GTAGGCTGAA\");\n    /// ```\n    ///\n    /// # Errors\n    /// If the `seq_name` does not exist within the index.\n    ///\n    pub fn fetch(\u0026mut self, seq_name: \u0026str, start: u64, stop: u64) -\u003e io::Result\u003c()\u003e {\n        let idx = self.idx(seq_name)?;\n        self.start = Some(start);\n        self.stop = Some(stop);\n        self.fetched_idx = Some(idx);\n        Ok(())\n    }\n\n    /// Fetch an interval from the sequence with the given record index for reading.\n    ///\n    /// `start` and `stop` are 0-based and `stop` is exclusive - i.e. `[start, stop)`\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use bio::io::fasta::IndexedReader;\n    /// // create dummy files\n    /// const FASTA_FILE: \u0026[u8] = b\"\u003echr1\\nGTAGGCTGAAAA\\nCCCC\";\n    /// const FAI_FILE: \u0026[u8] = b\"chr1\\t16\\t6\\t12\\t13\";\n    ///\n    /// let rid: usize = 0;\n    /// let start: u64 = 0;  // start is 0-based, inclusive\n    /// let stop: u64 = 10;  // stop is 0-based, exclusive\n    /// // load the index\n    /// let mut faidx = IndexedReader::new(std::io::Cursor::new(FASTA_FILE), FAI_FILE).unwrap();\n    /// // move the pointer in the index to the desired sequence and interval\n    /// faidx.fetch_by_rid(rid, start, stop).expect(\"Couldn't fetch interval\");\n    /// // read the subsequence defined by the interval into a vector\n    /// let mut seq = Vec::new();\n    /// faidx.read(\u0026mut seq).expect(\"Couldn't read the interval\");\n    /// assert_eq!(seq, b\"GTAGGCTGAA\");\n    /// ```\n    ///\n    /// # Errors\n    /// If `rid` does not exist within the index.\n    ///\n    pub fn fetch_by_rid(\u0026mut self, rid: usize, start: u64, stop: u64) -\u003e io::Result\u003c()\u003e {\n        let idx = self.idx_by_rid(rid)?;\n        self.start = Some(start);\n        self.stop = Some(stop);\n        self.fetched_idx = Some(idx);\n        Ok(())\n    }\n\n    /// Fetch the whole sequence with the given name for reading.\n    pub fn fetch_all(\u0026mut self, seq_name: \u0026str) -\u003e io::Result\u003c()\u003e {\n        let idx = self.idx(seq_name)?;\n        self.start = Some(0);\n        self.stop = Some(idx.len);\n        self.fetched_idx = Some(idx);\n        Ok(())\n    }\n\n    /// Fetch the whole sequence with the given record index for reading.\n    pub fn fetch_all_by_rid(\u0026mut self, rid: usize) -\u003e io::Result\u003c()\u003e {\n        let idx = self.idx_by_rid(rid)?;\n        self.start = Some(0);\n        self.stop = Some(idx.len);\n        self.fetched_idx = Some(idx);\n        Ok(())\n    }\n\n    /// Read the fetched sequence into the given vector.\n    pub fn read(\u0026mut self, seq: \u0026mut Text) -\u003e io::Result\u003c()\u003e {\n        let idx = self.fetched_idx.clone();\n        match (idx, self.start, self.stop) {\n            (Some(idx), Some(start), Some(stop)) =\u003e self.read_into_buffer(idx, start, stop, seq),\n            _ =\u003e Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"No sequence fetched for reading.\",\n            )),\n        }\n    }\n\n    /// Return an iterator yielding the fetched sequence.\n    pub fn read_iter(\u0026mut self) -\u003e io::Result\u003cIndexedReaderIterator\u003c'_, R\u003e\u003e {\n        let idx = self.fetched_idx.clone();\n        match (idx, self.start, self.stop) {\n            (Some(idx), Some(start), Some(stop)) =\u003e self.read_into_iter(idx, start, stop),\n            _ =\u003e Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"No sequence fetched for reading.\",\n            )),\n        }\n    }\n\n    fn read_into_buffer(\n        \u0026mut self,\n        idx: IndexRecord,\n        start: u64,\n        stop: u64,\n        seq: \u0026mut Text,\n    ) -\u003e io::Result\u003c()\u003e {\n        if stop \u003e idx.len {\n            return Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"FASTA read interval was out of bounds\",\n            ));\n        } else if start \u003e stop {\n            return Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"Invalid query interval\",\n            ));\n        }\n\n        let mut bases_left = stop - start;\n        let mut line_offset = self.seek_to(\u0026idx, start)?;\n\n        seq.clear();\n        while bases_left \u003e 0 {\n            bases_left -= self.read_line(\u0026idx, \u0026mut line_offset, bases_left, seq)?;\n        }\n\n        Ok(())\n    }\n\n    fn read_into_iter(\n        \u0026mut self,\n        idx: IndexRecord,\n        start: u64,\n        stop: u64,\n    ) -\u003e io::Result\u003cIndexedReaderIterator\u003c'_, R\u003e\u003e {\n        if stop \u003e idx.len {\n            return Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"FASTA read interval was out of bounds\",\n            ));\n        } else if start \u003e stop {\n            return Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"Invalid query interval\",\n            ));\n        }\n\n        let bases_left = stop - start;\n        let line_offset = self.seek_to(\u0026idx, start)?;\n        let capacity = min(\n            MAX_FASTA_BUFFER_SIZE,\n            min(bases_left, idx.line_bases) as usize,\n        );\n\n        Ok(IndexedReaderIterator {\n            reader: self,\n            record: idx,\n            bases_left,\n            line_offset,\n            buf: Vec::with_capacity(capacity),\n            buf_idx: 0,\n        })\n    }\n\n    /// Return the IndexRecord for the given sequence name or io::Result::Err\n    fn idx(\u0026self, seqname: \u0026str) -\u003e io::Result\u003cIndexRecord\u003e {\n        match self.index.name_to_rid.get(seqname) {\n            Some(rid) =\u003e self.idx_by_rid(*rid),\n            None =\u003e Err(io::Error::new(\n                io::ErrorKind::Other,\n                format!(\"Unknown sequence name: {}.\", seqname),\n            )),\n        }\n    }\n\n    /// Return the IndexRecord for the given record index or io::Result::Err\n    fn idx_by_rid(\u0026self, rid: usize) -\u003e io::Result\u003cIndexRecord\u003e {\n        match self.index.inner.get(rid) {\n            Some(record) =\u003e Ok(record.clone()),\n            None =\u003e Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"Invalid record index in fasta file.\",\n            )),\n        }\n    }\n\n    /// Seek to the given position in the specified FASTA record. The position\n    /// of the cursor on the line that the seek ended on is returned.\n    fn seek_to(\u0026mut self, idx: \u0026IndexRecord, start: u64) -\u003e io::Result\u003cu64\u003e {\n        assert!(start \u003c= idx.len);\n\n        let line_offset = start % idx.line_bases;\n        let line_start = start / idx.line_bases * idx.line_bytes;\n        let offset = idx.offset + line_start + line_offset;\n        self.reader.seek(io::SeekFrom::Start(offset))?;\n\n        Ok(line_offset)\n    }\n\n    /// Tries to read up to `bases_left` bases from the current line into `buf`,\n    /// returning the actual number of bases read. Depending on the amount of\n    /// whitespace per line, the current `line_offset`, and the amount of bytes\n    /// returned from `BufReader::fill_buf`, this function may return Ok(0)\n    /// multiple times in a row.\n    fn read_line(\n        \u0026mut self,\n        idx: \u0026IndexRecord,\n        line_offset: \u0026mut u64,\n        bases_left: u64,\n        buf: \u0026mut Vec\u003cu8\u003e,\n    ) -\u003e io::Result\u003cu64\u003e {\n        let (bytes_to_read, bytes_to_keep) = {\n            let src = self.reader.fill_buf()?;\n            if src.is_empty() {\n                return Err(io::Error::new(\n                    io::ErrorKind::UnexpectedEof,\n                    \"FASTA file is truncated.\",\n                ));\n            }\n\n            let bases_on_line = idx.line_bases - min(idx.line_bases, *line_offset);\n            let bases_in_buffer = min(src.len() as u64, bases_on_line);\n\n            let (bytes_to_read, bytes_to_keep) = if bases_in_buffer \u003c= bases_left {\n                let bytes_to_read = min(src.len() as u64, idx.line_bytes - *line_offset);\n\n                (bytes_to_read, bases_in_buffer)\n            } else {\n                (bases_left, bases_left)\n            };\n\n            buf.extend_from_slice(\u0026src[..bytes_to_keep as usize]);\n            (bytes_to_read, bytes_to_keep)\n        };\n\n        self.reader.consume(bytes_to_read as usize);\n\n        assert!(bytes_to_read \u003e 0);\n        *line_offset += bytes_to_read;\n        if *line_offset \u003e= idx.line_bytes {\n            *line_offset = 0;\n        }\n\n        Ok(bytes_to_keep)\n    }\n}\n\n/// Record of a FASTA index.\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\nstruct IndexRecord {\n    name: String,\n    len: u64,\n    offset: u64,\n    line_bases: u64,\n    line_bytes: u64,\n}\n\n/// A sequence record returned by the FASTA index.\n#[derive(Debug, PartialEq)]\npub struct Sequence {\n    pub name: String,\n    pub len: u64,\n}\n\npub struct IndexedReaderIterator\u003c'a, R: io::Read + io::Seek\u003e {\n    reader: \u0026'a mut IndexedReader\u003cR\u003e,\n    record: IndexRecord,\n    bases_left: u64,\n    line_offset: u64,\n    buf: Vec\u003cu8\u003e,\n    buf_idx: usize,\n}\n\nimpl\u003c'a, R: io::Read + io::Seek + 'a\u003e IndexedReaderIterator\u003c'a, R\u003e {\n    fn fill_buffer(\u0026mut self) -\u003e io::Result\u003c()\u003e {\n        assert!(self.bases_left \u003e 0);\n\n        self.buf.clear();\n        let bases_to_read = min(self.buf.capacity() as u64, self.bases_left);\n\n        // May loop one or more times; see IndexedReader::read_line.\n        while self.buf.is_empty() {\n            self.bases_left -= self.reader.read_line(\n                \u0026self.record,\n                \u0026mut self.line_offset,\n                bases_to_read,\n                \u0026mut self.buf,\n            )?;\n        }\n\n        self.buf_idx = 0;\n        Ok(())\n    }\n}\n\nimpl\u003c'a, R: io::Read + io::Seek + 'a\u003e Iterator for IndexedReaderIterator\u003c'a, R\u003e {\n    type Item = io::Result\u003cu8\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        if self.buf_idx \u003c self.buf.len() {\n            let item = Some(Ok(self.buf[self.buf_idx]));\n            self.buf_idx += 1;\n            item\n        } else if self.bases_left \u003e 0 {\n            if let Err(e) = self.fill_buffer() {\n                self.bases_left = 0;\n                self.buf_idx = self.buf.len();\n\n                return Some(Err(e));\n            }\n\n            self.buf_idx = 1;\n            Some(Ok(self.buf[0]))\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(\u0026self) -\u003e (usize, Option\u003cusize\u003e) {\n        let hint = self.bases_left as usize + (self.buf.len() - self.buf_idx);\n\n        (hint, Some(hint))\n    }\n}\n\n/// A Fasta writer.\n#[derive(Debug)]\npub struct Writer\u003cW: io::Write\u003e {\n    writer: io::BufWriter\u003cW\u003e,\n}\n\nimpl Writer\u003cfs::File\u003e {\n    /// Write to the given file path.\n    #[allow(clippy::wrong_self_convention)]\n    pub fn to_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e io::Result\u003cSelf\u003e {\n        fs::File::create(path).map(Writer::new)\n    }\n}\n\nimpl\u003cW: io::Write\u003e Writer\u003cW\u003e {\n    /// Create a new Fasta writer.\n    pub fn new(writer: W) -\u003e Self {\n        Writer {\n            writer: io::BufWriter::new(writer),\n        }\n    }\n\n    /// Directly write a [`fasta::Record`](struct.Record.html).\n    ///\n    /// # Errors\n    /// If there is an issue writing to the `Writer`.\n    ///\n    /// # Examples\n    /// ```rust\n    /// use bio::io::fasta::{Record, Writer};\n    /// use std::fs;\n    /// use std::io;\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"test.fa\");\n    /// let file = fs::File::create(path).unwrap();\n    /// {\n    ///     let handle = io::BufWriter::new(file);\n    ///     let mut writer = Writer::new(handle);\n    ///     let record = Record::with_attrs(\"id\", Some(\"desc\"), b\"ACGT\");\n    ///\n    ///     let write_result = writer.write_record(\u0026record);\n    ///     assert!(write_result.is_ok());\n    /// }\n    ///\n    /// let actual = fs::read_to_string(path).unwrap();\n    /// let expected = \"\u003eid desc\\nACGT\\n\";\n    ///\n    /// assert!(fs::remove_file(path).is_ok());\n    /// assert_eq!(actual, expected)\n    /// ```\n    pub fn write_record(\u0026mut self, record: \u0026Record) -\u003e io::Result\u003c()\u003e {\n        self.write(record.id(), record.desc(), record.seq())\n    }\n\n    /// Write a Fasta record with given id, optional description and sequence.\n    pub fn write(\u0026mut self, id: \u0026str, desc: Option\u003c\u0026str\u003e, seq: TextSlice\u003c'_\u003e) -\u003e io::Result\u003c()\u003e {\n        self.writer.write_all(b\"\u003e\")?;\n        self.writer.write_all(id.as_bytes())?;\n        if let Some(desc) = desc {\n            self.writer.write_all(b\" \")?;\n            self.writer.write_all(desc.as_bytes())?;\n        }\n        self.writer.write_all(b\"\\n\")?;\n        self.writer.write_all(seq)?;\n        self.writer.write_all(b\"\\n\")?;\n\n        Ok(())\n    }\n\n    /// Flush the writer, ensuring that everything is written.\n    pub fn flush(\u0026mut self) -\u003e io::Result\u003c()\u003e {\n        self.writer.flush()\n    }\n}\n\n/// A FASTA record.\n#[derive(Default, Clone, Debug, Serialize, Deserialize)]\npub struct Record {\n    id: String,\n    desc: Option\u003cString\u003e,\n    seq: String,\n}\n\nimpl Record {\n    /// Create a new instance.\n    pub fn new() -\u003e Self {\n        Record {\n            id: String::new(),\n            desc: None,\n            seq: String::new(),\n        }\n    }\n\n    /// Create a new `Record` from given attributes.\n    ///\n    /// # Examples\n    /// ```rust\n    /// use bio::io::fasta::Record;\n    ///\n    /// let read_id = \"read1\";\n    /// let description = Some(\"sampleid=foobar\");\n    /// let sequence = b\"ACGT\";\n    /// let record = Record::with_attrs(read_id, description, sequence);\n    ///\n    /// assert_eq!(\"\u003eread1 sampleid=foobar\\nACGT\\n\", record.to_string())\n    /// ```\n    pub fn with_attrs(id: \u0026str, desc: Option\u003c\u0026str\u003e, seq: TextSlice\u003c'_\u003e) -\u003e Self {\n        let desc = match desc {\n            Some(desc) =\u003e Some(desc.to_owned()),\n            _ =\u003e None,\n        };\n        Record {\n            id: id.to_owned(),\n            desc,\n            seq: String::from_utf8(seq.to_vec()).unwrap(),\n        }\n    }\n\n    /// Check if record is empty.\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.id.is_empty() \u0026\u0026 self.desc.is_none() \u0026\u0026 self.seq.is_empty()\n    }\n\n    /// Check validity of Fasta record.\n    pub fn check(\u0026self) -\u003e Result\u003c(), \u0026str\u003e {\n        if self.id().is_empty() {\n            return Err(\"Expecting id for Fasta record.\");\n        }\n        if !self.seq.is_ascii() {\n            return Err(\"Non-ascii character found in sequence.\");\n        }\n\n        Ok(())\n    }\n\n    /// Return the id of the record.\n    pub fn id(\u0026self) -\u003e \u0026str {\n        self.id.as_ref()\n    }\n\n    /// Return descriptions if present.\n    pub fn desc(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        match self.desc.as_ref() {\n            Some(desc) =\u003e Some(\u0026desc),\n            None =\u003e None,\n        }\n    }\n\n    /// Return the sequence of the record.\n    pub fn seq(\u0026self) -\u003e TextSlice\u003c'_\u003e {\n        self.seq.as_bytes()\n    }\n\n    /// Clear the record.\n    fn clear(\u0026mut self) {\n        self.id.clear();\n        self.desc = None;\n        self.seq.clear();\n    }\n}\n\nimpl fmt::Display for Record {\n    /// Allows for using `Record` in a given formatter `f`. In general this is for\n    /// creating a `String` representation of a `Record` and, optionally, writing it to\n    /// a file.\n    ///\n    /// # Errors\n    /// Returns [`std::fmt::Error`](https://doc.rust-lang.org/std/fmt/struct.Error.html)\n    /// if there is an issue formatting to the stream.\n    ///\n    /// # Examples\n    ///\n    /// Read in a Fasta `Record` and create a `String` representation of it.\n    ///\n    /// ```rust\n    /// use bio::io::fasta::Reader;\n    /// use std::fmt::Write;\n    /// // create a \"fake\" fasta file\n    /// let fasta: \u0026'static [u8] = b\"\u003eid comment1 comment2\\nACGT\\n\";\n    /// let mut records = Reader::new(fasta).records().map(|r| r.unwrap());\n    /// let record = records.next().unwrap();\n    ///\n    /// let mut actual = String::new();\n    /// // populate `actual` with a string representation of our record\n    /// write!(actual, \"{}\", record).unwrap();\n    ///\n    /// let expected = std::str::from_utf8(fasta).unwrap();\n    ///\n    /// assert_eq!(actual, expected)\n    /// ```\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e Result\u003c(), fmt::Error\u003e {\n        let header = match self.desc() {\n            Some(d) =\u003e format!(\"{} {}\", self.id().to_owned(), d),\n            None =\u003e self.id().to_owned(),\n        };\n        write!(\n            f,\n            \"\u003e{}\\n{}\\n\",\n            header,\n            std::str::from_utf8(self.seq()).unwrap(),\n        )\n    }\n}\n\n/// An iterator over the records of a Fasta file.\n#[derive(Debug)]\npub struct Records\u003cR: io::Read\u003e {\n    reader: Reader\u003cR\u003e,\n    error_has_occured: bool,\n}\n\nimpl\u003cR: io::Read\u003e Iterator for Records\u003cR\u003e {\n    type Item = io::Result\u003cRecord\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cio::Result\u003cRecord\u003e\u003e {\n        if self.error_has_occured {\n            None\n        } else {\n            let mut record = Record::new();\n            match self.reader.read(\u0026mut record) {\n                Ok(()) if record.is_empty() =\u003e None,\n                Ok(()) =\u003e Some(Ok(record)),\n                Err(err) =\u003e {\n                    self.error_has_occured = true;\n                    Some(Err(err))\n                }\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fmt::Write as FmtWrite;\n    use std::io;\n\n    const FASTA_FILE: \u0026[u8] = b\"\u003eid desc\nACCGTAGGCTGA\nCCGTAGGCTGAA\nCGTAGGCTGAAA\nGTAGGCTGAAAA\nCCCC\n\u003eid2\nATTGTTGTTTTA\nATTGTTGTTTTA\nATTGTTGTTTTA\nGGGG\n\";\n    const FAI_FILE: \u0026[u8] = b\"id\\t52\\t9\\t12\\t13\nid2\\t40\\t71\\t12\\t13\n\";\n\n    const TRUNCATED_FASTA: \u0026[u8] = b\"\u003eid desc\\nACCGTAGGCTGA\";\n\n    const FASTA_FILE_CRLF: \u0026[u8] = b\"\u003eid desc\\r\nACCGTAGGCTGA\\r\nCCGTAGGCTGAA\\r\nCGTAGGCTGAAA\\r\nGTAGGCTGAAAA\\r\nCCCC\\r\n\u003eid2\\r\nATTGTTGTTTTA\\r\nATTGTTGTTTTA\\r\nATTGTTGTTTTA\\r\nGGGG\\r\n\";\n    const FAI_FILE_CRLF: \u0026[u8] = b\"id\\t52\\t10\\t12\\t14\\r\nid2\\t40\\t78\\t12\\t14\\r\n\";\n\n    const FASTA_FILE_NO_TRAILING_LF: \u0026[u8] = b\"\u003eid desc\nGTAGGCTGAAAA\nCCCC\";\n    const FAI_FILE_NO_TRAILING_LF: \u0026[u8] = b\"id\\t16\\t9\\t12\\t13\";\n\n    const WRITE_FASTA_FILE: \u0026[u8] = b\"\u003eid desc\nACCGTAGGCTGA\n\u003eid2\nATTGTTGTTTTA\n\";\n\n    struct ReaderMock {\n        seek_fails: bool,\n        read_fails: bool,\n    }\n\n    impl Read for ReaderMock {\n        fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e io::Result\u003cusize\u003e {\n            if self.read_fails {\n                Err(io::Error::new(io::ErrorKind::Other, \"Read set to fail\"))\n            } else {\n                Ok(buf.len())\n            }\n        }\n    }\n\n    impl Seek for ReaderMock {\n        fn seek(\u0026mut self, pos: io::SeekFrom) -\u003e io::Result\u003cu64\u003e {\n            if let io::SeekFrom::Start(pos) = pos {\n                if self.seek_fails {\n                    Err(io::Error::new(io::ErrorKind::Other, \"Seek set to fail\"))\n                } else {\n                    Ok(pos)\n                }\n            } else {\n                unimplemented!();\n            }\n        }\n    }\n\n    #[test]\n    fn test_reader() {\n        let reader = Reader::new(FASTA_FILE);\n        let ids = [\"id\", \"id2\"];\n        let descs = [Some(\"desc\"), None];\n        let seqs: [\u0026[u8]; 2] = [\n            b\"ACCGTAGGCTGACCGTAGGCTGAACGTAGGCTGAAAGTAGGCTGAAAACCCC\",\n            b\"ATTGTTGTTTTAATTGTTGTTTTAATTGTTGTTTTAGGGG\",\n        ];\n\n        for (i, r) in reader.records().enumerate() {\n            let record = r.expect(\"Error reading record\");\n            assert_eq!(record.check(), Ok(()));\n            assert_eq!(record.id(), ids[i]);\n            assert_eq!(record.desc(), descs[i]);\n            assert_eq!(record.seq(), seqs[i]);\n        }\n    }\n\n    #[test]\n    fn test_faread_trait() {\n        let path = \"genome.fa.gz\";\n        let mut fa_reader: Box\u003cdyn FastaRead\u003e = match path.ends_with(\".gz\") {\n            true =\u003e Box::new(Reader::new(io::BufReader::new(FASTA_FILE))),\n            false =\u003e Box::new(Reader::new(FASTA_FILE)),\n        };\n        // The read method can be called, since it is implemented by\n        // FQRead. Right now, the records method would not work.\n        let mut record = Record::new();\n        fa_reader.read(\u0026mut record).unwrap();\n        // Check if the returned result is correct.\n        assert_eq!(record.check(), Ok(()));\n        assert_eq!(record.id(), \"id\");\n        assert_eq!(record.desc(), Some(\"desc\"));\n        assert_eq!(\n            record.seq().to_vec(),\n            b\"ACCGTAGGCTGACCGTAGGCTGAACGTAGGCTGAAAGTAGGCTGAAAACCCC\".to_vec()\n        );\n    }\n\n    #[test]\n    fn test_reader_wrong_header() {\n        let mut reader = Reader::new(\u0026b\"!test\\nACGTA\\n\"[..]);\n        let mut record = Record::new();\n        assert!(\n            reader.read(\u0026mut record).is_err(),\n            \"read() should return Err if FASTA header is malformed\"\n        );\n    }\n\n    #[test]\n    fn test_reader_no_id() {\n        let mut reader = Reader::new(\u0026b\"\u003e\\nACGTA\\n\"[..]);\n        let mut record = Record::new();\n        reader.read(\u0026mut record).unwrap();\n        assert!(\n            record.check().is_err(),\n            \"check() should return Err if FASTA header is empty\"\n        );\n    }\n\n    #[test]\n    fn test_reader_non_ascii_sequence() {\n        let mut reader = Reader::new(\u0026b\"\u003eid\\nACGTA\\xE2\\x98\\xB9AT\\n\"[..]);\n        let mut record = Record::new();\n        reader.read(\u0026mut record).unwrap();\n        assert!(\n            record.check().is_err(),\n            \"check() should return Err if FASTA sequence is not ASCII\"\n        );\n    }\n\n    #[test]\n    fn test_reader_read_fails() {\n        let mut reader = Reader::new(ReaderMock {\n            seek_fails: false,\n            read_fails: true,\n        });\n        let mut record = Record::new();\n        assert!(\n            reader.read(\u0026mut record).is_err(),\n            \"read() should return Err if Read::read fails\"\n        );\n    }\n\n    #[test]\n    fn test_reader_read_fails_iter() {\n        let reader = Reader::new(ReaderMock {\n            seek_fails: false,\n            read_fails: true,\n        });\n        let mut records = reader.records();\n\n        assert!(\n            records.next().unwrap().is_err(),\n            \"next() should return Err if Read::read fails\"\n        );\n        assert!(\n            records.next().is_none(),\n            \"next() should return None after error has occurred\"\n        );\n    }\n\n    #[test]\n    fn test_reader_from_file_path_doesnt_exist_returns_err() {\n        let path = Path::new(\"/I/dont/exist.fasta\");\n        let error = Reader::from_file(path)\n            .unwrap_err()\n            .downcast::\u003cString\u003e()\n            .unwrap();\n\n        assert_eq!(\u0026error, \"Failed to read fasta from \\\"/I/dont/exist.fasta\\\"\")\n    }\n\n    #[test]\n    fn test_record_with_attrs_without_description() {\n        let record = Record::with_attrs(\"id_str\", None, b\"ATGCGGG\");\n        assert_eq!(record.id(), \"id_str\");\n        assert_eq!(record.desc(), None);\n        assert_eq!(record.seq(), b\"ATGCGGG\");\n    }\n\n    #[test]\n    fn test_record_with_attrs_with_description() {\n        let record = Record::with_attrs(\"id_str\", Some(\"desc\"), b\"ATGCGGG\");\n        assert_eq!(record.id(), \"id_str\");\n        assert_eq!(record.desc(), Some(\"desc\"));\n        assert_eq!(record.seq(), b\"ATGCGGG\");\n    }\n\n    #[test]\n    fn test_index_sequences() {\n        let reader = IndexedReader::new(io::Cursor::new(FASTA_FILE), FAI_FILE).unwrap();\n\n        let sequences = reader.index.sequences();\n        assert_eq!(sequences.len(), 2);\n        assert_eq!(\n            sequences[0],\n            Sequence {\n                name: \"id\".into(),\n                len: 52,\n            }\n        );\n        assert_eq!(\n            sequences[1],\n            Sequence {\n                name: \"id2\".into(),\n                len: 40,\n            }\n        );\n    }\n\n    #[test]\n    fn test_indexed_reader() {\n        _test_indexed_reader(\u0026FASTA_FILE, \u0026FAI_FILE, _read_buffer);\n        _test_indexed_reader_truncated(_read_buffer);\n        _test_indexed_reader_extreme_whitespace(_read_buffer);\n    }\n\n    #[test]\n    fn test_indexed_reader_crlf() {\n        _test_indexed_reader(\u0026FASTA_FILE_CRLF, \u0026FAI_FILE_CRLF, _read_buffer);\n    }\n\n    #[test]\n    fn test_indexed_reader_iter() {\n        _test_indexed_reader(\u0026FASTA_FILE, \u0026FAI_FILE, _read_iter);\n        _test_indexed_reader_truncated(_read_iter);\n        _test_indexed_reader_extreme_whitespace(_read_iter);\n    }\n\n    #[test]\n    fn test_indexed_reader_iter_crlf() {\n        _test_indexed_reader(\u0026FASTA_FILE_CRLF, \u0026FAI_FILE_CRLF, _read_iter);\n    }\n\n    fn _test_indexed_reader\u003c'a, F\u003e(fasta: \u0026'a [u8], fai: \u0026'a [u8], read: F)\n    where\n        F: Fn(\u0026mut IndexedReader\u003cio::Cursor\u003c\u0026'a [u8]\u003e\u003e, \u0026str, u64, u64) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e,\n    {\n        let mut reader = IndexedReader::new(io::Cursor::new(fasta), fai).unwrap();\n\n        // Test reading various substrings of the sequence\n        assert_eq!(read(\u0026mut reader, \"id\", 1, 5).unwrap(), b\"CCGT\");\n        assert_eq!(\n            read(\u0026mut reader, \"id\", 1, 31).unwrap(),\n            b\"CCGTAGGCTGACCGTAGGCTGAACGTAGGC\"\n        );\n        assert_eq!(read(\u0026mut reader, \"id\", 13, 23).unwrap(), b\"CGTAGGCTGA\");\n        assert_eq!(\n            read(\u0026mut reader, \"id\", 36, 52).unwrap(),\n            b\"GTAGGCTGAAAACCCC\"\n        );\n        assert_eq!(\n            read(\u0026mut reader, \"id2\", 12, 40).unwrap(),\n            b\"ATTGTTGTTTTAATTGTTGTTTTAGGGG\"\n        );\n        assert_eq!(read(\u0026mut reader, \"id2\", 12, 12).unwrap(), b\"\");\n        assert_eq!(read(\u0026mut reader, \"id2\", 12, 13).unwrap(), b\"A\");\n        // Minimal sequence spanning new-line\n        assert_eq!(read(\u0026mut reader, \"id\", 11, 13).unwrap(), b\"AC\");\n\n        assert!(read(\u0026mut reader, \"id2\", 12, 11).is_err());\n        assert!(read(\u0026mut reader, \"id2\", 12, 1000).is_err());\n        assert!(read(\u0026mut reader, \"id3\", 0, 1).is_err());\n    }\n\n    fn _test_indexed_reader_truncated\u003c'a, F\u003e(read: F)\n    where\n        F: Fn(\u0026mut IndexedReader\u003cio::Cursor\u003c\u0026'a [u8]\u003e\u003e, \u0026str, u64, u64) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e,\n    {\n        let mut reader = IndexedReader::new(io::Cursor::new(TRUNCATED_FASTA), FAI_FILE).unwrap();\n\n        assert_eq!(read(\u0026mut reader, \"id\", 0, 12).unwrap(), b\"ACCGTAGGCTGA\");\n        assert!(read(\u0026mut reader, \"id\", 0, 13).is_err()); // read past EOF\n        assert!(read(\u0026mut reader, \"id\", 36, 52).is_err()); // seek and read past EOF\n        assert!(read(\u0026mut reader, \"id2\", 12, 40).is_err()); // seek and read past EOF\n    }\n\n    fn _test_indexed_reader_extreme_whitespace\u003cF\u003e(read: F)\n    where\n        F: Fn(\u0026mut IndexedReader\u003cio::Cursor\u003cVec\u003cu8\u003e\u003e\u003e, \u0026str, u64, u64) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e,\n    {\n        // Test to exercise the case where we cannot consume all whitespace at once. More than\n        // DEFAULT_BUF_SIZE (a non-public constant set to 8 * 1024) whitespace is used to ensure\n        // that it can't all fit in the BufReader at once.\n        let mut seq = Vec::new();\n        seq.push(b'A');\n        seq.resize(10000, b' ');\n        seq.push(b'B');\n\n        let fasta = io::Cursor::new(seq);\n        let fai = io::Cursor::new(Vec::from(\u0026b\"id\\t2\\t0\\t1\\t10000\"[..]));\n        let mut reader = IndexedReader::new(fasta, fai).unwrap();\n\n        assert_eq!(read(\u0026mut reader, \"id\", 0, 2).unwrap(), b\"AB\");\n    }\n\n    fn _read_buffer\u003cT\u003e(\n        reader: \u0026mut IndexedReader\u003cT\u003e,\n        seqname: \u0026str,\n        start: u64,\n        stop: u64,\n    ) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e\n    where\n        T: Seek + Read,\n    {\n        let mut seq = vec![];\n        reader.fetch(seqname, start, stop)?;\n        reader.read(\u0026mut seq)?;\n\n        Ok(seq)\n    }\n\n    fn _read_iter\u003cT\u003e(\n        reader: \u0026mut IndexedReader\u003cT\u003e,\n        seqname: \u0026str,\n        start: u64,\n        stop: u64,\n    ) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e\n    where\n        T: Seek + Read,\n    {\n        let mut seq = vec![];\n        reader.fetch(seqname, start, stop)?;\n        for nuc in reader.read_iter()? {\n            seq.push(nuc?);\n        }\n\n        Ok(seq)\n    }\n\n    #[test]\n    fn test_indexed_reader_all() {\n        _test_indexed_reader_all(\u0026FASTA_FILE, \u0026FAI_FILE, _read_buffer_all);\n    }\n\n    #[test]\n    fn test_indexed_reader_crlf_all() {\n        _test_indexed_reader_all(\u0026FASTA_FILE_CRLF, \u0026FAI_FILE_CRLF, _read_buffer_all);\n    }\n\n    #[test]\n    fn test_indexed_reader_iter_all() {\n        _test_indexed_reader_all(\u0026FASTA_FILE, \u0026FAI_FILE, _read_iter_all);\n    }\n\n    #[test]\n    fn test_indexed_reader_iter_crlf_all() {\n        _test_indexed_reader_all(\u0026FASTA_FILE_CRLF, \u0026FAI_FILE_CRLF, _read_iter_all);\n    }\n\n    fn _test_indexed_reader_all\u003c'a, F\u003e(fasta: \u0026'a [u8], fai: \u0026'a [u8], read: F)\n    where\n        F: Fn(\u0026mut IndexedReader\u003cio::Cursor\u003c\u0026'a [u8]\u003e\u003e, \u0026str) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e,\n    {\n        let mut reader = IndexedReader::new(io::Cursor::new(fasta), fai).unwrap();\n\n        assert_eq!(\n            read(\u0026mut reader, \"id\").unwrap(),\n            \u0026b\"ACCGTAGGCTGACCGTAGGCTGAACGTAGGCTGAAAGTAGGCTGAAAACCCC\"[..]\n        );\n        assert_eq!(\n            read(\u0026mut reader, \"id2\").unwrap(),\n            \u0026b\"ATTGTTGTTTTAATTGTTGTTTTAATTGTTGTTTTAGGGG\"[..]\n        );\n    }\n\n    fn _read_buffer_all\u003cT\u003e(reader: \u0026mut IndexedReader\u003cT\u003e, seqname: \u0026str) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e\n    where\n        T: Seek + Read,\n    {\n        let mut seq = vec![];\n        reader.fetch_all(seqname)?;\n        reader.read(\u0026mut seq)?;\n\n        Ok(seq)\n    }\n\n    fn _read_iter_all\u003cT\u003e(reader: \u0026mut IndexedReader\u003cT\u003e, seqname: \u0026str) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e\n    where\n        T: Seek + Read,\n    {\n        let mut seq = vec![];\n        reader.fetch_all(seqname)?;\n        for nuc in reader.read_iter()? {\n            seq.push(nuc?);\n        }\n\n        Ok(seq)\n    }\n\n    #[test]\n    fn test_indexed_reader_by_rid_all() {\n        _test_indexed_reader_by_rid_all(\u0026FASTA_FILE, \u0026FAI_FILE, _read_buffer_by_rid_all);\n    }\n\n    #[test]\n    fn test_indexed_reader_crlf_by_rid_all() {\n        _test_indexed_reader_by_rid_all(\u0026FASTA_FILE_CRLF, \u0026FAI_FILE_CRLF, _read_buffer_by_rid_all);\n    }\n\n    #[test]\n    fn test_indexed_reader_iter_by_rid_all() {\n        _test_indexed_reader_by_rid_all(\u0026FASTA_FILE, \u0026FAI_FILE, _read_iter_by_rid_all);\n    }\n\n    #[test]\n    fn test_indexed_reader_iter_crlf_by_rid_all() {\n        _test_indexed_reader_by_rid_all(\u0026FASTA_FILE_CRLF, \u0026FAI_FILE_CRLF, _read_iter_by_rid_all);\n    }\n\n    fn _test_indexed_reader_by_rid_all\u003c'a, F\u003e(fasta: \u0026'a [u8], fai: \u0026'a [u8], read: F)\n    where\n        F: Fn(\u0026mut IndexedReader\u003cio::Cursor\u003c\u0026'a [u8]\u003e\u003e, usize) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e,\n    {\n        let mut reader = IndexedReader::new(io::Cursor::new(fasta), fai).unwrap();\n\n        assert_eq!(\n            read(\u0026mut reader, 0).unwrap(),\n            \u0026b\"ACCGTAGGCTGACCGTAGGCTGAACGTAGGCTGAAAGTAGGCTGAAAACCCC\"[..]\n        );\n        assert_eq!(\n            read(\u0026mut reader, 1).unwrap(),\n            \u0026b\"ATTGTTGTTTTAATTGTTGTTTTAATTGTTGTTTTAGGGG\"[..]\n        );\n    }\n\n    fn _read_buffer_by_rid_all\u003cT\u003e(\n        reader: \u0026mut IndexedReader\u003cT\u003e,\n        seq_index: usize,\n    ) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e\n    where\n        T: Seek + Read,\n    {\n        let mut seq = vec![];\n        reader.fetch_all_by_rid(seq_index)?;\n        reader.read(\u0026mut seq)?;\n\n        Ok(seq)\n    }\n\n    fn _read_iter_by_rid_all\u003cT\u003e(\n        reader: \u0026mut IndexedReader\u003cT\u003e,\n        seq_index: usize,\n    ) -\u003e io::Result\u003cVec\u003cu8\u003e\u003e\n    where\n        T: Seek + Read,\n    {\n        let mut seq = vec![];\n        reader.fetch_all_by_rid(seq_index)?;\n        for nuc in reader.read_iter()? {\n            seq.push(nuc?);\n        }\n\n        Ok(seq)\n    }\n\n    #[test]\n    fn test_indexed_reader_iter_size_hint() {\n        let mut reader = IndexedReader::new(io::Cursor::new(FASTA_FILE), FAI_FILE).unwrap();\n        reader.fetch(\"id\", 2, 4).unwrap();\n        let mut iterator = reader.read_iter().unwrap();\n\n        assert_eq!(iterator.size_hint(), (2, Some(2)));\n        assert_eq!(iterator.next().unwrap().unwrap(), b'C');\n        assert_eq!(iterator.size_hint(), (1, Some(1)));\n        assert_eq!(iterator.next().unwrap().unwrap(), b'G');\n        assert_eq!(iterator.size_hint(), (0, Some(0)));\n        assert!(iterator.next().is_none());\n        assert_eq!(iterator.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_indexed_reader_reused_buffer() {\n        let mut reader = IndexedReader::new(io::Cursor::new(FASTA_FILE), FAI_FILE).unwrap();\n        let mut seq = Vec::new();\n\n        reader.fetch(\"id\", 1, 5).unwrap();\n        reader.read(\u0026mut seq).unwrap();\n        assert_eq!(seq, b\"CCGT\");\n\n        reader.fetch(\"id\", 13, 23).unwrap();\n        reader.read(\u0026mut seq).unwrap();\n        assert_eq!(seq, b\"CGTAGGCTGA\");\n    }\n\n    #[test]\n    fn test_indexed_reader_no_trailing_lf() {\n        let mut reader = IndexedReader::new(\n            io::Cursor::new(FASTA_FILE_NO_TRAILING_LF),\n            FAI_FILE_NO_TRAILING_LF,\n        )\n        .unwrap();\n        let mut seq = Vec::new();\n\n        reader.fetch(\"id\", 0, 16).unwrap();\n        reader.read(\u0026mut seq).unwrap();\n        assert_eq!(seq, b\"GTAGGCTGAAAACCCC\");\n    }\n\n    #[test]\n    fn test_indexed_reader_bad_reader() {\n        let bad_reader = ReaderMock {\n            seek_fails: false,\n            read_fails: false,\n        };\n        let mut reader = IndexedReader::new(bad_reader, FAI_FILE).unwrap();\n        let mut seq = Vec::new();\n        reader.fetch(\"id\", 0, 10).unwrap();\n        assert!(reader.read(\u0026mut seq).is_ok())\n    }\n\n    #[test]\n    fn test_indexed_reader_read_seek_fails() {\n        let bad_reader = ReaderMock {\n            seek_fails: true,\n            read_fails: false,\n        };\n        let mut reader = IndexedReader::new(bad_reader, FAI_FILE).unwrap();\n        let mut seq = Vec::new();\n        reader.fetch(\"id\", 0, 10).unwrap();\n        assert!(reader.read(\u0026mut seq).is_err());\n    }\n\n    #[test]\n    fn test_indexed_reader_read_read_fails() {\n        let bad_reader = ReaderMock {\n            seek_fails: false,\n            read_fails: true,\n        };\n        let mut reader = IndexedReader::new(bad_reader, FAI_FILE).unwrap();\n        let mut seq = Vec::new();\n        reader.fetch(\"id\", 0, 10).unwrap();\n        assert!(reader.read(\u0026mut seq).is_err());\n    }\n\n    #[test]\n    fn test_indexed_reader_iter_seek_fails() {\n        let bad_reader = ReaderMock {\n            seek_fails: true,\n            read_fails: false,\n        };\n        let mut reader = IndexedReader::new(bad_reader, FAI_FILE).unwrap();\n        reader.fetch(\"id\", 0, 10).unwrap();\n        assert!(reader.read_iter().is_err());\n    }\n\n    #[test]\n    fn test_indexed_reader_iter_read_fails() {\n        let bad_reader = ReaderMock {\n            seek_fails: false,\n            read_fails: true,\n        };\n        let mut reader = IndexedReader::new(bad_reader, FAI_FILE).unwrap();\n        reader.fetch(\"id\", 0, 10).unwrap();\n        let mut iterator = reader.read_iter().unwrap();\n        assert!(iterator.next().unwrap().is_err());\n        assert!(\n            iterator.next().is_none(),\n            \"next() should return none after error has occurred\"\n        );\n    }\n\n    #[test]\n    fn test_indexed_reader_no_fetch_read_fails() {\n        let reader = ReaderMock {\n            seek_fails: false,\n            read_fails: false,\n        };\n        let mut reader = IndexedReader::new(reader, FAI_FILE).unwrap();\n        let mut seq = vec![];\n        assert!(reader.read(\u0026mut seq).is_err());\n    }\n\n    #[test]\n    fn test_indexed_reader_no_fetch_read_iter_fails() {\n        let reader = ReaderMock {\n            seek_fails: false,\n            read_fails: false,\n        };\n        let mut reader = IndexedReader::new(reader, FAI_FILE).unwrap();\n        assert!(reader.read_iter().is_err());\n    }\n\n    #[test]\n    fn test_writer() {\n        let mut writer = Writer::new(Vec::new());\n        writer.write(\"id\", Some(\"desc\"), b\"ACCGTAGGCTGA\").unwrap();\n        writer.write(\"id2\", None, b\"ATTGTTGTTTTA\").unwrap();\n        writer.flush().unwrap();\n        assert_eq!(writer.writer.get_ref(), \u0026WRITE_FASTA_FILE);\n    }\n\n    #[test]\n    fn test_display_record_no_desc_id_without_space_after() {\n        let fasta: \u0026'static [u8] = b\"\u003eid\\nACGT\\n\";\n        let mut records = Reader::new(fasta).records().map(|r| r.unwrap());\n        let record = records.next().unwrap();\n        let mut actual = String::new();\n        write!(actual, \"{}\", record).unwrap();\n\n        let expected = std::str::from_utf8(fasta).unwrap();\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_display_record_with_desc_id_has_space_between_id_and_desc() {\n        let fasta: \u0026'static [u8] = b\"\u003eid comment1 comment2\\nACGT\\n\";\n        let mut records = Reader::new(fasta).records().map(|r| r.unwrap());\n        let record = records.next().unwrap();\n        let mut actual = String::new();\n        write!(actual, \"{}\", record).unwrap();\n\n        let expected = std::str::from_utf8(fasta).unwrap();\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_index_record_idx_by_rid_invalid_index_returns_error() {\n        let reader = ReaderMock {\n            seek_fails: false,\n            read_fails: false,\n        };\n        let index_reader = IndexedReader::new(reader, FAI_FILE).unwrap();\n\n        let actual = index_reader.idx_by_rid(99999).unwrap_err();\n        let expected = io::Error::new(io::ErrorKind::Other, \"Invalid record index in fasta file.\");\n\n        assert_eq!(actual.kind(), expected.kind());\n        assert_eq!(actual.to_string(), expected.to_string())\n    }\n\n    #[test]\n    fn test_index_record_fetch_by_rid_second_index_returns_second_record() {\n        let reader = ReaderMock {\n            seek_fails: false,\n            read_fails: false,\n        };\n        let mut index_reader = IndexedReader::new(reader, FAI_FILE).unwrap();\n\n        let actual = index_reader.fetch_by_rid(1, 1, 3);\n\n        assert!(actual.is_ok());\n        assert_eq!(\n            index_reader.fetched_idx,\n            Some(IndexRecord {\n                name: String::from(\"id2\"),\n                len: 40,\n                offset: 71,\n                line_bases: 12,\n                line_bytes: 13\n            })\n        )\n    }\n\n    #[test]\n    fn test_writer_to_file_dir_doesnt_exist_returns_err() {\n        let path = Path::new(\"/I/dont/exist.fa\");\n\n        let actual = Writer::to_file(path).unwrap_err();\n        let expected = io::Error::new(io::ErrorKind::NotFound, \"foo\");\n\n        assert_eq!(actual.kind(), expected.kind());\n    }\n\n    #[test]\n    fn test_writer_to_file_dir_exists_returns_ok() {\n        let file = tempfile::NamedTempFile::new().expect(\"Could not create temp file\");\n        let path = file.path();\n\n        assert!(Writer::to_file(path).is_ok())\n    }\n\n    #[test]\n    fn test_write_record() {\n        let path = Path::new(\"test.fa\");\n        let file = fs::File::create(path).unwrap();\n        {\n            let handle = io::BufWriter::new(file);\n            let mut writer = Writer { writer: handle };\n            let record = Record::with_attrs(\"id\", Some(\"desc\"), b\"ACGT\");\n\n            let write_result = writer.write_record(\u0026record);\n            assert!(write_result.is_ok());\n        }\n\n        let actual = fs::read_to_string(path).unwrap();\n        let expected = \"\u003eid desc\\nACGT\\n\";\n\n        assert!(fs::remove_file(path).is_ok());\n        assert_eq!(actual, expected)\n    }\n}\n","traces":[{"line":161,"address":[7537552,7537678],"length":1,"stats":{"Line":0},"fn_name":"from_file\u003c\u0026std::path::Path\u003e"},{"line":162,"address":[7537591,7537656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[7537734,7537648,7537712],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003c\u0026std::path::Path\u003e"},{"line":182,"address":[7538353,7537872,7538039,7538064,7538526,7538203,7538208,7538538,7538368,7538054,7538191,7538341],"length":1,"stats":{"Line":0},"fn_name":"new\u003cstd::io::buffered::bufreader::BufReader\u003c\u0026[u8]\u003e\u003e"},{"line":184,"address":[7537888,7538231,7538404,7538081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[7537926,7538096,7538246,7538431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[7538624,7538544],"length":1,"stats":{"Line":0},"fn_name":"records\u003c\u0026[u8]\u003e"},{"line":216,"address":[7538704],"length":1,"stats":{"Line":0},"fn_name":"new_with_line\u003c\u0026[u8]\u003e"},{"line":260,"address":[7540368,7542805,7538832,7539733,7541904,7541269],"length":1,"stats":{"Line":0},"fn_name":"read\u003cstd::io::buffered::bufreader::BufReader\u003c\u0026[u8]\u003e\u003e"},{"line":261,"address":[7540426,7541962,7538890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[7539195,7542267,7541975,7538903,7540439,7540731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[7539051,7542017,7538945,7542123,7540587,7540481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[7539030,7542102,7539189,7542261,7540725,7540566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[7540733,7539197,7542269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[7542287,7540751,7539215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[7539344,7542416,7540880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[7540872,7539336,7542408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[7541004,7539468,7542540,7542360,7540824,7539288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[7543440,7543558,7542746,7541210,7543462,7543510,7543488,7539511,7541047,7542583,7543536,7539674],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::io::fasta::tests::ReaderMock\u003e"},{"line":277,"address":[7539748,7541284,7543680,7542715,7543632,7543702,7542926,7541390,7539643,7543654,7543584,7543606,7542820,7541179,7539854],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::io::fasta::tests::ReaderMock\u003e"},{"line":278,"address":[7540357,7543424,7541380,7541888,7541893,7539844,7540352,7542916,7543429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[7542997,7541461,7539925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[7543114,7541578,7540042,7541478,7543014,7539942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[7541692,7543228,7541563,7540156,7543099,7540027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[7540266,7543391,7541855,7543338,7541802,7540319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[7543368,7541832,7540296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[7547828,7545792,7543728,7545762],"length":1,"stats":{"Line":0},"fn_name":"new\u003c\u0026[u8]\u003e"},{"line":301,"address":[7545814,7543774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[7543834,7545874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[7543899,7544039,7544129,7545939,7546195,7546079,7543964,7546004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[7546100,7544136,7544060,7546202],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[7546482,7544171,7544234,7546300,7546237,7546510,7547468,7544444,7545402,7544416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[7545119,7547185,7546851,7545065,7544785,7547131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[7547289,7545030,7545223,7547096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[7547360,7545294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[7547533,7545467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[5701536],"length":1,"stats":{"Line":0},"fn_name":"sequences"},{"line":336,"address":[5701568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[7547923,7547856],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":339,"address":[7547893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[7547919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[7549475,7548736,7550268,7548716,7549504,7547968],"length":1,"stats":{"Line":0},"fn_name":"new\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e,\u0026[u8]\u003e"},{"line":372,"address":[7549603,7548358,7549109,7548383,7549913,7549142,7549698,7548884,7548761,7548127,7549938,7548032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[7549241,7550037,7548482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[7549050,7549873,7548299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[7548423,7549182,7549978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[7549205,7550001,7548446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[7550013,7548458,7549217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[7550025,7549229,7548470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[7551056,7551824,7551025,7550288,7551784,7552558],"length":1,"stats":{"Line":0},"fn_name":"fetch\u003cstd::io::cursor::Cursor\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e\u003e"},{"line":423,"address":[7550362,7551559,7550794,7551898,7552327,7551130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[7550556,7551324,7552092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[7552142,7550606,7551374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[7551424,7551686,7550656,7550966,7550921,7552454,7551728,7552499,7552192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[7551708,7550946,7552479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[7552592,7553309],"length":1,"stats":{"Line":0},"fn_name":"fetch_by_rid\u003cbio::io::fasta::tests::ReaderMock\u003e"},{"line":459,"address":[7552655,7553084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[7552849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[7552899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[7552949,7553211,7553253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[7553233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[7553344,7554045],"length":1,"stats":{"Line":0},"fn_name":"fetch_all\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":468,"address":[7553389,7553814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[7553570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[7553624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[7553941,7553679,7553986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[7553966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[7554770,7554080],"length":1,"stats":{"Line":0},"fn_name":"fetch_all_by_rid\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":477,"address":[7554114,7554539],"length":1,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[7554295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[7554349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[7554666,7554404,7554711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[7554691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[7556528,7556436,7554800,7555572,7557297,7555664],"length":1,"stats":{"Line":0},"fn_name":"read\u003cstd::io::cursor::Cursor\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e\u003e"},{"line":486,"address":[7555703,7554839,7556567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[7556589,7556292,7555428,7555728,7554864,7557153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[7555026,7556846,7556751,7555985,7556382,7555121,7555890,7555518,7557243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[7557079,7555354,7555071,7555935,7556218,7556796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[7555927,7555063,7556788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[7558176,7559660,7557392,7558960,7558095,7558879],"length":1,"stats":{"Line":0},"fn_name":"read_iter\u003cstd::io::cursor::Cursor\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e\u003e"},{"line":498,"address":[7558206,7558990,7557422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[7558231,7558003,7559568,7559012,7557447,7558787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[7558867,7559648,7559268,7557703,7557609,7559174,7558487,7558083,7558393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[7559219,7557924,7559489,7558438,7558708,7557654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[7557646,7558430,7559211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[7563477,7562214,7560981,7563462,7562240,7560992,7559744,7562229,7560966],"length":1,"stats":{"Line":0},"fn_name":"read_into_buffer\u003cbio::io::fasta::tests::ReaderMock\u003e"},{"line":515,"address":[7562304,7561056,7559808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[7561094,7562342,7559846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[7562334,7561086,7559838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[7562320,7559824,7561072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[7560079,7561327,7562575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[7560071,7562567,7561319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[7561489,7562543,7560241,7560264,7561295,7561512,7562737,7560047,7562760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[7560523,7561633,7562881,7561544,7560296,7560385,7560257,7561771,7563019,7561505,7562753,7562792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[7560550,7561619,7562867,7563046,7560371,7561798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[7560928,7560552,7561800,7563048,7562176,7563424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[7560601,7563416,7560920,7560864,7560933,7562181,7563097,7563429,7562112,7562168,7561849,7563360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[7561816,7560568,7563064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[7563488,7565792,7564640,7566902,7564598,7565750],"length":1,"stats":{"Line":0},"fn_name":"read_into_iter\u003cstd::io::cursor::Cursor\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e\u003e"},{"line":544,"address":[7564701,7563549,7565853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[7563603,7565907,7564755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[7565899,7564747,7563595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[7565885,7563581,7564733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[7563832,7564984,7566136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[7564976,7563824,7566128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[7566302,7565150,7563998,7563800,7565173,7566104,7564952,7566325,7564021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[7566357,7566530,7564226,7564053,7565318,7565378,7566318,7566470,7565166,7564166,7564014,7565205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[7566442,7565290,7564138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[7565542,7566694,7564390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[7565463,7564311,7566615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[7564366,7566670,7565518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[7566944,7567776,7567360],"length":1,"stats":{"Line":0},"fn_name":"idx\u003cbio::io::fasta::tests::ReaderMock\u003e"},{"line":575,"address":[7567346,7567767,7567824,7567041,7567351,7567762,7567873,7567457,7568178,7566992,7567408,7568183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[7567021,7567944,7567437,7567528,7567853,7567112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[7567675,7567259,7568091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[7567043,7567459,7567875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[7567988,7567464,7567572,7567156,7567048,7567880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[7568512,7568832,7568192],"length":1,"stats":{"Line":0},"fn_name":"idx_by_rid\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":586,"address":[7568627,7569140,7569138,7568947,7568243,7568498,7568563,7568500,7568820,7568818,7568883,7568307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[7569033,7568927,7568393,7568287,7568713,7568607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[7568317,7568957,7568470,7568637,7568790,7569110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[7568309,7568629,7568949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[7569792,7569152,7570432],"length":1,"stats":{"Line":0},"fn_name":"seek_to\u003cstd::io::cursor::Cursor\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e\u003e"},{"line":598,"address":[7569248,7569888,7570528,7569208,7569848,7570488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[7569333,7569928,7569973,7569288,7570506,7569226,7569866,7570568,7570613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":601,"address":[7569951,7569467,7570107,7570018,7569311,7570658,7570747,7569378,7570591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[7569449,7570729,7569620,7570260,7570147,7570787,7570900,7570089,7569507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[7570930,7570290,7569650,7570852,7571003,7570212,7569572,7569723,7570363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[7570985,7570345,7569705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[7573536,7572304,7571072],"length":1,"stats":{"Line":0},"fn_name":"read_line\u003cbio::io::fasta::tests::ReaderMock\u003e"},{"line":620,"address":[7574522,7573290,7572058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[7571175,7572548,7571316,7572407,7573639,7573780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[7571293,7573862,7573757,7572525,7571398,7572630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[7572692,7573924,7571460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":624,"address":[7571452,7573916,7572684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[7571648,7574055,7572652,7573884,7571420,7572880,7572823,7574112,7571591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[7572867,7572920,7571635,7574152,7574099,7571688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":632,"address":[7574184,7574383,7571919,7571749,7571720,7574213,7573151,7572981,7572952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[7573002,7571770,7574234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[7573119,7571887,7574351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":637,"address":[7574197,7571733,7572965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[7574425,7573193,7571961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":641,"address":[7573274,7572042,7574506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[7574564,7572100,7573332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[7574617,7572110,7573342,7574574,7572153,7573385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[7574682,7573450,7573436,7572136,7572218,7573368,7572204,7574668,7574600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[7573480,7572248,7573439,7574671,7574712,7572207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[7572258,7574722,7573490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":652,"address":[7573510,7574742,7572278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[7575696,7574768,7575232],"length":1,"stats":{"Line":0},"fn_name":"fill_buffer\u003cbio::io::fasta::tests::ReaderMock\u003e"},{"line":684,"address":[7574788,7575252,7575716,7574819,7575747,7575283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[7575735,7574807,7575271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[7575782,7574854,7575318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[7575658,7575194,7576122,7574907,7575835,7575371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[7576127,7575892,7574964,7575953,7576118,7575663,7574985,7575093,7575654,7575229,7575199,7576021,7575557,7575428,7575025,7575190,7575489,7575449,7575913,7575693,7576157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[7575895,7574967,7575431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[7575438,7574974,7575902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":695,"address":[7575445,7574981,7575909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[7575864,7575400,7574936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":700,"address":[7575408,7574944,7575872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[7577760,7576476,7577276,7578076,7576160,7576960],"length":1,"stats":{"Line":0},"fn_name":"next\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":708,"address":[7576998,7576198,7577208,7577798,7576408,7578008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[7577063,7577863,7576263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":710,"address":[7577210,7576343,7577943,7576410,7577143,7578010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[7576382,7577982,7577182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":712,"address":[7576512,7578369,7577842,7578042,7576442,7577312,7577042,7576769,7577569,7577242,7576242,7578112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":713,"address":[7576519,7577319,7578119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":714,"address":[7576623,7578223,7577423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":715,"address":[7576789,7578389,7576631,7577431,7577589,7578231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[7577593,7576793,7578393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[7577473,7576673,7578273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[7576681,7578281,7577481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":723,"address":[7578109,7577309,7576509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":727,"address":[7578560],"length":1,"stats":{"Line":0},"fn_name":"size_hint\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":728,"address":[7578787,7578592,7578757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":730,"address":[7578717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[7578800],"length":1,"stats":{"Line":0},"fn_name":"to_file\u003c\u0026std::path::Path\u003e"},{"line":744,"address":[7578823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":750,"address":[7578960,7578864],"length":1,"stats":{"Line":0},"fn_name":"new\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":752,"address":[7578977,7578878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[7579040],"length":1,"stats":{"Line":0},"fn_name":"write_record\u003cstd::fs::File\u003e"},{"line":786,"address":[7579080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":790,"address":[7579248,7581552],"length":1,"stats":{"Line":0},"fn_name":"write\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":791,"address":[7581886,7579338,7579582,7581642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":792,"address":[7582032,7579577,7579905,7579728,7582209,7581881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":793,"address":[7582954,7580650,7579877,7582181,7580123,7580020,7582427,7582324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":794,"address":[7582504,7580056,7582680,7580376,7580200,7582360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[7580501,7580374,7582805,7580655,7582959,7582678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[7582434,7580931,7583069,7580130,7580765,7583235],"length":1,"stats":{"Line":0},"fn_name":null},{"line":798,"address":[7581209,7583513,7583180,7580876,7581041,7583345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[7583623,7581319,7581428,7583732,7581142,7583446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[7583719,7581415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":805,"address":[7583856],"length":1,"stats":{"Line":0},"fn_name":"flush\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":806,"address":[7583865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":820,"address":[5701664,5701842,5701854],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":822,"address":[5701677],"length":1,"stats":{"Line":0},"fn_name":null},{"line":824,"address":[5701701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[5701856,5702439],"length":1,"stats":{"Line":0},"fn_name":"with_attrs"},{"line":842,"address":[5701943,5702089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":843,"address":[5701951,5702051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":844,"address":[5702012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":847,"address":[5702044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":849,"address":[5702211,5702135,5702259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":854,"address":[5702480],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":855,"address":[5702494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":859,"address":[5702608],"length":1,"stats":{"Line":0},"fn_name":"check"},{"line":860,"address":[5702622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":861,"address":[5702692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":863,"address":[5702671,5702738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":864,"address":[5702768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":867,"address":[5702757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":871,"address":[5702800],"length":1,"stats":{"Line":0},"fn_name":"id"},{"line":872,"address":[5702809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":876,"address":[5702848],"length":1,"stats":{"Line":0},"fn_name":"desc"},{"line":877,"address":[5702857,5702892,5702903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":878,"address":[5702872,5702905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":879,"address":[5702894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":884,"address":[5702976],"length":1,"stats":{"Line":0},"fn_name":"seq"},{"line":885,"address":[5702985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":889,"address":[5703024,5703134],"length":1,"stats":{"Line":0},"fn_name":"clear"},{"line":890,"address":[5703037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":891,"address":[5703046,5703116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":892,"address":[5703101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":925,"address":[5703168,5703735],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":926,"address":[5703207,5703251,5703798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":927,"address":[5703800,5703295,5703228,5703750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":928,"address":[5703261,5703885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":930,"address":[5704046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":931,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":933,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":934,"address":[5703846,5703970,5703910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":949,"address":[7584139,7584544,7583920,7584763],"length":1,"stats":{"Line":0},"fn_name":"next\u003cbio::io::fasta::tests::ReaderMock\u003e"},{"line":950,"address":[7583950,7584513,7584574,7585137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":951,"address":[7584613,7583989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":953,"address":[7584588,7583964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":954,"address":[7584643,7585124,7584483,7584154,7584019,7585107,7584500,7584778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":955,"address":[7584785,7584084,7584708,7584161,7584493,7585117,7584964,7584340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":956,"address":[7584387,7585011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":957,"address":[7584187,7584811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":958,"address":[7584843,7584219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":959,"address":[7584223,7584847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1023,"address":[4715344],"length":1,"stats":{"Line":0},"fn_name":"read"},{"line":1024,"address":[4715534,4715532,4715383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1025,"address":[4715411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1027,"address":[4715521,4715399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1033,"address":[4715536],"length":1,"stats":{"Line":0},"fn_name":"seek"},{"line":1034,"address":[4715590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1035,"address":[4715674,4715617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1036,"address":[4715676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1038,"address":[4715663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1047,"address":[4717979,4715792],"length":1,"stats":{"Line":0},"fn_name":"test_reader"},{"line":1048,"address":[4715799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1049,"address":[4715832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1050,"address":[4715886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1051,"address":[4715989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1056,"address":[4716274,4716043,4716246,4717940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1057,"address":[4716682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1058,"address":[4716812,4717062,4717012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1059,"address":[4717026,4717343,4717126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1060,"address":[4717310,4717408,4717621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1061,"address":[4717588,4717686,4717885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1066,"address":[4719645,4718016],"length":1,"stats":{"Line":0},"fn_name":"test_faread_trait"},{"line":1067,"address":[4718023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1068,"address":[4718253,4718378,4718050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1069,"address":[4718093,4718230,4718129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1070,"address":[4718355,4718099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1074,"address":[4718293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1075,"address":[4718490,4718380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1077,"address":[4718600,4718810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1078,"address":[4718774,4718866,4719023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1079,"address":[4719080,4718990,4719233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1080,"address":[4719348],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1081,"address":[4719200,4719290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1082,"address":[4719309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1087,"address":[4719680,4720053],"length":1,"stats":{"Line":0},"fn_name":"test_reader_wrong_header"},{"line":1088,"address":[4719687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1089,"address":[4719741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1090,"address":[4720009,4719923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1091,"address":[4719828,4719758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1097,"address":[4720080,4720480],"length":1,"stats":{"Line":0},"fn_name":"test_reader_no_id"},{"line":1098,"address":[4720087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1099,"address":[4720144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1100,"address":[4720234,4720164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1101,"address":[4720415,4720436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1102,"address":[4720341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1108,"address":[4720912,4720512],"length":1,"stats":{"Line":0},"fn_name":"test_reader_non_ascii_sequence"},{"line":1109,"address":[4720519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1110,"address":[4720576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1111,"address":[4720596,4720666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1112,"address":[4720847,4720868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1113,"address":[4720773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1119,"address":[4721307,4720944],"length":1,"stats":{"Line":0},"fn_name":"test_reader_read_fails"},{"line":1120,"address":[4720951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1124,"address":[4720995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1125,"address":[4721177,4721263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1126,"address":[4721012,4721082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1132,"address":[4721806,4721344],"length":1,"stats":{"Line":0},"fn_name":"test_reader_read_fails_iter"},{"line":1133,"address":[4721351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1137,"address":[4721390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1139,"address":[4721632,4721543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1140,"address":[4721444,4721526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1143,"address":[4721689,4721773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1144,"address":[4721672,4721625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1150,"address":[4721840,4722184],"length":1,"stats":{"Line":0},"fn_name":"test_reader_from_file_path_doesnt_exist_returns_err"},{"line":1151,"address":[4721847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1152,"address":[4721900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1157,"address":[4722138,4721974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1161,"address":[4722977,4722208],"length":1,"stats":{"Line":0},"fn_name":"test_record_with_attrs_without_description"},{"line":1162,"address":[4722215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1163,"address":[4722291,4722527,4722480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1164,"address":[4722583,4722494,4722736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1165,"address":[4722793,4722703,4722930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1169,"address":[4723792,4723008],"length":1,"stats":{"Line":0},"fn_name":"test_record_with_attrs_with_description"},{"line":1170,"address":[4723015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1171,"address":[4723295,4723106,4723342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1172,"address":[4723551,4723398,4723309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1173,"address":[4723518,4723745,4723608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1177,"address":[4723824,4724851],"length":1,"stats":{"Line":0},"fn_name":"test_index_sequences"},{"line":1178,"address":[4723831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1180,"address":[4723914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1181,"address":[4723945,4724002,4724182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1182,"address":[4724309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1183,"address":[4724138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1184,"address":[4724265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1185,"address":[4724233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1189,"address":[4724623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1190,"address":[4724512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1191,"address":[4724579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1192,"address":[4724547],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1199,"address":[4724880],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader"},{"line":1200,"address":[4724881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1201,"address":[4724914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1202,"address":[4724919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1206,"address":[4724928],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_crlf"},{"line":1207,"address":[4724929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1211,"address":[4724976],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_iter"},{"line":1212,"address":[4724977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1213,"address":[4725010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1214,"address":[4725015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1218,"address":[4725024],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_iter_crlf"},{"line":1219,"address":[4725025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1222,"address":[4803120,4807312,4811470,4807278],"length":1,"stats":{"Line":0},"fn_name":"_test_indexed_reader\u003cfn(\u0026mut bio::io::fasta::IndexedReader\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e, \u0026str, u64, u64) -\u003e core::result::Result\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, std::io::error::Error\u003e\u003e"},{"line":1226,"address":[4803205,4803278,4807397,4807470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1229,"address":[4803316,4803522,4807714,4807508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1230,"address":[4803920,4808112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1231,"address":[4807946,4803754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1234,"address":[4804153,4808345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1235,"address":[4804718,4808910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1236,"address":[4808744,4804552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1239,"address":[4809297,4805105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1240,"address":[4804939,4809131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1243,"address":[4809512,4805320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1244,"address":[4809893,4805701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1246,"address":[4810274,4806082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1248,"address":[4806463,4806828,4811020,4810655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1249,"address":[4811061,4810892,4806869,4811290,4806700,4807098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1250,"address":[4807243,4811331,4811435,4811162,4807139,4806970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1253,"address":[4814200,4811504,4812840,4812864],"length":1,"stats":{"Line":0},"fn_name":"_test_indexed_reader_truncated\u003cfn(\u0026mut bio::io::fasta::IndexedReader\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e, \u0026str, u64, u64) -\u003e core::result::Result\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, std::io::error::Error\u003e\u003e"},{"line":1257,"address":[4811600,4811511,4812871,4812960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1259,"address":[4812992,4811632,4811832,4813192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1260,"address":[4812399,4813403,4812043,4813759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1261,"address":[4812274,4813634,4813800,4814023,4812440,4812663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1262,"address":[4813898,4814165,4812704,4812805,4812538,4814064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1265,"address":[4816211,4814224,4815203,4815232],"length":1,"stats":{"Line":0},"fn_name":"_test_indexed_reader_extreme_whitespace\u003cfn(\u0026mut bio::io::fasta::IndexedReader\u003cstd::io::cursor::Cursor\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e\u003e, \u0026str, u64, u64) -\u003e core::result::Result\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, std::io::error::Error\u003e\u003e"},{"line":1272,"address":[4815239,4814231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1273,"address":[4814263,4815271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1274,"address":[4815327,4814319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1275,"address":[4814383,4815391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1277,"address":[4814404,4815412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1278,"address":[4814464,4814567,4815472,4815575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1279,"address":[4815602,4814594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1281,"address":[4815737,4814932,4815940,4814729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1284,"address":[4817874,4817072,4816240,4817042],"length":1,"stats":{"Line":0},"fn_name":"_read_buffer\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":1293,"address":[4817154,4816322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1294,"address":[4817439,4816514,4816358,4817346,4817190,4816664,4816607,4817496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1295,"address":[4817847,4816955,4816579,4817549,4816717,4817015,4817787,4817411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1297,"address":[4817692,4816860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1300,"address":[4819395,4820930,4817904,4819424,4820915,4819410],"length":1,"stats":{"Line":0},"fn_name":"_read_iter\u003cstd::io::cursor::Cursor\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e\u003e"},{"line":1309,"address":[4817986,4819506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1310,"address":[4818030,4818184,4819704,4818312,4819778,4819550,4818258,4819832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1311,"address":[4820785,4818741,4819265,4819891,4820400,4818852,4820261,4818246,4818371,4818880,4819766,4820372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1312,"address":[4820544,4819024,4820737,4819217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1315,"address":[4819308,4820828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1319,"address":[4725072],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_all"},{"line":1320,"address":[4725073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1324,"address":[4725120],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_crlf_all"},{"line":1325,"address":[4725121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1329,"address":[4725168],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_iter_all"},{"line":1330,"address":[4725169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1334,"address":[4725216],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_iter_crlf_all"},{"line":1335,"address":[4725217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1338,"address":[4821968,4821943,4822967,4820944],"length":1,"stats":{"Line":0},"fn_name":"_test_indexed_reader_all\u003cfn(\u0026mut bio::io::fasta::IndexedReader\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e, \u0026str) -\u003e core::result::Result\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, std::io::error::Error\u003e\u003e"},{"line":1342,"address":[4821084,4822041,4821017,4822108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1344,"address":[4822357,4821333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1345,"address":[4821116,4822140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1346,"address":[4822286,4821262],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1348,"address":[4822747,4821723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1349,"address":[4821543,4822567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1350,"address":[4822676,4821652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1354,"address":[4822992,4823752],"length":1,"stats":{"Line":0},"fn_name":"_read_buffer_all\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":1358,"address":[4823048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1359,"address":[4823230,4823323,4823380,4823074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1360,"address":[4823433,4823665,4823295,4823725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1362,"address":[4823576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1365,"address":[4825253,4823792,4825238],"length":1,"stats":{"Line":0},"fn_name":"_read_iter_all\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":1369,"address":[4823848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1370,"address":[4824155,4824101,4824027,4823882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1371,"address":[4824695,4825108,4824214,4824584,4824089,4824723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1372,"address":[4824867,4825060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1375,"address":[4825151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1379,"address":[4725264],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_by_rid_all"},{"line":1380,"address":[4725265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1384,"address":[4725312],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_crlf_by_rid_all"},{"line":1385,"address":[4725313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1389,"address":[4725360],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_iter_by_rid_all"},{"line":1390,"address":[4725361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1394,"address":[4725408],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_iter_crlf_by_rid_all"},{"line":1395,"address":[4725409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1398,"address":[4825264,4826240,4827193,4826217],"length":1,"stats":{"Line":0},"fn_name":"_test_indexed_reader_by_rid_all\u003cfn(\u0026mut bio::io::fasta::IndexedReader\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e, usize) -\u003e core::result::Result\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, std::io::error::Error\u003e\u003e"},{"line":1402,"address":[4825337,4826380,4826313,4825404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1404,"address":[4825630,4826606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1405,"address":[4825436,4826412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1406,"address":[4825559,4826535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1408,"address":[4826973,4825997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1409,"address":[4826816,4825840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1410,"address":[4826902,4825926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1414,"address":[4827960,4827216],"length":1,"stats":{"Line":0},"fn_name":"_read_buffer_by_rid_all\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":1421,"address":[4827259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1422,"address":[4827529,4827436,4827280,4827586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1423,"address":[4827873,4827639,4827501,4827933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1425,"address":[4827784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1428,"address":[4828000,4829445,4829430],"length":1,"stats":{"Line":0},"fn_name":"_read_iter_by_rid_all\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":1435,"address":[4828043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1436,"address":[4828219,4828072,4828347,4828293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1437,"address":[4828887,4829300,4828915,4828776,4828406,4828281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1438,"address":[4829252,4829059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1441,"address":[4829343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1445,"address":[4727192,4725456],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_iter_size_hint"},{"line":1446,"address":[4725463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1447,"address":[4725549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1448,"address":[4725741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1450,"address":[4725982,4725940,4725794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1451,"address":[4726215,4726028,4725962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1452,"address":[4726396,4726198,4726275],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1453,"address":[4726443,4726379,4726630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1454,"address":[4726811,4726690,4726613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1455,"address":[4726794,4726978,4726866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1456,"address":[4726971,4727019,4727130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1460,"address":[4728198,4727216],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_reused_buffer"},{"line":1461,"address":[4727223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1462,"address":[4727306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1464,"address":[4727423,4727325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1465,"address":[4727536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1466,"address":[4727639,4727788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1468,"address":[4727727,4727844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1469,"address":[4727919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1470,"address":[4728139,4728022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1474,"address":[4728819,4728224],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_no_trailing_lf"},{"line":1476,"address":[4728231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1480,"address":[4728314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1482,"address":[4728430,4728333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1483,"address":[4728543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1484,"address":[4728646,4728761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1488,"address":[4729398,4728848],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_bad_reader"},{"line":1493,"address":[4728865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1494,"address":[4728935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1495,"address":[4729051,4728954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1496,"address":[4729354,4729164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1500,"address":[4729424,4729974],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_read_seek_fails"},{"line":1505,"address":[4729441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1506,"address":[4729511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1507,"address":[4729627,4729530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1508,"address":[4729930,4729740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1512,"address":[4730550,4730000],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_read_read_fails"},{"line":1517,"address":[4730017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1518,"address":[4730087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1519,"address":[4730106,4730203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1520,"address":[4730316,4730506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1524,"address":[4730980,4730576],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_iter_seek_fails"},{"line":1529,"address":[4730593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1530,"address":[4730663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1531,"address":[4730948,4730835],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1535,"address":[4731008,4731703],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_iter_read_fails"},{"line":1540,"address":[4731025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1541,"address":[4731095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1542,"address":[4731267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1543,"address":[4731514,4731320,4731405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1544,"address":[4731658,4731571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1545,"address":[4731554,4731507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1551,"address":[4731728,4732153],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_no_fetch_read_fails"},{"line":1556,"address":[4731745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1557,"address":[4731815],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1558,"address":[4731917,4731847,4732109,4732016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1562,"address":[4732176,4732458],"length":1,"stats":{"Line":0},"fn_name":"test_indexed_reader_no_fetch_read_iter_fails"},{"line":1567,"address":[4732193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1568,"address":[4732276,4732426,4732345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1572,"address":[4732496,4733198],"length":1,"stats":{"Line":0},"fn_name":"test_writer"},{"line":1573,"address":[4732503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1574,"address":[4732535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1575,"address":[4732744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1576,"address":[4732906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1577,"address":[4733006,4733152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1581,"address":[4733232,4733992],"length":1,"stats":{"Line":0},"fn_name":"test_display_record_no_desc_id_without_space_after"},{"line":1582,"address":[4733239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1583,"address":[4733266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1584,"address":[4733343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1585,"address":[4733425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1586,"address":[4733544,4733440,4733637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1588,"address":[4733694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1590,"address":[4733801,4733919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1594,"address":[4734016,4734776],"length":1,"stats":{"Line":0},"fn_name":"test_display_record_with_desc_id_has_space_between_id_and_desc"},{"line":1595,"address":[4734023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1596,"address":[4734050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1597,"address":[4734127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1598,"address":[4734209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1599,"address":[4734224,4734328,4734421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1601,"address":[4734478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1603,"address":[4734585,4734703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1607,"address":[4735468,4734800],"length":1,"stats":{"Line":0},"fn_name":"test_index_record_idx_by_rid_invalid_index_returns_error"},{"line":1612,"address":[4734817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1614,"address":[4734905,4734997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1615,"address":[4735029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1617,"address":[4735262,4735192,4735134,4735399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1618,"address":[4735382,4735728,4735461,4735491,4735654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1622,"address":[4736000,4736582],"length":1,"stats":{"Line":0},"fn_name":"test_index_record_fetch_by_rid_second_index_returns_second_record"},{"line":1627,"address":[4736017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1629,"address":[4736102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1631,"address":[4736236,4736170,4736322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1632,"address":[4736503,4736282,4736676,4736601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1634,"address":[4736359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1635,"address":[4736295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1645,"address":[4737366,4736832],"length":1,"stats":{"Line":0},"fn_name":"test_writer_to_file_dir_doesnt_exist_returns_err"},{"line":1646,"address":[4736839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1648,"address":[4736892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1649,"address":[4736961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1651,"address":[4737179,4737060,4737115,4737307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1655,"address":[4737678,4737392],"length":1,"stats":{"Line":0},"fn_name":"test_writer_to_file_dir_exists_returns_ok"},{"line":1656,"address":[4737399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1657,"address":[4737449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1659,"address":[4737503,4737646,4737553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1663,"address":[4737712,4738292],"length":1,"stats":{"Line":0},"fn_name":"test_write_record"},{"line":1664,"address":[4737719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1665,"address":[4737772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1667,"address":[4737814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1668,"address":[4737827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1669,"address":[4737891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1671,"address":[4738067,4737994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1672,"address":[4738165,4738099,4738230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1675,"address":[4738317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1676,"address":[4738368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1678,"address":[4738534,4738395,4738695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1679,"address":[4738616,4738764,4738732],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":586},{"path":["/","home","todd","rust-bio","src","io","fastq.rs"],"content":"// Copyright 2014-2018 Johannes Köster, Henning Timm.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Structs and trait to read and write files in FASTQ format.\n//!\n//! # Example\n//!\n//! ## Read\n//!\n//! In this example, we parse a fastq file from stdin and compute some statistics\n//!\n//! ```\n//! use bio::io::fastq;\n//! use std::io;\n//! let mut reader = fastq::Reader::new(io::stdin());\n//!\n//! let mut nb_reads = 0;\n//! let mut nb_bases = 0;\n//!\n//! for result in reader.records() {\n//!     let record = result.expect(\"Error during fastq record parsing\");\n//!\n//!     nb_reads += 1;\n//!     nb_bases += record.seq().len();\n//! }\n//!\n//! println!(\"Number of reads: {}\", nb_reads);\n//! println!(\"Number of bases: {}\", nb_bases);\n//! ```\n//!\n//! We can also use a `while` loop to iterate over records\n//! ```\n//! use bio::io::fastq;\n//! use std::io;\n//! let mut records = fastq::Reader::new(io::stdin()).records();\n//!\n//! let mut nb_reads = 0;\n//! let mut nb_bases = 0;\n//!\n//! while let Some(Ok(record)) = records.next() {\n//!     nb_reads += 1;\n//!     nb_bases += record.seq().len();\n//! }\n//!\n//! println!(\"Number of reads: {}\", nb_reads);\n//! println!(\"Number of bases: {}\", nb_bases);\n//! ```\n//!\n//! ## Write\n//!\n//! In this example we generate 10 random sequences with length 100 and write them to stdout.\n//!\n//! ```\n//! use std::io;\n//! use bio::io::fastq;\n//!\n//! let mut seed = 42;\n//!\n//! let nucleotides = [b'A', b'C', b'G', b'T'];\n//!\n//! let mut writer = fastq::Writer::new(io::stdout());\n//!\n//! for _ in 0..10 {\n//!     let seq = (0..100).map(|_| {\n//!         seed = ((seed ^ seed \u003c\u003c 13) ^ seed \u003e\u003e 7) ^ seed \u003c\u003c 17; // don't use this random generator\n//!         nucleotides[seed % 4]\n//!     }).collect::\u003cVec\u003cu8\u003e\u003e();\n//!\n//!     let qual = (0..100).map(|_| b'!').collect::\u003cVec\u003cu8\u003e\u003e();\n//!\n//!    writer.write(\"random\", None, seq.as_slice(), qual.as_slice());\n//! }\n//! ```\n//!\n//! ## Read and Write\n//!\n//! In this example we filter reads from stdin on mean quality (Phred + 33) and write them to stdout\n//!\n//! ```\n//! use bio::io::fastq;\n//! use bio::io::fastq::FastqRead;\n//! use std::io;\n//!\n//! let mut reader = fastq::Reader::new(io::stdin());\n//! let mut writer = fastq::Writer::new(io::stdout());\n//! let mut record = fastq::Record::new();\n//!\n//! while let Ok(()) = reader.read(\u0026mut record) {\n//!     if record.is_empty() {\n//!         let check = record.check();\n//!         break;\n//!     }\n//!\n//!     let mut sum_qual = record.qual().iter().sum::\u003cu8\u003e() as f64;\n//!\n//!     if (sum_qual / record.seq().len() as f64 - 33.0) \u003e 30.0 {\n//!         writer.write_record(\u0026record);\n//!     }\n//! }\n//! ```\n\nuse anyhow::Context;\nuse std::convert::AsRef;\nuse std::fmt;\nuse std::fs;\nuse std::io;\nuse std::io::prelude::*;\nuse std::path::{Path, PathBuf};\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum Error {\n    #[error(\"expected '@' at record start\")]\n    MissingAt,\n\n    #[error(\"can't open {path} file: {source}\")]\n    FileOpen { path: PathBuf, source: io::Error },\n\n    #[error(\"can't read input\")]\n    ReadError(#[from] io::Error),\n\n    #[error(\"Incomplete record. Each FastQ record has to consist of 4 lines: header, sequence, separator and qualities.\")]\n    IncompleteRecord,\n}\npub type Result\u003cT, E = Error\u003e = std::result::Result\u003cT, E\u003e;\n\nuse bio_types::sequence::SequenceRead;\n\nuse crate::utils::TextSlice;\n\n/// Trait for FastQ readers.\npub trait FastqRead {\n    fn read(\u0026mut self, record: \u0026mut Record) -\u003e Result\u003c()\u003e;\n}\n\n/// A FastQ reader.\n#[derive(Debug)]\npub struct Reader\u003cR: io::Read\u003e {\n    reader: io::BufReader\u003cR\u003e,\n    line_buffer: String,\n}\n\nimpl Reader\u003cfs::File\u003e {\n    /// Read from a given file.\n    pub fn from_file\u003cP: AsRef\u003cPath\u003e + std::fmt::Debug\u003e(path: P) -\u003e anyhow::Result\u003cSelf\u003e {\n        fs::File::open(path.as_ref())\n            .map_err(|e| Error::FileOpen {\n                path: path.as_ref().to_owned(),\n                source: e,\n            })\n            .map(Reader::new)\n            .with_context(|| format!(\"Failed to read fastq from {:#?}\", path))\n    }\n}\n\nimpl\u003cR: io::Read\u003e Reader\u003cR\u003e {\n    /// Read from a given [`io::Read`](https://doc.rust-lang.org/std/io/trait.Read.html).\n    pub fn new(reader: R) -\u003e Self {\n        Reader {\n            reader: io::BufReader::new(reader),\n            line_buffer: String::new(),\n        }\n    }\n\n    /// Return an iterator over the records of this FastQ file.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if a record is incomplete\n    /// or syntax is violated.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use bio::io::fastq;\n    ///\n    /// let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n!!!!\\n\";\n    /// let records = fastq::Reader::new(fq)\n    ///     .records()\n    ///     .map(|record| record.unwrap());\n    /// for record in records {\n    ///     assert!(record.check().is_ok())\n    /// }\n    /// ```\n    pub fn records(self) -\u003e Records\u003cR\u003e {\n        Records { reader: self }\n    }\n\n    pub(crate) fn new_with_line_buffer(reader: io::BufReader\u003cR\u003e, line_buffer: String) -\u003e Self {\n        Reader {\n            reader,\n            line_buffer,\n        }\n    }\n}\n\nimpl\u003cR\u003e FastqRead for Reader\u003cR\u003e\nwhere\n    R: io::Read,\n{\n    /// Read the next FastQ entry into the given [`Record`](#Record).\n    /// An empty record indicates that no more records can be read.\n    ///\n    /// This method is useful when you want to read records as fast as\n    /// possible because it allows the reuse of a `Record` allocation.\n    ///\n    /// A more ergonomic approach to reading FastQ records is the\n    /// [records](Reader::records) iterator.\n    ///\n    /// FastQ files with wrapped sequence and quality strings are allowed.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the record is incomplete,\n    /// syntax is violated or any form of I/O error is encountered.\n    /// Additionally, if the FastQ file has line-wrapped records, and the wrapping is not\n    /// consistent between the sequence and quality string for a record, parsing will fail.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use bio::io::fastq::Record;\n    /// use bio::io::fastq::{FastqRead, Reader};\n    /// const FASTQ_FILE: \u0026'static [u8] = b\"@id desc\n    /// AAAA\n    /// +\n    /// IIII\n    /// \";\n    /// let mut reader = Reader::new(FASTQ_FILE);\n    /// let mut record = Record::new();\n    ///\n    /// reader.read(\u0026mut record).unwrap();\n    ///\n    /// assert_eq!(record.id(), \"id\");\n    /// assert_eq!(record.desc().unwrap(), \"desc\");\n    /// assert_eq!(record.seq().to_vec(), b\"AAAA\");\n    /// assert_eq!(record.qual().to_vec(), b\"IIII\");\n    /// ```\n    fn read(\u0026mut self, record: \u0026mut Record) -\u003e Result\u003c()\u003e {\n        record.clear();\n        self.line_buffer.clear();\n\n        self.reader.read_line(\u0026mut self.line_buffer)?;\n\n        if !self.line_buffer.is_empty() {\n            if !self.line_buffer.starts_with('@') {\n                return Err(Error::MissingAt);\n            }\n            let mut header_fields = self.line_buffer[1..].trim_end().splitn(2, ' ');\n            record.id = header_fields.next().unwrap_or_default().to_owned();\n            record.desc = header_fields.next().map(|s| s.to_owned());\n            self.line_buffer.clear();\n\n            self.reader.read_line(\u0026mut self.line_buffer)?;\n\n            let mut lines_read = 0;\n            while !self.line_buffer.starts_with('+') {\n                record.seq.push_str(\u0026self.line_buffer.trim_end());\n                self.line_buffer.clear();\n                self.reader.read_line(\u0026mut self.line_buffer)?;\n                lines_read += 1;\n            }\n\n            for _ in 0..lines_read {\n                self.line_buffer.clear();\n                self.reader\n                    .read_line(\u0026mut self.line_buffer)\n                    .map_err(Error::ReadError)?;\n                record.qual.push_str(self.line_buffer.trim_end());\n            }\n\n            if record.qual.is_empty() {\n                return Err(Error::IncompleteRecord);\n            }\n        }\n\n        Ok(())\n    }\n}\n\n/// A FastQ record.\n#[derive(Debug, Clone, Default, Serialize, Deserialize, PartialEq)]\npub struct Record {\n    id: String,\n    desc: Option\u003cString\u003e,\n    seq: String,\n    qual: String,\n}\n\nimpl Record {\n    /// Create a new, empty FastQ record.\n    pub fn new() -\u003e Self {\n        Record {\n            id: String::new(),\n            desc: None,\n            seq: String::new(),\n            qual: String::new(),\n        }\n    }\n\n    /// Create a new FastQ record from given attributes.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use bio::io::fastq::Record;\n    ///\n    /// let record = Record::with_attrs(\"id_str\", Some(\"desc\"), b\"ATGCGGG\", b\"QQQQQQQ\");\n    /// assert_eq!(record.id(), \"id_str\");\n    /// assert_eq!(record.desc(), Some(\"desc\"));\n    /// assert_eq!(record.seq(), b\"ATGCGGG\");\n    /// assert_eq!(record.qual(), b\"QQQQQQQ\");\n    /// ```\n    pub fn with_attrs(id: \u0026str, desc: Option\u003c\u0026str\u003e, seq: TextSlice\u003c'_\u003e, qual: \u0026[u8]) -\u003e Self {\n        let desc = match desc {\n            Some(desc) =\u003e Some(desc.to_owned()),\n            _ =\u003e None,\n        };\n        Record {\n            id: id.to_owned(),\n            desc,\n            seq: String::from_utf8(seq.to_vec()).unwrap(),\n            qual: String::from_utf8(qual.to_vec()).unwrap(),\n        }\n    }\n\n    /// Check if a record is empty.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use bio::io::fastq::Record;\n    ///\n    /// let mut record = Record::new();\n    /// assert!(record.is_empty());\n    ///\n    /// record = Record::with_attrs(\"id_str\", Some(\"desc\"), b\"ATGCGGG\", b\"QQQQQQQ\");\n    /// assert!(!record.is_empty());\n    /// ```\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.id.is_empty() \u0026\u0026 self.desc.is_none() \u0026\u0026 self.seq.is_empty() \u0026\u0026 self.qual.is_empty()\n    }\n\n    /// Check the validity of a FastQ record.\n    ///\n    /// # Errors\n    /// This function will return an `Err` if one of the following conditions is met:\n    /// -   The record identifier is empty.\n    /// -   There is a non-ASCII character found in either the sequence or quality strings.\n    /// -   The sequence and quality strings do not have the same length.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use bio::io::fastq::Record;\n    ///\n    /// let mut record = Record::with_attrs(\"id\", None, \"Prüfung\".as_ref(), b\"!!!!!!!\");\n    /// let actual = record.check().unwrap_err();\n    /// let expected = \"Non-ascii character found in sequence.\";\n    /// assert_eq!(actual, expected);\n    ///\n    /// record = Record::with_attrs(\"id_str\", Some(\"desc\"), b\"ATGCGGG\", b\"QQQQQQQ\");\n    /// assert!(record.check().is_ok());\n    /// ```\n    pub fn check(\u0026self) -\u003e Result\u003c(), \u0026str\u003e {\n        if self.id().is_empty() {\n            return Err(\"Expecting id for FastQ record.\");\n        }\n        if !self.seq.is_ascii() {\n            return Err(\"Non-ascii character found in sequence.\");\n        }\n        if !self.qual.is_ascii() {\n            return Err(\"Non-ascii character found in qualities.\");\n        }\n        if self.seq().len() != self.qual().len() {\n            return Err(\"Unequal length of sequence an qualities.\");\n        }\n\n        Ok(())\n    }\n\n    /// Return the id of the record.\n    pub fn id(\u0026self) -\u003e \u0026str {\n        self.id.as_ref()\n    }\n\n    /// Return descriptions if present.\n    pub fn desc(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        match self.desc.as_ref() {\n            Some(desc) =\u003e Some(\u0026desc),\n            None =\u003e None,\n        }\n    }\n\n    /// Return the sequence of the record.\n    pub fn seq(\u0026self) -\u003e TextSlice\u003c'_\u003e {\n        self.seq.trim_end().as_bytes()\n    }\n\n    /// Return the base qualities of the record.\n    pub fn qual(\u0026self) -\u003e \u0026[u8] {\n        self.qual.trim_end().as_bytes()\n    }\n\n    /// Clear the record.\n    fn clear(\u0026mut self) {\n        self.id.clear();\n        self.desc = None;\n        self.seq.clear();\n        self.qual.clear();\n    }\n}\n\nimpl fmt::Display for Record {\n    /// Allows for using `Record` in a given formatter `f`. In general this is for\n    /// creating a `String` representation of a `Record` and, optionally, writing it to\n    /// a file.\n    ///\n    /// # Errors\n    /// Returns [`std::fmt::Error`](https://doc.rust-lang.org/std/fmt/struct.Error.html)\n    /// if there is an issue formatting to the stream.\n    ///\n    /// # Examples\n    ///\n    /// Read in a Fastq `Record` and create a `String` representation of it.\n    ///\n    /// ```rust\n    /// use bio::io::fastq::Reader;\n    /// use std::fmt::Write;\n    /// // create a \"fake\" fastq file\n    /// let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n!!!!\\n\";\n    /// let mut records = Reader::new(fq).records().map(|r| r.unwrap());\n    /// let record = records.next().unwrap();\n    ///\n    /// let mut actual = String::new();\n    /// // populate `actual` with a string representation of our record\n    /// write!(actual, \"{}\", record).unwrap();\n    ///\n    /// let expected = std::str::from_utf8(fq).unwrap();\n    ///\n    /// assert_eq!(actual, expected)\n    /// ```\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e Result\u003c(), fmt::Error\u003e {\n        let header = match self.desc() {\n            Some(d) =\u003e format!(\"{} {}\", self.id().to_owned(), d),\n            None =\u003e self.id().to_owned(),\n        };\n        write!(\n            f,\n            \"@{}\\n{}\\n+\\n{}\\n\",\n            header,\n            std::str::from_utf8(self.seq()).unwrap(),\n            std::str::from_utf8(self.qual()).unwrap()\n        )\n    }\n}\n\nimpl SequenceRead for Record {\n    fn name(\u0026self) -\u003e \u0026[u8] {\n        self.id.as_bytes()\n    }\n\n    fn base(\u0026self, i: usize) -\u003e u8 {\n        self.seq()[i]\n    }\n\n    fn base_qual(\u0026self, i: usize) -\u003e u8 {\n        self.qual()[i]\n    }\n\n    fn len(\u0026self) -\u003e usize {\n        self.seq().len()\n    }\n}\n\n/// An iterator over the records of a FastQ file.\n#[derive(Debug)]\npub struct Records\u003cR: io::Read\u003e {\n    reader: Reader\u003cR\u003e,\n}\n\nimpl\u003cR: io::Read\u003e Iterator for Records\u003cR\u003e {\n    type Item = Result\u003cRecord\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cResult\u003cRecord\u003e\u003e {\n        let mut record = Record::new();\n        match self.reader.read(\u0026mut record) {\n            Ok(()) if record.is_empty() =\u003e None,\n            Ok(()) =\u003e Some(Ok(record)),\n            Err(err) =\u003e Some(Err(err)),\n        }\n    }\n}\n\n/// A FastQ writer.\n#[derive(Debug)]\npub struct Writer\u003cW: io::Write\u003e {\n    writer: io::BufWriter\u003cW\u003e,\n}\n\nimpl Writer\u003cfs::File\u003e {\n    /// Write to a given file path.\n    #[allow(clippy::wrong_self_convention)]\n    pub fn to_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e io::Result\u003cSelf\u003e {\n        fs::File::create(path).map(Writer::new)\n    }\n}\n\nimpl\u003cW: io::Write\u003e Writer\u003cW\u003e {\n    /// Write to a given `io::Write`.\n    pub fn new(writer: W) -\u003e Self {\n        Writer {\n            writer: io::BufWriter::new(writer),\n        }\n    }\n\n    /// Directly write a FastQ record.\n    pub fn write_record(\u0026mut self, record: \u0026Record) -\u003e io::Result\u003c()\u003e {\n        self.write(record.id(), record.desc(), record.seq(), record.qual())\n    }\n\n    /// Write a FastQ record with given id, optional description, sequence and qualities.\n    pub fn write(\n        \u0026mut self,\n        id: \u0026str,\n        desc: Option\u003c\u0026str\u003e,\n        seq: TextSlice\u003c'_\u003e,\n        qual: \u0026[u8],\n    ) -\u003e io::Result\u003c()\u003e {\n        self.writer.write_all(b\"@\")?;\n        self.writer.write_all(id.as_bytes())?;\n        if let Some(desc) = desc {\n            self.writer.write_all(b\" \")?;\n            self.writer.write_all(desc.as_bytes())?;\n        }\n        self.writer.write_all(b\"\\n\")?;\n        self.writer.write_all(seq)?;\n        self.writer.write_all(b\"\\n+\\n\")?;\n        self.writer.write_all(qual)?;\n        self.writer.write_all(b\"\\n\")?;\n\n        Ok(())\n    }\n\n    /// Flush the writer, ensuring that everything is written.\n    pub fn flush(\u0026mut self) -\u003e io::Result\u003c()\u003e {\n        self.writer.flush()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fmt::Write as FmtWrite;\n    use std::io;\n\n    const FASTQ_FILE: \u0026[u8] = b\"@id desc\nACCGTAGGCTGA\n+\nIIIIIIJJJJJJ\n\";\n\n    #[test]\n    fn test_reader() {\n        let reader = Reader::new(FASTQ_FILE);\n        let records: Vec\u003cResult\u003cRecord\u003e\u003e = reader.records().collect();\n        assert_eq!(records.len(), 1);\n        for res in records {\n            let record = res.unwrap();\n            assert_eq!(record.check(), Ok(()));\n            assert_eq!(record.id(), \"id\");\n            assert_eq!(record.desc(), Some(\"desc\"));\n            assert_eq!(record.seq(), b\"ACCGTAGGCTGA\");\n            assert_eq!(record.qual(), b\"IIIIIIJJJJJJ\");\n        }\n    }\n\n    #[test]\n    fn test_display_record_no_desc_id_without_space_after() {\n        let fq: \u0026'static [u8] = b\"@id\\nACGT\\n+\\n!!!!\\n\";\n        let mut records = Reader::new(fq).records().map(|r| r.unwrap());\n        let record = records.next().unwrap();\n        let mut actual = String::new();\n        write!(actual, \"{}\", record).unwrap();\n\n        let expected = std::str::from_utf8(fq).unwrap();\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_display_record_with_desc_id_has_space_between_id_and_desc() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n!!!!\\n\";\n        let mut records = Reader::new(fq).records().map(|r| r.unwrap());\n        let record = records.next().unwrap();\n        let mut actual = String::new();\n        write!(actual, \"{}\", record).unwrap();\n\n        let expected = std::str::from_utf8(fq).unwrap();\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_fqread_trait() {\n        let path = \"reads.fq.gz\";\n        let mut fq_reader: Box\u003cdyn FastqRead\u003e = match path.ends_with(\".gz\") {\n            true =\u003e Box::new(Reader::new(io::BufReader::new(FASTQ_FILE))),\n            false =\u003e Box::new(Reader::new(FASTQ_FILE)),\n        };\n        // The read method can be called, since it is implemented by\n        // `Read`. Right now, the records method would not work.\n        let mut record = Record::new();\n        fq_reader.read(\u0026mut record).unwrap();\n        // Check if the returned result is correct.\n        assert_eq!(record.check(), Ok(()));\n        assert_eq!(record.id(), \"id\");\n        assert_eq!(record.desc(), Some(\"desc\"));\n        assert_eq!(record.seq(), b\"ACCGTAGGCTGA\");\n        assert_eq!(record.qual(), b\"IIIIIIJJJJJJ\");\n    }\n\n    #[test]\n    fn test_record_with_attrs() {\n        let record = Record::with_attrs(\"id_str\", Some(\"desc\"), b\"ATGCGGG\", b\"QQQQQQQ\");\n        assert_eq!(record.id(), \"id_str\");\n        assert_eq!(record.desc(), Some(\"desc\"));\n        assert_eq!(record.seq(), b\"ATGCGGG\");\n        assert_eq!(record.qual(), b\"QQQQQQQ\");\n    }\n\n    #[test]\n    fn test_writer() {\n        let mut writer = Writer::new(Vec::new());\n        writer\n            .write(\"id\", Some(\"desc\"), b\"ACCGTAGGCTGA\", b\"IIIIIIJJJJJJ\")\n            .expect(\"Expected successful write\");\n        writer.flush().expect(\"Expected successful write\");\n        assert_eq!(writer.writer.get_ref(), \u0026FASTQ_FILE);\n    }\n\n    #[test]\n    fn test_check_record_id_is_empty_raises_err() {\n        let record = Record::with_attrs(\"\", None, b\"ACGT\", b\"!!!!\");\n\n        let actual = record.check().unwrap_err();\n        let expected = \"Expecting id for FastQ record.\";\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_check_record_seq_is_not_ascii_raises_err() {\n        let record = Record::with_attrs(\"id\", None, \"Prüfung\".as_ref(), b\"!!!!\");\n\n        let actual = record.check().unwrap_err();\n        let expected = \"Non-ascii character found in sequence.\";\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_check_record_quality_is_not_ascii_raises_err() {\n        let record = Record::with_attrs(\"id\", None, b\"ACGT\", \"Qualität\".as_ref());\n\n        let actual = record.check().unwrap_err();\n        let expected = \"Non-ascii character found in qualities.\";\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_check_record_quality_and_seq_diff_len_raises_err() {\n        let record = Record::with_attrs(\"id\", None, b\"ACGT\", b\"!!!\");\n\n        let actual = record.check().unwrap_err();\n        let expected = \"Unequal length of sequence an qualities.\";\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_check_valid_record() {\n        let record = Record::with_attrs(\"id\", None, b\"ACGT\", b\"!!!!\");\n\n        assert!(record.check().is_ok())\n    }\n\n    #[test]\n    fn test_read_header_does_not_start_with_correct_char_raises_err() {\n        let fq: \u0026'static [u8] = b\"\u003eid description\\nACGT\\n+\\n!!!!\\n\";\n        let mut reader = Reader::new(fq);\n        let mut record = Record::new();\n\n        let error = reader.read(\u0026mut record).unwrap_err();\n\n        assert!(matches!(error, Error::MissingAt))\n    }\n\n    #[test]\n    fn test_read_quality_is_empty_raises_err() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n\";\n        let mut reader = Reader::new(fq);\n        let mut record = Record::new();\n\n        let error = reader.read(\u0026mut record).unwrap_err();\n\n        assert!(matches!(error, Error::IncompleteRecord))\n    }\n\n    #[test]\n    fn test_read_sequence_and_quality_are_wrapped_is_handled_with_one_sequence() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\nGGGG\\nC\\n+\\n@@@@\\n!!!!\\n$\\n\";\n        let mut reader = Reader::new(fq);\n\n        let mut actual = Record::new();\n        reader.read(\u0026mut actual).unwrap();\n        let expected = Record::with_attrs(\"id\", Some(\"description\"), b\"ACGTGGGGC\", b\"@@@@!!!!$\");\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_read_sequence_and_quality_are_wrapped_is_handled_with_three_sequences() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\nGGGG\\nC\\n+\\n@@@@\\n!!!!\\n$\\n@id2 description\\nACGT\\nGGGG\\nC\\n+\\n@@@@\\n!!!!\\n$\\n@id3 desc1 desc2\\nAAA\\nAAA\\nAA\\n+\\n^^^\\n^^^\\n^^\\n\";\n        let mut reader = Reader::new(fq);\n\n        let mut actual = Record::new();\n        reader.read(\u0026mut actual).unwrap();\n        let expected = Record::with_attrs(\"id\", Some(\"description\"), b\"ACGTGGGGC\", b\"@@@@!!!!$\");\n\n        assert_eq!(actual, expected);\n\n        reader.read(\u0026mut actual).unwrap();\n        let expected = Record::with_attrs(\"id2\", Some(\"description\"), b\"ACGTGGGGC\", b\"@@@@!!!!$\");\n\n        assert_eq!(actual, expected);\n\n        reader.read(\u0026mut actual).unwrap();\n        let expected = Record::with_attrs(\"id3\", Some(\"desc1 desc2\"), b\"AAAAAAAA\", b\"^^^^^^^^\");\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_read_wrapped_record_with_inconsistent_wrapping_errors() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\nGGGG\\nC\\n+\\n@@@@\\n!!!!$\\n@id2 description\\nACGT\\nGGGG\\nC\\n+\\n@@@@\\n!!!!\\n$\\n@id3 desc1 desc2\\nAAA\\nAAA\\nAA\\n+\\n^^^\\n^^^\\n^^\\n\";\n        let mut reader = Reader::new(fq);\n\n        let mut record = Record::new();\n        reader.read(\u0026mut record).unwrap();\n        let error = reader.read(\u0026mut record).unwrap_err();\n\n        assert!(matches!(error, Error::MissingAt))\n    }\n\n    #[test]\n    fn test_record_iterator_next_read_returns_err_causes_next_to_return_some_err() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n\";\n        let mut records = Reader::new(fq).records();\n\n        let error = records.next().unwrap().unwrap_err();\n\n        assert!(matches!(error, Error::IncompleteRecord));\n    }\n\n    #[test]\n    fn test_reader_from_file_path_doesnt_exist_returns_err() {\n        let path = Path::new(\"/I/dont/exist.fq\");\n        let error = Reader::from_file(path)\n            .unwrap_err()\n            .downcast::\u003cString\u003e()\n            .unwrap();\n\n        assert_eq!(\u0026error, \"Failed to read fastq from \\\"/I/dont/exist.fq\\\"\")\n    }\n\n    #[test]\n    fn test_reader_from_file_path_exists_returns_ok() {\n        let path = Path::new(\"Cargo.toml\");\n\n        assert!(Reader::from_file(path).is_ok())\n    }\n\n    #[test]\n    fn test_sequence_read_for_record_trait_method_name() {\n        let record = Record::with_attrs(\"id\", None, b\"ACGT\", b\"!!!!\");\n\n        let actual = record.name();\n        let expected = b\"id\";\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_sequence_read_for_record_trait_method_base_idx_in_range() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n!!!!\\n\";\n        let mut reader = Reader::new(fq);\n        let mut record = Record::new();\n        reader.read(\u0026mut record).unwrap();\n        let idx = 2;\n\n        let actual = record.base(idx);\n        let expected = b'G';\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_sequence_read_for_record_trait_method_base_idx_out_of_range() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n!!!!\\n\";\n        let mut reader = Reader::new(fq);\n        let mut record = Record::new();\n        reader.read(\u0026mut record).unwrap();\n        // idx 4 is where the newline character would be - we dont want that included\n        let idx = 4;\n\n        record.base(idx);\n    }\n\n    #[test]\n    fn test_sequence_read_for_record_trait_method_base_qual_idx_in_range() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n!!!!\\n\";\n        let mut reader = Reader::new(fq);\n        let mut record = Record::new();\n        reader.read(\u0026mut record).unwrap();\n        let idx = 2;\n\n        let actual = record.base_qual(idx);\n        let expected = b'!';\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_sequence_read_for_record_trait_method_base_qual_idx_out_of_range() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n!!!!\\n\";\n        let mut reader = Reader::new(fq);\n        let mut record = Record::new();\n        reader.read(\u0026mut record).unwrap();\n        // idx 4 is where the newline character would be - we dont want that included\n        let idx = 4;\n\n        record.base_qual(idx);\n    }\n\n    #[test]\n    fn test_sequence_read_for_record_trait_method_len() {\n        let fq: \u0026'static [u8] = b\"@id description\\nACGT\\n+\\n!!!!\\n\";\n        let mut reader = Reader::new(fq);\n        let mut record = Record::new();\n        reader.read(\u0026mut record).unwrap();\n\n        let actual = record.len();\n        let expected = 4;\n\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_writer_to_file_dir_doesnt_exist_returns_err() {\n        let path = Path::new(\"/I/dont/exist.fq\");\n\n        let actual = Writer::to_file(path).unwrap_err();\n        let expected = io::Error::new(io::ErrorKind::NotFound, \"foo\");\n\n        assert_eq!(actual.kind(), expected.kind());\n    }\n\n    #[test]\n    fn test_writer_to_file_dir_exists_returns_ok() {\n        let file = tempfile::NamedTempFile::new().expect(\"Could not create temp file\");\n        let path = file.path();\n\n        assert!(Writer::to_file(path).is_ok())\n    }\n\n    #[test]\n    fn test_write_record() {\n        let path = Path::new(\"test.fq\");\n        let file = fs::File::create(path).unwrap();\n        {\n            let handle = io::BufWriter::new(file);\n            let mut writer = Writer { writer: handle };\n            let record = Record::with_attrs(\"id\", Some(\"desc\"), b\"ACGT\", b\"!!!!\");\n\n            let write_result = writer.write_record(\u0026record);\n            assert!(write_result.is_ok());\n        }\n\n        let actual = fs::read_to_string(path).unwrap();\n        let expected = \"@id desc\\nACGT\\n+\\n!!!!\\n\";\n\n        assert!(fs::remove_file(path).is_ok());\n        assert_eq!(actual, expected)\n    }\n}\n","traces":[{"line":147,"address":[8056560,8056764],"length":1,"stats":{"Line":0},"fn_name":"from_file\u003c\u0026std::path::Path\u003e"},{"line":148,"address":[8056680,8056742,8056586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[8056672,8057047,8057032,8056972,8056800],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003c\u0026std::path::Path\u003e"},{"line":150,"address":[8056858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[8056952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[8057078,8057056,8056734],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003c\u0026std::path::Path\u003e"},{"line":160,"address":[8057376,8057216,8057361,8057695,8057349,8057543,8057707,8057558,8057568],"length":1,"stats":{"Line":0},"fn_name":"new\u003c\u0026[u8]\u003e"},{"line":162,"address":[8057239,8057585,8057392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[8057430,8057254,8057600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[8057712],"length":1,"stats":{"Line":0},"fn_name":"records\u003c\u0026[u8]\u003e"},{"line":191,"address":[8057776],"length":1,"stats":{"Line":0},"fn_name":"new_with_line_buffer\u003c\u0026[u8]\u003e"},{"line":241,"address":[8060016,8060804,8057904,8058692],"length":1,"stats":{"Line":0},"fn_name":"read\u003c\u0026[u8]\u003e"},{"line":242,"address":[8060082,8057970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[8057983,8060095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[8060223,8058111,8060112,8058000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[8060301,8060197,8058085,8058189,8062053,8059941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[8058208,8060320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[8058349,8060461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[8060512,8060399,8058400,8058287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[8058633,8060745,8060573,8058461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[8062150,8060942,8058602,8062198,8060819,8058707,8062128,8058830,8060714,8062176],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003c\u0026[u8]\u003e"},{"line":254,"address":[8060923,8058811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[8061111,8058999,8058901,8061013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[8061090,8058978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[8061177,8058989,8061101,8059065,8061590,8059478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[8059192,8061304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[8059285,8061397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[8061414,8059302,8061521,8059409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[8059379,8061583,8059471,8061491,8061595,8059483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[8061633,8061730,8059618,8059118,8062038,8059926,8061230,8059521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[8061751,8059639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[8059656,8059735,8061775,8061975,8059663,8061847,8061768,8059863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[8059659,8061771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[8061830,8061911,8059799,8059718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[8059769,8061881,8062003,8059891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[8062047,8061704,8059592,8059935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[8059951,8062063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[8059994,8062106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[8106618,8106630,8106352],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":296,"address":[8106369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[8106393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[8106405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[8107459,8106640],"length":1,"stats":{"Line":0},"fn_name":"with_attrs"},{"line":317,"address":[8106788,8106940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[8106899,8106796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[8106857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[8106892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[8107062,8106986,8107110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[8107237,8107154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[8107488],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":343,"address":[8107502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[8107664],"length":1,"stats":{"Line":0},"fn_name":"check"},{"line":368,"address":[8107684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[8107754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[8107815,8107733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[8107860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[8107839,8107899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[8107940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[8107923,8107982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[8108064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[8108047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[8108096],"length":1,"stats":{"Line":0},"fn_name":"id"},{"line":386,"address":[8108105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[8108144],"length":1,"stats":{"Line":0},"fn_name":"desc"},{"line":391,"address":[8108188,8108153,8108199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[8108201,8108168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[8108190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[8108272],"length":1,"stats":{"Line":0},"fn_name":"seq"},{"line":399,"address":[8108281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[8108400],"length":1,"stats":{"Line":0},"fn_name":"qual"},{"line":404,"address":[8108409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[8108528,8108638],"length":1,"stats":{"Line":0},"fn_name":"clear"},{"line":409,"address":[8108541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[8108620,8108550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[8108605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[8108670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[8108688,8109279],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":446,"address":[8109342,8108727,8108771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[8108748,8109344,8108815,8109294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[8109435,8108781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[8109748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[8109526,8109390,8109466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[8109614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[8110192],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":462,"address":[8110201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[8110240],"length":1,"stats":{"Line":0},"fn_name":"base"},{"line":466,"address":[8110258,8110338,8110320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[8110352],"length":1,"stats":{"Line":0},"fn_name":"base_qual"},{"line":470,"address":[8110370,8110450,8110432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[8110464],"length":1,"stats":{"Line":0},"fn_name":"len"},{"line":474,"address":[8110473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[8062224,8062363],"length":1,"stats":{"Line":0},"fn_name":"next\u003c\u0026[u8]\u003e"},{"line":488,"address":[8062254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[8062684,8062701,8062378,8062298],"length":1,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[8062541,8062694,8062385,8062305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[8062588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[8062401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[8062752],"length":1,"stats":{"Line":0},"fn_name":"to_file\u003c\u0026std::path::Path\u003e"},{"line":507,"address":[8062775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[8062816,8062896],"length":1,"stats":{"Line":0},"fn_name":"new\u003cstd::fs::File\u003e"},{"line":515,"address":[8062833,8062910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[8062992],"length":1,"stats":{"Line":0},"fn_name":"write_record\u003cstd::fs::File\u003e"},{"line":521,"address":[8063039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[8063248,8066176],"length":1,"stats":{"Line":0},"fn_name":"write\u003cstd::fs::File\u003e"},{"line":532,"address":[8066572,8066328,8063400,8063644],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[8066718,8063970,8066567,8063639,8066898,8063790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[8066867,8064194,8067122,8067013,8064085,8064721,8063939,8067649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[8067055,8067199,8067375,8064271,8064127,8064447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[8067654,8064445,8064726,8067500,8067373,8064572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[8067930,8065002,8067764,8064836,8067129,8064201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[8065280,8067875,8064947,8065112,8068040,8068208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[8068318,8065213,8068484,8068141,8065390,8065556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[8068594,8065834,8068762,8065666,8068429,8065501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[8065944,8068981,8065767,8066053,8068695,8068872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[8066040,8068968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[8069104],"length":1,"stats":{"Line":0},"fn_name":"flush\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":549,"address":[8069113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[5090192,5092632],"length":1,"stats":{"Line":0},"fn_name":"test_reader"},{"line":567,"address":[5090199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[5090240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[5090572,5090324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[5090775,5092578,5090623,5090803,5090493],"length":1,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[5091267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[5091417,5091679,5091620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[5091911,5091634,5091742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[5091968,5092121,5091875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[5092088,5092331,5092178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[5092388,5092523,5092298],"length":1,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[5092672,5093432],"length":1,"stats":{"Line":0},"fn_name":"test_display_record_no_desc_id_without_space_after"},{"line":582,"address":[5092679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[5092706],"length":1,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[5092783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[5092865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[5092880,5093077,5092984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[5093134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[5093241,5093359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[5093456,5094216],"length":1,"stats":{"Line":0},"fn_name":"test_display_record_with_desc_id_has_space_between_id_and_desc"},{"line":595,"address":[5093463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[5093490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[5093567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[5093649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[5093664,5093861,5093768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":601,"address":[5093918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[5094143,5094025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[5095878,5094240],"length":1,"stats":{"Line":0},"fn_name":"test_fqread_trait"},{"line":608,"address":[5094247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[5094477,5094602,5094274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[5094454,5094353,5094317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[5094323,5094579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[5094517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[5094684,5094604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[5094751,5094973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[5095204,5095035,5094928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[5095261,5095414,5095168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[5095381,5095471,5095624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[5095816,5095591,5095681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":626,"address":[5095904,5096955],"length":1,"stats":{"Line":0},"fn_name":"test_record_with_attrs"},{"line":627,"address":[5095911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[5096230,5096023,5096289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[5096351,5096244,5096504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[5096561,5096714,5096471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[5096681,5096908,5096771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[5097580,5096992],"length":1,"stats":{"Line":0},"fn_name":"test_writer"},{"line":636,"address":[5096999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":637,"address":[5097058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[5097031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[5097276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":641,"address":[5097388,5097534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":645,"address":[5097616,5098035],"length":1,"stats":{"Line":0},"fn_name":"test_check_record_id_is_empty_raises_err"},{"line":646,"address":[5097623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[5097713,5097823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[5097839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":651,"address":[5097989,5097874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":655,"address":[5098510,5098064],"length":1,"stats":{"Line":0},"fn_name":"test_check_record_seq_is_not_ascii_raises_err"},{"line":656,"address":[5098071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[5098188,5098298],"length":1,"stats":{"Line":0},"fn_name":null},{"line":659,"address":[5098314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":661,"address":[5098464,5098349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":665,"address":[5098990,5098544],"length":1,"stats":{"Line":0},"fn_name":"test_check_record_quality_is_not_ascii_raises_err"},{"line":666,"address":[5098551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[5098668,5098778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[5098794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":671,"address":[5098829,5098944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":675,"address":[5099024,5099444],"length":1,"stats":{"Line":0},"fn_name":"test_check_record_quality_and_seq_diff_len_raises_err"},{"line":676,"address":[5099031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[5099122,5099232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":679,"address":[5099248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":681,"address":[5099283,5099398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[5099472,5099728],"length":1,"stats":{"Line":0},"fn_name":"test_check_valid_record"},{"line":686,"address":[5099479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[5099678,5099570,5099696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[5099760,5100107],"length":1,"stats":{"Line":0},"fn_name":"test_read_header_does_not_start_with_correct_char_raises_err"},{"line":693,"address":[5099767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[5099794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":695,"address":[5099821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":697,"address":[5099890,5099846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[5100011,5099954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[5100491,5100144],"length":1,"stats":{"Line":0},"fn_name":"test_read_quality_is_empty_raises_err"},{"line":704,"address":[5100151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":705,"address":[5100178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":706,"address":[5100205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[5100274,5100230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":710,"address":[5100395,5100338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":714,"address":[5100528,5101066],"length":1,"stats":{"Line":0},"fn_name":"test_read_sequence_and_quality_are_wrapped_is_handled_with_one_sequence"},{"line":715,"address":[5100535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":716,"address":[5100562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[5100592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[5100664,5100620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[5100723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":722,"address":[5100837,5100993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":726,"address":[5102376,5101104],"length":1,"stats":{"Line":0},"fn_name":"test_read_sequence_and_quality_are_wrapped_is_handled_with_three_sequences"},{"line":727,"address":[5101111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":728,"address":[5101138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":730,"address":[5101168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":731,"address":[5101196,5101240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":732,"address":[5101299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":734,"address":[5101582,5101413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":736,"address":[5101628,5101565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[5101650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":739,"address":[5101764,5101933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":741,"address":[5101916,5101980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":742,"address":[5102002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":744,"address":[5102272,5102116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":748,"address":[5102400,5102794],"length":1,"stats":{"Line":0},"fn_name":"test_read_wrapped_record_with_inconsistent_wrapping_errors"},{"line":749,"address":[5102407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":750,"address":[5102434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":752,"address":[5102461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[5102530,5102486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":754,"address":[5102604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":756,"address":[5102698,5102641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[5102832,5103153],"length":1,"stats":{"Line":0},"fn_name":"test_record_iterator_next_read_returns_err_causes_next_to_return_some_err"},{"line":761,"address":[5102839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":762,"address":[5102866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":764,"address":[5102912,5102984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":766,"address":[5103071,5103014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":770,"address":[5103184,5103528],"length":1,"stats":{"Line":0},"fn_name":"test_reader_from_file_path_doesnt_exist_returns_err"},{"line":771,"address":[5103191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":772,"address":[5103244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[5103318,5103482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":781,"address":[5103552,5103687],"length":1,"stats":{"Line":0},"fn_name":"test_reader_from_file_path_exists_returns_ok"},{"line":782,"address":[5103559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":784,"address":[5103717,5103747,5103703,5103606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":788,"address":[5103760,5104121],"length":1,"stats":{"Line":0},"fn_name":"test_sequence_read_for_record_trait_method_name"},{"line":789,"address":[5103767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":791,"address":[5103858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":792,"address":[5103907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":794,"address":[5103930,5104075,5104047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":798,"address":[5104554,5104144],"length":1,"stats":{"Line":0},"fn_name":"test_sequence_read_for_record_trait_method_base_idx_in_range"},{"line":799,"address":[5104151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":800,"address":[5104178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[5104205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[5104230,5104274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[5104330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":805,"address":[5104352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":806,"address":[5104376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[5104384,5104491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":813,"address":[5104592,5104831],"length":1,"stats":{"Line":0},"fn_name":"test_sequence_read_for_record_trait_method_base_idx_out_of_range"},{"line":814,"address":[5104599],"length":1,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[5104626],"length":1,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[5104653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[5104722,5104678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":819,"address":[5104778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[5104800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":825,"address":[5105274,5104864],"length":1,"stats":{"Line":0},"fn_name":"test_sequence_read_for_record_trait_method_base_qual_idx_in_range"},{"line":826,"address":[5104871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[5104898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":828,"address":[5104925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":829,"address":[5104950,5104994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":830,"address":[5105050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":832,"address":[5105072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":833,"address":[5105096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":835,"address":[5105211,5105104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":840,"address":[5105312,5105551],"length":1,"stats":{"Line":0},"fn_name":"test_sequence_read_for_record_trait_method_base_qual_idx_out_of_range"},{"line":841,"address":[5105319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":842,"address":[5105346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":843,"address":[5105373],"length":1,"stats":{"Line":0},"fn_name":null},{"line":844,"address":[5105442,5105398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":846,"address":[5105498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":848,"address":[5105520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":852,"address":[5105987,5105584],"length":1,"stats":{"Line":0},"fn_name":"test_sequence_read_for_record_trait_method_len"},{"line":853,"address":[5105591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":854,"address":[5105618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":855,"address":[5105645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":856,"address":[5105714,5105670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":858,"address":[5105775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":859,"address":[5105803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":861,"address":[5105815,5105924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":865,"address":[5106550,5106016],"length":1,"stats":{"Line":0},"fn_name":"test_writer_to_file_dir_doesnt_exist_returns_err"},{"line":866,"address":[5106023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":868,"address":[5106076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":869,"address":[5106145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":871,"address":[5106244,5106363,5106299,5106491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":875,"address":[5106862,5106576],"length":1,"stats":{"Line":0},"fn_name":"test_writer_to_file_dir_exists_returns_ok"},{"line":876,"address":[5106583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":877,"address":[5106633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":879,"address":[5106687,5106830,5106737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":883,"address":[5107495,5106896],"length":1,"stats":{"Line":0},"fn_name":"test_write_record"},{"line":884,"address":[5106903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":885,"address":[5106956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":887,"address":[5106998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":888,"address":[5107011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":889,"address":[5107075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":891,"address":[5107270,5107197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":892,"address":[5107302,5107368,5107433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":895,"address":[5107520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":896,"address":[5107571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":898,"address":[5107898,5107598,5107737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":899,"address":[5107819,5107935,5107967],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":311},{"path":["/","home","todd","rust-bio","src","io","fastx.rs"],"content":"// Copyright 2021 Todd Morse.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Traits and utilities to read and write files in the FASTA and FASTQ format interchangably\n//!\n//! Files in the FASTA and FASTQ format have several common fields: ID, Sequence, and Description.\n//! These utilities can be used to implement algorithms that only require these fields for files\n//! that are in either format.\n//!\n//! This module serves two use cases:\n//!\n//! 1. Implementing functions that can be used generically with FASTA/FASTQ records. In this use\n//! case the type may be known at compile time by the caller of your function.\n//! 2. Processing data that may be either in the FASTA/FASTQ format. In this use case the type\n//! cannot be known at compile time and you may or may not want to treat FASTA/FASTQ data\n//! differently.\n//!\n//! # Generic Implementation Examples\n//!\n//! ## Common Statistics\n//!\n//! In this example, we implement a count_bases function that for supports both the FASTA and FASTQ\n//! format.\n//!\n//! ```\n//! use bio::io::{fasta, fastq, fastx};\n//! use std::io;\n//!\n//! fn count_bases\u003cT, E, I\u003e(mut records: I) -\u003e Result\u003cusize, E\u003e\n//! where T: fastx::Record,\n//!     E: std::error::Error,\n//!     I: fastx::Records\u003cT, E\u003e {\n//!     let mut nb_bases = 0;\n//!     for result in records {\n//!         let record = result?;\n//!         nb_bases += record.seq().len();\n//!     }\n//!     Ok(nb_bases)\n//! }\n//!\n//! let mut raw_reader = io::Cursor::new(b\"\u003eid desc\n//! ACTG\n//! \");\n//!\n//! match fastx::get_kind_seek(\u0026mut raw_reader) {\n//!     Ok(fastx::Kind::FASTA) =\u003e {\n//!         let mut reader = fasta::Reader::new(raw_reader);\n//!         let nb_bases = count_bases(reader.records()).unwrap();\n//!         println!(\"Number of bases: {}\", nb_bases);\n//!     },\n//!     Ok(fastx::Kind::FASTQ) =\u003e {\n//!         let mut reader = fastq::Reader::new(raw_reader);\n//!         let nb_bases = count_bases(reader.records()).unwrap();\n//!         println!(\"Number of bases: {}\", nb_bases);\n//!     },\n//!     _ =\u003e println!(\"Encountered an error\"),\n//! }\n//! ```\n//!\n//! ## Filtration\n//!\n//! In this example, we define an at_least_n_bases function that can filter FASTA or FASTQ\n//! records based on their sequence lengths. It works seemlessly with `fasta::Record`s as if\n//! it was implemented just for them. In a realistic scenario this function might be\n//! defined in a library so callers could use it with both FASTA and FASTQ files as needed.\n//!\n//! ```\n//! use bio::io::{fasta, fastq, fastx};\n//! use std::io;\n//!\n//! fn at_least_n_bases\u003cT, E, I\u003e(mut records: I, n: usize) -\u003e impl Iterator\u003cItem = Result\u003cT, E\u003e\u003e\n//! where T: fastx::Record,\n//!     E: std::error::Error,\n//!     I: fastx::Records\u003cT, E\u003e {\n//!     records.filter(move |rr| match rr {\n//!         Ok(r) =\u003e r.seq().len() \u003e n,\n//!         _ =\u003e true,\n//!     })\n//! }\n//!\n//! let mut reader = fasta::Reader::new(io::stdin());\n//! let mut writer = fasta::Writer::new(io::stdout());\n//!\n//! for record in at_least_n_bases(reader.records(), 10) {\n//!     writer.write_record(\u0026record.unwrap());\n//! }\n//! ```\n//! # Unknown Type Examples\n//!\n//! If the type of a record is not known at compile time the record is a `fastx::EitherRecord`.\n//! This type is an enum containing either a `fasta::Record` or a `fastq::Record`. There are also\n//! utility functions defined on the enum so you can work with it without detecting the type.\n//!\n//! ## Parsing data of unknown type\n//!\n//! ```\n//! use bio::io::fastx::{Record, EitherRecords};\n//! use std::io;\n//! use std::str;\n//!\n//! let mut records = EitherRecords::from(io::stdin());\n//! while let Some(Ok(record)) = records.next() {\n//!     println!(\"id  : {}\", record.id());\n//!     println!(\"desc: {}\", record.desc().unwrap_or(\"none\"));\n//!     println!(\"seq : {}\", str::from_utf8(record.seq()).unwrap_or(\"error\"));\n//!     // Add a default quality in case we have a FASTA record\n//!     let default_qual = vec![b'I' ; record.seq().len()];\n//!     let qual = record.qual().unwrap_or(\u0026default_qual);\n//!     println!(\"qual: {}\", str::from_utf8(qual).unwrap_or(\"error\"));\n//!     println!(\"\")\n//! }\n//! ```\n//!\n//! # Utility Examples\n//!\n//! ## Type Detection\n//!\n//! This module provides utilities for detecting if some data is a FASTA/FASTQ.\n//!\n//! ```\n//! use bio::io::fastx::{get_kind, get_kind_seek, get_kind_file, Kind};\n//! use std::io;\n//! use std::io::Read;\n//! use std::fs;\n//! use std::fs::File;\n//! use std::io::prelude::*;\n//!\n//! // From a Read\n//!\n//! fn from_read() -\u003e io::Result\u003cKind\u003e {\n//!     let reader = io::stdin();\n//!     let (mut new_reader, kind) = get_kind(reader)?;\n//!     println!(\"{}\", kind);\n//!     // Read from start of your old reader\n//!     let mut buf = [0u8; 8];\n//!     new_reader.read(\u0026mut buf)?;\n//!     Ok(kind)\n//! }\n//!\n//!\n//! // From a Read + Seek\n//!\n//! fn from_read_seek() -\u003e io::Result\u003cKind\u003e {\n//!     let mut read_seek = io::Cursor::new(b\"\u003eid desc\n//! ACTG\n//! \");\n//!\n//!     get_kind_seek(\u0026mut read_seek)\n//! }\n//!\n//! // From a file path\n//!\n//! fn from_file_path() -\u003e io::Result\u003cKind\u003e {\n//!     get_kind_file(\"foo.fasta\")\n//! }\n//! ```\n//!\nuse anyhow::Context;\nuse std::convert::AsRef;\nuse std::fs;\nuse std::io::SeekFrom;\nuse std::io::prelude::*;\nuse std::io;\nuse std::mem;\nuse std::path::Path;\nuse thiserror::Error;\n\nuse crate::io::{fasta, fastq};\nuse crate::utils::TextSlice;\n\nmacro_rules! passthrough {\n    ($name:ident, $t:ty) =\u003e {\n        fn $name(\u0026self) -\u003e $t {\n            self.$name()\n        }\n    };\n}\n\nmacro_rules! matchthrough {\n    ($name:ident, $t:ty) =\u003e {\n        fn $name(\u0026self) -\u003e $t {\n            match self {\n                EitherRecord::FASTA(f) =\u003e Record::$name(f),\n                EitherRecord::FASTQ(f) =\u003e Record::$name(f),\n            }\n        }\n    };\n}\n\npub trait Record {\n    fn is_empty(\u0026self) -\u003e bool;\n    fn check(\u0026self) -\u003e Result\u003c(), \u0026str\u003e;\n    fn id(\u0026self) -\u003e \u0026str;\n    fn desc(\u0026self) -\u003e Option\u003c\u0026str\u003e;\n    fn seq(\u0026self) -\u003e TextSlice\u003c'_\u003e;\n    fn qual(\u0026self) -\u003e Option\u003c\u0026[u8]\u003e;\n    fn kind(\u0026self) -\u003e Kind;\n}\n\nimpl Record for super::fasta::Record {\n    passthrough!(is_empty, bool);\n    passthrough!(check, Result\u003c(), \u0026str\u003e);\n    passthrough!(id, \u0026str);\n    passthrough!(desc, Option\u003c\u0026str\u003e);\n    passthrough!(seq, TextSlice\u003c'_\u003e);\n\n    fn qual(\u0026self) -\u003e Option\u003c\u0026[u8]\u003e {\n        None\n    }\n\n    fn kind(\u0026self) -\u003e Kind {\n        Kind::FASTA\n    }\n}\n\nimpl Record for super::fastq::Record {\n    passthrough!(is_empty, bool);\n    passthrough!(check, Result\u003c(), \u0026str\u003e);\n    passthrough!(id, \u0026str);\n    passthrough!(desc, Option\u003c\u0026str\u003e);\n    passthrough!(seq, TextSlice\u003c'_\u003e);\n\n    fn qual(\u0026self) -\u003e Option\u003c\u0026[u8]\u003e {\n        Some(self.qual())\n    }\n\n    fn kind(\u0026self) -\u003e Kind {\n        Kind::FASTQ\n    }\n}\n\npub enum EitherRecord {\n    FASTA(fasta::Record),\n    FASTQ(fastq::Record),\n}\n\nimpl EitherRecord {\n    pub fn to_fasta(self) -\u003e fasta::Record {\n        return self.into();\n    }\n\n    pub fn to_fastq(self, default_qual: u8) -\u003e fastq::Record {\n        match self {\n            EitherRecord::FASTQ(f) =\u003e f,\n            EitherRecord::FASTA(f) =\u003e {\n                let qual = \u0026vec![default_qual; f.seq().len()];\n                fastq::Record::with_attrs(f.id(), f.desc(), f.seq(), qual)\n            }\n        }\n    }\n}\n\nimpl Into\u003cfasta::Record\u003e for EitherRecord {\n    fn into(self) -\u003e fasta::Record {\n        match self {\n            EitherRecord::FASTA(f) =\u003e f,\n            EitherRecord::FASTQ(f) =\u003e fasta::Record::with_attrs(f.id(), f.desc(), f.seq()),\n        }\n    }\n}\n\nimpl From\u003cfasta::Record\u003e for EitherRecord {\n    fn from(record: fasta::Record) -\u003e Self {\n        EitherRecord::FASTA(record)\n    }\n}\n\nimpl From\u003cfastq::Record\u003e for EitherRecord {\n    fn from(record: fastq::Record) -\u003e Self {\n        EitherRecord::FASTQ(record)\n    }\n}\n\nimpl Record for EitherRecord {\n    matchthrough!(is_empty, bool);\n    matchthrough!(check, Result\u003c(), \u0026str\u003e);\n    matchthrough!(id, \u0026str);\n    matchthrough!(desc, Option\u003c\u0026str\u003e);\n    matchthrough!(seq, TextSlice\u003c'_\u003e);\n\n    fn qual(\u0026self) -\u003e Option\u003c\u0026[u8]\u003e {\n        match \u0026self {\n            EitherRecord::FASTA(f) =\u003e Record::qual(f),\n            EitherRecord::FASTQ(f) =\u003e Record::qual(f),\n        }\n    }\n\n    matchthrough!(kind, Kind);\n}\n\npub trait Records\u003cR: Record, E\u003e: Iterator\u003cItem = Result\u003cR, E\u003e\u003e {}\n\nimpl\u003cT: io::Read\u003e Records\u003cfasta::Record, io::Error\u003e for fasta::Records\u003cT\u003e {}\n\nimpl\u003cT: io::Read\u003e Records\u003cfastq::Record, fastq::Error\u003e for fastq::Records\u003cT\u003e {}\n\n#[derive(Debug)]\nenum EitherRecordsInner\u003cR: io::Read\u003e {\n    FASTA(fasta::Records\u003cR\u003e),\n    FASTQ(fastq::Records\u003cR\u003e),\n}\n\n#[derive(Debug)]\npub struct EitherRecords\u003cR: io::Read\u003e {\n    records: Option\u003cEitherRecordsInner\u003cR\u003e\u003e,\n    reader: Option\u003cR\u003e,\n}\n\nimpl EitherRecords\u003cfs::File\u003e {\n    /// Read from a given file.\n    pub fn from_file\u003cP: AsRef\u003cPath\u003e + std::fmt::Debug\u003e(path: P) -\u003e anyhow::Result\u003cSelf\u003e {\n        fs::File::open(path.as_ref())\n            .map(EitherRecords::from)\n            .with_context(|| format!(\"Failed to read fastq from {:#?}\", path))\n    }\n}\n\nimpl\u003cR: io::Read\u003e EitherRecords\u003cR\u003e {\n    pub fn new(reader: R) -\u003e Self {\n        EitherRecords::from(reader)\n    }\n\n    pub fn kind(\u0026mut self) -\u003e io::Result\u003cKind\u003e {\n        self.initialize()?;\n        match self.records {\n            Some(EitherRecordsInner::FASTA(_)) =\u003e Ok(Kind::FASTA),\n            Some(EitherRecordsInner::FASTQ(_)) =\u003e Ok(Kind::FASTQ),\n            None =\u003e Err(io::Error::new(\n                io::ErrorKind::UnexpectedEof,\n                \"Data is empty\",\n            )),\n        }\n    }\n\n    fn initialize(\u0026mut self) -\u003e io::Result\u003c()\u003e {\n        if let Some(reader) = mem::replace(\u0026mut self.reader, None) {\n            let mut reader: io::BufReader\u003cR\u003e = io::BufReader::new(reader);\n            let mut line = String::new();\n            reader.read_line(\u0026mut line)?;\n            match line.chars().next() {\n                Some('\u003e') =\u003e {\n                    self.records = Some(EitherRecordsInner::FASTA(\n                        fasta::Reader::new_with_line(reader, line).records(),\n                    ))\n                }\n                Some('@') =\u003e {\n                    self.records = Some(EitherRecordsInner::FASTQ(\n                        fastq::Reader::new_with_line_buffer(reader, line).records(),\n                    ))\n                }\n                Some(c) =\u003e {\n                    return Err(io::Error::new(\n                        io::ErrorKind::InvalidData,\n                        format!(\n                            \"Data is not a valid FASTA/FASTQ, illegal start character '{}'\",\n                            c\n                        ),\n                    ))\n                }\n                None =\u003e (),\n            }\n        }\n        Ok(())\n    }\n}\n\nimpl\u003cR: io::Read\u003e Iterator for EitherRecords\u003cR\u003e {\n    type Item = Result\u003cEitherRecord\u003e;\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        if let Err(e) = self.initialize() {\n            return Some(Err(Error::IO(e)));\n        }\n        match \u0026mut self.records {\n            Some(EitherRecordsInner::FASTA(r)) =\u003e r\n                .next()\n                .map(|record_res| record_res.map(EitherRecord::from).map_err(Error::from)),\n            Some(EitherRecordsInner::FASTQ(r)) =\u003e r\n                .next()\n                .map(|record_res| record_res.map(EitherRecord::from).map_err(Error::from)),\n            None =\u003e None,\n        }\n    }\n}\n\nimpl\u003cR: io::Read\u003e From\u003cR\u003e for EitherRecords\u003cR\u003e {\n    fn from(reader: R) -\u003e Self {\n        EitherRecords {\n            records: None,\n            reader: Some(reader),\n        }\n    }\n}\n\n#[derive(Display, Debug, Error)]\npub enum Error {\n    IO(io::Error),\n    FASTQ(fastq::Error),\n}\n\nimpl From\u003cio::Error\u003e for Error {\n    fn from(err: io::Error) -\u003e Self {\n        Error::IO(err)\n    }\n}\n\nimpl From\u003cfastq::Error\u003e for Error {\n    fn from(err: fastq::Error) -\u003e Self {\n        Error::FASTQ(err)\n    }\n}\n\ntype Result\u003cT, E = Error\u003e = std::result::Result\u003cT, E\u003e;\n\n#[derive(Debug, Eq, PartialEq)]\npub enum Kind {\n    FASTQ,\n    FASTA,\n}\n\n/// Determine whether a [`Read`](Read) is a FastA or FastQ.\n///\n/// This method takes ownership of the [`Read`](Read) and returns a new [`Read`](Read)\n/// with position identical to the position of the input [`Read`](Read).\n/// This allows you to pass the returned [`Read`]#Read) directly into\n/// [`fasta::Reader::new`](fasta::Reader::new) or [`fastq::Reader::new`](fastq::Reader::new).\n///\n/// In general this function is superior to [`get_kind_preserve_read`](get_kind) unless\n/// you would like to do something with the [`Read`](Read) in cases where\n/// there is an error determining the type.\n///\n/// Due to the implementation of the function it is sometimes impossible to return\n///\n/// # Example\n///\n/// ```rust\n/// use bio::io::{fasta, fastq};\n/// use bio::io::fastx::{Kind, get_kind};\n/// use std::io;\n///\n/// fn count_records() -\u003e io::Result\u003cusize\u003e {\n///     let (reader, kind) = get_kind(io::stdin())?;\n///     match kind {\n///         Kind::FASTA =\u003e Ok(fasta::Reader::new(reader).records().count()),\n///         Kind::FASTQ =\u003e Ok(fastq::Reader::new(reader).records().count()),\n///     }\n/// }\n/// ```\npub fn get_kind\u003cR: io::Read\u003e(mut reader: R) -\u003e io::Result\u003c(impl io::Read, Kind)\u003e {\n    let mut buf = [0];\n    reader.read_exact(\u0026mut buf)?;\n    let first = char::from(buf[0]);\n    let new_reader = Box::new(io::Cursor::new(buf).chain(reader));\n\n    match first {\n        '\u003e' =\u003e Ok((new_reader, Kind::FASTA)),\n        '@' =\u003e Ok((new_reader, Kind::FASTQ)),\n        _ =\u003e Err(io::Error::new(\n            io::ErrorKind::InvalidData,\n            format!(\n                \"Data is not a valid FASTA/FASTQ, illegal start character '{}'\",\n                first\n            ),\n        )),\n    }\n}\n\n/// Determine whether a [`Read`](Read) is a FastA or FastQ.\n///\n/// You should only use this function if you would like to use your input [`Read`](Read)\n/// for something else if there is an error determining the data type. Otherwise,\n/// [`get_kind`](get_kind) is preferred.\n///\n/// This function is very similar to [`get_kind`](get_kind) with the\n/// differences being that [`get_kind_preserve_read`](get_kind_preserve_read):\n///\n/// - Returns the [`Read`](Read) in the correct location if there is an\n///   error in determining the data type\n/// - Returns a tuple containing a [`Result`](Result) instead of a\n///   [`Result`](Result), which can be less convenient to work with\n/// - Requires [`Box`](Box) and `dyn`\n///\n/// # Example\n///\n/// ```rust\n/// use bio::io::{fasta, fastq};\n/// use bio::io::fastx::{Kind, get_kind_preserve_read};\n/// use std::io;\n///\n/// fn print_type() -\u003e io::Result\u003c()\u003e {\n///     let (mut reader, kind) = get_kind_preserve_read(Box::new(io::stdin()));\n///     match kind {\n///         Ok(Kind::FASTA) =\u003e println!(\"{}\", Kind::FASTA),\n///         Ok(Kind::FASTQ) =\u003e println!(\"{}\", Kind::FASTQ),\n///         Err(e) =\u003e {\n///             println!(\"Error determining FastA/FastQ: {}\", e);\n///             println!(\"Data:\");\n///             io::copy(\u0026mut reader, \u0026mut io::stdout());\n///         }\n///     }\n///     Ok(())\n/// }\n/// ```\npub fn get_kind_preserve_read(\n    mut reader: Box\u003cdyn io::Read\u003e,\n) -\u003e (Box\u003cdyn io::Read\u003e, io::Result\u003cKind\u003e) {\n    let mut buf = [0];\n    if let Err(e) = reader.read_exact(\u0026mut buf) {\n        return (reader, Err(e));\n    }\n    let first = char::from(buf[0]);\n    let new_reader = Box::new(io::Cursor::new(buf).chain(reader));\n\n    match first {\n        '\u003e' =\u003e (new_reader, Ok(Kind::FASTA)),\n        '@' =\u003e (new_reader, Ok(Kind::FASTQ)),\n        _ =\u003e (\n            new_reader,\n            Err(io::Error::new(\n                io::ErrorKind::InvalidData,\n                format!(\n                    \"Data is not a valid FASTA/FASTQ, illegal start character '{}'\",\n                    first\n                ),\n            )),\n        ),\n    }\n}\n\n/// Determine whether a [`Read`](Read) + [`Seek`](Seek) is a FastA or FastQ.\n///\n/// The benefit of this this function compared to [`get_kind`](get_kind) is that\n/// this function does not take ownership of the [`Read`](Read) so it can\n/// be slightly more convenient to use.\npub fn get_kind_seek\u003cR: io::Read + io::Seek\u003e(reader: \u0026mut R) -\u003e io::Result\u003cKind\u003e {\n    let mut buf = [0];\n    reader.read_exact(\u0026mut buf)?;\n    reader.seek(SeekFrom::Current(-1))?;\n    let first = char::from(buf[0]);\n\n    match first {\n        '\u003e' =\u003e Ok(Kind::FASTA),\n        '@' =\u003e Ok(Kind::FASTQ),\n        _ =\u003e Err(io::Error::new(\n            io::ErrorKind::InvalidData,\n            format!(\n                \"Data is not a valid FASTA/FASTQ, illegal start character '{}'\",\n                first\n            ),\n        )),\n    }\n}\n\n/// Determine whether a file is a FastA or FastQ.\npub fn get_kind_file\u003cP: AsRef\u003cPath\u003e + std::fmt::Debug\u003e(path: P) -\u003e io::Result\u003cKind\u003e {\n    fs::File::open(\u0026path).and_then(|mut f| get_kind_seek(\u0026mut f))\n}\n\nimpl std::fmt::Display for Kind {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"{}\",\n            match self {\n                Kind::FASTA =\u003e \"FastA\",\n                Kind::FASTQ =\u003e \"FastQ\",\n            }\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use std::io::Cursor;\n\n    const FASTA_FILE: \u0026[u8] = b\"\u003eid desc\nACCGTAGGCTGA\nCCGTAGGCTGAA\nCGTAGGCTGAAA\nGTAGGCTGAAAA\nCCCC\n\u003eid2\nATTGTTGTTTTA\nATTGTTGTTTTA\nATTGTTGTTTTA\nGGGG\n\";\n\n    const FASTQ_FILE: \u0026[u8] = b\"@id desc\nACCGTAGGCTGA\n+\nIIIIIIJJJJJJ\n\";\n    #[test]\n    fn records_trait() {\n        fn count_records\u003cR: Record, E, I: Records\u003cR, E\u003e\u003e(records: I) -\u003e usize {\n            records.count()\n        }\n        let records = fasta::Reader::new(FASTA_FILE).records();\n        let count = count_records(records);\n        assert_eq!(count, 2);\n    }\n\n    #[test]\n    fn get_fasta_either_records() {\n        let mut records = EitherRecords::from(FASTA_FILE);\n        assert_eq!(records.next().unwrap().unwrap().id(), \"id\");\n        assert_eq!(records.next().unwrap().unwrap().id(), \"id2\");\n        assert!(records.next().is_none());\n        assert!(records.next().is_none());\n    }\n\n    #[test]\n    fn get_empty_either_records() {\n        let mut records = EitherRecords::from(b\"\".as_ref());\n        assert!(records.next().is_none());\n        // this second check is intentional\n        assert!(records.next().is_none());\n    }\n\n    #[test]\n    fn get_invalid_either_records() {\n        let mut records = EitherRecords::from(b\"(\".as_ref());\n        assert!(records.next().unwrap().is_err());\n        // this second check is intentional\n        assert!(records.next().is_none());\n    }\n\n    #[test]\n    fn test_get_kind_preserve_read_fasta() {\n        let (mut new_read, fastx_kind) = get_kind_preserve_read(Box::new(FASTA_FILE));\n        assert_eq!(Kind::FASTA, fastx_kind.unwrap());\n        let mut buf = [0u8; 1];\n        new_read.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(buf[0], FASTA_FILE[0]);\n    }\n\n    #[test]\n    fn test_get_kind_preserve_read_fastq() {\n        let (mut new_read, fastx_kind) = get_kind_preserve_read(Box::new(FASTQ_FILE));\n        assert_eq!(Kind::FASTQ, fastx_kind.unwrap());\n        let mut buf = [0u8; 1];\n        new_read.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(buf[0], FASTQ_FILE[0]);\n    }\n\n    #[test]\n    fn test_get_kind_preserve_read_empty() {\n        let (_, kind_res) = get_kind_preserve_read(Box::new(Cursor::new(b\"\")));\n        assert_eq!(kind_res.err().unwrap().kind(), io::ErrorKind::UnexpectedEof);\n    }\n\n    #[test]\n    fn test_get_kind_preserve_read_invalid() {\n        let read = Cursor::new(b\"*\");\n        let (mut new_read, res) = get_kind_preserve_read(Box::new(read));\n        assert_eq!(io::ErrorKind::InvalidData, res.err().unwrap().kind());\n        let mut buf = [0u8; 1];\n        new_read.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(b'*', buf[0]);\n    }\n\n    #[test]\n    fn test_get_kind_seek_fasta() {\n        let mut read_seeker = Cursor::new(FASTA_FILE);\n        let fastx_kind = get_kind_seek(\u0026mut read_seeker).unwrap();\n        assert_eq!(Kind::FASTA, fastx_kind);\n        assert_eq!(read_seeker.position(), 0);\n    }\n\n    #[test]\n    fn test_get_kind_seek_fastq() {\n        let mut read_seeker = Cursor::new(FASTQ_FILE);\n        let fastq_kind = get_kind_seek(\u0026mut read_seeker).unwrap();\n        assert_eq!(Kind::FASTQ, fastq_kind);\n        assert_eq!(read_seeker.position(), 0);\n    }\n\n    #[test]\n    fn test_get_kind_seek_empty() {\n        let mut read_seeker = Cursor::new(b\"\");\n        let e = get_kind_seek(\u0026mut read_seeker).unwrap_err();\n        assert_eq!(io::ErrorKind::UnexpectedEof, e.kind());\n    }\n\n    #[test]\n    fn test_get_kind_seek_invalid() {\n        let mut read_seeker = Cursor::new(b\"*\");\n        let e = get_kind_seek(\u0026mut read_seeker).unwrap_err();\n        assert_eq!(io::ErrorKind::InvalidData, e.kind());\n    }\n}\n","traces":[{"line":175,"address":[5708016,5708144,5708192,5708096,5708048],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":176,"address":[5708057,5708025,5708105,5708201,5708153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[5913888,5914368,5914528,5914096,5913984,5914256],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":184,"address":[5914394,5914553,5914513,5914511,5913913,5914122,5914010,5914241,5914282,5914239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[5913919,5914270,5914289,5914129,5914017,5913998,5914541,5914401,5914559,5913901,5914110,5914501,5914382,5914229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[5914432,5914320,5914160,5914585,5913945,5914048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[5704368],"length":1,"stats":{"Line":0},"fn_name":"qual"},{"line":210,"address":[5704377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[5704400],"length":1,"stats":{"Line":0},"fn_name":"kind"},{"line":214,"address":[5704409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[8110528],"length":1,"stats":{"Line":0},"fn_name":"qual"},{"line":226,"address":[8110537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[8110592],"length":1,"stats":{"Line":0},"fn_name":"kind"},{"line":230,"address":[8110601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[5910608],"length":1,"stats":{"Line":0},"fn_name":"to_fasta"},{"line":241,"address":[5910621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[5910672,5911388,5911403],"length":1,"stats":{"Line":0},"fn_name":"to_fastq"},{"line":245,"address":[5910734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[5910849,5910722],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[5910744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[5910812,5910932,5911009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[5911055,5911204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[5911806,5911408],"length":1,"stats":{"Line":0},"fn_name":"into"},{"line":257,"address":[5911488,5911442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[5911449,5911430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[5911498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[5911840],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":266,"address":[5911853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[5911920],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":272,"address":[5911934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[5912000],"length":1,"stats":{"Line":0},"fn_name":"qual"},{"line":284,"address":[5912024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[5912026,5912008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[5912056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[6035936,6038055],"length":1,"stats":{"Line":0},"fn_name":"initialize\u003c\u0026[u8]\u003e"},{"line":338,"address":[6036113,6035956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[6036147,6036098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[6036163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[6036384,6036250,6036315,6036517,6036170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[6036596,6037942,6037641,6036701,6036358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[6036722,6036677],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[6037724,6037952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[6036846,6037712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[6037423,6037651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[6037411,6036976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[6036755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[6037232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[6036769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[6037116,6036785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[6038131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[6038144],"length":1,"stats":{"Line":0},"fn_name":"next\u003c\u0026[u8]\u003e"},{"line":372,"address":[6038182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[6038280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[6038467,6038453,6038427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[6038596,6038581,6038473,6038434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[6038624,6038608],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003c\u0026[u8]\u003e"},{"line":379,"address":[6038520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[6038688,6038705],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003c\u0026[u8]\u003e"},{"line":382,"address":[6038460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[6038784],"length":1,"stats":{"Line":0},"fn_name":"from\u003c\u0026[u8]\u003e"},{"line":391,"address":[6038825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[5912112],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":404,"address":[5912148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[5912208],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":410,"address":[5912222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[5913612,5912288],"length":1,"stats":{"Line":0},"fn_name":"get_kind_preserve_read"},{"line":508,"address":[5912315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[5912357,5912519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[5912551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[5912708],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[5912740,5912937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[5913159,5913240,5913610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[5913093,5912945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[5913174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[5913551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[5912983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[5913411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[5913006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[5913352,5913022,5913255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[6039696,6038896,6040496],"length":1,"stats":{"Line":0},"fn_name":"get_kind_seek\u003cstd::io::cursor::Cursor\u003c\u0026[u8; 1]\u003e\u003e"},{"line":537,"address":[6038934,6039734,6040534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[6040549,6040742,6039142,6039942,6039749,6038949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[6039882,6040873,6040682,6039082,6039992,6040073,6039273,6040792,6039192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[6040049,6039249,6040849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[6040484,6041054,6039454,6039437,6041037,6041279,6040479,6040237,6040254,6039679,6039684,6041284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[6039331,6040131,6041030,6040230,6039430,6040931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[6041047,6039447,6040247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[6039578,6041178,6040378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[6040960,6039360,6040160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[6041069,6039368,6040968,6039469,6040168,6040269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[5913664],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":562,"address":[5913749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[5913703,5913726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[5913728,5913692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[5913705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[4268480],"length":1,"stats":{"Line":0},"fn_name":"records_trait"},{"line":599,"address":[4528864],"length":1,"stats":{"Line":0},"fn_name":"count_records\u003cbio::io::fasta::Record,std::io::error::Error,bio::io::fasta::Records\u003c\u0026[u8]\u003e\u003e"},{"line":600,"address":[4528871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[4268487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[4268524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[4268568,4268670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[4268720,4269795],"length":1,"stats":{"Line":0},"fn_name":"get_fasta_either_records"},{"line":609,"address":[4268727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[4268836,4268762],"length":1,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[4269147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[4269496,4269620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[4269661,4269613,4269762],"length":1,"stats":{"Line":0},"fn_name":null},{"line":617,"address":[4269824,4270218],"length":1,"stats":{"Line":0},"fn_name":"get_empty_either_records"},{"line":618,"address":[4269831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[4269886,4269955,4270044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[4270037,4270084,4270185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":625,"address":[4270256,4270680],"length":1,"stats":{"Line":0},"fn_name":"get_invalid_either_records"},{"line":626,"address":[4270263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[4270318,4270506,4270400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[4270499,4270647,4270546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[4271442,4270704],"length":1,"stats":{"Line":0},"fn_name":"test_get_kind_preserve_read_fasta"},{"line":634,"address":[4270792,4270711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[4271134,4271069,4270863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[4271075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":637,"address":[4271190,4271101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[4271252,4271366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[4272210,4271472],"length":1,"stats":{"Line":0},"fn_name":"test_get_kind_preserve_read_fastq"},{"line":643,"address":[4271560,4271479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[4271902,4271837,4271631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":645,"address":[4271843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[4271958,4271869],"length":1,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[4272134,4272020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":651,"address":[4272240,4272905],"length":1,"stats":{"Line":0},"fn_name":"test_get_kind_preserve_read_empty"},{"line":652,"address":[4272247,4272348],"length":1,"stats":{"Line":0},"fn_name":null},{"line":653,"address":[4272527,4272411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[4273954,4272944],"length":1,"stats":{"Line":0},"fn_name":"test_get_kind_preserve_read_invalid"},{"line":658,"address":[4272951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":659,"address":[4273068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[4273364,4273154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":661,"address":[4273640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":662,"address":[4273666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":663,"address":[4273875,4273761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[4273984],"length":1,"stats":{"Line":0},"fn_name":"test_get_kind_seek_fasta"},{"line":668,"address":[4273991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[4274013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[4274051,4274158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":671,"address":[4274128,4274193,4274295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":675,"address":[4274352],"length":1,"stats":{"Line":0},"fn_name":"test_get_kind_seek_fastq"},{"line":676,"address":[4274359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":677,"address":[4274381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[4274526,4274419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":679,"address":[4274496,4274561,4274663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[4275023,4274720],"length":1,"stats":{"Line":0},"fn_name":"test_get_kind_seek_empty"},{"line":684,"address":[4274727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[4274749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[4274828,4274986,4274958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[4275056,4275359],"length":1,"stats":{"Line":0},"fn_name":"test_get_kind_seek_invalid"},{"line":691,"address":[4275063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[4275085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[4275294,4275322,4275164],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":174},{"path":["/","home","todd","rust-bio","src","io","gff.rs"],"content":"// Copyright 2016 Pierre Marijon.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! [GFF3] format reading and writing. [GFF2] is currently not supported.\n//!\n//! [GFF2]: http://gmod.org/wiki/GFF2 (not supported)\n//! [GTF2]: http://mblab.wustl.edu/GTF2.html (not supported)\n//! [GFF3]: http://gmod.org/wiki/GFF3#GFF3_Format\n//!\n//! # Example\n//!\n//! ```\n//! // import functions (at top of script)\n//! use bio::io::gff;\n//! use std::io;\n//! let mut reader = gff::Reader::new(io::stdin(), gff::GffType::GFF3);\n//! let mut writer = gff::Writer::new(vec![], gff::GffType::GFF3);\n//! for record in reader.records() {\n//!     let rec = record.ok().expect(\"Error reading record.\");\n//!     println!(\"{}\", rec.seqname());\n//!     writer.write(\u0026rec).ok().expect(\"Error writing record.\");\n//! }\n//! ```\n\nuse anyhow::Context;\nuse itertools::Itertools;\nuse multimap::MultiMap;\nuse regex::Regex;\nuse std::convert::AsRef;\nuse std::fs;\nuse std::io;\nuse std::path::Path;\nuse std::str::FromStr;\n\nuse bio_types::strand::Strand;\n\n/// `GffType`\n///\n/// We have three format in the GFF family.\n/// The change is in the last field of GFF.\n/// For each type we have key value separator and field separator\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum GffType {\n    /// Attribute format is: key1=value; key2=value1,value2\n    GFF3,\n    /// Attribute format is: key1 value; key2 value1; key2 value2\n    GFF2,\n    /// Same as GFF2 just possible keyword and possible value change\n    GTF2,\n    /// Any, first field of tuple separates key from value,\n    /// second field separates multiple key value pairs, and\n    /// third field separates multiple values for the same key\n    Any(u8, u8, u8),\n}\n\nimpl FromStr for GffType {\n    type Err = String;\n\n    /// Create a GffType from a string.\n    ///\n    /// # Arguments\n    ///\n    /// * `src_str` - The source string to convert to the GffType.\n    fn from_str(src_str: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        match src_str {\n            \"gff3\" =\u003e Ok(GffType::GFF3),\n            \"gff2\" =\u003e Ok(GffType::GFF2),\n            \"gtf2\" =\u003e Ok(GffType::GTF2),\n            _ =\u003e Err(format!(\n                \"String '{}' is not a valid GFFType (GFF/GTF format version).\",\n                src_str\n            )),\n        }\n    }\n}\n\nimpl GffType {\n    #[inline]\n    /// First field is key value separator.\n    /// Second field terminates a key value pair.\n    /// Third field\n    fn separator(self) -\u003e (u8, u8, u8) {\n        match self {\n            GffType::GFF3 =\u003e (b'=', b';', b','),\n            GffType::GFF2 =\u003e (b' ', b';', 0u8),\n            GffType::GTF2 =\u003e (b' ', b';', 0u8),\n            GffType::Any(x, y, z) =\u003e (x, y, z),\n        }\n    }\n}\n\n/// A GFF reader.\n#[derive(Debug)]\npub struct Reader\u003cR: io::Read\u003e {\n    inner: csv::Reader\u003cR\u003e,\n    gff_type: GffType,\n}\n\nimpl Reader\u003cfs::File\u003e {\n    /// Read GFF from given file path in given format.\n    pub fn from_file\u003cP: AsRef\u003cPath\u003e + std::fmt::Debug\u003e(\n        path: P,\n        fileformat: GffType,\n    ) -\u003e anyhow::Result\u003cSelf\u003e {\n        fs::File::open(\u0026path)\n            .map(|f| Reader::new(f, fileformat))\n            .with_context(|| format!(\"Failed to read GFF from {:#?}\", path))\n    }\n}\n\nimpl\u003cR: io::Read\u003e Reader\u003cR\u003e {\n    /// Create a new GFF reader given an instance of `io::Read`, in given format.\n    pub fn new(reader: R, fileformat: GffType) -\u003e Self {\n        Reader {\n            inner: csv::ReaderBuilder::new()\n                .delimiter(b'\\t')\n                .has_headers(false)\n                .comment(Some(b'#'))\n                .from_reader(reader),\n            gff_type: fileformat,\n        }\n    }\n\n    /// Iterate over all records.\n    pub fn records(\u0026mut self) -\u003e Records\u003c'_, R\u003e {\n        let (delim, term, vdelim) = self.gff_type.separator();\n        let r = format!(\n            r\" *(?P\u003ckey\u003e[^{delim}{term}\\t]+){delim}(?P\u003cvalue\u003e[^{delim}{term}\\t]+){term}?\",\n            delim = delim as char,\n            term = term as char\n        );\n        let attribute_re = Regex::new(\u0026r).unwrap();\n        Records {\n            inner: self.inner.deserialize(),\n            attribute_re,\n            value_delim: vdelim as char,\n        }\n    }\n}\n\ntype GffRecordInner = (\n    String,\n    String,\n    String,\n    u64,\n    u64,\n    String,\n    String,\n    String,\n    String,\n);\n\n/// An iterator over the records of a GFF file.\npub struct Records\u003c'a, R: io::Read\u003e {\n    inner: csv::DeserializeRecordsIter\u003c'a, R, GffRecordInner\u003e,\n    attribute_re: Regex,\n    value_delim: char,\n}\n\nimpl\u003c'a, R: io::Read\u003e Iterator for Records\u003c'a, R\u003e {\n    type Item = csv::Result\u003cRecord\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003ccsv::Result\u003cRecord\u003e\u003e {\n        self.inner.next().map(|res| {\n            res.map(\n                |(\n                    seqname,\n                    source,\n                    feature_type,\n                    start,\n                    end,\n                    score,\n                    strand,\n                    frame,\n                    raw_attributes,\n                )| {\n                    let trim_quotes = |s: \u0026str| s.trim_matches('\\'').trim_matches('\"').to_owned();\n                    let mut attributes = MultiMap::new();\n                    for caps in self.attribute_re.captures_iter(\u0026raw_attributes) {\n                        for value in caps[\"value\"].split(self.value_delim) {\n                            attributes.insert(trim_quotes(\u0026caps[\"key\"]), trim_quotes(value));\n                        }\n                    }\n                    Record {\n                        seqname,\n                        source,\n                        feature_type,\n                        start,\n                        end,\n                        score,\n                        strand,\n                        frame,\n                        attributes,\n                    }\n                },\n            )\n        })\n    }\n}\n\n/// A GFF writer.\n#[derive(Debug)]\npub struct Writer\u003cW: io::Write\u003e {\n    inner: csv::Writer\u003cW\u003e,\n    delimiter: char,\n    terminator: String,\n}\n\nimpl Writer\u003cfs::File\u003e {\n    /// Write to a given file path in given format.\n    #[allow(clippy::wrong_self_convention)]\n    pub fn to_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P, fileformat: GffType) -\u003e io::Result\u003cSelf\u003e {\n        fs::File::create(path).map(|f| Writer::new(f, fileformat))\n    }\n}\n\nimpl\u003cW: io::Write\u003e Writer\u003cW\u003e {\n    /// Write to a given writer.\n    pub fn new(writer: W, fileformat: GffType) -\u003e Self {\n        let (delim, termi, _) = fileformat.separator();\n\n        Writer {\n            inner: csv::WriterBuilder::new()\n                .delimiter(b'\\t')\n                .flexible(true)\n                .from_writer(writer),\n            delimiter: delim as char,\n            terminator: String::from_utf8(vec![termi]).unwrap(),\n        }\n    }\n\n    /// Write a given GFF record.\n    pub fn write(\u0026mut self, record: \u0026Record) -\u003e csv::Result\u003c()\u003e {\n        let attributes = if !record.attributes.is_empty() {\n            record\n                .attributes\n                .iter()\n                .map(|(a, b)| format!(\"{}{}{}\", a, self.delimiter, b))\n                .join(\u0026self.terminator)\n        } else {\n            \"\".to_owned()\n        };\n\n        self.inner.serialize((\n            \u0026record.seqname,\n            \u0026record.source,\n            \u0026record.feature_type,\n            record.start,\n            record.end,\n            \u0026record.score,\n            \u0026record.strand,\n            \u0026record.frame,\n            attributes,\n        ))\n    }\n}\n\n/// A GFF record\n#[derive(Debug, Default, Serialize, Deserialize, Clone)]\npub struct Record {\n    seqname: String,\n    source: String,\n    feature_type: String,\n    start: u64,\n    end: u64,\n    score: String,\n    strand: String,\n    frame: String,\n    attributes: MultiMap\u003cString, String\u003e,\n}\n\nimpl Record {\n    /// Create a new GFF record.\n    pub fn new() -\u003e Self {\n        Record {\n            seqname: \"\".to_owned(),\n            source: \"\".to_owned(),\n            feature_type: \"\".to_owned(),\n            start: 0,\n            end: 0,\n            score: \".\".to_owned(),\n            strand: \".\".to_owned(),\n            frame: \"\".to_owned(),\n            attributes: MultiMap::\u003cString, String\u003e::new(),\n        }\n    }\n\n    /// Sequence name of the feature.\n    pub fn seqname(\u0026self) -\u003e \u0026str {\n        \u0026self.seqname\n    }\n\n    /// Source of the feature.\n    pub fn source(\u0026self) -\u003e \u0026str {\n        \u0026self.source\n    }\n\n    /// Type of the feature.\n    pub fn feature_type(\u0026self) -\u003e \u0026str {\n        \u0026self.feature_type\n    }\n\n    /// Start position of feature (1-based).\n    pub fn start(\u0026self) -\u003e \u0026u64 {\n        \u0026self.start\n    }\n\n    /// End position of feature (1-based, not included).\n    pub fn end(\u0026self) -\u003e \u0026u64 {\n        \u0026self.end\n    }\n\n    /// Score of feature\n    pub fn score(\u0026self) -\u003e Option\u003cu64\u003e {\n        match self.score.as_ref() {\n            \".\" =\u003e None,\n            _ =\u003e self.score.parse::\u003cu64\u003e().ok(),\n        }\n    }\n\n    /// Strand of the feature.\n    pub fn strand(\u0026self) -\u003e Option\u003cStrand\u003e {\n        match self.strand.as_ref() {\n            \"+\" =\u003e Some(Strand::Forward),\n            \"-\" =\u003e Some(Strand::Reverse),\n            _ =\u003e None,\n        }\n    }\n\n    /// Frame of the feature.\n    pub fn frame(\u0026self) -\u003e \u0026str {\n        \u0026self.frame\n    }\n\n    /// Attribute of feature\n    pub fn attributes(\u0026self) -\u003e \u0026MultiMap\u003cString, String\u003e {\n        \u0026self.attributes\n    }\n\n    /// Get mutable reference on seqname of feature.\n    pub fn seqname_mut(\u0026mut self) -\u003e \u0026mut String {\n        \u0026mut self.seqname\n    }\n\n    /// Get mutable reference on source of feature.\n    pub fn source_mut(\u0026mut self) -\u003e \u0026mut String {\n        \u0026mut self.source\n    }\n\n    /// Get mutable reference on type of feature.\n    pub fn feature_type_mut(\u0026mut self) -\u003e \u0026mut String {\n        \u0026mut self.feature_type\n    }\n\n    /// Get mutable reference on start of feature.\n    pub fn start_mut(\u0026mut self) -\u003e \u0026mut u64 {\n        \u0026mut self.start\n    }\n\n    /// Get mutable reference on end of feature.\n    pub fn end_mut(\u0026mut self) -\u003e \u0026mut u64 {\n        \u0026mut self.end\n    }\n\n    /// Get mutable reference on score of feature.\n    pub fn score_mut(\u0026mut self) -\u003e \u0026mut String {\n        \u0026mut self.score\n    }\n\n    /// Get mutable reference on strand of feature.\n    pub fn strand_mut(\u0026mut self) -\u003e \u0026mut String {\n        \u0026mut self.strand\n    }\n\n    /// Get mutable reference on frame of feature.\n    pub fn frame_mut(\u0026mut self) -\u003e \u0026mut String {\n        \u0026mut self.frame\n    }\n\n    /// Get mutable reference on attributes of feature.\n    pub fn attributes_mut(\u0026mut self) -\u003e \u0026mut MultiMap\u003cString, String\u003e {\n        \u0026mut self.attributes\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bio_types::strand::Strand;\n    use multimap::MultiMap;\n\n    const GFF_FILE: \u0026[u8] = b\"P0A7B8\\tUniProtKB\\tInitiator methionine\\t1\\t1\\t.\\t.\\t.\\t\\\nNote=Removed,Obsolete;ID=test\nP0A7B8\\tUniProtKB\\tChain\\t2\\t176\\t50\\t+\\t.\\tNote=ATP-dependent protease subunit HslV;\\\nID=PRO_0000148105\";\n    const GFF_FILE_WITH_COMMENT: \u0026[u8] = b\"#comment\nP0A7B8\\tUniProtKB\\tInitiator methionine\\t1\\t1\\t.\\t.\\t.\\t\\\nNote=Removed,Obsolete;ID=test\n#comment\nP0A7B8\\tUniProtKB\\tChain\\t2\\t176\\t50\\t+\\t.\\tNote=ATP-dependent protease subunit HslV;\\\nID=PRO_0000148105\";\n    //required because MultiMap iter on element randomly\n    const GFF_FILE_ONE_ATTRIB: \u0026[u8] =\n        b\"P0A7B8\\tUniProtKB\\tInitiator methionine\\t1\\t1\\t.\\t.\\t.\\tNote=Removed\nP0A7B8\\tUniProtKB\\tChain\\t2\\t176\\t50\\t+\\t.\\tID=PRO_0000148105\n\";\n\n    const GTF_FILE: \u0026[u8] =\n        b\"P0A7B8\\tUniProtKB\\tInitiator methionine\\t1\\t1\\t.\\t.\\t.\\tNote Removed;ID test\nP0A7B8\\tUniProtKB\\tChain\\t2\\t176\\t50\\t+\\t.\\tNote ATP-dependent;ID PRO_0000148105\n\";\n\n    // Another variant of GTF file, modified from a published GENCODE GTF file.\n    const GTF_FILE_2: \u0026[u8] = b\"chr1\\tHAVANA\\tgene\\t11869\\t14409\\t.\\t+\\t.\\t\\\ngene_id \\\"ENSG00000223972.5\\\"; gene_type \\\"transcribed_unprocessed_pseudogene\\\";\nchr1\\tHAVANA\\ttranscript\\t11869\\t14409\\t.\\t+\\t.\\tgene_id \\\"ENSG00000223972.5\\\";\\\ntranscript_id \\\"ENST00000456328.2\\\"; gene_type \\\"transcribed_unprocessed_pseudogene\\\"\";\n\n    // GTF file with duplicate attribute keys, taken from a published GENCODE GTF file.\n    const GTF_FILE_DUP_ATTR_KEYS: \u0026[u8] = b\"chr1\\tENSEMBL\\ttranscript\\t182393\\t\\\n184158\\t.\\t+\\t.\\tgene_id \\\"ENSG00000279928.1\\\"; transcript_id \\\"ENST00000624431.1\\\";\\\ngene_type \\\"protein_coding\\\"; gene_status \\\"KNOWN\\\"; gene_name \\\"FO538757.2\\\";\\\ntranscript_type \\\"protein_coding\\\"; transcript_status \\\"KNOWN\\\";\\\ntranscript_name \\\"FO538757.2-201\\\"; level 3; protein_id \\\"ENSP00000485457.1\\\";\\\ntranscript_support_level \\\"1\\\"; tag \\\"basic\\\"; tag \\\"appris_principal_1\\\";\";\n\n    //required because MultiMap iter on element randomly\n    const GTF_FILE_ONE_ATTRIB: \u0026[u8] =\n        b\"P0A7B8\\tUniProtKB\\tInitiator methionine\\t1\\t1\\t.\\t.\\t.\\tNote Removed\nP0A7B8\\tUniProtKB\\tChain\\t2\\t176\\t50\\t+\\t.\\tID PRO_0000148105\n\";\n\n    #[test]\n    fn test_reader_gff3() {\n        let seqname = [\"P0A7B8\", \"P0A7B8\"];\n        let source = [\"UniProtKB\", \"UniProtKB\"];\n        let feature_type = [\"Initiator methionine\", \"Chain\"];\n        let starts = [1, 2];\n        let ends = [1, 176];\n        let scores = [None, Some(50)];\n        let strand = [None, Some(Strand::Forward)];\n        let frame = [\".\", \".\"];\n        let mut attributes = [MultiMap::new(), MultiMap::new()];\n        attributes[0].insert(\"ID\".to_owned(), \"test\".to_owned());\n        attributes[0].insert(\"Note\".to_owned(), \"Removed\".to_owned());\n        attributes[0].insert(\"Note\".to_owned(), \"Obsolete\".to_owned());\n        attributes[1].insert(\"ID\".to_owned(), \"PRO_0000148105\".to_owned());\n        attributes[1].insert(\n            \"Note\".to_owned(),\n            \"ATP-dependent protease subunit HslV\".to_owned(),\n        );\n\n        let mut reader = Reader::new(GFF_FILE, GffType::GFF3);\n        for (i, r) in reader.records().enumerate() {\n            let record = r.unwrap();\n            assert_eq!(record.seqname(), seqname[i]);\n            assert_eq!(record.source(), source[i]);\n            assert_eq!(record.feature_type(), feature_type[i]);\n            assert_eq!(*record.start(), starts[i]);\n            assert_eq!(*record.end(), ends[i]);\n            assert_eq!(record.score(), scores[i]);\n            assert_eq!(record.strand(), strand[i]);\n            assert_eq!(record.frame(), frame[i]);\n            assert_eq!(record.attributes(), \u0026attributes[i]);\n        }\n\n        let mut reader = Reader::new(GFF_FILE_WITH_COMMENT, GffType::GFF3);\n        for (i, r) in reader.records().enumerate() {\n            let record = r.unwrap();\n            assert_eq!(record.seqname(), seqname[i]);\n            assert_eq!(record.source(), source[i]);\n            assert_eq!(record.feature_type(), feature_type[i]);\n            assert_eq!(*record.start(), starts[i]);\n            assert_eq!(*record.end(), ends[i]);\n            assert_eq!(record.score(), scores[i]);\n            assert_eq!(record.strand(), strand[i]);\n            assert_eq!(record.frame(), frame[i]);\n            assert_eq!(record.attributes(), \u0026attributes[i]);\n        }\n    }\n\n    #[test]\n    fn test_reader_from_file_path_doesnt_exist_returns_err() {\n        let path = Path::new(\"/I/dont/exist.gff\");\n        let error = Reader::from_file(path, GffType::GFF3)\n            .unwrap_err()\n            .downcast::\u003cString\u003e()\n            .unwrap();\n\n        assert_eq!(\u0026error, \"Failed to read GFF from \\\"/I/dont/exist.gff\\\"\")\n    }\n\n    #[test]\n    fn test_gff_type_from_str() {\n        let gff3 = GffType::from_str(\"gff3\").expect(\"Error parsing\");\n        assert_eq!(gff3, GffType::GFF3);\n\n        let gff2 = GffType::from_str(\"gff2\").expect(\"Error parsing\");\n        assert_eq!(gff2, GffType::GFF2);\n\n        let gtf2 = GffType::from_str(\"gtf2\").expect(\"Error parsing\");\n        assert_eq!(gtf2, GffType::GTF2);\n\n        let unk = GffType::from_str(\"unknown\").unwrap_err();\n        assert_eq!(\n            unk,\n            \"String 'unknown' is not a valid GFFType (GFF/GTF format version).\"\n        )\n    }\n\n    #[test]\n    fn test_reader_gtf2() {\n        let seqname = [\"P0A7B8\", \"P0A7B8\"];\n        let source = [\"UniProtKB\", \"UniProtKB\"];\n        let feature_type = [\"Initiator methionine\", \"Chain\"];\n        let starts = [1, 2];\n        let ends = [1, 176];\n        let scores = [None, Some(50)];\n        let strand = [None, Some(Strand::Forward)];\n        let frame = [\".\", \".\"];\n        let mut attributes = [MultiMap::new(), MultiMap::new()];\n        attributes[0].insert(\"ID\".to_owned(), \"test\".to_owned());\n        attributes[0].insert(\"Note\".to_owned(), \"Removed\".to_owned());\n        attributes[1].insert(\"ID\".to_owned(), \"PRO_0000148105\".to_owned());\n        attributes[1].insert(\"Note\".to_owned(), \"ATP-dependent\".to_owned());\n\n        let mut reader = Reader::new(GTF_FILE, GffType::GTF2);\n        for (i, r) in reader.records().enumerate() {\n            let record = r.unwrap();\n            assert_eq!(record.seqname(), seqname[i]);\n            assert_eq!(record.source(), source[i]);\n            assert_eq!(record.feature_type(), feature_type[i]);\n            assert_eq!(*record.start(), starts[i]);\n            assert_eq!(*record.end(), ends[i]);\n            assert_eq!(record.score(), scores[i]);\n            assert_eq!(record.strand(), strand[i]);\n            assert_eq!(record.frame(), frame[i]);\n            assert_eq!(record.attributes(), \u0026attributes[i]);\n        }\n    }\n\n    #[test]\n    fn test_reader_gtf2_2() {\n        let seqname = [\"chr1\", \"chr1\"];\n        let source = [\"HAVANA\", \"HAVANA\"];\n        let feature_type = [\"gene\", \"transcript\"];\n        let starts = [11869, 11869];\n        let ends = [14409, 14409];\n        let scores = [None, None];\n        let strand = [Some(Strand::Forward), Some(Strand::Forward)];\n        let frame = [\".\", \".\"];\n        let mut attributes = [MultiMap::new(), MultiMap::new()];\n        attributes[0].insert(\"gene_id\".to_owned(), \"ENSG00000223972.5\".to_owned());\n        attributes[0].insert(\n            \"gene_type\".to_owned(),\n            \"transcribed_unprocessed_pseudogene\".to_owned(),\n        );\n        attributes[1].insert(\"gene_id\".to_owned(), \"ENSG00000223972.5\".to_owned());\n        attributes[1].insert(\"transcript_id\".to_owned(), \"ENST00000456328.2\".to_owned());\n        attributes[1].insert(\n            \"gene_type\".to_owned(),\n            \"transcribed_unprocessed_pseudogene\".to_owned(),\n        );\n\n        let mut reader = Reader::new(GTF_FILE_2, GffType::GTF2);\n        for (i, r) in reader.records().enumerate() {\n            let record = r.unwrap();\n            assert_eq!(record.seqname(), seqname[i]);\n            assert_eq!(record.source(), source[i]);\n            assert_eq!(record.feature_type(), feature_type[i]);\n            assert_eq!(*record.start(), starts[i]);\n            assert_eq!(*record.end(), ends[i]);\n            assert_eq!(record.score(), scores[i]);\n            assert_eq!(record.strand(), strand[i]);\n            assert_eq!(record.frame(), frame[i]);\n            assert_eq!(record.attributes(), \u0026attributes[i]);\n        }\n    }\n\n    #[test]\n    fn test_reader_gtf2_dup_attr_keys() {\n        let mut reader = Reader::new(GTF_FILE_DUP_ATTR_KEYS, GffType::GTF2);\n        let mut records = reader.records().collect::\u003cVec\u003c_\u003e\u003e();\n        assert_eq!(records.len(), 1);\n        let record = records.pop().unwrap().expect(\"expected one record\");\n        assert_eq!(record.attributes.get(\"tag\"), Some(\u0026\"basic\".to_owned()));\n        assert_eq!(\n            record.attributes.get_vec(\"tag\"),\n            Some(\u0026vec![\"basic\".to_owned(), \"appris_principal_1\".to_owned()])\n        );\n    }\n\n    #[test]\n    fn test_writer_gff3() {\n        let mut reader = Reader::new(GFF_FILE_ONE_ATTRIB, GffType::GFF3);\n        let mut writer = Writer::new(vec![], GffType::GFF3);\n        for r in reader.records() {\n            writer\n                .write(\u0026r.expect(\"Error reading record\"))\n                .expect(\"Error writing record\");\n        }\n        assert_eq!(writer.inner.into_inner().unwrap(), GFF_FILE_ONE_ATTRIB)\n    }\n\n    #[test]\n    fn test_writer_gtf2() {\n        let mut reader = Reader::new(GTF_FILE_ONE_ATTRIB, GffType::GTF2);\n        let mut writer = Writer::new(vec![], GffType::GTF2);\n        for r in reader.records() {\n            writer\n                .write(\u0026r.expect(\"Error reading record\"))\n                .expect(\"Error writing record\");\n        }\n        assert_eq!(writer.inner.into_inner().unwrap(), GTF_FILE_ONE_ATTRIB)\n    }\n\n    #[test]\n    fn test_convert_gtf2_to_gff3() {\n        let mut reader = Reader::new(GTF_FILE_ONE_ATTRIB, GffType::GTF2);\n        let mut writer = Writer::new(vec![], GffType::GFF3);\n        for r in reader.records() {\n            writer\n                .write(\u0026r.expect(\"Error reading record\"))\n                .expect(\"Error writing record\");\n        }\n        assert_eq!(writer.inner.into_inner().unwrap(), GFF_FILE_ONE_ATTRIB)\n    }\n\n    #[test]\n    fn test_unknown_gff_type() {\n        assert_eq!(\n            GffType::from_str(\"xtf9\"),\n            Err(\"String 'xtf9' is not a valid GFFType (GFF/GTF format version).\".to_string())\n        )\n    }\n}\n","traces":[{"line":66,"address":[8160032],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":67,"address":[8160314,8160229,8160475,8160470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[8160059,8160138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[8160170,8160214,8160100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[8160299,8160176,8160235],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[8160328,8160241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[8160480],"length":1,"stats":{"Line":0},"fn_name":"separator"},{"line":85,"address":[8160542,8160559,8160525,8160576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[8160527,8160496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[8160544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[8160561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[8160578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[4752721,4752528],"length":1,"stats":{"Line":0},"fn_name":"from_file\u003c\u0026std::path::Path\u003e"},{"line":107,"address":[4752699,4752609,4752629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[4752752,4752784,4752621],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003c\u0026std::path::Path\u003e"},{"line":109,"address":[4752691,4752816,4752838],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003c\u0026std::path::Path\u003e"},{"line":115,"address":[4753412,4753855,4753440,4752976],"length":1,"stats":{"Line":0},"fn_name":"new\u003cstd::fs::File\u003e"},{"line":117,"address":[4753509,4753763,4753124,4753261,4753622,4753011,4753702,4753204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[4754623,4753872],"length":1,"stats":{"Line":0},"fn_name":"records\u003c\u0026[u8]\u003e"},{"line":128,"address":[4753902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[4754023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[4754003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[4754013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[4754311,4754404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[4754485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[4754517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[4754656],"length":1,"stats":{"Line":0},"fn_name":"next\u003c\u0026[u8]\u003e"},{"line":166,"address":[4754678,4757344],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003c\u0026[u8]\u003e"},{"line":167,"address":[4757420,4757387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[4754896,4757307,4757412],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003c\u0026[u8]\u003e"},{"line":169,"address":[4754934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[4755029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[4755061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[4755093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[4755113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[4755133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[4755165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[4755200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[4755238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[4754807,4754752],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003c\u0026[u8]\u003e"},{"line":180,"address":[4755276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[4755387,4755584,4755460,4755616,4755288,4756499],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[4755824,4755976,4756117,4756467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[4756472,4756191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[4756848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[4756560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[4756600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[4756640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[4756680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[4756720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[4756760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[4756800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[4757456,4758039],"length":1,"stats":{"Line":0},"fn_name":"new\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":222,"address":[4757492],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[4757787,4757672,4757612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[4757798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[4757815,4757912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[4758080],"length":1,"stats":{"Line":0},"fn_name":"write\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":236,"address":[4758119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[4758206,4758269,4758173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[4758193,4758528,4758569],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":241,"address":[4758232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[4758145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[4758378,4758289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[4758294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[4758297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[4758304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[4758311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[4758315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[4758319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[4758326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[4758333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[4758339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[8161279,8160640,8161294],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":278,"address":[8160657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[8160678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[8160701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[8160762],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[8160821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[8160880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[8160949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[8161296],"length":1,"stats":{"Line":0},"fn_name":"seqname"},{"line":292,"address":[8161305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[8161344],"length":1,"stats":{"Line":0},"fn_name":"source"},{"line":297,"address":[8161353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[8161392],"length":1,"stats":{"Line":0},"fn_name":"feature_type"},{"line":302,"address":[8161401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[8161440],"length":1,"stats":{"Line":0},"fn_name":"start"},{"line":307,"address":[8161448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[8161456],"length":1,"stats":{"Line":0},"fn_name":"end"},{"line":312,"address":[8161464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[8161472],"length":1,"stats":{"Line":0},"fn_name":"score"},{"line":317,"address":[8161486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[8161515,8161571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[8161604,8161674,8161551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[8161680],"length":1,"stats":{"Line":0},"fn_name":"strand"},{"line":325,"address":[8161818,8161689,8161811,8161820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[8161782,8161718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[8161759,8161813,8161800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[8161806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[8161824],"length":1,"stats":{"Line":0},"fn_name":"frame"},{"line":334,"address":[8161833],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[8161872],"length":1,"stats":{"Line":0},"fn_name":"attributes"},{"line":339,"address":[8161880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[8161888],"length":1,"stats":{"Line":0},"fn_name":"seqname_mut"},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[8161904],"length":1,"stats":{"Line":0},"fn_name":"source_mut"},{"line":349,"address":[8161912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[8161920],"length":1,"stats":{"Line":0},"fn_name":"feature_type_mut"},{"line":354,"address":[8161928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[8161936],"length":1,"stats":{"Line":0},"fn_name":"start_mut"},{"line":359,"address":[8161944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[8161952],"length":1,"stats":{"Line":0},"fn_name":"end_mut"},{"line":364,"address":[8161960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[8161968],"length":1,"stats":{"Line":0},"fn_name":"score_mut"},{"line":369,"address":[8161976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[8161984],"length":1,"stats":{"Line":0},"fn_name":"strand_mut"},{"line":374,"address":[8161992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[8162000],"length":1,"stats":{"Line":0},"fn_name":"frame_mut"},{"line":379,"address":[8162008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[8162016],"length":1,"stats":{"Line":0},"fn_name":"attributes_mut"},{"line":384,"address":[8162024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[5921136,5921817],"length":1,"stats":{"Line":0},"fn_name":"test_reader_gff3"},{"line":437,"address":[5921149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[5921259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[5921313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[5921367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[5921391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[5921415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[5921515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[5921559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[5921613,5921780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[5921832,5922028,5921753,5921912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[5922209,5922047,5922001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[5922228,5922390,5922182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[5922409,5922347,5922571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[5922633,5922528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[5922544,5922590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[5922598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[5922709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[5926031,5922872,5922786,5922993,5923073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[5923278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[5923654,5923318,5923451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[5923963,5923722,5923609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[5924264,5924034,5923918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[5924230,5924319,5924520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[5924792,5924486,5924580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[5924868,5924747,5925096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[5925382,5925158,5925064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[5925683,5925337,5925453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[5925649,5925976,5925746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[5926073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[5926338,5926418,5926131,5929273,5926217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[5926623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[5927000,5926796,5926663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[5927071,5926955,5927312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[5927267,5927383,5927613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[5927869,5927579,5927668],"length":1,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[5927929,5927835,5928138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[5928211,5928096,5928418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[5928477,5928677,5928395],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[5928951,5928742,5928644],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[5929011,5929218,5928926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[5929735,5929376],"length":1,"stats":{"Line":0},"fn_name":"test_reader_from_file_path_doesnt_exist_returns_err"},{"line":486,"address":[5929383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[5929436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[5929525,5929689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[5929760,5930692],"length":1,"stats":{"Line":0},"fn_name":"test_gff_type_from_str"},{"line":497,"address":[5929767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[5929962,5929836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[5929925,5930006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[5930188,5930059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[5930232,5930151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[5930414,5930285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[5930458,5930377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[5930494,5930646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[5930720,5931379],"length":1,"stats":{"Line":0},"fn_name":"test_reader_gtf2"},{"line":515,"address":[5930727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[5930821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[5930875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[5930929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[5930953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[5930977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[5931077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[5931121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[5931342,5931175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[5931474,5931590,5931315,5931394],"length":1,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[5931609,5931563,5931771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[5931790,5931952,5931728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[5931909,5932132,5931971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[5932090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[5935313,5932167,5932253,5932374,5932454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[5932659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[5932699,5933035,5932832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[5932990,5933344,5933103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[5933299,5933645,5933415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[5933611,5933700,5933901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[5933961,5934173,5933867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[5934128,5934456,5934249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[5934433,5934715,5934515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[5934989,5934780,5934682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[5935049,5935258,5934964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[5935392,5936047],"length":1,"stats":{"Line":0},"fn_name":"test_reader_gtf2_2"},{"line":546,"address":[5935399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[5935501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[5935555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[5935609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[5935633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[5935657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[5935745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[5935789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[5936010,5935843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[5936062,5936258,5935983,5936142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[5936320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[5936277,5936231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[5936285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[5936396,5936620,5936458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[5936577,5936639,5936801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[5936758,5936863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[5936774,5936820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[5936828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[5936939],"length":1,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[5940154,5937223,5937016,5937102,5937303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[5937508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[5937681,5937548,5937884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[5937952,5938193,5937839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[5938148,5938494,5938264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[5938460,5938549,5938750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[5938810,5938716,5939019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[5938977,5939092,5939299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[5939358,5939276,5939558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[5939525,5939623,5939832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[5939807,5940099,5939892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[5940240,5941577],"length":1,"stats":{"Line":0},"fn_name":"test_reader_gtf2_dup_attr_keys"},{"line":584,"address":[5940247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[5940297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[5940561,5940372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[5940544,5940612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[5940684,5940807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[5941327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[5941031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[5941089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[5941600,5942590],"length":1,"stats":{"Line":0},"fn_name":"test_writer_gff3"},{"line":597,"address":[5941607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[5941660,5941754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[5941960,5942031,5942333,5941846,5941775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[5942224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":601,"address":[5942167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[5942690,5942609,5942371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[5942864,5943854],"length":1,"stats":{"Line":0},"fn_name":"test_writer_gtf2"},{"line":609,"address":[5942871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[5942924,5943018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[5943597,5943295,5943224,5943039,5943110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[5943488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[5943431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[5943873,5943635,5943954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[5945118,5944128],"length":1,"stats":{"Line":0},"fn_name":"test_convert_gtf2_to_gff3"},{"line":621,"address":[5944135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[5944188,5944282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[5944303,5944374,5944861,5944559,5944488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":624,"address":[5944752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":625,"address":[5944695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[5945218,5944899,5945137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":632,"address":[5945700,5945392],"length":1,"stats":{"Line":0},"fn_name":"test_unknown_gff_type"},{"line":633,"address":[5945475,5945579,5945642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[5945399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[5945421],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":275},{"path":["/","home","todd","rust-bio","src","io","mod.rs"],"content":"//! Readers and writers for common bioinformatics file formats.\n\npub mod bed;\npub mod fasta;\npub mod fastq;\npub mod fastx;\npub mod gff;\n#[cfg(feature = \"phylogeny\")]\npub mod newick;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","io","newick.rs"],"content":"// Copyright 2020 Franklin Delehelle.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A struct to read phylogenetic trees in the Newick format.\n//!\n//!  # Example\n//!\n//!  In this example, we parse a tree from a string and display all the taxons.\n//!  See `petgraph` documentation for more details on how to handle the tree.\n//!\n//!  ```\n//!  use bio::io::newick;\n//!\n//!  let tree = newick::from_string(\"(A:0.1,B:0.2,(C:0.3,D:0.4)E:0.5)F;\").unwrap();\n//!  for taxon in tree.raw_nodes() {\n//!      println!(\"{}\", taxon.weight);\n//!  }\n//!  ```\n\nuse bio_types::phylogeny::{Tree, TreeGraph};\nuse pest::iterators::Pair;\nuse pest::Parser;\nuse petgraph::graph::NodeIndex;\nuse std::fs;\nuse std::io;\nuse std::path::{Path, PathBuf};\nuse thiserror::Error;\n\n/// A `thiserror` error type gathering all the potential bad outcomes\n#[derive(Debug, Error)]\npub enum Error {\n    #[error(\"Error while opening {}: {}\", filename.display(), source)]\n    OpenFile {\n        filename: PathBuf,\n        source: std::io::Error,\n    },\n\n    #[error(\"Error while reading tree: {0}\")]\n    Read(#[from] std::io::Error),\n\n    #[error(\"Tree contains invalid UTF-8: {0}\")]\n    InvalidContent(#[from] std::str::Utf8Error),\n\n    #[error(\"Error while parsing tree: {0}\")]\n    ParsingError(#[from] pest::error::Error\u003ccrate::io::newick::Rule\u003e),\n}\ntype Result\u003cT, E = Error\u003e = std::result::Result\u003cT, E\u003e;\n\n/// The parser is automagically derived from the `newick.pest` grammar\n/// file\n#[derive(Parser)]\n#[grammar = \"io/newick.pest\"]\npub struct NewickParser;\n\n/// A hidden, temporary datatype used to collect the parser result\n/// before converting it to a `Tree`\nenum TreeValue {\n    Node {\n        name: Option\u003cString\u003e,\n        children: Option\u003cVec\u003cTreeValue\u003e\u003e,\n    },\n    Link {\n        weight: f32,\n        node: Box\u003cTreeValue\u003e,\n    },\n}\n\n/// Given a string representing a Newick tree, tries to parse it and\n/// returns the `TreeValue` of the root\nfn parse_newick_file(content: \u0026str) -\u003e Result\u003cTreeValue\u003e {\n    fn parse_value(pair: Pair\u003cRule\u003e) -\u003e TreeValue {\n        match pair.as_rule() {\n            Rule::Leaf =\u003e {\n                let name = pair.into_inner().next().unwrap().as_str();\n                TreeValue::Node {\n                    name: Some(name.into()),\n                    children: None,\n                }\n            }\n            Rule::Internal =\u003e {\n                let mut inner_rules = pair.into_inner();\n                let children = Some(\n                    inner_rules\n                        .next()\n                        .unwrap()\n                        .into_inner()\n                        .map(parse_value)\n                        .collect(),\n                );\n                let name = if let Some(clade) = inner_rules.next() {\n                    Some(clade.as_str().into())\n                } else {\n                    None\n                };\n                TreeValue::Node { children, name }\n            }\n\n            Rule::Branch =\u003e {\n                fn get_weight(mut inner: pest::iterators::Pairs\u003cRule\u003e) -\u003e f32 {\n                    if let Some(weight) = inner.next() {\n                        weight.as_str().parse::\u003cf32\u003e().unwrap()\n                    } else {\n                        f32::NAN\n                    }\n                }\n\n                let mut inner = pair.into_inner();\n                let (node, weight) = if let Some(next) = inner.next() {\n                    match next.as_rule() {\n                        Rule::SubTree =\u003e (parse_value(next), get_weight(inner)),\n                        _ =\u003e (\n                            TreeValue::Node {\n                                name: None,\n                                children: None,\n                            },\n                            next.as_str().parse::\u003cf32\u003e().unwrap(),\n                        ),\n                    }\n                } else {\n                    (\n                        TreeValue::Node {\n                            name: None,\n                            children: None,\n                        },\n                        get_weight(inner),\n                    )\n                };\n\n                TreeValue::Link {\n                    weight,\n                    node: Box::new(node),\n                }\n            }\n\n            Rule::SubTree =\u003e parse_value(pair.into_inner().next().unwrap()),\n            Rule::EOI\n            | Rule::WHITESPACE\n            | Rule::Tree\n            | Rule::Length\n            | Rule::BranchSet\n            | Rule::float\n            | Rule::safe\n            | Rule::name =\u003e unreachable!(),\n        }\n    }\n\n    let root = NewickParser::parse(Rule::Tree, \u0026content)\n        .map_err(Error::ParsingError)?\n        .next()\n        .unwrap();\n\n    Ok(parse_value(root))\n}\n\n/// Convert an intermediary `TreeValue` to the public `Tree` type\nfn newick_to_graph(root: TreeValue) -\u003e Result\u003cTree\u003e {\n    fn add_node(g: \u0026mut TreeGraph, t: TreeValue) -\u003e NodeIndex {\n        match t {\n            TreeValue::Node { name, children } =\u003e {\n                let node_id = g.add_node(name.unwrap_or(\"N/A\".into()).into());\n                if let Some(children) = children {\n                    for child in children {\n                        match child {\n                            TreeValue::Node { .. } =\u003e unimplemented!(),\n                            TreeValue::Link { weight, node } =\u003e {\n                                let child_id = add_node(g, *node);\n                                g.add_edge(node_id, child_id, weight);\n                            }\n                        }\n                    }\n                };\n                node_id\n            }\n            TreeValue::Link { .. } =\u003e unreachable!(),\n        }\n    }\n\n    let mut g = TreeGraph::new();\n    add_node(\u0026mut g, root);\n\n    Ok(Tree { g })\n}\n\n/// Reads a tree from an `\u0026str`-compatible type\npub fn from_string\u003cS: AsRef\u003cstr\u003e\u003e(content: S) -\u003e Result\u003cTree\u003e {\n    let raw_tree = parse_newick_file(content.as_ref())?;\n    newick_to_graph(raw_tree)\n}\n\n/// Reads a tree from a file\npub fn from_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e Result\u003cTree\u003e {\n    fs::File::open(\u0026path)\n        .map(read)\n        .map_err(|e| Error::OpenFile {\n            filename: path.as_ref().to_owned(),\n            source: e,\n        })?\n}\n\n/// Reads a tree from any type implementing `io::Read`\npub fn read\u003cR: io::Read\u003e(reader: R) -\u003e Result\u003cTree\u003e {\n    let content_bytes = reader\n        .bytes()\n        .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n        .map_err(Error::Read)?;\n    let content_str = std::str::from_utf8(\u0026content_bytes).map_err(Error::InvalidContent)?;\n    from_string(\u0026content_str)\n}\n","traces":[{"line":72,"address":[6402432,6402845],"length":1,"stats":{"Line":0},"fn_name":"parse_newick_file"},{"line":73,"address":[6406486,6403040],"length":1,"stats":{"Line":0},"fn_name":"parse_value"},{"line":74,"address":[6405132,6403076,6406345,6403237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[6403162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[6405956,6403339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[6406192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[6403401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[6405274,6405181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[6405458,6405375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[6405638,6405506,6405594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[6405529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[6406528,6406926],"length":1,"stats":{"Line":0},"fn_name":"get_weight"},{"line":102,"address":[6406543,6406627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[6406657,6406736,6406790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[6406680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[6403463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[6403625,6404716,6403914,6403988,6403541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[6404085,6404645,6403681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[6404149,6404527,6404092,6404650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[6404467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[6404239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[6404215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[6404227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[6404322,6404415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[6403721],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[6403697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[6403709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[6403796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[6405028,6404830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[6406366,6403277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[6402564,6402767,6402733,6402458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[6402547,6402673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[6402860,6402957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[6407258,6406960],"length":1,"stats":{"Line":0},"fn_name":"newick_to_graph"},{"line":159,"address":[6407296,6408800],"length":1,"stats":{"Line":0},"fn_name":"add_node"},{"line":160,"address":[6407356],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[6407321,6407363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[6407677,6407407,6407544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[6407861,6407749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[6407806,6408633,6407895,6408045,6408073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[6408361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[6408401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[6408446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[6408540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[6406982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[6407015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[6407119],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":47},{"path":["/","home","todd","rust-bio","src","lib.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n#![doc(\n    html_logo_url = \"https://raw.githubusercontent.com/rust-bio/rust-bio/master/img/bioferris.svg\",\n    html_favicon_url = \"https://raw.githubusercontent.com/rust-bio/rust-bio/master/img/bioferris.svg\"\n)]\n\n//! # Rust-bio, a bioinformatics library for Rust.\n//! This library provides implementations of many algorithms and data structures\n//! that are useful for bioinformatics.\n//! All provided implementations are rigorously tested via continuous\n//! integration.\n//!\n//! For **getting started** with using `rust-bio`, see [the `Getting started` section below](#getting-started).\n//! For navigating the documentation of the available modules, see [the `Modules` section below](#modules).\n//! If you want to contribute to `rust-bio`, see [the `Contribute` section in the repo](https://github.com/rust-bio/rust-bio#contribute).\n//!\n//! Currently, rust-bio provides\n//!\n//! * most major pattern matching algorithms,\n//! * a convenient alphabet implementation,\n//! * pairwise alignment,\n//! * suffix arrays,\n//! * the [Burrows-Wheeler-transform (BWT)]()\n//! * the [Full-text index in Minute space index (FM-index)](https://doi.org/10.1109/SFCS.2000.892127),\n//! * FMD-Index for finding supermaximal exact matches,\n//! * a q-gram index,\n//! * utilities to work with [PSSMs](https://en.wikipedia.org/wiki/Position_weight_matrix),\n//! * an open reading frame (ORF) search algorithm,\n//! * a rank/select data structure,\n//! * [serde](https://github.com/serde-rs/serde) support for all data structures when built with `nightly` feature,\n//! * readers and writers for FASTQ, FASTA and BED,\n//! * helper functions for combinatorics and dealing with log probabilities,\n//! * an implementation of the Hidden Markov Model and related algorithms.\n//!\n//! For reading and writing SAM/BAM/CRAM, VCF/BCF files or tabix indexed files, have a look at [rust-htslib](https://docs.rs/rust-htslib).\n//!\n//! # Getting started\n//!\n//! We explain how to use Rust-Bio step-by-step.\n//! Users who already have experience with Rust can skip right to [Step 3: Use Rust-Bio in your project](https://docs.rs/bio/#step-3-use-rust-bio-in-your-project).\n//! Users who already know `rust-bio` might want to jump right into the [modules docs](https://docs.rs/bio/#modules)\n//!\n//! ## Step 1: Setting up Rust\n//!\n//! Rust can be installed following the instruction for [rustup](https://rustup.rs/).\n//!\n//!\n//! ## Step 2: Setting up a new Rust project\n//!\n//! Since Rust-Bio is a library, you need to setup your own new Rust project to use Rust-Bio.\n//! With Rust, projects and their dependencies are managed with the builtin package manager [Cargo](https://doc.rust-lang.org/cargo/index.html).\n//! To create a new Rust project, issue\n//!\n//! ```bash\n//! cargo new hello_world --bin\n//! cd hello_world\n//! ```\n//! in your terminal. The flag `--bin` tells Cargo to create an executable project instead of a library.\n//! In [this section](https://doc.rust-lang.org/nightly/book/hello-cargo.html#a-new-project) of the Rust docs, you find details about what Cargo just created for you.\n//!\n//! Your new project can be compiled with\n//! ```bash\n//! cargo build\n//! ```\n//! If dependencies in your project are out of date, update with\n//! ```bash\n//! cargo update\n//! ```\n//! Execute the compiled code with\n//! ```bash\n//! cargo run\n//! ```\n//! If you are new to Rust, we suggest to proceed with [learning Rust](https://www.rust-lang.org/learn) via the Rust docs.\n//!\n//! ## Step 3: Use Rust-Bio in your project\n//!\n//! To use Rust-Bio in your Rust project, add the following to your `Cargo.toml`\n//!\n//! ```toml\n//! [dependencies]\n//! bio = \"*\"\n//! ```\n//!\n//! and import the crate from your source code:\n//!\n//! ```rust\n//! extern crate bio;\n//! ```\n//!\n//! ## Example: FM-index and FASTQ\n//!\n//! An example of using `rust-bio`:\n//!\n//! ```rust\n//! // Import some modules\n//! use bio::alphabets;\n//! use bio::data_structures::bwt::{bwt, less, Occ};\n//! use bio::data_structures::fmindex::{FMIndex, FMIndexable};\n//! use bio::data_structures::suffix_array::suffix_array;\n//! use bio::io::fastq;\n//! use bio::io::fastq::FastqRead;\n//! use std::io;\n//!\n//! // a given text\n//! let text = b\"ACAGCTCGATCGGTA$\";\n//! let pattern = b\"ATCG\";\n//!\n//! // Create an FM-Index for the given text.\n//!\n//! // instantiate an alphabet\n//! let alphabet = alphabets::dna::iupac_alphabet();\n//! // calculate a suffix array\n//! let sa = suffix_array(text);\n//! // calculate the Burrows-Wheeler-transform\n//! let bwt = bwt(text, \u0026sa);\n//! // calculate the vectors less and Occ (occurrences)\n//! let less = less(\u0026bwt, \u0026alphabet);\n//! let occ = Occ::new(\u0026bwt, 3, \u0026alphabet);\n//! // set up FMIndex\n//! let fmindex = FMIndex::new(\u0026bwt, \u0026less, \u0026occ);\n//! // do a backwards search for the pattern\n//! let interval = fmindex.backward_search(pattern.iter());\n//! let positions = interval.occ(\u0026sa);\n//!\n//! // Iterate over a FASTQ file, use the alphabet to validate read\n//! // sequences and search for exact matches in the FM-Index.\n//!\n//! // create FASTQ reader\n//! let mut reader = fastq::Reader::new(io::stdin());\n//! let mut record = fastq::Record::new();\n//! reader.read(\u0026mut record).expect(\"Failed to parse record\");\n//! while !record.is_empty() {\n//!     let check = record.check();\n//!     if check.is_err() {\n//!         panic!(\"I got a rubbish record!\")\n//!     }\n//!     // obtain sequence\n//!     let seq = record.seq();\n//!     // check, whether seq is in the expected alphabet\n//!     if alphabet.is_word(seq) {\n//!         let interval = fmindex.backward_search(seq.iter());\n//!         let positions = interval.occ(\u0026positions);\n//!     }\n//!     reader.read(\u0026mut record).expect(\"Failed to parse record\");\n//! }\n//! ```\n//!\n//! Documentation and further examples for each module can be found in the module descriptions below.\n//!\n//!\n//! ## Example: Multithreaded\n//!\n//! ```rust\n//! use bio::alphabets;\n//! use bio::data_structures::bwt::{bwt, less, Occ};\n//! use bio::data_structures::fmindex::{FMIndex, FMIndexable};\n//! use bio::data_structures::suffix_array::suffix_array;\n//! use std::sync::Arc;\n//! use std::thread;\n//!\n//! let text = b\"ACGGATGCTGGATCGGATCGCGCTAGCTA$\";\n//! let patterns = vec![b\"ACCG\", b\"TGCT\"];\n//!\n//! // Create an FM-Index for a given text.\n//! let alphabet = alphabets::dna::iupac_alphabet();\n//! let sa = suffix_array(text);\n//! let bwt = Arc::new(bwt(text, \u0026sa));\n//! let less = Arc::new(less(bwt.as_ref(), \u0026alphabet));\n//! let occ = Arc::new(Occ::new(bwt.as_ref(), 3, \u0026alphabet));\n//! let fmindex = Arc::new(FMIndex::new(bwt, less, occ));\n//!\n//! // Spawn threads to perform backward searches for each interval\n//! let interval_calculators = patterns\n//!     .into_iter()\n//!     .map(|pattern| {\n//!         let fmindex = fmindex.clone();\n//!         thread::spawn(move || fmindex.backward_search(pattern.iter()))\n//!     })\n//!     .collect::\u003cVec\u003c_\u003e\u003e();\n//!\n//! // Loop through the results, extracting the positions array for each pattern\n//! for interval_calculator in interval_calculators {\n//!     let positions = interval_calculator.join().unwrap().occ(\u0026sa);\n//! }\n//! ```\n//!\n//! Documentation and further examples for each module can be found in the module descriptions below.\n//!\n//! # Benchmarks\n//!\n//! Since Rust-Bio is based on a compiled language, similar performance to C/C++ based libraries can be expected. Indeed, we find the pattern matching algorithms of Rust-Bio to perform in the range of the C++ library Seqan:\n//!\n//! | Algorithm | Rust-Bio | Seqan   |\n//! | --------- | -------: | ------: |\n//! | BNDM      | 77ms     | 80ms    |\n//! | Horspool  | 122ms    | 125ms   |\n//! | BOM       | 103ms    | 107ms   |\n//! | Shift-And | 241ms    | 545ms   |\n//!\n//! We measured 10000 iterations of searching pattern `GCGCGTACACACCGCCCG` in the sequence of the hg38 MT chromosome.\n//! Initialization time of each algorithm for the given pattern was included in each iteration. Benchmarks were conducted with *Cargo bench* for Rust-Bio and *Python timeit* for Seqan on an Intel Core i5-3427U CPU.\n//! Benchmarking Seqan from *Python timeit* entails an overhead of 1.46ms for calling a C++ binary. This overhead was subtracted from above Seqan run times.\n//! Note that this benchmark only compares the two libraries to exemplify that Rust-Bio has comparable speed to C++ libraries: all used algorithms have their advantages for specific text and pattern structures and lengths (see [the pattern matching section in the documentation](https://docs.rs/bio/0.28.2/bio/pattern_matching/index.html))./!\n\n#[macro_use]\nextern crate approx;\n\n#[macro_use]\nextern crate custom_derive;\n\n#[macro_use]\nextern crate lazy_static;\n\n#[macro_use]\nextern crate newtype_derive;\n\n#[macro_use]\nextern crate serde_derive;\n\n#[macro_use]\nextern crate strum_macros;\n\n#[macro_use]\nextern crate getset;\n\n#[cfg(feature = \"phylogeny\")]\n#[macro_use]\nextern crate pest_derive;\n\npub mod alignment;\npub mod alphabets;\npub mod data_structures;\npub mod io;\npub mod pattern_matching;\npub mod scores;\npub mod seq_analysis;\npub mod stats;\npub mod utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","pattern_matching","bndm.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Backward nondeterministic DAWG matching (BNDM).\n//! Best-case complexity: O(n / m) with pattern of length m \u003c= 64 and text of length n.\n//! Worst case complexity: O(n * m).\n//!\n//! # Example\n//!\n//! ```\n//! use bio::pattern_matching::bndm;\n//! let pattern = b\"GAAAA\";\n//! let text = b\"ACGGCTAGAAAAGGCTAGAAAA\";\n//! let bndm = bndm::BNDM::new(pattern);\n//! let occ: Vec\u003cusize\u003e = bndm.find_all(text).collect();\n//! assert_eq!(occ, [7, 17]);\n//! ```\n\nuse crate::pattern_matching::shift_and::masks;\nuse crate::utils::TextSlice;\nuse std::borrow::Borrow;\n\n/// BNDM algorithm.\npub struct BNDM {\n    m: usize,\n    masks: [u64; 256],\n    accept: u64,\n}\n\nimpl BNDM {\n    /// Create a new instance for a given pattern.\n    pub fn new\u003cC, P\u003e(pattern: P) -\u003e Self\n    where\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: DoubleEndedIterator + ExactSizeIterator,\n    {\n        let pattern = pattern.into_iter();\n        let m = pattern.len();\n        assert!(m \u003c= 64, \"Expecting a pattern of at most 64 symbols.\");\n        // take the reverse pattern and build nondeterministic\n        // suffix automaton\n        let (masks, accept) = masks(pattern.rev());\n\n        BNDM { m, masks, accept }\n    }\n\n    /// Find all matches of pattern with a given text. Matches are returned as iterator over start positions.\n    pub fn find_all\u003c'a\u003e(\u0026'a self, text: TextSlice\u003c'a\u003e) -\u003e Matches\u003c'_\u003e {\n        Matches {\n            bndm: self,\n            window: self.m,\n            text,\n        }\n    }\n}\n\n/// Iterator over start positions of matches.\npub struct Matches\u003c'a\u003e {\n    bndm: \u0026'a BNDM,\n    window: usize,\n    text: TextSlice\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e Iterator for Matches\u003c'a\u003e {\n    type Item = usize;\n\n    fn next(\u0026mut self) -\u003e Option\u003cusize\u003e {\n        while self.window \u003c= self.text.len() {\n            let mut occ = None;\n            // bit mask of ones, all states active\n            let mut active = (1u64 \u003c\u003c self.bndm.m) - 1;\n            let (mut j, mut lastsuffix) = (1, 0);\n            // while not in fail state\n            while active != 0 {\n                // process j-th symbol from right\n                active \u0026= self.bndm.masks[self.text[self.window - j] as usize];\n                if active \u0026 self.bndm.accept != 0 {\n                    // reached accepting state\n                    if j == self.bndm.m {\n                        occ = Some(self.window - self.bndm.m);\n                        break;\n                    } else {\n                        // we reached the accepting state\n                        // but not the end of the pattern\n                        // hence, a suffix of the reverse pattern\n                        // i.e. a prefix of the pattern of\n                        // length j matches\n                        // in case of a mismatch, we can shift\n                        // to this prefix\n                        lastsuffix = j;\n                    }\n                }\n                j += 1;\n                active \u003c\u003c= 1;\n            }\n            // shift the window\n            self.window += self.bndm.m - lastsuffix;\n            if occ.is_some() {\n                return occ;\n            }\n        }\n\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use itertools::Itertools;\n\n    #[test]\n    fn test_find_all() {\n        let text = b\"dhjalkjwqnnnannanaflkjdklfj\";\n        let pattern = b\"qnnnannan\";\n        let bndm = BNDM::new(pattern);\n        assert_eq!(bndm.find_all(text).collect_vec(), [8]);\n    }\n\n    #[test]\n    fn test_find_all_at_start() {\n        let text = b\"dhjalkjwqnnnannanaflkjdklfj\";\n        let pattern = b\"dhjalk\";\n        let bndm = BNDM::new(pattern);\n        assert_eq!(bndm.find_all(text).collect_vec(), [0]);\n    }\n}\n","traces":[{"line":34,"address":[4597879,4597328,4596752,4597303],"length":1,"stats":{"Line":0},"fn_name":"new\u003c\u0026u8,\u0026[u8; 6]\u003e"},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[4597007,4597108,4597583,4597684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4597158,4597734,4597063,4597639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[5447632],"length":1,"stats":{"Line":0},"fn_name":"find_all"},{"line":54,"address":[5447656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[5447680],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":71,"address":[5448638,5447705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[5447767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[5447912,5447779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[5447886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[5448501,5447942,5447910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[5250643,5250427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[5250612,5250666,5250708],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[5250676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[5250799,5250718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[5250692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[5250866,5250922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[5250957,5250903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[5250980,5250834,5251062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[5251042,5251096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[5251107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[5250212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[5917303,5916992],"length":1,"stats":{"Line":0},"fn_name":"test_find_all"},{"line":117,"address":[5916999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[5917014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[5917029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[5917046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[5917639,5917328],"length":1,"stats":{"Line":0},"fn_name":"test_find_all_at_start"},{"line":125,"address":[5917335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[5917350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[5917365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[5917382],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":35},{"path":["/","home","todd","rust-bio","src","pattern_matching","bom.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Backward oracle matching algorithm.\n//! Best-case complexity: O(n / m) with pattern of length m and text of length n.\n//! Worst case complexity: O(n * m).\n//!\n//! # Example\n//!\n//! ```\n//! use bio::pattern_matching::bom::BOM;\n//! let text = b\"ACGGCTAGGAAAAAGACTGAGGACTGAAAA\";\n//! let pattern = b\"GAAAA\";\n//! let bom = BOM::new(pattern);\n//! let occ: Vec\u003cusize\u003e = bom.find_all(text).collect();\n//! assert_eq!(occ, [8, 25]);\n//! ```\n\nuse crate::utils::TextSlice;\nuse std::borrow::Borrow;\nuse std::cmp::Ord;\nuse std::iter::repeat;\n\nuse vec_map::VecMap;\n\n/// Backward oracle matching algorithm.\npub struct BOM {\n    m: usize,\n    table: Vec\u003cVecMap\u003cusize\u003e\u003e,\n}\n\nimpl BOM {\n    /// Create a new instance for a given pattern.\n    pub fn new\u003cC, P\u003e(pattern: P) -\u003e Self\n    where\n        C: Borrow\u003cu8\u003e + Ord,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: DoubleEndedIterator + ExactSizeIterator + Clone,\n    {\n        let pattern = pattern.into_iter();\n        let m = pattern.len();\n        let maxsym = *pattern\n            .clone()\n            .max()\n            .expect(\"Expecting non-empty pattern.\")\n            .borrow() as usize;\n        let mut table: Vec\u003cVecMap\u003cusize\u003e\u003e = Vec::with_capacity(m);\n        // init suffix table, initially all values unknown\n        // suff[i] is the state in which the longest suffix of\n        // pattern[..i+1] ends that does not end in i\n        let mut suff: Vec\u003cOption\u003cusize\u003e\u003e = repeat(None).take(m + 1).collect();\n\n        for (j, b) in pattern.rev().enumerate() {\n            let i = j + 1;\n            let a = *b.borrow() as usize;\n            let mut delta = VecMap::with_capacity(maxsym);\n            // reading symbol a leads into state i (this is an inner edge)\n            delta.insert(a, i);\n            // now, add edges for substrings ending with a\n            let mut k = suff[i - 1];\n\n            // for this iterate over the known suffixes until\n            // reaching an edge labelled with a or the start\n            while let Some(k_) = k {\n                if table[k_].contains_key(a) {\n                    break;\n                }\n                table[k_].insert(a, i);\n                k = suff[k_];\n            }\n\n            // the longest suffix is either 0 or the state\n            // reached by the edge labelled with a\n            suff[i] = Some(match k {\n                Some(k) =\u003e *table[k].get(a).unwrap(),\n                None =\u003e 0,\n            });\n\n            table.push(delta);\n        }\n\n        BOM { m, table }\n    }\n\n    fn delta(\u0026self, q: usize, a: u8) -\u003e Option\u003cusize\u003e {\n        if q \u003e= self.table.len() {\n            None\n        } else {\n            match self.table[q].get(a as usize) {\n                Some(\u0026q) =\u003e Some(q),\n                None =\u003e None,\n            }\n        }\n    }\n\n    /// Find all matches of the pattern in the given text. Matches are returned as an iterator over start positions.\n    pub fn find_all\u003c'a\u003e(\u0026'a self, text: TextSlice\u003c'a\u003e) -\u003e Matches\u003c'_\u003e {\n        Matches {\n            bom: self,\n            text,\n            window: self.m,\n        }\n    }\n}\n\n/// Iterator over start positions of matches.\npub struct Matches\u003c'a\u003e {\n    bom: \u0026'a BOM,\n    text: TextSlice\u003c'a\u003e,\n    window: usize,\n}\n\nimpl\u003c'a\u003e Iterator for Matches\u003c'a\u003e {\n    type Item = usize;\n\n    fn next(\u0026mut self) -\u003e Option\u003cusize\u003e {\n        while self.window \u003c= self.text.len() {\n            let (mut q, mut j) = (Some(0), 1);\n            while j \u003c= self.bom.m {\n                match q {\n                    Some(q_) =\u003e {\n                        q = self.bom.delta(q_, self.text[self.window - j]);\n                        j += 1;\n                    }\n                    None =\u003e break,\n                }\n            }\n            // putative start position\n            let i = self.window - self.bom.m;\n            self.window += self.bom.m + 2 - j;\n            if q.is_some() {\n                // return match\n                return Some(i);\n            }\n        }\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::BOM;\n    use itertools::Itertools;\n\n    #[test]\n    fn test_delta() {\n        let pattern = b\"qnnnannan\"; // reverse of nannannnq\n        let bom = BOM::new(pattern);\n        assert_eq!(bom.delta(0, b'n'), Some(1));\n        assert_eq!(bom.delta(1, b'a'), Some(2));\n        assert_eq!(bom.delta(2, b'n'), Some(3));\n        assert_eq!(bom.delta(3, b'n'), Some(4));\n        assert_eq!(bom.delta(4, b'a'), Some(5));\n        assert_eq!(bom.delta(5, b'n'), Some(6));\n        assert_eq!(bom.delta(6, b'n'), Some(7));\n        assert_eq!(bom.delta(7, b'n'), Some(8));\n        assert_eq!(bom.delta(8, b'q'), Some(9));\n\n        assert_eq!(bom.delta(0, b'a'), Some(2));\n        assert_eq!(bom.delta(0, b'q'), Some(9));\n        assert_eq!(bom.delta(1, b'n'), Some(4));\n        assert_eq!(bom.delta(1, b'q'), Some(9));\n        assert_eq!(bom.delta(4, b'n'), Some(8));\n        assert_eq!(bom.delta(4, b'q'), Some(9));\n        bom.delta(9, b'a');\n    }\n\n    #[test]\n    fn test_find_all() {\n        let text = b\"dhjalkjwqnnnannanaflkjdklfj\";\n        let pattern = b\"qnnnannan\";\n        let bom = BOM::new(pattern);\n        assert_eq!(bom.find_all(text).collect_vec(), [8]);\n    }\n\n    #[test]\n    fn test_find_all_at_start() {\n        let text = b\"dhjalkjwqnnnannanaflkjdklfj\";\n        let pattern = b\"dhjalk\";\n        let bom = BOM::new(pattern);\n        assert_eq!(bom.find_all(text).collect_vec(), [0]);\n    }\n}\n","traces":[{"line":36,"address":[5335450,5335472,5337834,5333088],"length":1,"stats":{"Line":0},"fn_name":"new\u003c\u0026u8,\u0026[u8; 9]\u003e"},{"line":42,"address":[5335522,5333138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[5335794,5333410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[5335900,5333516,5333418,5335802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[5336036,5333652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[5333697,5336081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[5336255,5333871,5333712,5336096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[5335174,5336638,5336653,5333933,5334269,5334254,5337558,5334078,5336462,5336317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[5336749,5334417,5336801,5334365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[5336786,5334402,5336874,5334490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[5334514,5336898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[5336931,5334547],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[5334565,5334629,5336949,5337013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[5335268,5334782,5337652,5334720,5337166,5337104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[5334752,5337136,5334811,5337195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[5337578,5335194,5337223,5334839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[5337596,5335212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[5334888,5334874,5335009,5337272,5337393,5337258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[5337274,5334784,5334890,5337168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[5337260,5334876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[5335095,5337479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[9681616],"length":1,"stats":{"Line":0},"fn_name":"delta"},{"line":88,"address":[9681650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[9681712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[9681822,9681780,9681745,9681689,9681820,9681791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[9681760,9681793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[9681782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[9681824],"length":1,"stats":{"Line":0},"fn_name":"find_all"},{"line":103,"address":[9681870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[9681904],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":119,"address":[9682729,9681929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[9681989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[9682106,9682406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[9682144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[9682156,9682127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[9682177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[9682369,9682411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[9682146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[9682446,9682510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[9682545,9682486,9682689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[9682669,9682723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[9682739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[9681972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[7731872,7731877],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":149,"address":[9774455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[9774470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[9774783,9774507,9774714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[9774738,9774850,9775041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[9775109,9775300,9774996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[9775255,9775368,9775559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[9775514,9775818,9775627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[9775886,9775773,9776077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[9776336,9776032,9776145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[9776595,9776404,9776291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[9776550,9776663,9776853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[9776921,9777111,9776808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[9777370,9777066,9777179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[9777438,9777617,9777325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[9777581,9777846,9777679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[9777908,9778075,9777813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[9778042,9778292,9778137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[9778270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[7731909,7731904],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":172,"address":[9778391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[9778406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[9778421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[9778526,9778438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[7731941,7731936],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":180,"address":[9778759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[9778774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[9778789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[9778806,9778894],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":76},{"path":["/","home","todd","rust-bio","src","pattern_matching","horspool.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Algorithm of Horspool.\n//! Window-based, similar to but faster than Boyer-Moore.\n//!\n//! # Idea\n//! Look at a search window m, match pattern backwards.\n//! In case of a mismatch, you can jump behind that.\n//! Best case time complexity: O(n / m)\n//! Worst case time complexity: O(n * m)\n//! With a large alphabet, you are likely\n//! around the best case, and faster than the rather\n//! complicated Boyer-Moore.\n//!\n//! The algorithm has two phases (let a be the last symbol in the window):\n//!\n//! 1. test phase: compare the last symbol of the window.\n//!    If it matches, compare the whole pattern.\n//!    If it does not match, continue with the shift phase.\n//! 2. shift phase: let `l[a]` be the rightmost position of a in\n//!    the pattern without the last symbol. If it does not occur\n//!    let `l[a]` be -1. Shift the window by `m - 1 - l[a]`. i.e.\n//!    we shift the window such that the rightmost a matches\n//!    the a at the end of the last window.\n//!    If a does not occur in the pattern, we shift by the whole length.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::pattern_matching::horspool::Horspool;\n//! let text = b\"ACGGCTAGGAAAAAGACTGAGGACTGAAAA\";\n//! let pattern = b\"GAAAA\";\n//! let horspool = Horspool::new(pattern);\n//! let occ: Vec\u003cusize\u003e = horspool.find_all(text).collect();\n//! assert_eq!(occ, [8, 25]);\n//! ```\n\nuse crate::utils::TextSlice;\n\n/// Algorithm of Horspool.\npub struct Horspool\u003c'a\u003e {\n    shift: Vec\u003cusize\u003e,\n    m: usize,\n    pattern: TextSlice\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e Horspool\u003c'a\u003e {\n    /// Create a new instance for a given pattern.\n    pub fn new(pattern: TextSlice\u003c'a\u003e) -\u003e Self {\n        let m = pattern.len();\n        let mut shift = vec![m; 256];\n        // shift is m for all not occurring characters\n        // and m - 1 - j for all others\n        for (j, \u0026a) in pattern[..m - 1].iter().enumerate() {\n            shift[a as usize] = m - 1 - j;\n        }\n\n        Horspool { m, shift, pattern }\n    }\n\n    /// Find all matches with a given text. Matches are returned as an iterator over start\n    /// positions.\n    pub fn find_all\u003c'b\u003e(\u0026'b self, text: TextSlice\u003c'b\u003e) -\u003e Matches\u003c'_\u003e {\n        Matches {\n            horspool: self,\n            text,\n            n: text.len(),\n            last: self.m - 1,\n            pattern_last: self.pattern[self.m - 1],\n        }\n    }\n}\n\n/// Iterator over start positions of matches.\npub struct Matches\u003c'a\u003e {\n    horspool: \u0026'a Horspool\u003c'a\u003e,\n    text: TextSlice\u003c'a\u003e,\n    n: usize,\n    last: usize,\n    pattern_last: u8,\n}\n\nimpl\u003c'a\u003e Iterator for Matches\u003c'a\u003e {\n    type Item = usize;\n\n    fn next(\u0026mut self) -\u003e Option\u003cusize\u003e {\n        loop {\n            // shift until the last symbol matches\n            while self.last \u003c self.n \u0026\u0026 self.text[self.last] != self.pattern_last {\n                self.last += self.horspool.shift[self.text[self.last] as usize];\n            }\n            // stop if end of text is reached\n            if self.last \u003e= self.n {\n                return None;\n            }\n\n            // putative start position\n            let i = self.last + 1 - self.horspool.m;\n            let j = self.last;\n\n            // shift again (after both match and mismatch, this makes sense)\n            self.last += self.horspool.shift[self.pattern_last as usize];\n\n            if self.text[i..j] == self.horspool.pattern[..self.horspool.m - 1] {\n                return Some(i);\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Horspool;\n    use itertools::Itertools;\n\n    #[test]\n    fn test_shift() {\n        let pattern = b\"AACB\";\n        let horspool = Horspool::new(pattern);\n        assert_eq!(horspool.shift[b'A' as usize], 2);\n        assert_eq!(horspool.shift[b'C' as usize], 1);\n        assert_eq!(horspool.shift[b'B' as usize], 4);\n        assert_eq!(horspool.shift[b'X' as usize], 4);\n    }\n\n    #[test]\n    fn test_find_all() {\n        let text = b\"dhjalkjwqnnnannanaflkjdklfj\";\n        let pattern = b\"qnnnannan\";\n        let horspool = Horspool::new(pattern);\n        assert_eq!(horspool.find_all(text).collect_vec(), [8]);\n    }\n\n    #[test]\n    fn test_find_all_at_start() {\n        let text = b\"dhjalkjwqnnnannanaflkjdklfj\";\n        let pattern = b\"dhjalk\";\n        let horspool = Horspool::new(pattern);\n        assert_eq!(horspool.find_all(text).collect_vec(), [0]);\n    }\n}\n","traces":[{"line":52,"address":[4934280,4934265,4933376],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":53,"address":[4933438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[4933468],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[4934021,4933495,4934260,4933659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[4934095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[4934288],"length":1,"stats":{"Line":0},"fn_name":"find_all"},{"line":70,"address":[4934348],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[4934411,4934364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[4934587,4934451,4934389,4934605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[4934608],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":90,"address":[4935600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[4935006,4934639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[4934822,4935011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[4934795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[4935071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[4935238,4935120,4935049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[4935192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[4935209,4935281,4935392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[4935327,4935430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[4935610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[5039808,5040624],"length":1,"stats":{"Line":0},"fn_name":"test_shift"},{"line":121,"address":[5039815],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[5039830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[5039852,5040056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[5040010,5040112,5040236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[5040417,5040190,5040293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[5040572,5040371,5040474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[5040656,5041001],"length":1,"stats":{"Line":0},"fn_name":"test_find_all"},{"line":131,"address":[5040663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[5040678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[5040693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[5040803,5040715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[5041024,5041369],"length":1,"stats":{"Line":0},"fn_name":"test_find_all_at_start"},{"line":139,"address":[5041031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[5041046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[5041061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[5041083,5041171],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":37},{"path":["/","home","todd","rust-bio","src","pattern_matching","kmp.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Algorithm of Knuth Morris and Pratt.\n//! Constructs an automaton recognizing the pattern, and scans linearly over\n//! a text of length n. Complexity: O(n).\n//! The transition function delta is simulated via the lps-function, that assigns to each position\n//! q in the pattern the longest prefix of the pattern that is suffix of pattern[..q+1].\n//! Then, in the NFA for the pattern, active states after reading position q are\n//! {q, lps(q), lps(lps(q)), ... 0}.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::pattern_matching::kmp::KMP;\n//! let text = b\"aaaaabbabbbbbbbabbab\";\n//! let pattern = b\"abbab\";\n//! let kmp = KMP::new(pattern);\n//! let occ: Vec\u003cusize\u003e = kmp.find_all(text).collect();\n//! assert_eq!(occ, [4, 15]);\n//! ```\n\nuse std::borrow::Borrow;\nuse std::iter::{repeat, Enumerate};\n\nuse crate::utils::TextSlice;\n\ntype LPS = Vec\u003cusize\u003e;\n\n/// KMP algorithm.\npub struct KMP\u003c'a\u003e {\n    m: usize,\n    lps: LPS,\n    pattern: TextSlice\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e KMP\u003c'a\u003e {\n    /// Create a new instance for a given pattern.\n    pub fn new(pattern: TextSlice\u003c'a\u003e) -\u003e Self {\n        let m = pattern.len();\n        let lps = lps(pattern);\n\n        KMP { lps, m, pattern }\n    }\n\n    fn delta(\u0026self, mut q: usize, a: u8) -\u003e usize {\n        while q == self.m || (self.pattern[q] != a \u0026\u0026 q \u003e 0) {\n            q = self.lps[q - 1];\n        }\n        if self.pattern[q] == a {\n            q += 1;\n        }\n\n        q\n    }\n\n    /// Find all matches of pattern in a given text. Matches are returned as iterator over start\n    /// positions.\n    pub fn find_all\u003cC, T\u003e(\u0026self, text: T) -\u003e Matches\u003cC, T::IntoIter\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        Matches {\n            kmp: self,\n            q: 0,\n            text: text.into_iter().enumerate(),\n        }\n    }\n}\n\nfn lps(pattern: \u0026[u8]) -\u003e LPS {\n    let (m, mut q) = (pattern.len(), 0);\n    let mut lps: LPS = repeat(0).take(m).collect();\n    for i in 1..m {\n        while q \u003e 0 \u0026\u0026 pattern[q] != pattern[i] {\n            q = lps[q - 1];\n        }\n        if pattern[q] == pattern[i] {\n            q += 1;\n        }\n        lps[i] = q;\n    }\n\n    lps\n}\n\n/// Iterator over start positions of matches.\npub struct Matches\u003c'a, C, T\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    kmp: \u0026'a KMP\u003c'a\u003e,\n    q: usize,\n    text: Enumerate\u003cT\u003e,\n}\n\nimpl\u003c'a, C, T\u003e Iterator for Matches\u003c'a, C, T\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    type Item = usize;\n\n    fn next(\u0026mut self) -\u003e Option\u003cusize\u003e {\n        for (i, c) in self.text.by_ref() {\n            self.q = self.kmp.delta(self.q, *c.borrow());\n            if self.q == self.kmp.m {\n                return Some(1 + i - self.kmp.m);\n            }\n        }\n\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{lps, KMP};\n    use itertools::Itertools;\n\n    #[test]\n    fn test_find_all() {\n        let text = b\"dhjalkjwqnnnannanaflkjdklfj\";\n        let pattern = b\"qnnnannan\";\n        let kmp = KMP::new(pattern);\n        assert_eq!(kmp.find_all(text).collect_vec(), [8]);\n    }\n\n    #[test]\n    fn test_find_all_at_start() {\n        let text = b\"dhjalkjwqnnnannanaflkjdklfj\";\n        let pattern = b\"dhjalk\";\n        let kmp = KMP::new(pattern);\n        assert_eq!(kmp.find_all(text).collect_vec(), [0]);\n    }\n\n    #[test]\n    fn test_lps() {\n        let pattern = b\"ababaca\";\n        let lps = lps(pattern);\n        assert_eq!(lps, [0, 0, 1, 2, 3, 0, 1]);\n    }\n\n    #[test]\n    fn test_delta() {\n        let pattern = b\"abbab\";\n        let kmp = KMP::new(pattern);\n        assert_eq!(kmp.delta(0, b'a'), 1);\n        assert_eq!(kmp.delta(0, b'b'), 0);\n        assert_eq!(kmp.delta(1, b'a'), 1);\n        assert_eq!(kmp.delta(1, b'b'), 2);\n        assert_eq!(kmp.delta(2, b'a'), 1);\n        assert_eq!(kmp.delta(2, b'b'), 3);\n        assert_eq!(kmp.delta(3, b'a'), 4);\n        assert_eq!(kmp.delta(3, b'b'), 0);\n        assert_eq!(kmp.delta(4, b'a'), 1);\n        assert_eq!(kmp.delta(4, b'b'), 5);\n        assert_eq!(kmp.delta(5, b'a'), 1);\n        assert_eq!(kmp.delta(5, b'b'), 3);\n    }\n}\n","traces":[{"line":41,"address":[7771184],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":42,"address":[7771234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[7771260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[7771376],"length":1,"stats":{"Line":0},"fn_name":"delta"},{"line":49,"address":[7771708,7771410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[7771605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[7771727,7771799,7771566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[7771768,7771801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[7771831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[5916208],"length":1,"stats":{"Line":0},"fn_name":"find_all\u003c\u0026u8,\u0026[u8; 27]\u003e"},{"line":69,"address":[5916249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[7773012,7771856,7772997],"length":1,"stats":{"Line":0},"fn_name":"lps"},{"line":75,"address":[7771933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[7772011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[7772992,7772090,7772318,7772222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[7772713,7772355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[7772601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[7772744,7772573,7772894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[7772857,7772896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[7772942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[5916963,5916352],"length":1,"stats":{"Line":0},"fn_name":"next\u003c\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":109,"address":[5916537,5916958,5916372,5916566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[5916771,5916661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[5916775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[5916894,5916797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[5916547],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[7732064,7732069],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":127,"address":[7519879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[7519894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[7519909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[7520014,7519931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[7732101,7732096],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":135,"address":[7520247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[7520262],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[7520277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[7520382,7520299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[7520608,7520830],"length":1,"stats":{"Line":0},"fn_name":"test_lps"},{"line":143,"address":[7520615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[7520630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[7520657,7520793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[7523411,7520864],"length":1,"stats":{"Line":0},"fn_name":"test_delta"},{"line":150,"address":[7520871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[7520886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[7520928,7521147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[7521113,7521358,7521206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[7521418,7521324,7521570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[7521536,7521782,7521630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[7521748,7521842,7521994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[7522206,7522054,7521960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[7522409,7522266,7522172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[7522381,7522466,7522603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[7522797,7522660,7522578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[7522991,7522772,7522854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[7523185,7523048,7522966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[7523160,7523359,7523242],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":55},{"path":["/","home","todd","rust-bio","src","pattern_matching","mod.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! This module contains various useful pattern matching algorithms.\n//! The implementations are based on the lecture notes\n//! \"Algorithmen auf Sequenzen\", Kopczynski, Marschall, Martin and Rahmann, 2008 - 2015.\n//!\n//! * Algorithm of Horspool: fastest for a sufficiently large alphabet\n//! * Shift And algorithm: fast for patterns with less than 64 symbols and very small alphabets.\n//! * BNDM algorithm: fast for patterns with less than 64 symbols.\n//! * BOM algorithm: fast for long patterns and small alphabet.\n//! * KMP algorithm: the classical ancestor.\n//! * Ukkonens algorithm: approximate pattern matching with dynamic programming.\n//! * Myers algorithm: linear-time approximate pattern matching with edit distance for small patterns\n//!\n//! Another fast pattern matching algorithm is available in the twoway crate: https://crates.io/crates/twoway\n\npub mod bndm;\npub mod bom;\npub mod horspool;\npub mod kmp;\npub mod myers;\npub mod pssm;\npub mod shift_and;\npub mod ukkonen;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","pattern_matching","myers","builder.rs"],"content":"use std::borrow::Borrow;\nuse std::collections::HashMap;\n\nuse super::long::Myers as MyersLong;\nuse super::{BitVec, Myers};\n\n/// Builds a Myers instance, allowing to specify ambiguities.\n///\n/// # Example:\n///\n/// This example shows how recognition of IUPAC ambiguities in patterns can be implemented:\n///\n/// ```\n/// # extern crate bio;\n/// use bio::pattern_matching::myers::MyersBuilder;\n///\n/// # fn main() {\n/// let ambigs = [\n///     (b'M', \u0026b\"AC\"[..]),\n///     (b'R', \u0026b\"AG\"[..]),\n///     (b'W', \u0026b\"AT\"[..]),\n///     (b'S', \u0026b\"CG\"[..]),\n///     (b'Y', \u0026b\"CT\"[..]),\n///     (b'K', \u0026b\"GT\"[..]),\n///     (b'V', \u0026b\"ACGMRS\"[..]),\n///     (b'H', \u0026b\"ACTMWY\"[..]),\n///     (b'D', \u0026b\"AGTRWK\"[..]),\n///     (b'B', \u0026b\"CGTSYK\"[..]),\n///     (b'N', \u0026b\"ACGTMRWSYKVHDB\"[..]),\n/// ];\n///\n/// let mut builder = MyersBuilder::new();\n///\n/// for \u0026(base, equivalents) in \u0026ambigs {\n///     builder.ambig(base, equivalents);\n/// }\n///\n/// let text = b\"GGATGNGCGCCATAG\";\n/// let pattern = b\"TRANCGG\";\n/// //                *   * (mismatch)\n///\n/// let myers = builder.build_64(pattern);\n/// assert_eq!(myers.distance(text), 2);\n/// # }\n/// ```\n///\n/// Note that only ambiguities in the pattern are recognized. The reverse is not true; ambiguities\n/// in the search text are not matched by multiple symbols in the pattern. This would require\n/// specifying additional ambiguities (`builder.ambig(b'A', b\"MRWVHDN\")`, etc...).\n#[derive(Default, Clone, Eq, PartialEq)]\npub struct MyersBuilder {\n    ambigs: HashMap\u003cu8, Vec\u003cu8\u003e\u003e,\n    wildcards: Vec\u003cu8\u003e,\n}\n\nimpl MyersBuilder {\n    pub fn new() -\u003e MyersBuilder {\n        Self::default()\n    }\n\n    /// Allows to specify ambiguous symbols and their equivalents. Note that the ambiguous symbol\n    /// will always be matched by itself. Explicitly including it in the equivalents is not\n    /// necessary.\n    ///\n    /// # Example:\n    ///\n    /// ```\n    /// # extern crate bio;\n    /// use bio::pattern_matching::myers::MyersBuilder;\n    ///\n    /// # fn main() {\n    /// let text = b\"GGATGAGCGCCATAG\";\n    /// let pattern = b\"TGAGCGN\";\n    ///\n    /// let myers = MyersBuilder::new()\n    ///     .ambig(b'N', b\"ACGT\")\n    ///     .build_64(pattern);\n    ///\n    /// assert_eq!(myers.distance(text), 0);\n    /// # }\n    pub fn ambig\u003cI, B\u003e(\u0026mut self, byte: u8, equivalents: I) -\u003e \u0026mut Self\n    where\n        I: IntoIterator\u003cItem = B\u003e,\n        B: Borrow\u003cu8\u003e,\n    {\n        let eq = equivalents\n            .into_iter()\n            .map(|b| *b.borrow())\n            .chain(Some(byte))\n            .collect();\n        self.ambigs.insert(byte, eq);\n        self\n    }\n\n    /// Allows to specify a wildcard symbol, that upon appearance in the search text\n    /// shall be matched by any symbol of the pattern. Multiple wildcards are possible.\n    /// For the inverse, that is, wildcards in the pattern matching any symbol in search\n    /// text, use `ambig(byte, 0..255)`.\n    ///\n    /// # Example:\n    ///\n    /// ```\n    /// # extern crate bio;\n    /// use bio::pattern_matching::myers::MyersBuilder;\n    ///\n    /// # fn main() {\n    /// let text = b\"GGATGAGCG*CATAG\";\n    /// let pattern = b\"TGAGCGT\";\n    ///\n    /// let myers = MyersBuilder::new()\n    ///     .text_wildcard(b'*')\n    ///     .build_64(pattern);\n    ///\n    /// assert_eq!(myers.distance(text), 0);\n    /// # }\n    pub fn text_wildcard(\u0026mut self, wildcard: u8) -\u003e \u0026mut Self {\n        self.wildcards.push(wildcard);\n        self\n    }\n\n    /// Creates a Myers instance given a pattern, using `u64` as bit vector type.\n    /// Pattern length is restricted to at most 64 symbols.\n    pub fn build_64\u003cC, P\u003e(\u0026self, pattern: P) -\u003e Myers\u003cu64\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        self.build(pattern)\n    }\n\n    /// Creates a Myers instance given a pattern, using `u128` as bit vector type.\n    /// Pattern length is restricted to at most 128 symbols.\n    #[cfg(has_u128)]\n    pub fn build_128\u003cC, P\u003e(\u0026self, pattern: P) -\u003e Myers\u003cu128\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        self.build(pattern)\n    }\n\n    /// Creates a Myers instance given a pattern, using any desired type for bit vectors.\n    /// Pattern length is restricted to the size of the bit vector `T`.\n    ///\n    /// # Example:\n    ///\n    /// ```\n    /// # extern crate bio;\n    /// use bio::pattern_matching::myers::{MyersBuilder, Myers};\n    ///\n    /// # fn main() {\n    /// let myers: Myers\u003cu32\u003e = MyersBuilder::new()\n    ///     .text_wildcard(b'*')\n    ///     .build(b\"TGAGCG*\");\n    /// // ...\n    /// # }\n    pub fn build\u003cT, C, P\u003e(\u0026self, pattern: P) -\u003e Myers\u003cT\u003e\n    where\n        T: BitVec,\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        Myers::new_ambig(pattern, Some(\u0026self.ambigs), Some(\u0026self.wildcards))\n    }\n\n    /// Creates a `long::Myers` instance given a pattern, using `u64` as bit vector type.\n    /// Pattern length is not restricted regardless of the type of the bit vector.\n    pub fn build_long_64\u003cC, P\u003e(\u0026self, pattern: P) -\u003e MyersLong\u003cu64\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        self.build_long(pattern)\n    }\n\n    /// Creates a `long::Myers` instance given a pattern, using `u128` as bit vector type.\n    /// Pattern length is not restricted regardless of the type of the bit vector.\n    #[cfg(has_u128)]\n    pub fn build_long_128\u003cC, P\u003e(\u0026self, pattern: P) -\u003e MyersLong\u003cu128\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        self.build_long(pattern)\n    }\n\n    /// Creates a `long::Myers` instance given a pattern, using any desired type for bit vectors.\n    /// Pattern length is not restricted regardless of the type of the bit vector.\n    pub fn build_long\u003cT, C, P\u003e(\u0026self, pattern: P) -\u003e MyersLong\u003cT\u003e\n    where\n        T: BitVec,\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        MyersLong::new_ambig(pattern, Some(\u0026self.ambigs), Some(\u0026self.wildcards))\n    }\n}\n","traces":[{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[5038688],"length":1,"stats":{"Line":0},"fn_name":"ambig\u003c\u0026[u8; 2],\u0026u8\u003e"},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[9772704],"length":1,"stats":{"Line":0},"fn_name":"text_wildcard"},{"line":117,"address":[9772724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[5039040,5039088,5039136],"length":1,"stats":{"Line":0},"fn_name":"build_64\u003c\u0026u8,\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":129,"address":[5039109,5039061,5039157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[5039785,5039577,5039184,5039600,5039369,5039392],"length":1,"stats":{"Line":0},"fn_name":"build\u003cu64,\u0026u8,\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":166,"address":[5039799,5039642,5039383,5039591,5039589,5039381,5039434,5039226,5039797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":19},{"path":["/","home","todd","rust-bio","src","pattern_matching","myers","common_tests.rs"],"content":"macro_rules! impl_tests {\n    ($mod_:ident, $bitvec:ty, $dist_type:ty, $builder_method:ident) =\u003e {\n        use crate::alignment::AlignmentOperation::*;\n        use crate::alignment::{Alignment, AlignmentMode};\n        use crate::pattern_matching::myers::MyersBuilder;\n        use itertools::Itertools;\n        use $mod_::Myers;\n\n        #[test]\n        fn test_find_all_end() {\n            let text = \"ACCGTGGATGAGCGCCATAG\".to_string();\n            let patt = \"------GATGAGCGT-----\".replace('-', \"\");\n            let myers = Myers::\u003c$bitvec\u003e::new(patt.as_bytes());\n            let occ = myers.find_all_end(text.as_bytes(), 1).collect_vec();\n            assert_eq!(occ, [(13, 1), (14, 1)]);\n        }\n\n        #[test]\n        fn test_distance() {\n            let text = b\"TGAGCNTA\";\n            let patt = b\"TGAGCGT\";\n\n            let myers = Myers::\u003c$bitvec\u003e::new(patt);\n            assert_eq!(myers.distance(text), 1);\n\n            let myers_wildcard = MyersBuilder::new().text_wildcard(b'N').build_64(patt);\n            assert_eq!(myers_wildcard.distance(text), 0);\n        }\n\n        #[test]\n        fn test_full_position() {\n            let text = \"CAGACATCTT\".to_string();\n            let patt = \"-AGA------\".replace('-', \"\");\n\n            let mut myers = Myers::\u003c$bitvec\u003e::new(patt.as_bytes());\n            let matches: Vec\u003c_\u003e = myers.find_all(text.as_bytes(), 1).collect();\n            assert_eq!(\u0026matches, \u0026[(1, 3, 1), (1, 4, 0), (1, 5, 1), (3, 6, 1)]);\n        }\n\n        #[test]\n        fn test_traceback_path() {\n            let text = \"TCAGACAT-CTT\".replace('-', \"\");\n            let patt = \"TC-GACGTGCT\".replace('-', \"\");\n\n            let mut myers = Myers::\u003c$bitvec\u003e::new(patt.as_bytes());\n            let mut matches = myers.find_all(text.as_bytes(), 3);\n            let mut aln = vec![];\n            assert_eq!(matches.next_path(\u0026mut aln).unwrap(), (0, 10, 3));\n            assert_eq!(\n                aln,\n                \u0026[Match, Match, Del, Match, Match, Match, Subst, Match, Ins, Match, Match]\n            );\n        }\n\n        #[test]\n        fn test_traceback_path2() {\n            let text = \"TCAG--CAGATGGAGCTC\".replace('-', \"\");\n            let patt = \"TCAGAGCAG---------\".replace('-', \"\");\n\n            let mut myers = Myers::\u003c$bitvec\u003e::new(patt.as_bytes());\n            let mut matches = myers.find_all(text.as_bytes(), 2);\n            let mut aln = vec![];\n            assert_eq!(matches.next_path(\u0026mut aln).unwrap(), (0, 7, 2));\n            assert_eq!(\n                aln,\n                \u0026[Match, Match, Match, Match, Ins, Ins, Match, Match, Match]\n            );\n        }\n\n        #[test]\n        fn test_alignment() {\n            let text = \"GGTCCTGAGGGATTA\".to_string();\n            let patt = \"--TCCT-AGGGA---\".replace('-', \"\");\n\n            let mut myers = Myers::\u003c$bitvec\u003e::new(patt.as_bytes());\n            let expected = Alignment {\n                score: 1,\n                xstart: 0,\n                xend: 9,\n                xlen: 9,\n                ystart: 2,\n                yend: 12,\n                ylen: 15,\n                operations: vec![\n                    Match, Match, Match, Match, Del, Match, Match, Match, Match, Match,\n                ],\n                mode: AlignmentMode::Semiglobal,\n            };\n\n            let mut aln = Alignment::default();\n            {\n                let mut matches = myers.find_all(text.as_bytes(), 1);\n                assert!(matches.next_alignment(\u0026mut aln));\n                assert_eq!(\u0026aln, \u0026expected);\n\n                aln.score = -1;\n                matches.alignment(\u0026mut aln);\n                assert_eq!(\u0026aln, \u0026expected);\n            }\n            // Lazy API\n            aln.score = -1;\n            let end = expected.yend - 1;\n            let mut lazy_matches = myers.find_all_lazy(text.as_bytes(), 1);\n            assert!(!lazy_matches.alignment_at(end, \u0026mut aln));\n            // now search positions\n            aln.score = -1;\n            assert_eq!(\n                lazy_matches.next(),\n                Some((end, expected.score as $dist_type))\n            );\n            assert!(lazy_matches.alignment_at(end, \u0026mut aln));\n            assert_eq!(\u0026aln, \u0026expected);\n        }\n\n        #[test]\n        fn test_position_cmp() {\n            // same as position_at, but 0-based positions from\n            let text = \"CAGACATCTT\".to_string();\n            let patt = \"---AGA----\".replace('-', \"\");\n            let text = text.as_bytes();\n\n            let starts_exp = [1, 1, 1, 3];\n            let end_dist_exp = [(2, 1), (3, 0), (4, 1), (5, 1)];\n\n            let mut myers = Myers::\u003c$bitvec\u003e::new(patt.as_bytes());\n\n            // standard iterator with 0-based ends\n            let end_dist: Vec\u003c_\u003e = myers.find_all_end(text, 1).collect();\n            assert_eq!(\u0026end_dist, \u0026end_dist_exp);\n\n            // iterator over full ranges where ends are + 1\n            let full_hits: Vec\u003c_\u003e = myers.find_all(text, 1).collect();\n\n            // allows to retrive starting position later\n            let mut lazy_matches = myers.find_all_lazy(text, 1);\n\n            // compare with each other and lazy matches\n            for ((\u0026start, (end, dist)), (f_start, f_end, f_dist)) in\n                starts_exp.iter().zip(end_dist).zip(full_hits)\n            {\n                assert_eq!(start, f_start);\n                assert_eq!(dist, f_dist);\n                assert_eq!(end + 1, f_end);\n\n                // lazy API\n                let (lazy_end, lazy_dist) = lazy_matches.next().unwrap();\n                assert_eq!(end, lazy_end);\n                assert_eq!(dist, lazy_dist);\n                assert_eq!(lazy_matches.hit_at(end), Some((start, dist)));\n                // For positions above, information is not (yet) available\n                assert_eq!(lazy_matches.hit_at(end + 1), None);\n            }\n        }\n\n        #[test]\n        fn test_path_at() {\n            let text = \"CAGACATCTT\".to_string();\n            let patt = \"---AGA----\".replace('-', \"\");\n\n            let mut myers = Myers::\u003c$bitvec\u003e::new(patt.as_bytes());\n            let mut matches = myers.find_all_lazy(text.as_bytes(), 1);\n\n            let expected = \u0026[Match, Match, Ins];\n            let mut path = vec![];\n\n            // search first hit\n            assert_eq!(matches.next(), Some((2, 1)));\n\n            // retrieve first hit at 0-based end position (2)\n            assert_eq!(matches.hit_at(2), Some((1, 1)));\n            assert_eq!(matches.path_at(2, \u0026mut path), Some((1, 1)));\n            assert_eq!(\u0026path, expected);\n\n            // hit out of range\n            path.clear();\n            assert!(matches.path_at(3, \u0026mut path).is_none());\n            assert!(path.is_empty());\n\n            // now search the next hit\n            assert_eq!(matches.next(), Some((3, 0)));\n            // position 3 is now searched -\u003e path can be retrieved\n            assert_eq!(matches.path_at(3, \u0026mut path), Some((1, 0)));\n            assert_eq!(\u0026path, \u0026[Match, Match, Match])\n        }\n\n        #[test]\n        fn test_shorter() {\n            let text = \"-ATG\".replace('-', \"\");\n            let patt = \"CATGC\".to_string();\n\n            let mut myers = Myers::\u003c$bitvec\u003e::new(patt.as_bytes());\n            let mut matches = myers.find_all(text.as_bytes(), 2);\n            let mut aln = vec![];\n            assert_eq!(matches.next_path(\u0026mut aln).unwrap(), (0, 3, 2));\n            assert_eq!(aln, \u0026[Ins, Match, Match, Match, Ins]);\n        }\n\n        #[test]\n        fn test_long_shorter() {\n            let text =\n                \"C--------CACGCGTGGGTCCTGAGGGAGCTCGTCGGTGTGGGGTTCGGGGGGGTTTGT\".replace('-', \"\");\n            let patt = \"CGGGGTGTGCACGCGTGGGTCCTGAGGGAGCTCGTCGGTGTGGGGTTCGGGGGGGTTTGT\".to_string();\n\n            let mut myers = Myers::\u003c$bitvec\u003e::new(patt.as_bytes());\n            let mut matches = myers.find_all(text.as_bytes(), 8);\n            assert_eq!(matches.next().unwrap(), (0, 52, 8));\n        }\n\n        #[test]\n        fn test_ambig() {\n            let text = b\"TGABCNTR\";\n            let patt = b\"TGRRCGTR\";\n            //                x  x\n            // Matching is asymmetric here (A matches R and G matches N, but the reverse is not true)\n\n            let myers = MyersBuilder::new().ambig(b'R', b\"AG\").build_64(patt);\n            assert_eq!(myers.distance(text), 2);\n        }\n\n        #[test]\n        fn test_longest_possible() {\n            let text = b\"CCACGCGT\";\n\n            let mut myers: Myers\u003cu8\u003e = Myers::new(text);\n            assert_eq!(myers.find_all(text, 0).next(), Some((0, 8, 0)));\n        }\n\n        #[test]\n        fn test_large_dist() {\n            use std::iter::repeat;\n\n            let pattern: Vec\u003c_\u003e = repeat(b'T').take(64).collect();\n            let text: Vec\u003c_\u003e = repeat(b'A').take(64).collect();\n\n            let mut myers = Myers::\u003cu64\u003e::new(\u0026pattern);\n            let max_dist = myers\n                .find_all_end(\u0026text, 64)\n                .max_by_key(|\u0026(_, dist)| dist)\n                .unwrap()\n                .1;\n            assert_eq!(max_dist, 64);\n\n            let max_dist = myers\n                .find_all(\u0026text, 64)\n                .max_by_key(|\u0026(_, _, dist)| dist)\n                .unwrap()\n                .2;\n            assert_eq!(max_dist, 64);\n        }\n\n        // macro end\n    };\n}\n","traces":[{"line":10,"address":[4384544,4385113],"length":1,"stats":{"Line":0},"fn_name":"test_find_all_end"},{"line":11,"address":[4384551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[4384573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[4384624,4384700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[4384747,4384856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[4385026,4384871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[4385136,4385795],"length":1,"stats":{"Line":0},"fn_name":"test_distance"},{"line":20,"address":[4385149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[4385164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[4385179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[4385196,4385381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[4385445,4385364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[4385542,4385731,4385614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[4385824,4386407],"length":1,"stats":{"Line":0},"fn_name":"test_full_position"},{"line":32,"address":[4385831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[4385853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[4385980,4385904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[4386136,4386027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[4386151,4386320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[4387239,4386432],"length":1,"stats":{"Line":0},"fn_name":"test_traceback_path"},{"line":42,"address":[4386439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[4386479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4386609,4386530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[4386656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4386755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[4386798,4387067,4386884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[4387151,4387117,4386980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[4387264,4388071],"length":1,"stats":{"Line":0},"fn_name":"test_traceback_path2"},{"line":57,"address":[4387271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[4387311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[4387441,4387362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[4387488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[4387587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[4387899,4387630,4387716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[4387949,4387812,4387983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[4390397,4388096],"length":1,"stats":{"Line":0},"fn_name":"test_alignment"},{"line":72,"address":[4388103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[4388128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[4388185,4388279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[4388749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[4388334,4388470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[4388350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[4388741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[4388886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[4388941,4389040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[4389101,4389243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[4389132,4389329,4389279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[4389285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[4389312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[4389381,4389549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[4389502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[4389640,4389513,4389601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[4389617,4389705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[4389733,4389792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[4389758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[4390035,4389902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[4389785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[4389830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[4390086,4390012,4390210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[4390247,4390281,4390100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[4393624,4390432],"length":1,"stats":{"Line":0},"fn_name":"test_position_cmp"},{"line":118,"address":[4390445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[4390486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[4390629,4390543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[4390667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[4390715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[4391017,4390923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[4391132,4391062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[4391385,4391148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[4391362,4391447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[4391500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[4393460,4391899,4391816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[4391507,4391610,4391879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[4392072,4392278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[4392379,4392167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[4392439,4392604,4392330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[4392656,4392587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[4392718,4392906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[4392999,4392807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[4392958,4393051,4393256],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[4393220,4393475,4393324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[4393648,4395610],"length":1,"stats":{"Line":0},"fn_name":"test_path_at"},{"line":157,"address":[4393655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[4393680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[4393831,4393737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[4393884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[4393998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[4394013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[4394048,4394248,4394198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[4394454,4394302,4394225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[4394431,4394509,4394710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[4394792,4394605,4394761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[4394775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[4394868,4394931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[4394968,4394997,4394906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[4395172,4394990,4395038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[4395155,4395427,4395227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[4395478,4395323,4395513],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[4396433,4395648],"length":1,"stats":{"Line":0},"fn_name":"test_shorter"},{"line":188,"address":[4395655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[4395695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[4395724,4395803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[4395850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[4395949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[4396261,4395992,4396078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[4396311,4396174,4396345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[4397002,4396464],"length":1,"stats":{"Line":0},"fn_name":"test_long_shorter"},{"line":201,"address":[4396471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[4396511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[4396616,4396540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[4396663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[4396772,4396927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[4397040,4397201],"length":1,"stats":{"Line":0},"fn_name":"test_ambig"},{"line":211,"address":[4397047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[4397062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[4397077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[4397279,4397391,4397216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[4397748,4397456],"length":1,"stats":{"Line":0},"fn_name":"test_longest_possible"},{"line":222,"address":[4397463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[4397478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[4397702,4397495,4397592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[4398589,4397776],"length":1,"stats":{"Line":0},"fn_name":"test_large_dist"},{"line":232,"address":[4397783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[4397945,4397850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[4397973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[4398108,4398064,4398006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[7733168,7732669,7733181,7732656],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":241,"address":[4398152,4398280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[4398263,4398347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[7733200,7733213,7732701,7732688],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":248,"address":[4398508,4398398],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":131},{"path":["/","home","todd","rust-bio","src","pattern_matching","myers","helpers.rs"],"content":"use std::fmt::{Binary, Debug};\nuse std::ops::*;\n\nuse num_traits::{AsPrimitive, FromPrimitive, PrimInt, ToPrimitive, WrappingAdd};\n\n/// Trait for types that should be used to store the distance score when using the simple\n/// Myers algorithm (not the block-based one, which always uses `usize`).\n///\n/// For all currently implemented BitVec types, the maximum possible distance\n/// can be stored in `u8`. Custom implementations using bigger integers can\n/// adjust `DistType` to hold bigger numbers. Note that due to how the traceback\n/// algorithm currently works, `DistType` should be able to represent numbers larger\n/// than the bit-width of the `BitVec` type. For instance, a hypothetical `BitVec` type\n/// of `u256` should use `u16` as distance, since `u8` cannot store numbers larger\n/// than 255.\npub trait DistType: Copy\n        + Debug\n        + Default\n        + AddAssign\n        + SubAssign\n        + PrimInt // includes Bounded, Num, Zero, One\n        + FromPrimitive\n        + ToPrimitive\n        + AsPrimitive\u003cusize\u003e + AsPrimitive\u003ci64\u003e\n        + WrappingAdd\n        + Sub\u003cOutput=Self\u003e {}\n\nimpl DistType for u8 {}\nimpl DistType for u16 {}\nimpl DistType for u32 {}\nimpl DistType for u64 {}\nimpl DistType for usize {}\n\n/// This trait must be implemented for integer types serving as bit vectors.\n/// Only unsigned integers will work correctly.\npub trait BitVec: Copy\n    + Debug\n    + Binary\n    + Default\n    + Add\n    + Sub\n    + BitOr\n    + BitOrAssign\n    + BitAnd\n    + BitXor\n    + Not\n    + Shl\u003cusize\u003e\n    + ShlAssign\u003cusize\u003e\n    + ShrAssign\u003cusize\u003e\n    // These num_traits traits are required; in addition there are Bounded, Zero and One,\n    // which are all required by PrimInt and thus included\n    + PrimInt\n    + WrappingAdd\n    + ToPrimitive\n    + FromPrimitive\n    + AsPrimitive\u003cusize\u003e + AsPrimitive\u003ci64\u003e\n{\n    /// Type that should be used to store the distance score when using the simple\n    /// Myers algorithm (not the block-based one, which always uses `usize`).\n    type DistType: DistType;\n}\n\nmacro_rules! impl_bitvec {\n    ($type:ty, $dist:ty) =\u003e {\n        impl BitVec for $type {\n            type DistType = $dist;\n        }\n    };\n}\n\nimpl_bitvec!(u8, u8);\nimpl_bitvec!(u16, u8);\nimpl_bitvec!(u32, u8);\nimpl_bitvec!(u64, u8);\n#[cfg(has_u128)]\nimpl_bitvec!(u128, u8);\n\nuse crate::alignment::{Alignment, AlignmentMode};\n\n/// Updates an `Alignment` instance with new data (except of path).\n/// Assumes *0-based* range end coordinates, they will be converted to 1-based ones\n#[inline(always)]\npub(crate) fn update_aln(\n    end_pos: usize,\n    aln_len: usize,\n    text_len: usize,\n    dist: usize,\n    m: usize,\n    aln: \u0026mut Alignment,\n) {\n    aln.xstart = 0;\n    aln.xend = m;\n    aln.xlen = m;\n    aln.ylen = text_len;\n    aln.yend = end_pos + 1;\n    aln.ystart = aln.yend - aln_len;\n    aln.mode = AlignmentMode::Semiglobal;\n    aln.score = dist as i32;\n}\n\n#[inline]\npub(crate) fn word_size\u003cT\u003e() -\u003e usize {\n    std::mem::size_of::\u003cT\u003e() * 8\n}\n\n#[inline]\npub(crate) fn ceil_div(x: usize, y: usize) -\u003e usize {\n    if x % y != 0 {\n        x / y + 1\n    } else {\n        x / y\n    }\n}\n","traces":[{"line":91,"address":[7690272,7694342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[4510771,4506729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[4510779,4506737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[7690351,7690292,7694362,7694421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[7690381,7690330,7694400,7694451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[4506879,4510921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[4506897,4510939],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[7729216,7729152],"length":1,"stats":{"Line":0},"fn_name":"word_size\u003cu64\u003e"},{"line":103,"address":[7729213,7729217,7729183,7729279,7729249,7729153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[7770880],"length":1,"stats":{"Line":0},"fn_name":"ceil_div"},{"line":108,"address":[7771144,7771082,7770904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[7770998,7771084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[7771134,7771146,7770973,7771176],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","todd","rust-bio","src","pattern_matching","myers","long.rs"],"content":"//! Block-based version of the algorithm, which does not restrict pattern length.\n//!\n//! This module implements the block-based version of the Myers pattern matching algorithm.\n//! It can be used for searching patterns of any length and obtaining semiglobal alignments\n//! of the hits. Apart from that, the `Myers` object in this module provides exactly the same\n//! API as the 'simple' version `bio::pattern_matching::myers::Myers`.\n//! For short patterns, the 'simple' version is still to be preferred, as the block-based\n//! algorithm is slower.\n\nuse std::borrow::Borrow;\nuse std::cmp::{max, min};\nuse std::collections::HashMap;\nuse std::iter;\nuse std::marker::PhantomData;\nuse std::mem::replace;\nuse std::slice;\nuse std::u64;\n\nuse itertools::Itertools;\nuse num_traits::ToPrimitive;\n\nuse crate::pattern_matching::myers::traceback::{StatesHandler, TracebackHandler};\nuse crate::pattern_matching::myers::{ceil_div, State};\n\nuse super::word_size;\nuse super::BitVec;\n\nstruct Peq\u003cT: BitVec\u003e {\n    peq: [T; 256],\n    bound: T,\n}\n\n/// Myers algorithm.\npub struct Myers\u003cT = u64\u003e\nwhere\n    T: BitVec,\n{\n    peq: Vec\u003cPeq\u003cT\u003e\u003e,\n    pub(crate) m: usize,\n    pub(crate) states_store: Vec\u003cState\u003cT, usize\u003e\u003e,\n}\n\nimpl\u003cT: BitVec\u003e Myers\u003cT\u003e {\n    /// Create a new instance of Myers algorithm for a given pattern.\n    #[inline]\n    pub fn new\u003cP, C\u003e(pattern: P) -\u003e Self\n    where\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        Self::new_ambig(pattern, None, None)\n    }\n\n    #[inline]\n    pub(crate) fn new_ambig\u003cP, C\u003e(\n        pattern: P,\n        opt_ambigs: Option\u003c\u0026HashMap\u003cu8, Vec\u003cu8\u003e\u003e\u003e,\n        opt_wildcards: Option\u003c\u0026[u8]\u003e,\n    ) -\u003e Self\n    where\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        let w = word_size::\u003cT\u003e();\n        let pattern = pattern.into_iter();\n        let m = pattern.len();\n        assert!(m \u003e 0, \"Pattern is empty\");\n        assert!(m \u003c= usize::max_value() / 2, \"Pattern too long\");\n\n        // build peq\n        let mut peq = vec![];\n        for chunk in pattern.chunks(w).into_iter() {\n            let mut peq_block = [T::zero(); 256];\n            let mut i = 0;\n            for symbol in chunk {\n                let symbol = *symbol.borrow();\n                let mask = T::one() \u003c\u003c i;\n                // equivalent\n                peq_block[symbol as usize] |= mask;\n                // ambiguities\n                if let Some(equivalents) = opt_ambigs.and_then(|ambigs| ambigs.get(\u0026symbol)) {\n                    for \u0026eq in equivalents {\n                        peq_block[eq as usize] |= mask;\n                    }\n                }\n                i += 1;\n            }\n            // wildcards\n            if let Some(wildcards) = opt_wildcards {\n                for \u0026w in wildcards {\n                    peq_block[w as usize] = T::max_value();\n                }\n            }\n\n            peq.push(Peq {\n                peq: peq_block,\n                bound: T::one() \u003c\u003c (i - 1),\n            });\n        }\n\n        Myers {\n            peq,\n            m,\n            states_store: vec![],\n        }\n    }\n\n    #[inline]\n    fn step(\u0026self, state: \u0026mut States\u003cT\u003e, a: u8, max_dist: usize) {\n        state.step(a, \u0026self.peq, max_dist)\n    }\n\n    #[inline]\n    fn initial_state(\u0026self, m: usize, max_dist: usize) -\u003e States\u003cT\u003e {\n        States::new(m, max_dist)\n    }\n}\n\n#[inline]\nfn advance_block\u003cT: BitVec\u003e(state: \u0026mut State\u003cT, usize\u003e, p: \u0026Peq\u003cT\u003e, a: u8, hin: i8) -\u003e i8 {\n    let mut eq = p.peq[a as usize];\n    let xv = eq | state.mv;\n    if hin \u003c 0 {\n        eq |= T::one();\n    }\n    let xh = ((eq \u0026 state.pv).wrapping_add(\u0026state.pv) ^ state.pv) | eq;\n\n    let mut ph = state.mv | !(xh | state.pv);\n    let mut mh = state.pv \u0026 xh;\n\n    // let hout = if ph \u0026 p.bound \u003e T::zero() {\n    //     state.dist += 1;\n    //     1\n    // } else if mh \u0026 p.bound \u003e T::zero() {\n    //     state.dist -= 1;\n    //     -1\n    // } else {\n    //     0\n    // };\n\n    // apparently faster than uncommented code above\n    let mut hout = ((ph \u0026 p.bound) != T::zero()) as i8;\n    hout -= ((mh \u0026 p.bound) != T::zero()) as i8;\n    state.dist = state.dist.wrapping_add(hout as usize);\n\n    ph \u003c\u003c= 1;\n    mh \u003c\u003c= 1;\n\n    if hin \u003c 0 {\n        mh |= T::one();\n    }\n    if hin \u003e 0 {\n        ph |= T::one();\n    }\n    // not faster:\n    // mh |= T::from_u8((hin \u003c 0) as u8).unwrap();\n    // ph |= T::from_u8((hin \u003e 0) as u8).unwrap();\n\n    state.pv = mh | !(xv | ph);\n    state.mv = ph \u0026 xv;\n\n    hout\n}\n\npub(super) struct States\u003cT: BitVec\u003e {\n    states: Vec\u003cState\u003cT, usize\u003e\u003e,\n    max_block: usize,\n    last_m: usize,\n}\n\nimpl\u003cT\u003e States\u003cT\u003e\nwhere\n    T: BitVec,\n{\n    fn new(m: usize, max_dist: usize) -\u003e Self {\n        let w = word_size::\u003cT\u003e();\n        let mut s = States {\n            states: vec![],\n            max_block: ceil_div(m, w) - 1,\n            last_m: m % w,\n        };\n        let min_blocks = max(1, ceil_div(min(max_dist, m), w));\n        for _ in 0..min_blocks {\n            s.add_state(0);\n        }\n        s\n    }\n\n    #[inline]\n    fn add_state(\u0026mut self, offset: i8) {\n        let prev_dist = self.states.last().map(|s| s.dist).unwrap_or(0);\n        // delta: number of bits of the new state covered by the pattern\n        // For the last block, we add m % w, not all bits are necessarily used.\n        // This strategy differs from the solution by Myers (p. 407, note 4).\n        // We wanted to avoid having to pad pattern and sequence.\n        let delta = if self.states.len() == self.max_block \u0026\u0026 self.last_m \u003e 0 {\n            self.last_m\n        } else {\n            word_size::\u003cT\u003e()\n        };\n        self.states.push(State::init(\n            (prev_dist)\n                .wrapping_add(delta)\n                .wrapping_add(offset as usize)\n                .to_usize()\n                .unwrap(),\n        ));\n    }\n\n    #[inline]\n    fn step(\u0026mut self, a: u8, peq: \u0026[Peq\u003cT\u003e], max_dist: usize) {\n        let mut carry = 0;\n        let mut last_block = self.states.len() - 1;\n\n        for (state, block_peq) in self.states.iter_mut().zip(peq) {\n            carry = advance_block(state, block_peq, a, carry);\n        }\n\n        let w = word_size::\u003cT\u003e();\n        let last_dist = self.states[last_block].dist;\n        if (last_dist as isize - carry as isize) as usize \u003c= max_dist\n            \u0026\u0026 last_block \u003c self.max_block\n            \u0026\u0026 (peq[last_block + 1].peq[a as usize] \u0026 T::one() == T::one() || carry \u003c 0)\n        {\n            last_block += 1;\n            self.add_state(-carry as i8);\n            advance_block(\u0026mut self.states[last_block], \u0026peq[last_block], a, carry);\n        } else {\n            while last_block \u003e 0 \u0026\u0026 self.states[last_block].dist \u003e= max_dist + w {\n                last_block -= 1;\n            }\n            self.states.truncate(last_block + 1);\n        }\n    }\n\n    /// Returns the last distance score of the traceback column if known\n    /// (only if all blocks were computed).\n    #[inline]\n    fn known_dist(\u0026self) -\u003e Option\u003cusize\u003e {\n        self.states.get(self.max_block).map(|s| s.dist)\n    }\n}\n\n#[derive(Default)]\npub(super) struct LongStatesHandler\u003c'a\u003e {\n    n_blocks: usize,\n    _a: PhantomData\u003c\u0026'a ()\u003e,\n}\n\nimpl\u003c'a\u003e LongStatesHandler\u003c'a\u003e {\n    #[inline]\n    pub fn new() -\u003e Self {\n        LongStatesHandler {\n            n_blocks: 0,\n            _a: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'a, T\u003e StatesHandler\u003c'a, T, usize\u003e for LongStatesHandler\u003c'a\u003e\nwhere\n    T: BitVec + 'a,\n{\n    type TracebackHandler = LongTracebackHandler\u003c'a, T\u003e;\n    type TracebackColumn = States\u003cT\u003e;\n\n    #[inline]\n    fn init(\u0026mut self, n: usize, m: usize) -\u003e usize {\n        let w = word_size::\u003cT\u003e();\n        self.n_blocks = ceil_div(m.to_usize().unwrap(), w);\n        n * self.n_blocks\n    }\n\n    #[inline]\n    fn set_max_state(\u0026self, pos: usize, states: \u0026mut [State\u003cT, usize\u003e]) {\n        let pos = pos * self.n_blocks;\n        for s in states.iter_mut().skip(pos).take(self.n_blocks) {\n            *s = State::max();\n        }\n    }\n\n    #[inline]\n    fn add_state(\n        \u0026self,\n        source: \u0026Self::TracebackColumn,\n        pos: usize,\n        states: \u0026mut [State\u003cT, usize\u003e],\n    ) {\n        let source = \u0026source.states;\n        let pos = pos * self.n_blocks;\n        states[pos..pos + source.len()].clone_from_slice(source);\n\n        if source.len() \u003c self.n_blocks {\n            // When following the traceback path, it can happen that the block to the\n            // left was not computed because it is outside of the band.\n            // In order to prevent the algorithm from going left in this case,\n            // we initialize the block below the last computed block with meaningful\n            // defaults.\n            states[pos + source.len()] = State {\n                dist: usize::max_value(),\n                pv: T::zero(),\n                mv: T::zero(),\n            };\n        }\n    }\n\n    #[inline]\n    fn init_traceback(\n        \u0026self,\n        m: usize,\n        pos: usize,\n        states: \u0026'a [State\u003cT, usize\u003e],\n    ) -\u003e Self::TracebackHandler {\n        LongTracebackHandler::new(self.n_blocks, m, pos, states)\n    }\n}\n\ntype RevColIter\u003c'a, T\u003e = iter::Rev\u003cslice::Chunks\u003c'a, State\u003cT, usize\u003e\u003e\u003e;\n\npub(super) struct LongTracebackHandler\u003c'a, T: BitVec\u003e {\n    states_iter: iter::Chain\u003cRevColIter\u003c'a, T\u003e, iter::Cycle\u003cRevColIter\u003c'a, T\u003e\u003e\u003e,\n    block_pos: usize,\n    left_block_pos: usize,\n    col: \u0026'a [State\u003cT, usize\u003e],\n    left_col: \u0026'a [State\u003cT, usize\u003e],\n    block: State\u003cT, usize\u003e,\n    left_block: State\u003cT, usize\u003e,\n    left_max_mask: T,\n    pos_bitvec: T,\n    left_mask: T,\n    _a: PhantomData\u003c\u0026'a ()\u003e,\n}\n\nimpl\u003c'a, T: BitVec\u003e LongTracebackHandler\u003c'a, T\u003e {\n    #[inline]\n    fn new(n_blocks: usize, m: usize, pos: usize, states: \u0026'a [State\u003cT, usize\u003e]) -\u003e Self {\n        let mut last_m = m.to_usize().unwrap() % word_size::\u003cT\u003e();\n        if last_m == 0 {\n            last_m = word_size::\u003cT\u003e();\n        }\n        let mask0 = T::one() \u003c\u003c (last_m - 1);\n\n        let pos = n_blocks * (pos + 1);\n        let mut states_iter = states[..pos]\n            .chunks(n_blocks)\n            .rev()\n            .chain(states.chunks(n_blocks).rev().cycle());\n\n        let col = states_iter.next().unwrap();\n        let left_col = states_iter.next().unwrap();\n\n        // This bit mask is supplied to State::adjust_by_mask() in order to adjust the distance\n        // of the left block. It is adjusted with every `move_up_left`\n        let left_mask = if last_m != 1 {\n            T::zero()\n        } else {\n            T::from_usize(0b10).unwrap()\n        };\n\n        LongTracebackHandler {\n            block_pos: n_blocks - 1,\n            left_block_pos: n_blocks - 1,\n            block: col.last().unwrap().clone(),\n            left_block: left_col.last().unwrap().clone(),\n            col,\n            left_col,\n            states_iter,\n            pos_bitvec: mask0,\n            left_mask,\n            left_max_mask: mask0,\n            _a: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'a, T: BitVec + 'a\u003e TracebackHandler\u003c'a, T, usize\u003e for LongTracebackHandler\u003c'a, T\u003e {\n    #[inline]\n    fn block(\u0026self) -\u003e \u0026State\u003cT, usize\u003e {\n        \u0026self.block\n    }\n\n    #[inline]\n    fn block_mut(\u0026mut self) -\u003e \u0026mut State\u003cT, usize\u003e {\n        \u0026mut self.block\n    }\n\n    #[inline]\n    fn left_block(\u0026self) -\u003e \u0026State\u003cT, usize\u003e {\n        \u0026self.left_block\n    }\n\n    #[inline]\n    fn left_block_mut(\u0026mut self) -\u003e \u0026mut State\u003cT, usize\u003e {\n        \u0026mut self.left_block\n    }\n\n    #[inline]\n    fn pos_bitvec(\u0026self) -\u003e T {\n        self.pos_bitvec\n    }\n\n    #[inline]\n    fn move_up(\u0026mut self, adjust_dist: bool) {\n        // If the block boundary has not been reached yet, we can shift to the\n        // upper position. Otherwise, we move to a new block (if there is one!)\n        if self.pos_bitvec != T::one() || self.block_pos == 0 {\n            if adjust_dist {\n                self.block.adjust_dist(self.pos_bitvec);\n            }\n            self.pos_bitvec \u003e\u003e= 1;\n        } else {\n            // move to upper block\n            self.pos_bitvec = T::one() \u003c\u003c (word_size::\u003cT\u003e() - 1);\n            self.block_pos -= 1;\n            if adjust_dist {\n                self.block = self.col[self.block_pos].clone();\n            }\n        }\n    }\n\n    #[inline]\n    fn move_up_left(\u0026mut self, adjust_dist: bool) {\n        // If the block boundary has not been reached yet, we can extend the range mask by\n        // activating a new bit.\n        // However, we switch to a new block (if there is one!) before the mask would cover\n        // the whole block.\n        if self.left_mask \u0026 T::from_usize(0b10).unwrap() == T::zero() || self.left_block_pos == 0 {\n            self.left_mask = (self.left_mask \u003e\u003e 1) | self.left_max_mask;\n            if adjust_dist {\n                self.left_block.adjust_dist(self.pos_bitvec);\n            }\n        } else {\n            self.left_max_mask = T::one() \u003c\u003c (word_size::\u003cT\u003e() - 1);\n            self.left_mask = T::zero();\n            self.left_block_pos -= 1;\n            if adjust_dist {\n                self.left_block = self.left_col[self.left_block_pos].clone();\n            }\n        }\n    }\n\n    #[inline]\n    fn move_to_left(\u0026mut self) {\n        self.col = self.left_col;\n        self.left_col = self.states_iter.next().unwrap();\n        self.block = replace(\n            \u0026mut self.left_block,\n            self.left_col[self.left_block_pos].clone(),\n        );\n        self.left_block.adjust_by_mask(self.left_mask);\n    }\n\n    #[inline]\n    fn move_left_down_if_better(\u0026mut self) -\u003e bool {\n        if self.left_mask != T::zero() {\n            // simple case: not at block boundary\n            if self.left_block.mv \u0026 self.pos_bitvec != T::zero() {\n                self.left_block.dist -= 1;\n                return true;\n            }\n        } else if let Some(b) = self.left_col.get(self.left_block_pos + 1) {\n            // more complicated: at lower block boundary, and there is a lower block\n            if b.mv \u0026 T::one() == T::one() {\n                let d = self.left_block().dist - 1;\n                self.left_block = b.clone();\n                self.left_block.dist = d;\n                return true;\n            }\n        }\n        false\n    }\n\n    #[inline]\n    fn column_slice(\u0026self) -\u003e \u0026[State\u003cT, usize\u003e] {\n        self.col\n    }\n\n    #[inline]\n    fn finished(\u0026self) -\u003e bool {\n        self.pos_bitvec == T::zero() \u0026\u0026 self.block_pos == 0\n    }\n}\n\nimpl_myers!(\n    usize,\n    Myers\u003cT\u003e,\n    crate::pattern_matching::myers::long::States\u003cT\u003e,\n    crate::pattern_matching::myers::long::LongStatesHandler\u003c'a\u003e\n);\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    impl_tests!(super, u8, usize, build_64);\n\n    #[test]\n    fn test_myers_long_overflow() {\n        let pattern = b\"AAGACGAGAAAAGAAAGTCTAAAGGACTTTTGTGGCAAGACCATCCCTGTTCCCAACCCGACCCCTGGACCTCCCGCCCCGGGCACTCCCGACCCCCCGACCCCCCGACTCCTGGACCAGGAGACTGA\";\n        let text = b\"GGCAAGGGGGACTGTAGATGGGTGAAAAGAGCAGTCAGGGACCAGGTCCTCAGCCCCCCAGCCCCCCAGCCCTCCAGGTCCCCAGCCCTCCAGGTCCCCAGCCCAACCCTTGTCCTTACCAGAACGTTGTTTTCAGGAAGTCTGAAAGACAAGAGCAGAAAGTCAGTCCCATGGAATTTTCGCTTCCCACAG\".to_vec();\n\n        let myers: Myers\u003cu64\u003e = Myers::new(pattern.iter().cloned());\n\n        let hits: Vec\u003c_\u003e = myers.find_all_end(text, usize::max_value() - 64).collect();\n        dbg!(hits);\n    }\n}\n","traces":[{"line":46,"address":[4759872,4760016,4759952,4759808,4759728],"length":1,"stats":{"Line":0},"fn_name":"new\u003cu64,core::iter::adapters::cloned::Cloned\u003ccore::slice::iter::Iter\u003cu8\u003e\u003e,u8\u003e"},{"line":52,"address":[4760032,4759968,4759894,4759824,4759750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[4763270,4766304,4763296,4769488,4769466,4775802,4766274,4772615,4760080,4772640],"length":1,"stats":{"Line":0},"fn_name":"new_ambig\u003cu8,\u0026[u8],\u0026u8\u003e"},{"line":66,"address":[4769568,4760170,4772714,4766378,4763392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[4772906,4769666,4766476,4769764,4763592,4760374,4772812,4760276,4766570,4763498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[4763624,4760609,4773141,4766805,4769999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[4770065,4770007,4773149,4763658,4766871,4766813,4760675,4763716,4773207,4760617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[4766911,4763756,4766949,4760753,4773247,4770105,4773285,4770143,4760715,4763794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[4773278,4770136,4766942,4760746,4763787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[4762988,4767264,4770303,4767109,4761086,4770476,4764125,4770458,4763954,4763832,4760913,4767282,4761068,4773600,4773445,4765992,4775520,4766987,4769184,4773323,4770181,4772333,4764107,4760791,4773618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[4773780,4764287,4767444,4770638,4761248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[4761428,4770800,4767624,4773960,4764449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[4768637,4774076,4767740,4761544,4771778,4771057,4764692,4774230,4767894,4771029,4761698,4774973,4762441,4761440,4774258,4764461,4767636,4764720,4770812,4761726,4767922,4765437,4773972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[4771113,4774314,4764772,4761782,4767978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[4771148,4764860,4768013,4761817,4771201,4764807,4774399,4768063,4774349,4761867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[4774440,4771243,4761908,4768104,4764902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[4775968,4762261,4765259,4771474,4768331,4762022,4775872,4775995,4775851,4775947,4765133,4771355,4762135,4775920,4775899,4774554,4774793,4774667,4771600,4776016,4775824,4765014,4768218,4776043,4768457],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cu8,\u0026[u8; 8],\u0026u8\u003e"},{"line":84,"address":[4762108,4768304,4774912,4774712,4774795,4762380,4771519,4768576,4771447,4768459,4765261,4762263,4768376,4771602,4765178,4771717,4765106,4762180,4765376,4774640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[4774828,4768492,4771635,4765294,4762296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[4768596,4765396,4774932,4765386,4768586,4768333,4762390,4771737,4765135,4762400,4762137,4774922,4771727,4774669,4771476],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[4765688,4771803,4774998,4768662,4765547,4762690,4768747,4775083,4765462,4772029,4771888,4768886,4775222,4762466,4762551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[4765693,4772131,4762609,4762788,4762695,4775320,4765520,4765790,4771948,4765607,4775141,4775227,4768891,4772034,4762524,4768984,4768720,4768805,4771861,4775056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[4772071,4765730,4762798,4768928,4772141,4775330,4768994,4775264,4762732,4765800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[4765941,4762939,4775471,4769135,4772282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[4768777,4771918,4762581,4765577,4775113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[4775115,4769020,4768779,4775356,4772167,4771920,4762583,4765826,4765579,4762824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[4775609,4763077,4769273,4772422,4766081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[4776160,4776064],"length":1,"stats":{"Line":0},"fn_name":"step\u003cu64\u003e"},{"line":112,"address":[4776198,4776102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[4776336,4776256],"length":1,"stats":{"Line":0},"fn_name":"initial_state\u003cu8\u003e"},{"line":117,"address":[4776389,4776309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[4777248,4776416],"length":1,"stats":{"Line":0},"fn_name":"advance_block\u003cu8\u003e"},{"line":123,"address":[4777415,4776530,4777310,4776454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[4776499,4777372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[4776557,4776589,4777445,4777479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[4776563,4777451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[4777489,4776596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[4776698,4777609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[4777682,4776769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[4777706,4776790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[4777794,4776857,4776974,4777945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[4777943,4777906,4777014,4777988,4776945,4776972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[4777992,4777017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[4777032,4778010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[4777051,4778069,4777083,4778035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[4778041,4777057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[4777121,4778078,4777089,4778112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[4777095,4778084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[4778122,4777127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[4777207,4778212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[4778272,4778593,4779265,4778944],"length":1,"stats":{"Line":0},"fn_name":"new\u003cu8\u003e"},{"line":178,"address":[4778987,4778315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[4778333,4779005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[4779025,4778446,4778353,4779118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[4778563,4778433,4779105,4778498,4779235,4779170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[4779216,4779344,4778618,4778544,4779290,4778672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[4778932,4778894,4779381,4778709,4779604,4779599,4778927,4779566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[4778920,4779592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[4779616,4780016],"length":1,"stats":{"Line":0},"fn_name":"add_state\u003cu64\u003e"},{"line":193,"address":[4779650,4780050,4780496,4780464,4780505,4780473],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cu64\u003e"},{"line":198,"address":[4779743,4780143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[4779819,4780228],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[4780211,4779802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[4779966,4780377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[4780313,4779904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[4779843,4780252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[4780290,4779881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[4782256,4780528],"length":1,"stats":{"Line":0},"fn_name":"step\u003cu64\u003e"},{"line":214,"address":[4782344,4780616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[4780624,4782439,4780711,4782352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[4782777,4780954,4782485,4782416,4782682,4781055,4780688,4780757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[4781018,4782746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[4782652,4780924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[4782790,4781068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[4783956,4783287,4781579,4781229,4781920,4781116,4782251,4783628,4782938,4782246,4782831,4783951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[4781214,4782923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[4781261,4782970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[4783333,4781684,4783392,4781625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[4781662,4781726,4783370,4783434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[4783486,4781778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[4783869,4783313,4781930,4783638,4781605,4782164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[4782169,4783834,4782127,4783874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[4783914,4782209,4782101,4783808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[4784064,4783968],"length":1,"stats":{"Line":0},"fn_name":"known_dist\u003cu64\u003e"},{"line":242,"address":[4784201,4784192,4784169,4783982,4784078,4784160],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cu8\u003e"},{"line":254,"address":[7729280],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":270,"address":[4784224,4784416],"length":1,"stats":{"Line":0},"fn_name":"init\u003cu8\u003e"},{"line":271,"address":[4784253,4784445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[4784460,4784268],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[4784601,4784379,4784546,4784571,4784354,4784409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[4784608,4785040],"length":1,"stats":{"Line":0},"fn_name":"set_max_state\u003cu8\u003e"},{"line":278,"address":[4785097,4784665,4784720,4785152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[4785040,4784765,4785035,4785452,4784919,4785135,4785357,4785197,4785447,4784703],"length":1,"stats":{"Line":0},"fn_name":"set_max_state\u003cu64\u003e"},{"line":280,"address":[4785394,4784955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[4786064,4785456],"length":1,"stats":{"Line":0},"fn_name":"add_state\u003cu64\u003e"},{"line":291,"address":[4786134,4785526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[4785579,4786142,4785534,4786187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[4786227,4785567,4785619,4786175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[4786611,4786021,4785790,4786398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[4786622,4785857,4786461,4786032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[4785820,4786428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[4785822,4786430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[4785832,4786439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[4786720,4786656],"length":1,"stats":{"Line":0},"fn_name":"init_traceback\u003cu64\u003e"},{"line":316,"address":[4786693,4786757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[4786784,4788304],"length":1,"stats":{"Line":0},"fn_name":"new\u003cu64\u003e"},{"line":339,"address":[4788400,4787020,4786880,4788540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[4787098,4788527,4788585,4787007,4788617,4787065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[4788570,4787050,4787090,4788609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[4788619,4787100,4787067,4788587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[4787367,4788723,4787204,4788886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[4788940,4788840,4789053,4787321,4787421,4787534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[4788998,4787479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[4789082,4787563],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[4787646,4789153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[4789224,4787717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[4789255,4787750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[4787848,4789275,4789361,4787771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[4787900,4789343,4787830,4789413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[4789448,4787935,4789401,4787888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[4787980,4789533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[4789872,4789856],"length":1,"stats":{"Line":0},"fn_name":"block\u003cu64\u003e"},{"line":381,"address":[4789864,4789880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[4789888,4789904],"length":1,"stats":{"Line":0},"fn_name":"left_block\u003cu64\u003e"},{"line":391,"address":[4789912,4789896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[4789920,4789936],"length":1,"stats":{"Line":0},"fn_name":"pos_bitvec\u003cu8\u003e"},{"line":401,"address":[4789941,4789925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[4789952,4790480],"length":1,"stats":{"Line":0},"fn_name":"move_up\u003cu8\u003e"},{"line":408,"address":[4790516,4789982,4790672,4790136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[4790648,4790080,4790112,4790616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[4790629,4790093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[4790655,4790119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[4790065,4790682,4790600,4790146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[4790245,4790289,4790826,4790782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[4790856,4790283,4790474,4791000,4790995,4790820,4790319,4790479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[4790329,4790866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[4791008,4791712],"length":1,"stats":{"Line":0},"fn_name":"move_up_left\u003cu64\u003e"},{"line":429,"address":[4791044,4791742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[4791240,4791917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[4791985,4791343,4792018,4791310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[4791996,4791321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[4791223,4791353,4791901,4792028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[4792127,4791453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[4792151,4791524,4792195,4791480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[4791702,4791707,4792225,4792386,4792391,4792189,4791518,4791554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[4792235,4791564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[4792400,4792752],"length":1,"stats":{"Line":0},"fn_name":"move_to_left\u003cu8\u003e"},{"line":446,"address":[4792417,4792766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[4792782,4792433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[4792957,4792636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[4792852,4792503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[4792516,4792865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[4793010,4792713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[4793744,4793040],"length":1,"stats":{"Line":0},"fn_name":"move_left_down_if_better\u003cu64\u003e"},{"line":457,"address":[4793060,4793934,4793764,4793243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[4793871,4793168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[4793941,4793297,4793250,4793988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[4793290,4793981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[4793555,4793819,4794057,4794158,4793479,4793116,4793366,4794221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[4793494,4794168,4793458,4794140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[4794336,4793565,4793631,4794231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[4794281,4793616,4793670,4794375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[4793715,4794405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[4794412,4793722],"length":1,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[4793344,4794035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[4794544,4794432],"length":1,"stats":{"Line":0},"fn_name":"finished\u003cu64\u003e"},{"line":482,"address":[4794446,4794558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[7732725,7732720],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":501,"address":[8180359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[8180390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[8180579,8180424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[8180847,8180586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[8180863],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":184},{"path":["/","home","todd","rust-bio","src","pattern_matching","myers","mod.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Myers bit-parallel approximate pattern matching algorithm.\n//! Finds all matches up to a given edit distance. The pattern has to fit into a bitvector,\n//! and is thus limited to 64 or (since stable Rust version 1.26) to 128 symbols.\n//! Complexity: O(n)\n//!\n//! Traceback allows obtaining the starting position and the alignment path of the hit.\n//! Its implementation is somehow similar to the one by Edlib (Šošić and Šikić 2017),\n//! although there can be small differences when there is more than one possible alignment\n//! path with then same edit distance at a position: Edlib prefers to make insertions\n//! and deletions to the pattern (query) over substitutions\n//! (Insertion \u003e Deletion \u003e Substitution) while our implementation prefers substitutions\n//! (Substitution \u003e Insertion \u003e Deletion).\n//!\n//! *Myers, G. (1999). A fast bit-vector algorithm for approximate string matching based on dynamic\n//!  programming. Journal of the ACM (JACM) 46, 395–415.*\n//!\n//! *Šošić, M., and Šikić, M. (2017). Edlib: a C/C ++ library for fast, exact sequence alignment\n//! using edit distance. Bioinformatics 33, 1394–1395.*\n//!\n//! # Example\n//!\n//! Iterating over matches in pairs of `(end, distance)` using `u64` as bitvector type:\n//!\n//! ```\n//! # extern crate bio;\n//! use bio::pattern_matching::myers::Myers;\n//!\n//! # fn main() {\n//! let text = b\"CGGTCCTGAGGGATTAGCAC\";\n//! let pattern = b\"TCCTAGGGC\";\n//!\n//! let myers = Myers::\u003cu64\u003e::new(pattern);\n//! let occ: Vec\u003c_\u003e = myers.find_all_end(text, 2).collect();\n//!\n//! assert_eq!(occ, [(11, 2), (12, 2)]);\n//! # }\n//! ```\n//!\n//! Starting with stable Rust 1.26, it is also possible to use `u128` as bitvector\n//! (`Myers::\u003cu128\u003e`), which enables longer patterns, but is somewhat slower.\n//!\n//! # Long patterns\n//!\n//! With the default implementation, query (pattern) length is limited by the size of the\n//! bit-vector; 64 symbols for `Myers::\u003cu64\u003e`. Patterns longer than 128 symbols (when using\n//! `u128` as bit-vector) can only be handled by using the block-based Myers implementation,\n//! which lives in the [`long`](long/index.html) submodule. An example:\n//!\n//! ```\n//! # extern crate bio;\n//! use bio::pattern_matching::myers::{long, Myers};\n//!\n//! # fn main() {\n//! let text = b\"CGGTCCTGAGGGATTAGCAC\";\n//! let pattern = b\"TCCTAGGGC\";\n//!\n//! let myers_64 = Myers::\u003cu64\u003e::new(pattern);\n//! let occ_64: Vec\u003c_\u003e = myers_64.find_all_end(text, 2).collect();\n//!\n//! // the pattern of length 9 is too long to fit into a single `u8` bit-vector\n//! // (panics!)\n//! // let myers_8 = Myers::\u003cu8\u003e::new(pattern);\n//!\n//! // However, we can use the block-based implementation with `u8` bit-vectors\n//! let myers_long_8 = long::Myers::\u003cu8\u003e::new(pattern);\n//! let occ_long_8: Vec\u003c_\u003e = myers_long_8\n//!     .find_all_end(text, 2)\n//!     .map(|(end, dist)| (end, dist as u8))\n//!     .collect();\n//!\n//! assert_eq!(occ_64, occ_long_8);\n//! # }\n//! ```\n//! Note that `u8` just used for demonstration, using `u64` is still the best in most cases.\n//!\n//! # Obtaining the starting position of a match\n//!\n//! The `Myers::find_all` method provides an iterator over tuples of `(start, end, distance)`.\n//! Calculating the starting position requires finding the alignment path, therefore this is\n//! slower than `Myers::find_all_end`. Note that the end positions differ from above by one.\n//! This is intentional, as the iterator returns a range rather an index, and ranges in Rust\n//! do not include the end position by default.\n//!\n//! ```\n//! # extern crate bio;\n//! use bio::pattern_matching::myers::Myers;\n//!\n//! # fn main() {\n//! let text = b\"CGGTCCTGAGGGATTAGCAC\";\n//! let pattern = b\"TCCTAGGGC\";\n//!\n//! let mut myers = Myers::\u003cu64\u003e::new(pattern);\n//! let occ: Vec\u003c_\u003e = myers.find_all(text, 2).collect();\n//!\n//! assert_eq!(occ, [(3, 12, 2), (3, 13, 2)]);\n//! # }\n//! ```\n//!\n//! # Obtaining alignments\n//!\n//! [`FullMatches`](struct.FullMatches.html) returned by `Myers::find_all()` also provide a method\n//! for obtaining an alignment path:\n//!\n//! ```\n//! # extern crate bio;\n//! use bio::alignment::Alignment;\n//! use bio::pattern_matching::myers::Myers;\n//!\n//! # fn main() {\n//! let text = b\"CGGTCCTGAGGGATTAGCAC\";\n//! let pattern = b\"TCCTAGGGC\";\n//!\n//! let mut myers = Myers::\u003cu64\u003e::new(pattern);\n//! // create an 'empty' alignment instance, which can be reused\n//! let mut aln = Alignment::default();\n//!\n//! let mut matches = myers.find_all(text, 3);\n//! while matches.next_alignment(\u0026mut aln) {\n//!     //println!(\"Hit fond in range: {}..{} (distance: {})\", aln.ystart, aln.yend, aln.score);\n//!     //println!(\"{}\", aln.pretty(pattern, text));\n//! }\n//! # }\n//! ```\n//! **Output:**\n//!\n//! \u003cpre\u003e\n//! Hit fond in range: 3..10 (distance: 3)\n//!    TCCTAGGGC\n//!    ||||+|\\|+\n//! TCCTCCT-GAG-GGATTAGCAC\n//!\n//! Hit fond in range: 3..11 (distance: 3)\n//!    TCCTAGGGC\n//!    ||||+|\\|\\\n//! TCCTCCT-GAGGGATTAGCAC\n//!\n//! Hit fond in range: 3..12 (distance: 2)\n//!    TCCT-AGGGC\n//!    ||||x||||+\n//! TCCTCCTGAGGG-ATTAGCAC\n//!\n//! Hit fond in range: 3..13 (distance: 2)\n//!    TCCT-AGGGC\n//!    ||||x||||\\\n//! TCCTCCTGAGGGATTAGCAC\n//!\n//! ... (truncated)\n//!\n//! \u003c/pre\u003e\n//!\n//! **Note** that the [`Alignment`](../../alignment/struct.Alignment.html) instance is only created\n//! once and then reused. Because the Myers algorithm is very fast, the allocation necessary for\n//! `Alignment::operations` can have a non-negligible impact on performance; and thus, recycling\n//! makes sense.\n//!\n//! # Finding the best hit\n//!\n//! In many cases, only the match with the smallest edit distance is actually of interest.\n//! Calculating an alignment for every hit is therefore not necessary.\n//! [`LazyMatches`](struct.LazyMatches.html) returned by `Myers::find_all_lazy()`\n//! provide an iterator over tuples of `(end, distance)` like `Myers::find_all_end()`, but\n//! additionally keep the data necessary for calculating the alignment path later at any desired\n//! position. Storing the data itself has a slight performance impact and requires more memory\n//! compared to `Myers::find_all_end()` [O(n) as opposed to O(m + k)]. Still the following code\n//! is faster than using `FullMatches`:\n//!\n//! ```\n//! # extern crate bio;\n//! use bio::alignment::Alignment;\n//! use bio::pattern_matching::myers::Myers;\n//!\n//! # fn main() {\n//! let text = b\"CGGTCCTGAGGGATTAGCAC\";\n//! let pattern = b\"TCCTAGGGC\";\n//!\n//! let mut myers = Myers::\u003cu64\u003e::new(pattern);\n//! let mut aln = Alignment::default();\n//!\n//! let mut matches = myers.find_all_lazy(text, 2);\n//!\n//! // first, find the best hit\n//! let (best_end, _) = matches.by_ref().min_by_key(|\u0026(_, dist)| dist).unwrap();\n//!\n//! // now calculate the alignment\n//! matches.alignment_at(best_end, \u0026mut aln);\n//! println!(\n//!     \"Best alignment at {}..{} (distance: {})\",\n//!     aln.ystart, aln.yend, aln.score\n//! );\n//! println!(\"{}\", aln.pretty(pattern, text));\n//! # }\n//! ```\n//!\n//! **Output:**\n//!\n//! \u003cpre\u003e\n//! Best alignment at 3..12 (distance: 2)\n//!    TCCT-AGGGC\n//!    ||||x||||+\n//! TCCTCCTGAGGG-ATTAGCAC\n//! \u003c/pre\u003e\n//!\n//! Actually as seen in the previous chapters, there are two hits with the same distance of 2.\n//! It may make sense to consider both of them.\n//!\n//! # Dealing with ambiguities\n//!\n//! Matching multiple or all symbols at once can be achieved using `MyersBuilder`. This example\n//! allows `N` in the search pattern to match all four DNA bases in the text:\n//!\n//! ```\n//! # extern crate bio;\n//! use bio::pattern_matching::myers::MyersBuilder;\n//!\n//! # fn main() {\n//! let text = b\"GTCTGATCTTACC\";\n//! let pattern = b\"TGATCNT\";\n//!\n//! let myers = MyersBuilder::new().ambig(b'N', b\"ACGT\").build_64(pattern);\n//! assert_eq!(myers.distance(text), 0);\n//! # }\n//! ```\n//!\n//! For more examples see the documentation of [`MyersBuilder`](struct.MyersBuilder.html).\n\n#[macro_use]\nmod myers_impl;\nmod builder;\nmod helpers;\n#[cfg(test)]\n#[macro_use]\npub(crate) mod common_tests;\npub mod long;\nmod simple;\nmod traceback;\n\npub use self::builder::MyersBuilder;\npub use self::helpers::*;\nuse self::myers_impl::*;\npub use self::simple::*;\n\n#[cfg(test)]\nmod tests {\n    // from common_tests.rs\n    impl_tests!(super, u64, u8, build_64);\n\n    use std::iter::repeat;\n\n    #[test]\n    #[should_panic(expected = \"Pattern too long\")]\n    fn test_pattern_too_long() {\n        let pattern: Vec\u003c_\u003e = repeat(b'T').take(65).collect();\n        super::Myers::\u003cu8\u003e::new(\u0026pattern);\n    }\n\n    #[test]\n    #[should_panic(expected = \"Pattern too long\")]\n    fn test_pattern_too_long_builder() {\n        let pattern: Vec\u003c_\u003e = repeat(b'T').take(65).collect();\n        super::MyersBuilder::new().build_64(\u0026pattern);\n    }\n}\n","traces":[{"line":256,"address":[4398768,4398624],"length":1,"stats":{"Line":0},"fn_name":"test_pattern_too_long"},{"line":257,"address":[4398631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[4398701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[4398800,4399019],"length":1,"stats":{"Line":0},"fn_name":"test_pattern_too_long_builder"},{"line":264,"address":[4398807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[4398947,4398875],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","home","todd","rust-bio","src","pattern_matching","myers","myers_impl.rs"],"content":"use crate::pattern_matching::myers::{BitVec, DistType};\nuse num_traits::ToPrimitive;\n\n/// The current algorithm state.\n#[derive(Clone, Default, Debug)]\npub(crate) struct State\u003cT, D\u003e\nwhere\n    T: BitVec,\n    D: std::fmt::Debug,\n{\n    pub pv: T,\n    pub mv: T,\n    pub dist: D,\n}\n\nimpl\u003cT, D\u003e State\u003cT, D\u003e\nwhere\n    T: BitVec,\n    D: DistType,\n{\n    /// Create and initiate leftmost block given the maximum pattern length\n    // it should represent (m)\n    #[inline]\n    pub fn init(m: D) -\u003e Self {\n        State {\n            pv: T::max_value(),\n            mv: T::zero(),\n            dist: m,\n        }\n    }\n\n    #[inline]\n    pub fn max() -\u003e Self {\n        Self::init(D::max_value())\n    }\n\n    #[inline]\n    pub fn known_dist(\u0026self) -\u003e Option\u003cD\u003e {\n        Some(self.dist)\n    }\n\n    pub fn is_new(\u0026self) -\u003e bool {\n        self.dist == D::zero() \u0026\u0026 self.pv == T::zero() \u0026\u0026 self.mv == T::zero()\n    }\n\n    pub fn is_max(\u0026self) -\u003e bool {\n        self.pv \u003e= (T::max_value() \u003e\u003e 1) \u0026\u0026 self.mv == T::zero()\n    }\n\n    // Adjust the distance of the block ('moving the cursor up in the traceback matrix')\n    // given a range bit mask that specifies which positions should be crossed.\n    #[inline]\n    pub fn adjust_by_mask(\u0026mut self, mask: T) {\n        let p = (self.pv \u0026 mask).count_ones();\n        let m = (self.mv \u0026 mask).count_ones();\n        let mut dist = self.dist.to_u64().unwrap();\n        dist = dist.wrapping_add(m.to_u64().unwrap());\n        dist = dist.wrapping_sub(p.to_u64().unwrap());\n        self.dist = D::from_u64(dist).unwrap();\n    }\n\n    #[inline]\n    pub fn adjust_dist(\u0026mut self, pos_mask: T) {\n        //debug_assert!(!self.is_max());\n        if self.pv \u0026 pos_mask != T::zero() {\n            self.dist -= D::one();\n        } else if self.mv \u0026 pos_mask != T::zero() {\n            self.dist += D::one();\n        }\n\n        // not faster:\n        // let diff = ((self.mv \u0026 pos_mask) != T::zero()) as isize - ((self.pv \u0026 pos_mask) != T::zero()) as isize;\n        // self.dist = D::from_usize(self.dist.to_usize().unwrap().wrapping_add(diff as usize)).unwrap();\n    }\n\n    /// This method may be used for performance comparison instead of adjust_by_mask()\n    #[inline]\n    #[allow(dead_code)]\n    pub fn adjust_many(\u0026mut self, pos_mask: T, n: usize) {\n        let mut pos_mask = pos_mask;\n        for _ in 0..n {\n            self.adjust_dist(pos_mask);\n            pos_mask \u003c\u003c= 1;\n        }\n    }\n\n    /// Writes a distance matrix column to the vector 'out'\n    /// (excluding the uppermost state distance).\n    /// This is done in a reverse order (lowest / highest value first).\n    /// Used for debugging.\n    pub fn write_dist_column(\u0026self, m: usize, out: \u0026mut Vec\u003cD\u003e) {\n        let mut pos_mask = T::one() \u003c\u003c (m - 1);\n        let mut dist = self.dist;\n        for _ in 0..m {\n            out.push(dist);\n            if dist != D::max_value() {\n                if self.pv \u0026 pos_mask != T::zero() {\n                    dist -= D::one();\n                } else if self.mv \u0026 pos_mask != T::zero() {\n                    dist += D::one();\n                }\n            }\n            pos_mask \u003e\u003e= 1;\n        }\n    }\n}\n\n#[rustfmt::skip]\n// rustfmt::skip prevents automatic indentation.\n// This is not optimal, as no checks are done at all..\nmacro_rules! impl_myers {\n    ($DistType:ty, $Myers:ty, $State:ty, $TbHandler:ty) =\u003e {\n        mod myers_impl {\n// Macro implementing common methods in Myers object. Wrapped in a module\n// and then re-exported from there to avoid mixing of namespaces.\n// Indented at top level for readability.\n\nuse super::Myers;\nuse crate::pattern_matching::myers::traceback::Traceback;\nuse crate::pattern_matching::myers::{update_aln, BitVec};\nuse crate::alignment::{Alignment, AlignmentOperation};\n#[allow(unused_imports)] // Bounded is required for \u003c$DistType\u003e::max_value()\nuse num_traits::{Bounded, ToPrimitive};\nuse std::borrow::Borrow;\nuse std::cmp::min;\nuse std::iter;\n\nimpl\u003cT: BitVec\u003e $Myers {\n    // Combining these two steps into one function seems beneficial for performance\n    fn step_trace\u003c'a\u003e(\n        \u0026mut self,\n        mut state: \u0026mut $State,\n        a: u8,\n        max_dist: $DistType,\n        traceback: \u0026mut Traceback\u003c'a, T, $DistType, $TbHandler\u003e,\n    ) {\n        self.step(\u0026mut state, a, max_dist);\n        traceback.add_state(\u0026state, \u0026mut self.states_store);\n    }\n\n    /// Calculate the global distance of the pattern to the given text.\n    pub fn distance\u003cC, I\u003e(\u0026self, text: I) -\u003e $DistType\n    where\n        C: Borrow\u003cu8\u003e,\n        I: IntoIterator\u003cItem = C\u003e,\n    {\n        let max_dist = \u003c$DistType\u003e::max_value();\n        let mut dist = max_dist;\n        let m = self.m;\n        let mut state = self.initial_state(m, max_dist);\n        for a in text {\n            self.step(\u0026mut state, *a.borrow(), max_dist);\n            if let Some(d) = state.known_dist() {\n                if d \u003c dist {\n                    dist = d;\n                }\n            }\n        }\n        dist\n    }\n\n    /// Finds all matches of pattern in the given text up to a given maximum distance.\n    /// Matches are returned as an iterator over pairs of end position and distance.\n    pub fn find_all_end\u003cC, I\u003e(\n        \u0026self,\n        text: I,\n        max_dist: $DistType,\n    ) -\u003e Matches\u003cT, C, I::IntoIter\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        I: IntoIterator\u003cItem = C\u003e,\n    {\n        Matches::new(self, text.into_iter(), max_dist)\n    }\n\n    /// Find the best match of the pattern in the given text.\n    /// if multiple end positions have the same distance, the first is returned.\n    pub fn find_best_end\u003cC, I\u003e(\u0026self, text: I) -\u003e (usize, $DistType)\n    where\n        C: Borrow\u003cu8\u003e,\n        I: IntoIterator\u003cItem = C\u003e,\n    {\n        self.find_all_end(text, \u003c$DistType\u003e::max_value())\n            .min_by_key(|\u0026(_, dist)| dist)\n            .unwrap()\n    }\n\n    /// Finds all matches of pattern in the given text up to a given maximum distance.\n    /// In contrast to `find_all_end`, matches are returned as an iterator over ranges\n    /// of `(start, end, distance)`. Note that the end coordinate is not included in the\n    /// range and thus and thus greater by one compared to the end index returned by\n    /// `find_all_end()`.\n    pub fn find_all\u003cC, I\u003e(\n        \u0026mut self,\n        text: I,\n        max_dist: $DistType,\n    ) -\u003e FullMatches\u003c'_, T, C, I::IntoIter\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        I: IntoIterator\u003cItem = C\u003e,\n        I::IntoIter: ExactSizeIterator,\n    {\n        FullMatches::new(self, text.into_iter(), max_dist)\n    }\n\n    /// As `find_all_end`, this function returns an iterator over tuples of `(end, distance)`.\n    /// Additionally, it keeps the data necessary for later obtaining the starting positions and/or\n    /// the alignment path at *any* position that was already searched.\n    pub fn find_all_lazy\u003cC, I\u003e(\n        \u0026mut self,\n        text: I,\n        max_dist: $DistType,\n    ) -\u003e LazyMatches\u003c'_, T, C, I::IntoIter\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        I: IntoIterator\u003cItem = C\u003e,\n        I::IntoIter: ExactSizeIterator,\n    {\n        LazyMatches::new(self, text.into_iter(), max_dist)\n    }\n}\n\n/// Iterator over pairs of end positions and distance of matches.\npub struct Matches\u003c'a, T, C, I\u003e\nwhere\n    T: BitVec,\n    C: Borrow\u003cu8\u003e,\n    I: Iterator\u003cItem = C\u003e,\n{\n    myers: \u0026'a $Myers,\n    state: $State,\n    text: iter::Enumerate\u003cI\u003e,\n    max_dist: $DistType,\n}\n\nimpl\u003c'a, T, C, I\u003e Matches\u003c'a, T, C, I\u003e\nwhere\n    T: BitVec,\n    C: Borrow\u003cu8\u003e,\n    I: Iterator\u003cItem = C\u003e,\n{\n    fn new(myers: \u0026'a Myers\u003cT\u003e, text: I, max_dist: $DistType) -\u003e Self {\n        let m = myers.m;\n        let state = myers.initial_state(m, max_dist);\n        Matches {\n            myers,\n            state,\n            text: text.enumerate(),\n            max_dist,\n        }\n    }\n}\n\nimpl\u003c'a, T, C, I\u003e Iterator for Matches\u003c'a, T, C, I\u003e\nwhere\n    T: BitVec,\n    C: Borrow\u003cu8\u003e,\n    I: Iterator\u003cItem = C\u003e,\n{\n    type Item = (usize, $DistType);\n\n    fn next(\u0026mut self) -\u003e Option\u003c(usize, $DistType)\u003e {\n        for (i, a) in self.text.by_ref() {\n            self.myers.step(\u0026mut self.state, *a.borrow(), self.max_dist);\n            if let Some(dist) = self.state.known_dist() {\n                if dist \u003c= self.max_dist {\n                    return Some((i, dist));\n                }\n            }\n        }\n        None\n    }\n}\n\n/// Iterator over tuples of starting position, end position and distance of matches. In addition,\n/// methods for obtaining the hit alignment path are provided.\npub struct FullMatches\u003c'a, T, C, I\u003e\nwhere\n    T: BitVec,\n    C: Borrow\u003cu8\u003e,\n    I: Iterator\u003cItem = C\u003e,\n{\n    myers: \u0026'a mut $Myers,\n    traceback: Traceback\u003c'a, T, $DistType, $TbHandler\u003e,\n    state: $State,\n    text: iter::Enumerate\u003cI\u003e,\n    text_len: usize,\n    m: $DistType,\n    max_dist: $DistType,\n    pos: usize, // current end position, has to be stored for alignment() method\n    unsuccessfully_finished: bool,\n}\n\nimpl\u003c'a, T, C, I\u003e FullMatches\u003c'a, T, C, I\u003e\nwhere\n    T: 'a + BitVec,\n    C: Borrow\u003cu8\u003e,\n    I: Iterator\u003cItem = C\u003e + ExactSizeIterator,\n{\n    fn new(myers: \u0026'a mut $Myers, text_iter: I, max_dist: $DistType) -\u003e Self {\n        let state = myers.initial_state(myers.m, max_dist);\n        // Calculate maximum number of traceback columns possibly used by a match\n        let m = myers.m.to_usize().unwrap();\n        let num_cols = m + min(max_dist.to_usize().unwrap(), m);\n        let tb = Traceback::new(\n            \u0026mut myers.states_store,\n            \u0026state,\n            num_cols.to_usize().unwrap(),\n            myers.m,\n            \u003c$TbHandler\u003e::new(),\n        );\n        FullMatches {\n            m: myers.m,\n            myers,\n            traceback: tb,\n            state,\n            text_len: text_iter.len(),\n            text: text_iter.enumerate(),\n            max_dist,\n            pos: 0,\n            unsuccessfully_finished: false,\n        }\n    }\n\n    /// Searches the next match and returns a tuple of end position and distance\n    /// if found. This involves *no* searching for a starting position and is thus\n    /// faster than just iterating over `FullMatches`\n    #[inline]\n    pub fn next_end(\u0026mut self) -\u003e Option\u003c(usize, $DistType)\u003e {\n        for (i, a) in self.text.by_ref() {\n            self.pos = i; // used in alignment()\n            self.myers.step_trace(\n                \u0026mut self.state,\n                *a.borrow(),\n                self.max_dist,\n                \u0026mut self.traceback,\n            );\n            if let Some(dist) = self.state.known_dist() {\n                if dist \u003c= self.max_dist {\n                    return Some((i, dist));\n                }\n            }\n        }\n        self.unsuccessfully_finished = true;\n        None\n    }\n\n    /// Searches the next match and returns a tuple of starting position, end position and\n    /// distance, or `None` if no match was found. In addition, the alignment path is added to\n    /// `ops`. Existing data in the vector will be cleared beforehand.\n    #[inline]\n    pub fn next_path(\n        \u0026mut self,\n        ops: \u0026mut Vec\u003cAlignmentOperation\u003e,\n    ) -\u003e Option\u003c(usize, usize, $DistType)\u003e {\n        self.next_end()\n            .map(|(end, dist)| (self.path(ops).unwrap(), end + 1, dist))\n    }\n\n    /// Like `FullMatches::path_reverse()`, but the operations will be in reverse order. This\n    /// is slightly faster, as the traceback algorithm adds them in reverse order,\n    /// and `path()` needs to reverse them. Existing data in the vector will be cleared\n    /// beforehand.\n    #[inline]\n    pub fn next_path_reverse(\n        \u0026mut self,\n        ops: \u0026mut Vec\u003cAlignmentOperation\u003e,\n    ) -\u003e Option\u003c(usize, usize, $DistType)\u003e {\n        self.next_end()\n            .map(|(end, dist)| (self.path_reverse(ops).unwrap(), end + 1, dist))\n    }\n\n    /// Searches the next match and updates the given `Alignment` with its position\n    /// and alignment path if found. The distance is stored in `Alignment::score`.\n    /// If no next hit is found, `false` is returned and `aln` remains unchanged.\n    #[inline]\n    pub fn next_alignment(\u0026mut self, aln: \u0026mut Alignment) -\u003e bool {\n        if self.next_end().is_some() {\n            self.alignment(aln);\n            return true;\n        }\n        false\n    }\n\n    /// Returns the starting position of the current hit. If the search is finished and no hit was\n    /// found, `None` is returned.\n    #[inline]\n    pub fn start(\u0026self) -\u003e Option\u003cusize\u003e {\n        if self.unsuccessfully_finished {\n            return None;\n        }\n        let (len, _) = self.traceback.traceback(None, \u0026self.myers.states_store);\n        Some(self.pos + 1 - len.to_usize().unwrap())\n    }\n\n    /// Adds the path of the current hit alignment to `ops` and returns the starting position of\n    /// the current hit. If the search is finished and no hit was found, `None` is returned.\n    /// Adds the path of the current hit alignment to `ops` and returns the starting position of\n    /// the current hit. If the search is finished and no hit was found, `None` is returned.\n    /// Existing data in the vector will be cleared beforehand.\n    #[inline]\n    pub fn path(\u0026self, ops: \u0026mut Vec\u003cAlignmentOperation\u003e) -\u003e Option\u003cusize\u003e {\n        self.path_reverse(ops).map(|pos| {\n            ops.reverse();\n            pos\n        })\n    }\n\n    /// Like `FullMatches::path()`, but the operations will be in reverse order. This\n    /// is slightly faster, as the traceback algorithm adds them in reverse order,\n    /// and `path()` needs to reverse them.\n    /// Existing data in the vector will be cleared beforehand.\n    #[inline]\n    pub fn path_reverse(\u0026self, ops: \u0026mut Vec\u003cAlignmentOperation\u003e) -\u003e Option\u003cusize\u003e {\n        if self.unsuccessfully_finished {\n            return None;\n        }\n        ops.clear();\n        let (len, _) = self\n            .traceback\n            .traceback(Some(ops), \u0026self.myers.states_store);\n        Some(self.pos + 1 - len.to_usize().unwrap())\n    }\n\n    /// Updates the given `Alignment` with its position and alignment path. The edit distance is\n    /// stored in `Alignment::score`. If no hit has been found yet, then `false` will be returned\n    /// and nothing is done.\n    #[inline]\n    pub fn alignment(\u0026mut self, aln: \u0026mut Alignment) -\u003e bool {\n        if self.unsuccessfully_finished {\n            return false;\n        }\n        if let Some(dist) = self.state.known_dist() {\n            aln.operations.clear();\n            let (len, _) = self\n                .traceback\n                .traceback(Some(\u0026mut aln.operations), \u0026self.myers.states_store);\n            aln.operations.reverse();\n            update_aln(\n                self.pos,\n                len.to_usize().unwrap(),\n                self.text_len,\n                dist.to_usize().unwrap(), //self.state.dist().to_usize().unwrap(),\n                self.m.to_usize().unwrap(),\n                aln,\n            );\n            true\n        } else {\n            false\n        }\n    }\n}\n\nimpl\u003c'a, T, C, I\u003e Iterator for FullMatches\u003c'a, T, C, I\u003e\nwhere\n    T: 'a + BitVec,\n    C: Borrow\u003cu8\u003e,\n    I: Iterator\u003cItem = C\u003e + ExactSizeIterator,\n{\n    type Item = (usize, usize, $DistType);\n\n    #[inline]\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.next_end()\n            .map(|(end, dist)| (self.start().unwrap(), end + 1, dist))\n    }\n}\n\n/// Iterator over tuples of end position and distance of matches. In addition,\n/// methods for obtaining the hit alignment path are provided.\npub struct LazyMatches\u003c'a, T, C, I\u003e\nwhere\n    T: BitVec,\n    C: Borrow\u003cu8\u003e,\n    I: Iterator\u003cItem = C\u003e,\n{\n    myers: \u0026'a mut $Myers,\n    traceback: Traceback\u003c'a, T, $DistType, $TbHandler\u003e,\n    state: $State,\n    text: iter::Enumerate\u003cI\u003e,\n    text_len: usize,\n    m: $DistType,\n    max_dist: $DistType,\n}\n\nimpl\u003c'a, T, C, I\u003e Iterator for LazyMatches\u003c'a, T, C, I\u003e\nwhere\n    T: BitVec,\n    C: Borrow\u003cu8\u003e,\n    I: Iterator\u003cItem = C\u003e + ExactSizeIterator,\n{\n    type Item = (usize, $DistType);\n\n    fn next(\u0026mut self) -\u003e Option\u003c(usize, $DistType)\u003e {\n        for (i, a) in self.text.by_ref() {\n            self.myers.step_trace(\n                \u0026mut self.state,\n                *a.borrow(),\n                self.max_dist,\n                \u0026mut self.traceback,\n            );\n            // self.traceback\n            //     .add_state(\u0026self.state, \u0026mut self.myers.states_store);\n            if let Some(dist) = self.state.known_dist() {\n                if dist \u003c= self.max_dist {\n                    return Some((i, dist));\n                }\n            }\n        }\n        None\n    }\n}\n\nimpl\u003c'a, T, C, I\u003e LazyMatches\u003c'a, T, C, I\u003e\nwhere\n    T: 'a + BitVec,\n    C: Borrow\u003cu8\u003e,\n    I: Iterator\u003cItem = C\u003e + ExactSizeIterator,\n{\n    #[inline]\n    fn new(myers: \u0026'a mut Myers\u003cT\u003e, text_iter: I, max_dist: $DistType) -\u003e Self {\n        let state = myers.initial_state(myers.m, max_dist);\n        let tb = Traceback::new(\n            \u0026mut myers.states_store,\n            \u0026state,\n            text_iter.len(),\n            myers.m,\n            \u003c$TbHandler\u003e::new(),\n        );\n        LazyMatches {\n            m: myers.m,\n            myers,\n            traceback: tb,\n            state,\n            text_len: text_iter.len(),\n            text: text_iter.enumerate(),\n            max_dist,\n        }\n    }\n\n    /// Takes the end position of a hit (as returned by the `LazyMatches` iterator) and returns a\n    /// tuple of the corresponding starting position and the hit distance. If the end position is\n    /// greater than the end position of the previously returned hit, `None` is returned.\n    #[inline]\n    pub fn hit_at(\u0026self, end_pos: usize) -\u003e Option\u003c(usize, $DistType)\u003e {\n        self.traceback\n            .traceback_at(end_pos, None, \u0026self.myers.states_store)\n            .map(|(len, dist)| (end_pos + 1 - len.to_usize().unwrap(), dist))\n    }\n\n    /// Takes the end position of a hit and returns a tuple of the corresponding starting position\n    /// and the hit distance. The alignment path is added to `ops`.\n    /// As in `hit_at`, the end position has to be searched already, otherwise `None` is returned.\n    #[inline]\n    pub fn path_at(\n        \u0026self,\n        end_pos: usize,\n        ops: \u0026mut Vec\u003cAlignmentOperation\u003e,\n    ) -\u003e Option\u003c(usize, $DistType)\u003e {\n        self.path_at_reverse(end_pos, ops).map(|rv| {\n            ops.reverse();\n            rv\n        })\n    }\n\n    /// Like `LazyMatches::path_at()`, but the operations will be in reverse order. This\n    /// is slightly faster, as the traceback algorithm adds them in reverse order,\n    /// and `path_at()` needs to reverse them.\n    #[inline]\n    pub fn path_at_reverse(\n        \u0026self,\n        end_pos: usize,\n        ops: \u0026mut Vec\u003cAlignmentOperation\u003e,\n    ) -\u003e Option\u003c(usize, $DistType)\u003e {\n        self.traceback\n            .traceback_at(end_pos, Some(ops), \u0026self.myers.states_store)\n            .map(|(len, dist)| (end_pos + 1 - len.to_usize().unwrap(), dist))\n    }\n\n    /// Takes the end position of a hit and returns a tuple of the corresponding starting position\n    /// and the hit distance. The alignment `aln` is updated with the position, alignment path\n    /// and distance (stored in `Alignment::score`).\n    /// If the end position has not yet been searched, nothing is done and `false` is returned.\n    /// This function will succeed even if the edit distance at the given position is greater\n    /// than the maximum distance specified when calling `Myers::find_all_lazy`. However, this\n    /// is only true for the implementation with restricted pattern lengths (in module\n    /// `bio::pattern_matching::myers`). The block-based implementation (in the `long`\n    /// submodule) avoids computing blocks with values \u003e max_dist.\n    #[inline]\n    pub fn alignment_at(\u0026self, end_pos: usize, aln: \u0026mut Alignment) -\u003e bool {\n        aln.operations.clear();\n        if let Some((aln_len, dist)) = self.traceback.traceback_at(\n            end_pos,\n            Some(\u0026mut aln.operations),\n            \u0026self.myers.states_store,\n        ) {\n            aln.operations.reverse();\n            update_aln(\n                end_pos,\n                aln_len.to_usize().unwrap(),\n                self.text_len,\n                dist.to_usize().unwrap(),\n                self.m.to_usize().unwrap(),\n                aln,\n            );\n            return true;\n        }\n        false\n    }\n}\n\n// module end\n}\n\npub use myers_impl::*;\n\n// macro end\n};\n}\n","traces":[{"line":24,"address":[9758496,9758416,9758336,9758240],"length":1,"stats":{"Line":0},"fn_name":"init\u003cu64,u8\u003e"},{"line":26,"address":[9758265,9758430,9758520,9758351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[9758275,9758530,9758439,9758360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[9758640,9758688,9758592,9758768],"length":1,"stats":{"Line":0},"fn_name":"max\u003cu64,u8\u003e"},{"line":34,"address":[9758605,9758772,9758692,9758653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[9758848,9758880],"length":1,"stats":{"Line":0},"fn_name":"known_dist\u003cu8,u8\u003e"},{"line":39,"address":[9758889,9758857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[9760368,9759408,9758912,9759888],"length":1,"stats":{"Line":0},"fn_name":"adjust_by_mask\u003cu8,usize\u003e"},{"line":54,"address":[9760401,9759927,9758952,9759445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[9759008,9759979,9759497,9760447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[9760483,9759057,9759537,9760018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[9759103,9760068,9760636,9759587,9760533,9760171,9759206,9759690],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[9759317,9760747,9760179,9760644,9759801,9759214,9760282,9759698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[9760755,9759809,9760290,9759325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[9760848,9761568,9761088,9761328],"length":1,"stats":{"Line":0},"fn_name":"adjust_dist\u003cu8,u8\u003e"},{"line":65,"address":[9761352,9760993,9761469,9761709,9761593,9761112,9761230,9760873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[9760958,9761684,9761435,9761195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[9761237,9761174,9761000,9761656,9761791,9761554,9761414,9761716,9761318,9761316,9761080,9760935,9761078,9761476,9761556,9761789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[9761765,9761283,9761522,9761045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[4496032,4495904],"length":1,"stats":{"Line":0},"fn_name":"step_trace\u003cu64\u003e"},{"line":137,"address":[4496073,4495945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[4495966,4496094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[4496726,4496160],"length":1,"stats":{"Line":0},"fn_name":"distance\u003cu64,\u0026u8,\u0026[u8; 8]\u003e"},{"line":147,"address":[4496193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[4496237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[4496247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[4496258,4496241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[4496468,4496316,4496456,4496702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[4496509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[4496588,4496671],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[4496695,4496658,4496679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[4496687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[4496752,4496896],"length":1,"stats":{"Line":0},"fn_name":"find_all_end\u003cu64,\u0026u8,\u0026[u8]\u003e"},{"line":173,"address":[4496823,4496948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[4497264,4497152,4497008],"length":1,"stats":{"Line":0},"fn_name":"find_all\u003cu64,\u0026u8,\u0026[u8]\u003e"},{"line":203,"address":[4497316,4497079,4497204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[4497376],"length":1,"stats":{"Line":0},"fn_name":"find_all_lazy\u003cu64,\u0026u8,\u0026[u8]\u003e"},{"line":219,"address":[4497447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[4500142,4499824],"length":1,"stats":{"Line":0},"fn_name":"new\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":243,"address":[4499941,4499919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[4499935,4499952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[4500074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[4499977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[4499997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[4500160,4500809],"length":1,"stats":{"Line":0},"fn_name":"next\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":263,"address":[4500363,4500395,4500198,4500804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[4500484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[4500589,4500698,4500712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[4500706,4500673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[4500724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[4500378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[4500832,4503147,4501979,4502000],"length":1,"stats":{"Line":0},"fn_name":"new\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":301,"address":[4502076,4500950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[4501003,4502282,4501096,4502189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[4501343,4501149,4502335,4502523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[4502630,4501450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[4501301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[4502500,4501320,4502565,4501385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[4501419,4502599],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[4501429,4502609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[4501821,4502999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[4501485,4502665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[4501495,4502675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[4502723,4501543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[4502929,4501751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[4502988,4501810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[4503838,4504525,4503856,4503168],"length":1,"stats":{"Line":0},"fn_name":"next_end\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":330,"address":[4503833,4503206,4503894,4503412,4504100,4504520,4504059,4503371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[4503501,4504189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[4503505,4504193,4503572,4504260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[4504201,4503513],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[4503530,4504218],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[7687775,7687087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[4504253,4503565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[4504305,4504414,4503727,4503741,4504428,4503618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[4503735,4504389,4503702,4504422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[4504440,4503753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[4503391,4504079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[4503395,4504083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[4504544],"length":1,"stats":{"Line":0},"fn_name":"next_path\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":356,"address":[4504606,4504567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[4504586,4504640,4504685],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":377,"address":[4504848],"length":1,"stats":{"Line":0},"fn_name":"next_alignment\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":378,"address":[4504878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[4504929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[4504934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[4504912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[4504960,4505280],"length":1,"stats":{"Line":0},"fn_name":"start\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":389,"address":[4505294,4504974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[4505026,4505353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[4505065,4504985,4505305,4505392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[4505269,4505566,4505419,4505596,4505092,4505239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[4505600],"length":1,"stats":{"Line":0},"fn_name":"path\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":403,"address":[4505696,4505614],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":404,"address":[4505714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[4505760],"length":1,"stats":{"Line":0},"fn_name":"path_reverse\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":415,"address":[4505790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[4505808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[4505801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[4505845,4505902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[4505857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[4506106,4505929,4506076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[4506112],"length":1,"stats":{"Line":0},"fn_name":"alignment\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":430,"address":[4506151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[4506190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[4506913,4506165,4506908,4506218,4506277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[4506258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[4506295,4506377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[4506310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[4506413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[4506457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[4506466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[4506525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[4506534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[4506593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[4506900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[4506269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[4506928,4507008],"length":1,"stats":{"Line":0},"fn_name":"next\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":464,"address":[4506975,4507026,4506946,4507055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[4507088,4507045,4507319,4507127,4507280,4506965],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cu8,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":494,"address":[4508129,4507472],"length":1,"stats":{"Line":0},"fn_name":"next\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":495,"address":[4508124,4507510,4507675,4507707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[4507796,4507863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[4507804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[4507821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[7691420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[4507856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[4508032,4507909,4508018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[4507993,4508026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[4508044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[4507690],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[4508160,4509099],"length":1,"stats":{"Line":0},"fn_name":"new\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":522,"address":[4508273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[4508590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[4508321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[4508559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[4508569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[4508950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[4508625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[4508635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[4508683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[4508891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[4509120],"length":1,"stats":{"Line":0},"fn_name":"hit_at\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":546,"address":[4509220,4509278,4509144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[4509156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[4509354,4509273,4509328],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":555,"address":[4509552],"length":1,"stats":{"Line":0},"fn_name":"path_at\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":560,"address":[4509648,4509580],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":561,"address":[4509676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[4509728],"length":1,"stats":{"Line":0},"fn_name":"path_at_reverse\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":575,"address":[4509756,4509828,4509885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[4509768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[4509946,4509880,4509920],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":590,"address":[4510144],"length":1,"stats":{"Line":0},"fn_name":"alignment_at\u003cu64,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":591,"address":[4510218],"length":1,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[4510321,4510243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[4510255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[4510267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[4510439,4510499],"length":1,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[4510505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":601,"address":[4510564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[4510573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[4510632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[4510942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[4510461],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":185},{"path":["/","home","todd","rust-bio","src","pattern_matching","myers","simple.rs"],"content":"use std::borrow::Borrow;\nuse std::collections::HashMap;\nuse std::iter;\nuse std::marker::PhantomData;\nuse std::mem::{replace, size_of};\nuse std::slice;\nuse std::u64;\n\nuse num_traits::{FromPrimitive, One, ToPrimitive, Zero};\n\nuse crate::pattern_matching::myers::traceback::{StatesHandler, TracebackHandler};\nuse crate::pattern_matching::myers::{BitVec, State};\n\n/// Myers algorithm.\npub struct Myers\u003cT = u64\u003e\nwhere\n    T: BitVec,\n{\n    pub(crate) peq: [T; 256],\n    pub(crate) bound: T,\n    pub(crate) m: T::DistType,\n    pub(crate) states_store: Vec\u003cState\u003cT, T::DistType\u003e\u003e,\n}\n\nimpl\u003cT: BitVec\u003e Myers\u003cT\u003e {\n    /// Create a new instance of Myers algorithm for a given pattern.\n    #[inline]\n    pub fn new\u003cP, C\u003e(pattern: P) -\u003e Self\n    where\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        Self::new_ambig(pattern, None, None)\n    }\n\n    #[inline]\n    pub(crate) fn new_ambig\u003cP, C\u003e(\n        pattern: P,\n        opt_ambigs: Option\u003c\u0026HashMap\u003cu8, Vec\u003cu8\u003e\u003e\u003e,\n        opt_wildcards: Option\u003c\u0026[u8]\u003e,\n    ) -\u003e Self\n    where\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n        P::IntoIter: ExactSizeIterator,\n    {\n        let maxsize = T::DistType::from_usize(size_of::\u003cT\u003e() * 8).unwrap();\n        let pattern = pattern.into_iter();\n        let m = T::DistType::from_usize(pattern.len()).unwrap();\n        assert!(m \u003c= maxsize, \"Pattern too long\");\n        assert!(m \u003e T::DistType::zero(), \"Pattern is empty\");\n\n        let mut peq = [T::zero(); 256];\n\n        for (i, symbol) in pattern.enumerate() {\n            let symbol = *symbol.borrow();\n            let mask = T::one() \u003c\u003c i;\n            // equivalent\n            peq[symbol as usize] |= mask;\n            // ambiguities\n            if let Some(equivalents) = opt_ambigs.and_then(|ambigs| ambigs.get(\u0026symbol)) {\n                for \u0026eq in equivalents {\n                    peq[eq as usize] |= mask;\n                }\n            }\n        }\n\n        if let Some(wildcards) = opt_wildcards {\n            for \u0026w in wildcards {\n                peq[w as usize] = T::max_value();\n            }\n        }\n\n        Myers {\n            peq,\n            bound: T::one() \u003c\u003c (m.to_usize().unwrap() - 1),\n            m,\n            states_store: vec![],\n        }\n    }\n\n    #[inline]\n    fn initial_state(\u0026self, m: T::DistType, _: T::DistType) -\u003e State\u003cT, T::DistType\u003e {\n        State::init(m)\n    }\n\n    #[inline]\n    fn step(\u0026self, state: \u0026mut State\u003cT, T::DistType\u003e, a: u8, _: T::DistType) {\n        self._step(state, a);\n    }\n\n    #[inline]\n    fn _step(\u0026self, state: \u0026mut State\u003cT, T::DistType\u003e, a: u8) {\n        let eq = self.peq[a as usize];\n        let xv = eq | state.mv;\n        let xh = ((eq \u0026 state.pv).wrapping_add(\u0026state.pv) ^ state.pv) | eq;\n\n        let mut ph = state.mv | !(xh | state.pv);\n        let mut mh = state.pv \u0026 xh;\n\n        // if ph \u0026 self.bound \u003e T::zero() {\n        //     state.dist += T::DistType::one();\n        // } else if mh \u0026 self.bound \u003e T::zero() {\n        //     state.dist -= T::DistType::one();\n        // }\n        let diff = ((ph \u0026 self.bound) != T::zero()) as i8 - ((mh \u0026 self.bound) != T::zero()) as i8;\n        state.dist =\n            T::DistType::from_usize(state.dist.to_usize().unwrap().wrapping_add(diff as usize))\n                .unwrap();\n\n        ph \u003c\u003c= 1;\n        mh \u003c\u003c= 1;\n        state.pv = mh | !(xv | ph);\n        state.mv = ph \u0026 xv;\n    }\n\n    #[inline]\n    pub fn m(\u0026self) -\u003e T::DistType {\n        self.m\n    }\n}\n\n#[derive(Default)]\npub(super) struct ShortStatesHandler\u003c'a\u003e(PhantomData\u003c\u0026'a ()\u003e);\n\nimpl\u003c'a\u003e ShortStatesHandler\u003c'a\u003e {\n    #[inline]\n    pub fn new() -\u003e Self {\n        ShortStatesHandler(PhantomData)\n    }\n}\n\nimpl\u003c'a, T: BitVec + 'a\u003e StatesHandler\u003c'a, T, T::DistType\u003e for ShortStatesHandler\u003c'a\u003e {\n    type TracebackHandler = ShortTracebackHandler\u003c'a, T\u003e;\n    type TracebackColumn = State\u003cT, T::DistType\u003e;\n\n    #[inline]\n    fn init(\u0026mut self, n: usize, _: T::DistType) -\u003e usize {\n        n\n    }\n\n    #[inline]\n    fn set_max_state(\u0026self, pos: usize, states: \u0026mut [State\u003cT, T::DistType\u003e]) {\n        //states[pos] = State::max();\n        *unsafe { states.get_unchecked_mut(pos) } = State::max();\n    }\n\n    #[inline]\n    fn add_state(\n        \u0026self,\n        source: \u0026Self::TracebackColumn,\n        pos: usize,\n        states: \u0026mut [State\u003cT, T::DistType\u003e],\n    ) {\n        //states[pos] = source.clone();\n        *unsafe { states.get_unchecked_mut(pos) } = source.clone();\n    }\n\n    #[inline]\n    fn init_traceback(\n        \u0026self,\n        m: T::DistType,\n        pos: usize,\n        states: \u0026'a [State\u003cT, T::DistType\u003e],\n    ) -\u003e Self::TracebackHandler {\n        ShortTracebackHandler::new(m, pos, states)\n    }\n}\n\ntype RevColIter\u003c'a, T\u003e = iter::Rev\u003cslice::Iter\u003c'a, State\u003cT, \u003cT as BitVec\u003e::DistType\u003e\u003e\u003e;\n\npub(super) struct ShortTracebackHandler\u003c'a, T: BitVec\u003e {\n    states_iter: iter::Chain\u003cRevColIter\u003c'a, T\u003e, iter::Cycle\u003cRevColIter\u003c'a, T\u003e\u003e\u003e,\n    state: State\u003cT, T::DistType\u003e,\n    left_state: State\u003cT, T::DistType\u003e,\n    max_mask: T,\n    pos_bitvec: T,\n    left_mask: T,\n    _a: PhantomData\u003c\u0026'a ()\u003e,\n}\n\nimpl\u003c'a, T: BitVec\u003e ShortTracebackHandler\u003c'a, T\u003e {\n    #[inline]\n    fn new(m: T::DistType, pos: usize, states: \u0026'a [State\u003cT, T::DistType\u003e]) -\u003e Self {\n        let mask0 = T::one() \u003c\u003c (m.to_usize().unwrap() - 1);\n\n        // Reverse iterator over states. If remembering all positions,\n        // the chain() and cycle() are not actually needed, but there seems\n        // to be almost no performance loss.\n        let mut states_iter = states[..=pos]\n            .iter()\n            .rev()\n            .chain(states.iter().rev().cycle());\n\n        // // Simpler alternative using skip() is slower in some cases:\n        // let mut states = states.iter().rev().cycle().skip(states.len() - pos - 1);\n\n        ShortTracebackHandler {\n            state: states_iter.next().unwrap().clone(),\n            left_state: states_iter.next().unwrap().clone(),\n            states_iter,\n            max_mask: mask0,\n            pos_bitvec: mask0,\n            left_mask: T::zero(),\n            _a: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'a, T\u003e TracebackHandler\u003c'a, T, T::DistType\u003e for ShortTracebackHandler\u003c'a, T\u003e\nwhere\n    T: BitVec + 'a,\n{\n    #[inline]\n    fn block(\u0026self) -\u003e \u0026State\u003cT, T::DistType\u003e {\n        \u0026self.state\n    }\n\n    #[inline]\n    fn block_mut(\u0026mut self) -\u003e \u0026mut State\u003cT, T::DistType\u003e {\n        \u0026mut self.state\n    }\n\n    #[inline]\n    fn left_block(\u0026self) -\u003e \u0026State\u003cT, T::DistType\u003e {\n        \u0026self.left_state\n    }\n\n    #[inline]\n    fn left_block_mut(\u0026mut self) -\u003e \u0026mut State\u003cT, T::DistType\u003e {\n        \u0026mut self.left_state\n    }\n\n    #[inline]\n    fn pos_bitvec(\u0026self) -\u003e T {\n        self.pos_bitvec\n    }\n\n    #[inline]\n    fn move_up(\u0026mut self, adjust_dist: bool) {\n        if adjust_dist {\n            self.state.adjust_dist(self.pos_bitvec);\n        }\n        self.pos_bitvec \u003e\u003e= 1;\n    }\n\n    #[inline]\n    fn move_up_left(\u0026mut self, adjust_dist: bool) {\n        self.left_mask = (self.left_mask \u003e\u003e 1) | self.max_mask;\n        if adjust_dist {\n            self.left_state.adjust_dist(self.pos_bitvec);\n        }\n    }\n\n    #[inline]\n    fn move_to_left(\u0026mut self) {\n        self.state = replace(\n            \u0026mut self.left_state,\n            self.states_iter.next().unwrap().clone(),\n        );\n        self.left_state.adjust_by_mask(self.left_mask);\n    }\n\n    #[inline]\n    fn move_left_down_if_better(\u0026mut self) -\u003e bool {\n        if self.left_state.mv \u0026 self.pos_bitvec != T::zero() {\n            self.left_state.dist -= T::DistType::one();\n            return true;\n        }\n        false\n    }\n\n    #[inline]\n    fn column_slice(\u0026self) -\u003e \u0026[State\u003cT, T::DistType\u003e] {\n        std::slice::from_ref(\u0026self.state)\n    }\n\n    #[inline]\n    fn finished(\u0026self) -\u003e bool {\n        self.pos_bitvec == T::zero()\n    }\n}\n\nimpl_myers!(\n    T::DistType,\n    Myers\u003cT\u003e,\n    crate::pattern_matching::myers::State\u003cT, T::DistType\u003e,\n    crate::pattern_matching::myers::simple::ShortStatesHandler\u003c'a\u003e\n);\n","traces":[{"line":28,"address":[4473184,4473120,4473248,4473312,4473392],"length":1,"stats":{"Line":0},"fn_name":"new\u003cu8,\u0026[u8; 8],\u0026u8\u003e"},{"line":34,"address":[4473334,4473408,4473264,4473136,4473200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[4489870,4481631,4476176,4487136,4487114,4478907,4484355,4476159,4481648,4484384,4478928,4473456],"length":1,"stats":{"Line":0},"fn_name":"new_ambig\u003cu64,\u0026[u8; 7],\u0026u8\u003e"},{"line":48,"address":[4476378,4473642,4473533,4484455,4476269,4481725,4484566,4481834,4487207,4487318,4479005,4479114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[4473773,4476517,4487449,4479245,4484697,4481965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[4476809,4485067,4482339,4474143,4487741,4474061,4476891,4479533,4479615,4482257,4484985,4487823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[4482450,4482405,4485178,4474209,4485133,4477002,4476957,4479726,4474254,4487889,4479681,4487934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[4479766,4485218,4476986,4474364,4487918,4482560,4479836,4488042,4474294,4474238,4482490,4487974,4479710,4485162,4485286,4477042,4477112,4482434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[4477094,4474346,4488082,4482593,4477145,4488026,4485270,4474397,4479818,4482542,4479869,4485326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[4480953,4488494,4480240,4475481,4488239,4477501,4474768,4477246,4485738,4485483,4483677,4482949,4489204,4480225,4482694,4474498,4485753,4488509,4479970,4486448,4474753,4478229,4482964,4477516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[4477628,4483076,4488621,4480352,4485865,4474880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[4477663,4477724,4483111,4480448,4474976,4488656,4485958,4480387,4488714,4483172,4474915,4485900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[4483206,4480482,4477758,4485991,4488747,4475010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[4489936,4488974,4483443,4490155,4489888,4490128,4477995,4480594,4480823,4475122,4475351,4490080,4478099,4475247,4488861,4486218,4483318,4490107,4486316,4480719,4483547,4477870,4489984,4490011,4490032,4489915,4489072,4486105,4489963,4490059],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cu64,\u0026[u8; 8],\u0026u8\u003e"},{"line":63,"address":[4488991,4489074,4483664,4483410,4488947,4486191,4486318,4478216,4475270,4483549,4480742,4478018,4480825,4475353,4475468,4478101,4475214,4483466,4480940,4486235,4480686,4477962,4489191,4486435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[4486351,4480858,4489107,4483582,4478134,4475386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[4483915,4489301,4489216,4475493,4489440,4475719,4486545,4478326,4475578,4486684,4480965,4478467,4481050,4486460,4483689,4478241,4483774,4481191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[4475551,4489359,4478569,4483834,4483920,4481023,4489538,4486782,4486603,4486518,4478386,4475724,4475638,4483747,4481110,4489274,4478472,4475821,4481293,4484017,4478299,4489445,4481196,4486689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[4489548,4483957,4478579,4486726,4481303,4484027,4486792,4489482,4475831,4475761,4478509,4481233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[4481082,4486826,4483806,4486577,4489333,4478613,4478358,4489582,4484061,4475610,4475865,4481337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[4489739,4481494,4484218,4486983,4478770,4476022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[4490224,4490176],"length":1,"stats":{"Line":0},"fn_name":"initial_state\u003cu64\u003e"},{"line":85,"address":[4490202,4490246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[4490368,4490320],"length":1,"stats":{"Line":0},"fn_name":"step\u003cu64\u003e"},{"line":90,"address":[4490391,4490343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[4491392,4490416],"length":1,"stats":{"Line":0},"fn_name":"_step\u003cu64\u003e"},{"line":95,"address":[4490464,4491502,4490569,4491425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[4490534,4491475],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[4491534,4490608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[4491628,4490732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[4490805,4491698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[4491894,4491044,4490829,4491718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[4492050,4491206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[4491144,4491873,4491023,4491991,4491934,4491084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[4492053,4491209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[4491227,4492068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[4491253,4492087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[4492166,4491343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[4935648],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[4492208,4492240],"length":1,"stats":{"Line":0},"fn_name":"init\u003cu64\u003e"},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[4492272,4492384],"length":1,"stats":{"Line":0},"fn_name":"set_max_state\u003cu64\u003e"},{"line":146,"address":[4492311,4492423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[4492512,4492640],"length":1,"stats":{"Line":0},"fn_name":"add_state\u003cu64\u003e"},{"line":157,"address":[4492697,4492556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[4492800,4492896],"length":1,"stats":{"Line":0},"fn_name":"init_traceback\u003cu8\u003e"},{"line":167,"address":[4492968,4492872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[4493776,4492992],"length":1,"stats":{"Line":0},"fn_name":"new\u003cu64\u003e"},{"line":186,"address":[4493073,4493857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[4494055,4493272,4494232,4493449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[4493376,4494159],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[4493470,4494253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[4494354,4493528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[4493612,4494481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[4494624,4494640],"length":1,"stats":{"Line":0},"fn_name":"block\u003cu64\u003e"},{"line":217,"address":[4494632,4494648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[4494672,4494656],"length":1,"stats":{"Line":0},"fn_name":"left_block\u003cu8\u003e"},{"line":227,"address":[4494664,4494680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[4494688,4494704],"length":1,"stats":{"Line":0},"fn_name":"pos_bitvec\u003cu8\u003e"},{"line":237,"address":[4494709,4494693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[4494800,4494720],"length":1,"stats":{"Line":0},"fn_name":"move_up\u003cu64\u003e"},{"line":242,"address":[4494771,4494745,4494825,4494851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[4494835,4494755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[4494777,4494857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[4495008,4494880],"length":1,"stats":{"Line":0},"fn_name":"move_up_left\u003cu8\u003e"},{"line":250,"address":[4495035,4494907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[4494966,4494993,4495121,4495094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[4494977,4495105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[4495136,4495344],"length":1,"stats":{"Line":0},"fn_name":"move_to_left\u003cu8\u003e"},{"line":258,"address":[4495242,4495420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[4495358,4495150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[4495370,4495162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[4495467,4495316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[4495632,4495488],"length":1,"stats":{"Line":0},"fn_name":"move_left_down_if_better\u003cu8\u003e"},{"line":267,"address":[4495505,4495649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[4495718,4495574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[4495611,4495755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[4495706,4495562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[4495776,4495840],"length":1,"stats":{"Line":0},"fn_name":"finished\u003cu8\u003e"},{"line":281,"address":[4495785,4495849],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":90},{"path":["/","home","todd","rust-bio","src","pattern_matching","myers","traceback.rs"],"content":"use std::default::Default;\nuse std::iter;\nuse std::marker::PhantomData;\nuse std::ops::Range;\n\nuse crate::alignment::AlignmentOperation;\n\nuse crate::pattern_matching::myers::{word_size, BitVec, DistType, State};\n\n/// Objects implementing this trait handle the addition of calculated blocks (State\u003cT, D\u003e)\n/// to a container, and are responsible for creating the respective `TracebackHandler` object.\npub(super) trait StatesHandler\u003c'a, T, D\u003e\nwhere\n    T: BitVec + 'a,\n    D: DistType,\n{\n    /// Object that helps obtaining a single traceback path\n    type TracebackHandler: TracebackHandler\u003c'a, T, D\u003e;\n    /// Type that represents a column in the traceback matrix\n    type TracebackColumn: ?Sized;\n\n    /// Prepare for a new search given n (maximum expected number of traceback columns) and\n    /// m (pattern length).\n    /// Returns the expected size of the vector storing the calculated blocks given this\n    /// information. The vector will then be initialized with the given number of 'empty'\n    /// State\u003cT, D\u003e objects and supplied to the other methods as slice.\n    fn init(\u0026mut self, n: usize, m: D) -\u003e usize;\n\n    /// Fill the column at `pos` with states initialized with the maximum distance\n    /// (`State::max()`).\n    fn set_max_state(\u0026self, pos: usize, states: \u0026mut [State\u003cT, D\u003e]);\n\n    /// This method copies over all blocks (or the one block) from a tracback column\n    /// into the mutable `states` slice at the given column position.\n    fn add_state(\u0026self, source: \u0026Self::TracebackColumn, pos: usize, states: \u0026mut [State\u003cT, D\u003e]);\n\n    /// Initiates a `TracebackHandler` object to assist with a traceback, 'starting'\n    /// at the given end position.\n    fn init_traceback(\u0026self, m: D, pos: usize, states: \u0026'a [State\u003cT, D\u003e])\n        -\u003e Self::TracebackHandler;\n}\n\n/// Objects implementing this trait should store states and have methods\n/// necessary for obtaining a single traceback path. This allows to use the\n/// same traceback code for the simple and the block-based Myers pattern\n/// matching approaches. It is designed to be as general as possible\n/// to allow different implementations.\n///\n/// Implementors of `TracebackHandler` keep two `State\u003cT, D\u003e` instances,\n/// which store the information from two horizontally adjacent traceback\n/// columns, encoded in the PV / MV bit vectors. The columns are accessible\n/// using the methods `block()` (current / right column) and `left_block()`\n/// (left column). Moving horizontally to the next position can be achieved\n/// using `move_left()`.\n///\n/// Implementors also track the vertical cursor positions within the current\n/// traceback columns (two separate cursors for left and right column).\n/// `block()` and `left_block()` will always return the block that currently\n/// contain the cursors.\n/// `pos_bitvec()` returns a bit vector with a single activated bit at the current\n/// vertical position within the *right (current)* column.\n/// Moving to the next vertical position is achieved by `move_up()` and\n/// `move_up_left()`. With the block based implementation, this may involve\n/// switching to a new block.\npub(super) trait TracebackHandler\u003c'a, T, D\u003e\nwhere\n    T: BitVec + 'a,\n    D: DistType,\n{\n    /// Returns a reference to the current (right) block.\n    fn block(\u0026self) -\u003e \u0026State\u003cT, D\u003e;\n\n    /// Returns a mutable reference to the current (right) block.\n    fn block_mut(\u0026mut self) -\u003e \u0026mut State\u003cT, D\u003e;\n\n    /// Returns a reference to the left block.\n    fn left_block(\u0026self) -\u003e \u0026State\u003cT, D\u003e;\n\n    /// Returns a mutable reference to the left block.\n    fn left_block_mut(\u0026mut self) -\u003e \u0026mut State\u003cT, D\u003e;\n\n    /// Bit vector representing the position in the traceback. Only the bit\n    /// at the current position should be on.\n    /// For a search pattern of length 4, the initial bit vector would be\n    /// `0b1000`. A call to `move_up_cursor()` will shift the vector, so another\n    /// call to `pos_bitvec()` results in `0b100`.\n    /// The bit vector has a width of `T`, meaning that it can store\n    /// the same number of positions as the PV and MV vectors. In the\n    /// case of the block based algorithm, the vector only stores the\n    /// position within the current block.\n    fn pos_bitvec(\u0026self) -\u003e T;\n\n    /// Move up cursor by one position in traceback matrix.\n    ///\n    /// # Arguments\n    ///\n    /// * adjust_dist: If true, the distance score of the block is adjusted\n    ///   based on the current cursor position before moving it up.\n    ///  *Note concerning the block based Myers algorithm:*\n    ///  The the active bit in bit vector returned by `pos_bitvec()`\n    ///  is expected to jump back to the maximum (lowest) position\n    ///  when reaching the uppermost position (like `rotate_right()` does).\n    fn move_up(\u0026mut self, adjust_dist: bool);\n\n    /// Move up left cursor by one position in traceback matrix.\n    ///\n    /// # Arguments\n    ///\n    /// * adjust_dist: If true, the distance score of the block is adjusted\n    ///   based on the current cursor position before moving it up.\n    ///   However, the current cursor position of the **right** block is used,\n    ///   **not** the one of the left block. This is an important oddity, which\n    ///   makes only sense because of the design of the traceback algorithm.\n    fn move_up_left(\u0026mut self, adjust_dist: bool);\n\n    /// Shift the view by one traceback column / block to the left. The\n    /// block that was on the left position previously moves to the right /\n    /// current block without changes. The cursor positions have to be\n    /// adjusted indepentedently if necessary using `move_up(false)` /\n    /// `move_up_left(false)`.\n    /// `move_left()` adjusts distance score of the new left block to\n    /// be correct for the left vertical cursor position. It is therefore\n    /// important that the cursor is moved *before* calling `move_left()`.\n    fn move_to_left(\u0026mut self);\n\n    /// Rather specialized method that allows having a simpler code in Traceback::_traceback_at()\n    /// Checks if the position below the left cursor has a smaller distance, and if so,\n    /// moves the cursor to this block and returns `true`.\n    ///\n    /// The problem is that the current implementation always keeps the left cursor in the\n    /// diagonal position for performance reasons. In this case, checking the actual left\n    /// distance score can be complicated with the block-based algorithm since the left cursor\n    /// may be at the lower block boundary. If so, the function thus has to check the topmost\n    /// position of the lower block and keep this block if the distance is better (lower).\n    fn move_left_down_if_better(\u0026mut self) -\u003e bool;\n\n    /// Returns a slice containing all blocks of the current traceback column\n    /// from top to bottom. Used for debugging only.\n    fn column_slice(\u0026self) -\u003e \u0026[State\u003cT, D\u003e];\n\n    /// Returns true if topmost position in the traceback matrix has been reached,\n    /// meaning that the traceback is complete.\n    /// Technically this means, that `move_up_cursor()` was called so many times\n    /// until the uppermost block was reached and the pos_bitvec() does not contain\n    /// any bit, since shifting has removed it from the vector.\n    fn finished(\u0026self) -\u003e bool;\n\n    /// For debugging only\n    fn print_state(\u0026self) {\n        println!(\n            \"--- TB dist ({:?} \u003c-\u003e {:?})\",\n            self.left_block().dist,\n            self.block().dist\n        );\n        println!(\n            \"{:064b} m\\n{:064b} + ({:?}) (left) d={:?}\\n{:064b} - ({:?})\\n \\\n             {:064b} + ({:?}) (current) d={:?}\\n{:064b} - ({:?})\\n\",\n            self.pos_bitvec(),\n            self.left_block().pv,\n            self.left_block().pv,\n            self.left_block().dist,\n            self.left_block().mv,\n            self.left_block().mv,\n            self.block().pv,\n            self.block().pv,\n            self.block().dist,\n            self.block().mv,\n            self.block().mv\n        );\n    }\n}\n\npub(super) struct Traceback\u003c'a, T, D, H\u003e\nwhere\n    T: BitVec + 'a,\n    D: DistType,\n    H: StatesHandler\u003c'a, T, D\u003e,\n{\n    m: D,\n    positions: iter::Cycle\u003cRange\u003cusize\u003e\u003e,\n    handler: H,\n    pos: usize,\n    _t: PhantomData\u003c\u0026'a T\u003e,\n}\n\nimpl\u003c'a, T, D, H\u003e Traceback\u003c'a, T, D, H\u003e\nwhere\n    T: BitVec,\n    D: DistType,\n    H: StatesHandler\u003c'a, T, D\u003e,\n{\n    #[inline]\n    pub fn new(\n        states: \u0026mut Vec\u003cState\u003cT, D\u003e\u003e,\n        initial_state: \u0026H::TracebackColumn,\n        num_cols: usize,\n        m: D,\n        mut handler: H,\n    ) -\u003e Self {\n        // Correct traceback needs two additional columns at the left of the matrix (see below).\n        // Therefore reserving additional space.\n        let num_cols = num_cols + 2;\n\n        let n_states = handler.init(num_cols, m);\n\n        let mut tb = Traceback {\n            m,\n            positions: (0..num_cols).cycle(),\n            handler,\n            pos: 0,\n            _t: PhantomData,\n        };\n\n        // extend or truncate states vector\n        let curr_len = states.len();\n        if n_states \u003e curr_len {\n            states.reserve(n_states);\n            states.extend((0..n_states - curr_len).map(|_| State::default()));\n        } else {\n            states.truncate(n_states);\n            states.shrink_to_fit();\n        }\n        // important if using unsafe in add_state(), and also for correct functioning of traceback\n        debug_assert!(states.len() == n_states);\n\n        // first column is used to ensure a correct path if the text (target)\n        // is shorter than the pattern (query)\n        tb.pos = tb.positions.next().unwrap();\n        tb.handler.set_max_state(tb.pos, states);\n\n        // initial state\n        tb.add_state(initial_state, states);\n\n        tb\n    }\n\n    #[inline]\n    pub fn add_state(\u0026mut self, column: \u0026H::TracebackColumn, states: \u0026mut [State\u003cT, D\u003e]) {\n        self.pos = self.positions.next().unwrap();\n        self.handler.add_state(column, self.pos, states);\n    }\n\n    /// Returns the length of the current match, optionally adding the\n    /// alignment path to `ops`\n    #[inline]\n    pub fn traceback(\n        \u0026self,\n        ops: Option\u003c\u0026mut Vec\u003cAlignmentOperation\u003e\u003e,\n        states: \u0026'a [State\u003cT, D\u003e],\n    ) -\u003e (D, D) {\n        self._traceback_at(self.pos, ops, states)\n    }\n\n    /// Returns the length of a match with a given end position, optionally adding the\n    /// alignment path to `ops`\n    /// only to be called if the `states` vec contains all states of the text\n    #[inline]\n    pub fn traceback_at(\n        \u0026self,\n        pos: usize,\n        ops: Option\u003c\u0026mut Vec\u003cAlignmentOperation\u003e\u003e,\n        states: \u0026'a [State\u003cT, D\u003e],\n    ) -\u003e Option\u003c(D, D)\u003e {\n        let pos = pos + 2; // in order to be comparable since self.pos starts at 2, not 0\n        if pos \u003c= self.pos {\n            return Some(self._traceback_at(pos, ops, states));\n        }\n        None\n    }\n\n    /// returns a tuple of alignment length and hit distance, optionally adding the alignment path\n    /// to `ops`\n    #[inline]\n    fn _traceback_at(\n        \u0026self,\n        pos: usize,\n        mut ops: Option\u003c\u0026mut Vec\u003cAlignmentOperation\u003e\u003e,\n        state_slice: \u0026'a [State\u003cT, D\u003e],\n    ) -\u003e (D, D) {\n        use self::AlignmentOperation::*;\n\n        // Generic object that holds the necessary data and methods\n        let mut h = self.handler.init_traceback(self.m, pos, state_slice);\n\n        // self.print_tb_matrix(pos, state_slice);\n\n        let ops = \u0026mut ops;\n\n        // horizontal column offset from starting point in traceback matrix (bottom right)\n        let mut h_offset = D::zero();\n\n        // distance of the match (will be returned)\n        let dist = h.block().dist;\n\n        // The cursor of the left state is always for diagonal position in the traceback matrix.\n        // This allows checking for a substitution by a simple comparison.\n        h.move_up_left(true);\n\n        // Loop for finding the traceback path\n        // If there are several possible solutions, substitutions are preferred over InDels\n        // (Subst \u003e Ins \u003e Del)\n        while !h.finished() {\n            let op;\n            // This loop is used to allow skipping `move_left()` using break (kind of similar\n            // to 'goto'). This was done to avoid having to inline move_left() three times,\n            // which would use more space.\n            #[allow(clippy::never_loop)]\n            loop {\n                // h.print_state();\n\n                if h.left_block().dist.wrapping_add(\u0026D::one()) == h.block().dist {\n                    // Diagonal (substitution)\n                    // Since the left cursor is always in the upper diagonal position,\n                    // a simple comparison of distances is enough to determine substitutions.\n                    h.move_up(false);\n                    h.move_up_left(false);\n                    op = Subst;\n                } else if h.block().pv \u0026 h.pos_bitvec() != T::zero() {\n                    // Up\n                    h.move_up(true);\n                    h.move_up_left(true);\n                    op = Ins;\n                    break;\n                } else if h.move_left_down_if_better() {\n                    // Left\n                    op = Del;\n                } else {\n                    // Diagonal (match)\n                    h.move_up(false);\n                    h.move_up_left(false);\n                    op = Match;\n                }\n\n                // Moving one position to the left, adjusting h_offset\n                h_offset += D::one();\n                h.move_to_left();\n                break;\n            }\n\n            // println!(\"{:?}\", op);\n\n            if let Some(o) = ops.as_mut() {\n                o.push(op);\n            }\n        }\n\n        (h_offset, dist)\n    }\n\n    // Useful for debugging\n    #[allow(dead_code)]\n    fn print_tb_matrix(\u0026self, pos: usize, state_slice: \u0026'a [State\u003cT, D\u003e]) {\n        let mut h = self.handler.init_traceback(self.m, pos, state_slice);\n        let m = self.m.to_usize().unwrap();\n        let mut out = vec![];\n        for _ in 0..state_slice.len() {\n            let mut col_out = vec![];\n            let mut empty = true;\n            for (i, state) in h.column_slice().iter().enumerate().rev() {\n                if !(state.is_new() || state.is_max()) {\n                    empty = false;\n                }\n                let w = word_size::\u003cT\u003e();\n                let end = (i + 1) * w;\n                let n = if end \u003c= m { w } else { m % w };\n                state.write_dist_column(n, \u0026mut col_out);\n            }\n            out.push(col_out);\n            h.move_to_left();\n            if empty {\n                break;\n            }\n        }\n\n        for j in (0..m).rev() {\n            print!(\"{:\u003e4}: \", m - j + 1);\n            for col in out.iter().rev() {\n                if let Some(d) = col.get(j) {\n                    if *d \u003e= (D::max_value() \u003e\u003e 1) {\n                        // missing value\n                        print!(\"    \");\n                    } else {\n                        print!(\"{:\u003e4?}\", d);\n                    }\n                } else {\n                    print!(\"   -\");\n                }\n            }\n            println!();\n        }\n    }\n}\n","traces":[{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[9746016,9744000,9745986,9744967,9744992,9743975,9747010,9743008],"length":1,"stats":{"Line":0},"fn_name":"new\u003cu8,u8,bio::pattern_matching::myers::simple::ShortStatesHandler\u003e"},{"line":202,"address":[9743088,9746185,9744080,9744164,9743172,9745079,9746103,9745161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[9743146,9745146,9746271,9745247,9744138,9744250,9743258,9746170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[9746279,9744258,9745255,9743266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[9744374,9745385,9746409,9743382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[9746442,9744407,9743415,9743639,9745682,9746706,9746666,9744671,9743679,9745418,9744631,9745642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[9743485,9746512,9744477,9745488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[9747088,9745505,9743502,9747040,9747136,9747150,9747216,9747230,9746529,9744494,9747109,9747061],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cu64,u8,bio::pattern_matching::myers::simple::ShortStatesHandler\u003e"},{"line":220,"address":[9746489,9743462,9744454,9745465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[9744664,9745675,9746699,9743672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[9744726,9744641,9744683,9745694,9746676,9743649,9746765,9745741,9745652,9743734,9743691,9746718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[9743777,9744703,9744769,9743711,9746808,9745714,9745784,9746738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[9744820,9743828,9746859,9745835],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[9746938,9743903,9745914,9744895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[9747568,9747280,9747712,9747424],"length":1,"stats":{"Line":0},"fn_name":"add_state\u003cu64,usize,bio::pattern_matching::myers::long::LongStatesHandler\u003e"},{"line":239,"address":[9747468,9747324,9747612,9747756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[9747538,9747398,9747682,9747830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[9748080,9747936,9748016,9747856],"length":1,"stats":{"Line":0},"fn_name":"traceback\u003cu8,usize,bio::pattern_matching::myers::long::LongStatesHandler\u003e"},{"line":251,"address":[9748113,9747969,9747889,9748049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[9748144,9748352],"length":1,"stats":{"Line":0},"fn_name":"traceback_at\u003cu64,u8,bio::pattern_matching::myers::simple::ShortStatesHandler\u003e"},{"line":264,"address":[9748450,9748232,9748411,9748193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[9748442,9748224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[9748294,9748519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[9748485,9748262],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[9753071,9752048,9751997,9749760,9750912,9748576,9750868,9749709],"length":1,"stats":{"Line":0},"fn_name":"_traceback_at\u003cu64,usize,bio::pattern_matching::myers::long::LongStatesHandler\u003e"},{"line":283,"address":[9750965,9748632,9752104,9749819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[9748663,9750993,9749847,9752126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[9751001,9748671,9749855,9752134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[9751084,9749946,9748713,9752210,9752163,9749893,9748766,9751037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[9751113,9752234,9749973,9748799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[9748816,9751130,9752248,9749990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[9748884,9750051,9752300,9751192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[9750237,9752477,9751378,9749078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[9752491,9750254,9751395,9749095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[9752498,9750261,9751402,9749102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[9752455,9750212,9751353,9750326,9752563,9749169,9751469,9749053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[9751632,9750496,9749339,9752716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[9749359,9752733,9751652,9750516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[9752740,9751659,9750523,9749366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[9749313,9752810,9752937,9749573,9749440,9751606,9751796,9749507,9750470,9750730,9751729,9751862,9750664,9752874,9752693,9750597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[9751752,9752830,9749463,9750620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[9750613,9751745,9749456,9752823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[9750679,9751811,9752886,9749522],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[9750686,9752893,9749529,9751818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[9749146,9749591,9751880,9750739,9750305,9751446,9752542,9752946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[9749606,9752969,9751895,9750765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[9752976,9749613,9751902,9750772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[9753061,9750858,9752789,9752985,9749418,9750575,9750782,9751708,9749699,9749623,9751987,9751911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[9750832,9749673,9751961,9753035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[9751158,9752275,9748847,9750017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":100},{"path":["/","home","todd","rust-bio","src","pattern_matching","pssm","dnamotif.rs"],"content":"// Copyright 2018 Kieran Hervold\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse super::*;\nuse ndarray::prelude::Array2;\nuse std::f32;\nuse std::f32::{INFINITY, NEG_INFINITY};\n\n/// Position-specific scoring matrix for DNA sequences\n#[derive(Clone, Debug, PartialEq)]\npub struct DNAMotif {\n    /// matrix holding weights at each position, indexed by [position, base]\n    pub scores: Array2\u003cf32\u003e,\n    /// sum of \"worst\" base at each position\n    pub min_score: f32,\n    /// sum of \"best\" base at each position\n    pub max_score: f32,\n}\n\nimpl DNAMotif {\n    /// Returns a Motif representing the sequences provided.\n    /// # Arguments\n    /// * `seqs` - sequences incorporated into motif\n    /// * `pseudos` - array slice with a pseudocount for each monomer;\n    ///    defaults to pssm::DEF_PSEUDO for all if None is supplied\n    ///\n    /// FIXME: pseudos should be an array of size MONO_CT, but that\n    /// is currently impossible - see\n    /// https://github.com/rust-lang/rust/issues/42863\n    pub fn from_seqs(seqs: \u0026[Vec\u003cu8\u003e], pseudos: Option\u003c\u0026[f32]\u003e) -\u003e Result\u003cSelf\u003e {\n        let w = Self::seqs_to_weights(seqs, pseudos)?;\n        let mut m = DNAMotif {\n            scores: w,\n            min_score: 0.0,\n            max_score: 0.0,\n        };\n        m.normalize();\n        m.calc_minmax();\n        Ok(m)\n    }\n\n    // helper function -- normalize self.scores\n    fn normalize(\u0026mut self) {\n        for i in 0..self.len() {\n            let mut tot: f32 = 0.0;\n            // FIXME: slices would be cleaner\n            for base_i in 0..4 {\n                tot += self.scores[[i, base_i]];\n            }\n            for base_i in 0..4 {\n                self.scores[[i, base_i]] /= tot;\n            }\n        }\n    }\n\n    // helper function: populate min_score and max_score\n    fn calc_minmax(\u0026mut self) {\n        let pssm_len = self.len();\n\n        // score corresponding to sum of \"worst\" bases at each position\n        self.min_score = 0.0;\n        for i in 0..pssm_len {\n            // can't use the regular min/max on f32, so we use f32::min\n            let min_sc = (0..4).map(|b| self.scores[[i, b]]).fold(INFINITY, f32::min);\n            self.min_score += min_sc;\n        }\n\n        // score corresponding to \"best\" base at each position\n        self.max_score = 0.0;\n        for i in 0..pssm_len {\n            let max_sc = (0..4)\n                .map(|b| self.scores[[i, b]])\n                .fold(NEG_INFINITY, f32::max);\n            self.max_score += max_sc;\n        }\n    }\n}\n\nimpl Motif for DNAMotif {\n    const LK: [u8; 127] = [\n        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 255, 3, 255, 255, 255, 2, 255,\n        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 1, 255, 255, 255, 255, 255, 255,\n        255, 255, 255, 255, 255, 255, 0, 255, 3, 255, 255, 255, 2, 255, 255, 255, 255, 255, 255,\n        255, 255, 255, 255, 255, 255, 1, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n    ];\n    const MONOS: \u0026'static [u8] = b\"ATGC\";\n    const MONO_CT: usize = 4;\n\n    fn rev_lk(idx: usize) -\u003e u8 {\n        match idx {\n            0 =\u003e b'A',\n            1 =\u003e b'T',\n            2 =\u003e b'G',\n            3 =\u003e b'C',\n            _ =\u003e INVALID_MONO,\n        }\n    }\n\n    fn len(\u0026self) -\u003e usize {\n        self.scores.dim().0\n    }\n\n    fn get_scores(\u0026self) -\u003e \u0026Array2\u003cf32\u003e {\n        \u0026self.scores\n    }\n    fn get_min_score(\u0026self) -\u003e f32 {\n        self.min_score\n    }\n    fn get_max_score(\u0026self) -\u003e f32 {\n        self.max_score\n    }\n    fn get_bits() -\u003e f32 {\n        2.0\n    }\n\n    fn degenerate_consensus(\u0026self) -\u003e Vec\u003cu8\u003e {\n        // derived from\n        // https://github.com/biopython/biopython/blob/master/Bio/motifs/matrix.py#L205\n        fn two(_a: u8, _b: u8) -\u003e u8 {\n            let (a, b) = if _b \u003e _a { (_a, _b) } else { (_b, _a) };\n            match (a, b) {\n                (b'A', b'C') =\u003e b'M',\n                (b'A', b'G') =\u003e b'R',\n                (b'A', b'T') =\u003e b'W',\n                (b'C', b'G') =\u003e b'S',\n                (b'C', b'T') =\u003e b'Y',\n                (b'G', b'T') =\u003e b'K',\n                _ =\u003e unreachable!(), // no other combinations exist\n            }\n        }\n        let len = self.len();\n        let mut res = Vec::with_capacity(len);\n        for pos in 0..len {\n            let mut fracs = (0..4)\n                .map(|b| (self.scores[[pos, b]], b))\n                .collect::\u003cVec\u003c(f32, usize)\u003e\u003e();\n            // note: reverse sort\n            fracs.sort_by(|a, b| b.partial_cmp(a).unwrap());\n\n            res.push(if fracs[0].0 \u003e 0.5 \u0026\u0026 fracs[0].0 \u003e 2.0 * fracs[1].0 {\n                Self::MONOS[fracs[0].1]\n            } else if 4.0 * (fracs[0].0 + fracs[1].0) \u003e 3.0 {\n                two(Self::MONOS[fracs[0].1], Self::MONOS[fracs[1].1])\n            } else if fracs[3].0 \u003c EPSILON {\n                let base = Self::MONOS[fracs[3].1];\n                match base {\n                    b'T' =\u003e b'V',\n                    b'G' =\u003e b'H',\n                    b'C' =\u003e b'D',\n                    b'A' =\u003e b'B',\n                    _ =\u003e unreachable!(), // no other bases exist\n                }\n            } else {\n                b'N'\n            });\n        }\n        res\n    }\n}\n\n/// Return a DNAMotif wrapping an Array2 representing amino acid\n/// weights at each position.  The dimensions and contents of this\n/// array are unchecked, and it is incumbent on the user to ensure\n/// the correct dimensions are used (ie, SEQ_LEN x 4), and no zeros\n/// appear in the array.\nimpl From\u003cArray2\u003cf32\u003e\u003e for DNAMotif {\n    fn from(scores: Array2\u003cf32\u003e) -\u003e Self {\n        let mut m = DNAMotif {\n            scores,\n            min_score: 0.0,\n            max_score: 0.0,\n        };\n        m.normalize();\n        m.calc_minmax();\n        m\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::pattern_matching::pssm::ScoredPos;\n    #[test]\n    fn simple_pssm() {\n        let pssm: DNAMotif = DNAMotif::from_seqs(\n            vec![\n                b\"AAAA\".to_vec(),\n                b\"TTTT\".to_vec(),\n                b\"GGGG\".to_vec(),\n                b\"CCCC\".to_vec(),\n            ]\n            .as_ref(),\n            None,\n        )\n        .unwrap();\n        assert_eq!(pssm.scores, Array2::from_elem((4, 4), 0.25));\n    }\n    #[test]\n    fn find_motif() {\n        let pssm = DNAMotif::from_seqs(vec![b\"ATGC\".to_vec()].as_ref(), None).unwrap();\n        let seq = b\"GGGGATGCGGGG\";\n        if let Ok(ScoredPos {\n            ref loc, ref sum, ..\n        }) = pssm.score(seq)\n        {\n            assert_eq!(*loc, 4);\n            assert_relative_eq!(*sum, 1.0, epsilon = f32::EPSILON);\n        } else {\n            assert!(false);\n        }\n    }\n\n    #[test]\n    fn test_info_content() {\n        // matrix w/ 100% match to A at each position\n        let pssm =\n            DNAMotif::from_seqs(vec![b\"AAAA\".to_vec()].as_ref(), Some(\u0026[0.0, 0.0, 0.0, 0.0]))\n                .unwrap();\n        // 4 bases * 2 bits per base = 8\n        assert_relative_eq!(pssm.info_content(), 8.0, epsilon = f32::EPSILON);\n    }\n\n    #[test]\n    fn test_mono_err() {\n        let pssm = DNAMotif::from_seqs(vec![b\"ATGC\".to_vec()].as_ref(), None).unwrap();\n        assert_eq!(\n            pssm.score(b\"AAAAXAAAAAAAAA\"),\n            Err(Error::InvalidMonomer { mono: b'X' })\n        );\n    }\n\n    #[test]\n    fn test_inconsist_err() {\n        assert_eq!(\n            DNAMotif::from_seqs(\n                vec![b\"AAAA\".to_vec(), b\"TTTT\".to_vec(), b\"C\".to_vec()].as_ref(),\n                Some(\u0026[0.0; 4])\n            ),\n            Err(Error::InconsistentLen)\n        );\n    }\n\n    #[test]\n    fn test_degenerate_consensus_same_bases() {\n        let pssm: DNAMotif = DNAMotif::from_seqs(\n            vec![b\"ATGC\".to_vec(), b\"ATGC\".to_vec()].as_ref(),\n            Some(\u0026[0., 0., 0., 0.]),\n        )\n        .unwrap();\n        assert_eq!(pssm.degenerate_consensus(), b\"ATGC\".to_vec());\n    }\n\n    #[test]\n    fn test_degenerate_consensus_two_bases() {\n        let pssm: DNAMotif = DNAMotif::from_seqs(\n            vec![b\"AAACCG\".to_vec(), b\"CGTGTT\".to_vec()].as_ref(),\n            Some(\u0026[0., 0., 0., 0.]),\n        )\n        .unwrap();\n        assert_eq!(pssm.degenerate_consensus(), b\"MRWSYK\".to_vec());\n    }\n\n    #[test]\n    fn test_degenerate_consensus_three_bases() {\n        let pssm: DNAMotif = DNAMotif::from_seqs(\n            vec![b\"AAAC\".to_vec(), b\"CCGG\".to_vec(), b\"GTTT\".to_vec()].as_ref(),\n            Some(\u0026[0., 0., 0., 0.]),\n        )\n        .unwrap();\n        assert_eq!(pssm.degenerate_consensus(), b\"VHDB\".to_vec());\n    }\n\n    #[test]\n    fn test_degenerate_consensus_n() {\n        let pssm: DNAMotif = DNAMotif::from_seqs(\n            vec![\n                b\"AAAA\".to_vec(),\n                b\"GGGG\".to_vec(),\n                b\"CCCC\".to_vec(),\n                b\"TTTT\".to_vec(),\n            ]\n            .as_ref(),\n            None,\n        )\n        .unwrap();\n        assert_eq!(pssm.degenerate_consensus(), b\"NNNN\".to_vec());\n    }\n}\n","traces":[{"line":32,"address":[4436373,4435728],"length":1,"stats":{"Line":0},"fn_name":"from_seqs"},{"line":33,"address":[4435776,4436114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[4436103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4436243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[4436287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4436400],"length":1,"stats":{"Line":0},"fn_name":"normalize"},{"line":46,"address":[4436994,4436552,4436420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4436589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[4436911,4436601,4436803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[4436835],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[4437128,4436735,4437009,4436926,4437133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[4437041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[4437136],"length":1,"stats":{"Line":0},"fn_name":"calc_minmax"},{"line":60,"address":[4437148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[4437176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[4437541,4437189,4437364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[4437390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[4437521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[4437294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[4437829,4437824,4437556,4437632,4437307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[4437664,4437717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[4437688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[4437804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[4437840],"length":1,"stats":{"Line":0},"fn_name":"rev_lk"},{"line":95,"address":[4437908,4437901,4437894,4437887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[4437849,4437889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[4437896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[4437903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[4437910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[4437882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[4437936],"length":1,"stats":{"Line":0},"fn_name":"len"},{"line":105,"address":[4437945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[4437968],"length":1,"stats":{"Line":0},"fn_name":"get_scores"},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[4437984],"length":1,"stats":{"Line":0},"fn_name":"get_min_score"},{"line":112,"address":[4437989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[4438000],"length":1,"stats":{"Line":0},"fn_name":"get_max_score"},{"line":115,"address":[4438005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[4438016],"length":1,"stats":{"Line":0},"fn_name":"get_bits"},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[4439724,4438032,4439709],"length":1,"stats":{"Line":0},"fn_name":"degenerate_consensus"},{"line":124,"address":[4439728],"length":1,"stats":{"Line":0},"fn_name":"two"},{"line":125,"address":[4439754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[4439992,4439978,4439808,4439994,4439971,4439964,4439985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[4439880,4439816,4439973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[4439980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[4439987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[4439959,4439914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[4439966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[4439938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[4438063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[4438108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[4438374,4439704,4438266,4438122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[4438406,4438462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[4438438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[4438540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[4438977,4438632,4439017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[4438894,4438984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[4439044,4438857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[4439167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[4439428,4439449,4439129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[4439454,4439578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[4439658,4439684,4439671,4439645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[4439637,4439538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[4439650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[4439663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[4439676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[4439604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[4439441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[4440167,4440000,4440155],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":178,"address":[4440100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[4440111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[7733296,7733301],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":191,"address":[7756065,7755985,7756128,7756197,7756467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[7755998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[7756029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[7756097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[7756166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[7756500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[7756637,7756742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[7733333,7733328],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":205,"address":[7757170,7757000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[7757345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[7757423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[7757438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[7757760,7757490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[7757660,7757948,7757838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[7757580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[7733360,7733365],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":221,"address":[7759186,7758872,7759042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[7759545,7759243,7759308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[7733397,7733392],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":230,"address":[7760562,7760401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[7760794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[7760722],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[7733424,7733429],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":239,"address":[7761506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[7761478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[7761041,7761418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[7761451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[7733456,7733461],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":251,"address":[7762049,7761777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[7762082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[7762275,7762231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[7733493,7733488],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":261,"address":[7762897,7762625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[7762930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[7763123,7763079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[7733520,7733525],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":271,"address":[7763473,7763850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[7763883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[7764041,7764085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[7733557,7733552],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":281,"address":[7764433,7764915,7764513,7764576,7764645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[7764446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[7764477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[7764545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[7764614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[7764948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[7765082,7765126],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":123},{"path":["/","home","todd","rust-bio","src","pattern_matching","pssm","errors.rs"],"content":"// Copyright 2019 Johannes Köster, University of Duisburg-Essen.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Error definitions for the `pssm` module.\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum Error {\n    #[error(\n        \"query length {} is shorter than motif length {}\",\n        query_len,\n        motif_len\n    )]\n    QueryTooShort { motif_len: usize, query_len: usize },\n    #[error(\"attempted to build a motif from sequences with mismatched lengths\")]\n    InconsistentLen,\n    #[error(\"monomer '{}' is invalid\", char::from(*mono))]\n    InvalidMonomer { mono: u8 },\n    #[error(\"motif cannot be created from zero sequences\")]\n    EmptyMotif,\n    #[error(\"information-free motif: a motif in which every monomer is equally likely at every position will result in a divide-by-zero exception\")]\n    NullMotif,\n    #[error(\"expected pseudo-score array of length {}; got {}\", expected, received)]\n    InvalidPseudos { expected: u8, received: u8 },\n}\n\npub type Result\u003cT, E = Error\u003e = std::result::Result\u003cT, E\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","pattern_matching","pssm","mod.rs"],"content":"// Copyright 2018 Kieran Hervold\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Create a weight matrix representing a set of aligned reference sequences\n//! that constitute a motif, and use this matrix to scan query sequences for\n//! occurrences of this motif.\n//! Complexity: O(n*m) for motif length n and query length m\n//!\n//! The position-specific scoring matrix (PSSM), aka position weight matrix (PWM),\n//! algorithm is implemented for both DNA and amino-acid sequences.\n//!\n//! # Examples\n//!\n//! use bio::pattern_matching::pssm::DNAMotif;\n//! let pssm = DNAMotif::from_seqs(vec![\n//!            b\"AAAA\".to_vec(),\n//!            b\"AATA\".to_vec(),\n//!            b\"AAGA\".to_vec(),\n//!            b\"AAAA\".to_vec(),\n//!        ].as_ref(), None).unwrap();\n//! let start_pos = pssm.score(b\"CCCCCAATA\").unwrap().loc;\n//! println!(\"motif found at position {}\", start_pos);\n//!\n//! /* amino acid sequences are supported, too */\n//! use pssm::pattern_matching::pssm::ProtMotif;\n//! let pssm = ProtMotif::from_seqs(vec![\n//!            b\"ARNNYM\".to_vec(),\n//!            b\"ARNRYM\".to_vec(),\n//!            b\"ARNNCM\".to_vec(),\n//!            b\"ARNNYM\".to_vec(),\n//!        ].as_ref(), None).unwrap();\n\nuse std::borrow::Borrow;\nuse std::f32::NEG_INFINITY;\n\nuse itertools::Itertools;\nuse ndarray::prelude::Array2;\n\nmod dnamotif;\npub mod errors;\nmod protmotif;\n\npub use self::dnamotif::DNAMotif;\npub use self::errors::{Error, Result};\npub use self::protmotif::ProtMotif;\n\n/// default pseudocount - used to prevent 0 tallies\npub const DEF_PSEUDO: f32 = 0.5;\n/// approximately zero\npub const EPSILON: f32 = 1e-5;\n/// value representing an invalid monomer in lookup table\npub const INVALID_MONO: u8 = 255;\n\n/// Represents motif score \u0026 location of match\n#[derive(Debug, Clone, PartialEq)]\npub struct ScoredPos {\n    pub loc: usize,\n    pub sum: f32,\n    pub scores: Vec\u003cf32\u003e,\n}\n\nimpl Default for ScoredPos {\n    fn default() -\u003e ScoredPos {\n        ScoredPos {\n            loc: 0,\n            sum: NEG_INFINITY,\n            scores: Vec::new(),\n        }\n    }\n}\n\n/// Trait containing code shared between DNA and protein implementations\n/// of the position-specific scoring matrix.\npub trait Motif {\n    /// Lookup table mapping monomer -\u003e index\n    const LK: [u8; 127] = [INVALID_MONO; 127];\n    /// All monomers, in order corresponding to lookup table\n    const MONOS: \u0026'static [u8] = b\"\";\n    /// Monomer count - equal to length of `MONOS`\n    const MONO_CT: usize = 0;\n\n    /// Returns a weight matrix representing the sequences provided.\n    /// This code is shared by implementations of `from_seqs`\n    /// # Arguments\n    /// * `seqs` - sequences incorporated into motif\n    /// * `pseudos` - array slice with a pseudocount for each monomer;\n    ///    defaults to DEF_PSEUDO for all if None is supplied\n    ///\n    /// FIXME: pseudos should be an array of size MONO_CT, but that\n    /// is currently unsupported\n    fn seqs_to_weights(seqs: \u0026[Vec\u003cu8\u003e], _pseudos: Option\u003c\u0026[f32]\u003e) -\u003e Result\u003cArray2\u003cf32\u003e\u003e {\n        let p1 = vec![DEF_PSEUDO; Self::MONO_CT];\n        let pseudos = match _pseudos {\n            Some(ref p2) =\u003e p2,\n            None =\u003e p1.as_slice(),\n        };\n\n        if pseudos.len() != Self::MONO_CT {\n            return Err(Error::InvalidPseudos {\n                expected: Self::MONO_CT as u8,\n                received: pseudos.len() as u8,\n            });\n        }\n\n        if seqs.is_empty() {\n            return Err(Error::EmptyMotif);\n        }\n\n        let seqlen = seqs[0].len();\n        let mut counts = Array2::zeros((seqlen, Self::MONO_CT));\n        for i in 0..seqlen {\n            for base in 0..Self::MONO_CT {\n                counts[[i, base]] = pseudos[base];\n            }\n        }\n\n        for seq in seqs.iter() {\n            if seq.len() != seqlen {\n                return Err(Error::InconsistentLen);\n            }\n\n            for (idx, base) in seq.iter().enumerate() {\n                match Self::lookup(*base) {\n                    Err(e) =\u003e return Err(e),\n                    Ok(pos) =\u003e counts[[idx, pos]] += 1.0,\n                }\n            }\n        }\n        Ok(counts)\n    }\n\n    /// Returns the index of given monomer in the scores matrix using the lookup table `LK`\n    /// # Arguments\n    /// * `mono` - monomer, eg, b'A' for DNA or b'R' for protein\n    /// # Errors\n    /// * `Error::InvalidMonomer(mono)` - `mono` wasn't found in the lookup table\n    fn lookup(mono: u8) -\u003e Result\u003cusize\u003e {\n        if mono \u003e= 127 {\n            Err(Error::InvalidMonomer { mono })\n        } else {\n            let idx = Self::LK[mono as usize];\n            if idx == INVALID_MONO {\n                Err(Error::InvalidMonomer { mono })\n            } else {\n                Ok(idx as usize)\n            }\n        }\n    }\n\n    /// Returns the monomer associated with the given index; the reverse of `lookup`.\n    /// Returns INVALID_MONO if the index isn't associated with a monomer.\n    /// # Arguments\n    /// * `idx` - the index in question\n    fn rev_lk(idx: usize) -\u003e u8;\n\n    /// Returns the length of motif\n    fn len(\u0026self) -\u003e usize;\n\n    fn is_empty(\u0026self) -\u003e bool {\n        self.len() == 0usize\n    }\n\n    /// Returns a representation of the motif using ambiguous codes.\n    /// Primarily useful for DNA motifs, where ambiguous codes are\n    /// common (eg, 'M' for 'A or C'); less so for proteins, where we\n    /// represent any position without a dominant amino acid as an 'X'\n    fn degenerate_consensus(\u0026self) -\u003e Vec\u003cu8\u003e;\n\n    /// Accessor - returns scores matrix\n    fn get_scores(\u0026self) -\u003e \u0026Array2\u003cf32\u003e;\n\n    /// Return sum of \"worst\" base at each position\n    fn get_min_score(\u0026self) -\u003e f32;\n\n    /// Return sum of \"best\" base at each position\n    fn get_max_score(\u0026self) -\u003e f32;\n\n    /// Returns information content of a single position.\n    /// Used `info_content` method.\n    /// FIXME: this should be replaced with a CTFE ... or maybe just a constant\n    fn get_bits() -\u003e f32;\n\n    /// Returns the un-normalized sum of matching bases, useful for comparing matches from\n    /// motifs of different lengths\n    ///\n    /// # Arguments\n    /// * `seq_it` - iterator representing the query sequence\n    ///\n    /// # Errors\n    /// * `Error::InvalidMonomer(mono)` - sequence `seq_it` contained invalid monomer `mono`\n    fn raw_score\u003cC, T\u003e(\u0026self, seq_it: T) -\u003e Result\u003c(usize, f32, Vec\u003cf32\u003e)\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        let pssm_len = self.len();\n\n        let mut best_start = 0;\n        let mut best_score = -1.0;\n        let mut best_m = Vec::new();\n        // we have to look at slices, so a simple iterator won't do\n        let seq = seq_it.into_iter().map(|c| *c.borrow()).collect_vec();\n        let scores = self.get_scores();\n        for start in 0..=seq.len() - pssm_len {\n            let m: Vec\u003cf32\u003e = match (0..pssm_len)\n                .map(|i| match Self::lookup(seq[start + i]) {\n                    Err(e) =\u003e Err(e),\n                    Ok(pos) =\u003e Ok(scores[[i, pos]]),\n                })\n                .collect()\n            {\n                Ok(m) =\u003e m,\n                Err(e) =\u003e return Err(e),\n            };\n            let tot = m.iter().sum();\n            if tot \u003e best_score {\n                best_score = tot;\n                best_start = start;\n                best_m = m;\n            }\n        }\n        Ok((best_start, best_score, best_m))\n    }\n\n    /// Returns a `ScoredPos` struct representing the best match within the query sequence\n    /// see:\n    ///   MATCHTM: a tool for searching transcription factor binding sites in DNA sequences\n    ///   Nucleic Acids Res. 2003 Jul 1; 31(13): 3576–3579\n    ///   https://www.ncbi.nlm.nih.gov/pmc/articles/PMC169193/\n    ///\n    /// # Arguments\n    /// * `seq_it` - iterator representing the query sequence\n    ///\n    /// # Errors\n    /// * `Error::InvalidMonomer(mono)` - sequence `seq_it` contained invalid monomer `mono`\n    /// * `Error::QueryTooShort` - sequence `seq_id` was too short\n    ///\n    /// # Example\n    /// let pssm = DNAMotif::from_seqs(vec![\n    ///            b\"AAAA\".to_vec(),\n    ///            b\"AATA\".to_vec(),\n    ///            b\"AAGA\".to_vec(),\n    ///            b\"AAAA\".to_vec(),\n    ///        ].as_ref(), None).unwrap();\n    /// let start_pos = pssm.score(b\"CCCCCAATA\").unwrap().loc;\n    fn score\u003cC, T\u003e(\u0026self, seq_it: T) -\u003e Result\u003cScoredPos\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        let pssm_len = self.len();\n        let seq = seq_it.into_iter().map(|c| *c.borrow()).collect_vec();\n        if seq.len() \u003c pssm_len {\n            return Err(Error::QueryTooShort {\n                motif_len: pssm_len,\n                query_len: seq.len(),\n            });\n        }\n        let min_score = self.get_min_score();\n        let max_score = self.get_max_score();\n\n        if abs_diff_eq!(max_score, min_score) {\n            return Err(Error::NullMotif);\n        }\n\n        let (best_start, best_score, best_m) = self.raw_score(\u0026seq)?;\n\n        Ok(ScoredPos {\n            loc: best_start,\n            sum: (best_score - min_score) / (max_score - min_score),\n            scores: best_m,\n        })\n    }\n\n    /// Returns a float representing the information content of a motif; roughly the\n    /// inverse of Shannon Entropy.\n    /// Adapted from the information content described here:\n    ///    https://en.wikipedia.org/wiki/Sequence_logo#Logo_creation\n    fn info_content(\u0026self) -\u003e f32 {\n        fn ent\u003c'a, I\u003e(probs: I) -\u003e f32\n        where\n            I: Iterator\u003cItem = \u0026'a f32\u003e,\n        {\n            probs\n                .map(|p| {\n                    if *p == 0.0 {\n                        0.0\n                    } else {\n                        -1.0 * *p * p.log(2.0)\n                    }\n                })\n                .sum()\n        }\n        let bits = Self::get_bits();\n        let scores = self.get_scores();\n        let mut tot = 0.0;\n        for row in scores.genrows() {\n            tot += bits - ent(row.iter());\n        }\n        tot\n    }\n}\n","traces":[{"line":65,"address":[5724656],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":69,"address":[5724669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[4710351,4710336,4707824],"length":1,"stats":{"Line":0},"fn_name":"seqs_to_weights\u003cbio::pattern_matching::pssm::dnamotif::DNAMotif\u003e"},{"line":94,"address":[4707895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[4707944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[4707983,4707921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[4707954,4708085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[4708151,4708031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[4708246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[4708192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[4708173,4708337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[4708373],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[4708351,4708434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[4708502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[4708848,4709085,4708561,4708704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[4709090,4708888,4709307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[4709130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[4709328,4709535,4708812,4709945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[4709572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[4709649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[4709728,4709614,4710331,4709950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[4710054,4710019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[4710150,4710037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[4710315,4710061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[4709446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[4710352],"length":1,"stats":{"Line":0},"fn_name":"lookup\u003cbio::pattern_matching::pssm::dnamotif::DNAMotif\u003e"},{"line":140,"address":[4710383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[4710443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[4710504,4710530,4710387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[4710576,4710519,4710650,4710645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[4710587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[4710562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[4710656],"length":1,"stats":{"Line":0},"fn_name":"is_empty\u003cbio::pattern_matching::pssm::dnamotif::DNAMotif\u003e"},{"line":162,"address":[4710665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[4710704,4712489],"length":1,"stats":{"Line":0},"fn_name":"raw_score\u003cbio::pattern_matching::pssm::dnamotif::DNAMotif,\u0026u8,\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":198,"address":[4710764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[4710830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[4710842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[4710861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[4711049,4710914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[4711061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[4711170,4711089,4711588,4712438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[4711620,4711688,4711767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[4711648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[5946900,5947401,5947300,5947001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[5947528,5946926,5947326,5947128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[4711769,4711750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[4711883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[4712132,4711849,4712054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[4712317,4712160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[4712181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[4712190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[4712319,4712206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[4711409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[4714851,4713696,4712512,4713667],"length":1,"stats":{"Line":0},"fn_name":"score\u003cbio::pattern_matching::pssm::dnamotif::DNAMotif,\u0026u8,\u0026[u8; 14]\u003e"},{"line":253,"address":[4713750,4712566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[4712615,4712697,4713799,4713881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[4712742,4713926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[4712878,4714062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[4714023,4712839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[4714159,4712826,4712975,4714010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[4712984,4714168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[4713012,4714196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[4714284,4713100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[4714356,4713172,4713088,4713627,4714272,4714727,4714811,4713543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[4713430,4714614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[4713368,4714552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[4713398,4714582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[4714880],"length":1,"stats":{"Line":0},"fn_name":"info_content\u003cbio::pattern_matching::pssm::dnamotif::DNAMotif\u003e"},{"line":282,"address":[5947936],"length":1,"stats":{"Line":0},"fn_name":"ent\u003cndarray::iterators::Iter\u003cf32, ndarray::dimension::dim::Dim\u003c[usize; 1]\u003e\u003e\u003e"},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[5947943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[5948000],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cndarray::iterators::Iter\u003cf32, ndarray::dimension::dim::Dim\u003c[usize; 1]\u003e\u003e\u003e"},{"line":288,"address":[5948123,5948019,5948125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[5948082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[5948040,5948113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[4714900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[4714925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[4714948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[4715325,4714957,4715065,4715330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[4715257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":88},{"path":["/","home","todd","rust-bio","src","pattern_matching","pssm","protmotif.rs"],"content":"// Copyright 2018 Kieran Hervold\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse super::*;\nuse ndarray::prelude::Array2;\nuse std::f32;\nuse std::f32::{INFINITY, NEG_INFINITY};\n\n/// Position-specific scoring matrix for protein sequences\n#[derive(Clone, Debug, PartialEq)]\npub struct ProtMotif {\n    /// matrix holding weights at each position, indexed by [position, base]\n    pub scores: Array2\u003cf32\u003e,\n    /// sum of \"worst\" base at each position\n    pub min_score: f32,\n    /// sum of \"best\" base at each position\n    pub max_score: f32,\n}\n\nimpl ProtMotif {\n    /// Returns a Motif representing the sequences provided.\n    /// # Arguments\n    /// * `seqs` - sequences incorporated into motif\n    /// * `pseudos` - array slice with a pseudocount for each monomer;\n    ///    defaults to pssm::DEF_PSEUDO for all if None is supplied\n    ///\n    /// FIXME: pseudos should be an array of size MONO_CT, but that\n    /// is currently impossible - see\n    /// https://github.com/rust-lang/rust/issues/42863\n    pub fn from_seqs(seqs: \u0026[Vec\u003cu8\u003e], pseudos: Option\u003c\u0026[f32]\u003e) -\u003e Result\u003cSelf\u003e {\n        let w = Self::seqs_to_weights(seqs, pseudos)?;\n        let mut m = ProtMotif {\n            scores: w,\n            min_score: 0.0,\n            max_score: 0.0,\n        };\n        m.normalize();\n        m.calc_minmax();\n        Ok(m)\n    }\n\n    // helper function -- normalize self.scores\n    fn normalize(\u0026mut self) {\n        for i in 0..self.len() {\n            let mut tot: f32 = 0.0;\n            // FIXME: slices would be cleaner\n            for base_i in 0..20 {\n                tot += self.scores[[i, base_i]];\n            }\n            for base_i in 0..20 {\n                self.scores[[i, base_i]] /= tot;\n            }\n        }\n    }\n\n    // helper function\n    fn calc_minmax(\u0026mut self) {\n        let pssm_len = self.len();\n\n        // score corresponding to sum of \"worst\" bases at each position\n        // FIXME: iter ...\n        self.min_score = 0.0;\n        for i in 0..pssm_len {\n            // can't use the regular min/max on f32, so we use f32::min\n            let min_sc = (0..20)\n                .map(|b| self.scores[[i, b]])\n                .fold(INFINITY, f32::min);\n            self.min_score += min_sc;\n        }\n\n        // score corresponding to \"best\" base at each position\n        self.max_score = 0.0;\n        for i in 0..pssm_len {\n            let max_sc = (0..20)\n                .map(|b| self.scores[[i, b]])\n                .fold(NEG_INFINITY, f32::max);\n            self.max_score += max_sc;\n        }\n    }\n}\n\nimpl Motif for ProtMotif {\n    const LK: [u8; 127] = [\n        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 255, 4, 3, 5, 13, 7, 8, 9, 255,\n        11, 10, 12, 2, 255, 14, 6, 1, 15, 16, 255, 19, 17, 255, 18, 255, 255, 255, 255, 255, 255,\n        255, 0, 255, 4, 3, 5, 13, 7, 8, 9, 255, 11, 10, 12, 2, 255, 14, 6, 1, 15, 16, 255, 19, 17,\n        255, 18, 255, 255, 255, 255, 255,\n    ];\n    const MONOS: \u0026'static [u8] = b\"ARNDCEQGHILKMFPSTWYV\";\n    const MONO_CT: usize = 20;\n\n    fn rev_lk(idx: usize) -\u003e u8 {\n        if idx \u003e= Self::MONOS.len() {\n            INVALID_MONO\n        } else {\n            Self::MONOS[idx]\n        }\n    }\n\n    fn len(\u0026self) -\u003e usize {\n        self.scores.dim().0\n    }\n    fn get_scores(\u0026self) -\u003e \u0026Array2\u003cf32\u003e {\n        \u0026self.scores\n    }\n    fn get_min_score(\u0026self) -\u003e f32 {\n        self.min_score\n    }\n    fn get_max_score(\u0026self) -\u003e f32 {\n        self.max_score\n    }\n    fn get_bits() -\u003e f32 {\n        20f32.log2()\n    }\n    fn degenerate_consensus(\u0026self) -\u003e Vec\u003cu8\u003e {\n        let len = self.len();\n        let mut res = Vec::with_capacity(len);\n        for pos in 0..len {\n            let mut fracs = (0..20)\n                .map(|b| (self.scores[[pos, b]], b))\n                .collect::\u003cVec\u003c(f32, usize)\u003e\u003e();\n            // note: reverse sort\n            fracs.sort_by(|a, b| b.partial_cmp(a).unwrap());\n\n            res.push(if fracs[0].0 \u003e 0.5 \u0026\u0026 fracs[0].0 \u003e 2.0 * fracs[1].0 {\n                Self::MONOS[fracs[0].1]\n            } else {\n                b'X'\n            });\n        }\n        res\n    }\n}\n\n/// Return a ProtMotif wrapping an Array2 representing amino acid\n/// weights at each position.  The dimensions and contents of this\n/// array are unchecked, and it is incumbent on the user to ensure\n/// the correct dimensions are used (ie, SEQ_LEN x 20), and no zeros\n/// appear in the array.\nimpl From\u003cArray2\u003cf32\u003e\u003e for ProtMotif {\n    fn from(scores: Array2\u003cf32\u003e) -\u003e Self {\n        let mut m = ProtMotif {\n            scores,\n            min_score: 0.0,\n            max_score: 0.0,\n        };\n        m.normalize();\n        m.calc_minmax();\n        m\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use ndarray::Array;\n\n    #[test]\n    fn test_info_content() {\n        let pssm = ProtMotif::from_seqs(vec![b\"AAAA\".to_vec()].as_ref(), Some(\u0026[0.0; 20])).unwrap();\n        assert_relative_eq!(\n            pssm.info_content(),\n            ProtMotif::get_bits() * 4.0,\n            epsilon = f32::EPSILON\n        );\n    }\n\n    #[test]\n    fn test_scoring() {\n        // should match \"ARND\"\n        let m: Array2\u003cf32\u003e = Array::from(vec![\n            0.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,\n            0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,\n            0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,\n            0.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,\n            0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,\n            0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,\n        ])\n        .into_shape((4, 20))\n        .unwrap();\n        let pssm: ProtMotif = m.into();\n        let scored_pos = pssm.score(b\"AAAAARNDAAA\").unwrap();\n        assert_eq!(scored_pos.loc, 4);\n    }\n\n    #[test]\n    fn test_mono_err() {\n        let pssm = ProtMotif::from_seqs(vec![b\"ARGN\".to_vec()].as_ref(), None).unwrap();\n        assert!(matches!(\n            pssm.score(b\"AAAABAAAAAAAAA\"),\n            Err(Error::InvalidMonomer { mono: b'B' })\n        ));\n    }\n\n    #[test]\n    fn test_inconsist_err() {\n        assert!(matches!(\n            ProtMotif::from_seqs(\n                vec![b\"NNNNN\".to_vec(), b\"RRRRR\".to_vec(), b\"C\".to_vec()].as_ref(),\n                Some(\u0026[0.0; 20])\n            ),\n            Err(Error::InconsistentLen)\n        ));\n    }\n\n    #[test]\n    fn test_degenerate_consensus_same_bases() {\n        let pssm = ProtMotif::from_seqs(\n            vec![b\"QVTYNDSA\".to_vec(), b\"QVTYNDSA\".to_vec()].as_ref(),\n            Some(\u0026[0.0; 20]),\n        )\n        .unwrap();\n        assert_eq!(pssm.degenerate_consensus(), b\"QVTYNDSA\".to_vec());\n    }\n\n    #[test]\n    fn test_degenerate_consensus_x() {\n        let pssm = ProtMotif::from_seqs(\n            vec![b\"QVTYNDSA\".to_vec(), b\"ASDNYTVQ\".to_vec()].as_ref(),\n            Some(\u0026[0.0; 20]),\n        )\n        .unwrap();\n        assert_eq!(pssm.degenerate_consensus(), b\"XXXXXXXX\".to_vec());\n    }\n}\n","traces":[{"line":32,"address":[4426485,4425840],"length":1,"stats":{"Line":0},"fn_name":"from_seqs"},{"line":33,"address":[4426226,4425888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[4426215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4426355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[4426399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4426512],"length":1,"stats":{"Line":0},"fn_name":"normalize"},{"line":46,"address":[4426532,4426664,4427106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4426701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[4427023,4426713,4426915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[4426947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[4427121,4427240,4427245,4426847,4427038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[4427153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[4427248],"length":1,"stats":{"Line":0},"fn_name":"calc_minmax"},{"line":60,"address":[4427260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[4427288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[4427301,4427476,4427653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[4427502,4427552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[4427526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[4427633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[4427406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[4427744,4427936,4427668,4427941,4427419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[4427776,4427829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[4427800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[4427916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[4427952],"length":1,"stats":{"Line":0},"fn_name":"rev_lk"},{"line":98,"address":[4428055,4427966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[4428022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[4428062,4428085,4428009,4428041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[4428096],"length":1,"stats":{"Line":0},"fn_name":"len"},{"line":106,"address":[4428105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[4428128],"length":1,"stats":{"Line":0},"fn_name":"get_scores"},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[4428144],"length":1,"stats":{"Line":0},"fn_name":"get_min_score"},{"line":112,"address":[4428149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[4428160],"length":1,"stats":{"Line":0},"fn_name":"get_max_score"},{"line":115,"address":[4428165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[4428176],"length":1,"stats":{"Line":0},"fn_name":"get_bits"},{"line":118,"address":[4428177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[4429130,4429115,4428208],"length":1,"stats":{"Line":0},"fn_name":"degenerate_consensus"},{"line":121,"address":[4428233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[4428269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[4428502,4428280,4429110,4428409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[4428534,4428590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[4428566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[4428668],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[4428954,4429039,4429076,4428748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[4428956,4429046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[4428946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[4429291,4429136,4429303],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":152,"address":[4429236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[4429247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[7708800,7708971],"length":1,"stats":{"Line":0},"fn_name":"test_info_content"},{"line":165,"address":[7708824,7708994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[7709323,7709544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[7709260,7709195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[7709269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[7710400,7712093],"length":1,"stats":{"Line":0},"fn_name":"test_scoring"},{"line":176,"address":[7711676,7710407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[7711652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[7711732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[7711776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[7711987,7711876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[7712283,7712128],"length":1,"stats":{"Line":0},"fn_name":"test_mono_err"},{"line":193,"address":[7712145,7712306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[7712628,7712549,7712569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[7712460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[7712524,7712559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[7712672,7713040],"length":1,"stats":{"Line":0},"fn_name":"test_inconsist_err"},{"line":202,"address":[7713202,7713266,7713296,7713148],"length":1,"stats":{"Line":0},"fn_name":"test_degenerate_consensus_same_bases"},{"line":203,"address":[7713120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[7713060,7712689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[7713093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[7713183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[7713567,7713296],"length":1,"stats":{"Line":0},"fn_name":"test_degenerate_consensus_same_bases"},{"line":214,"address":[7713318,7713590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[7713623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[7713825,7713781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[7714431,7714160],"length":1,"stats":{"Line":0},"fn_name":"test_degenerate_consensus_x"},{"line":224,"address":[7714182,7714454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[7714487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[7714645,7714689],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":85},{"path":["/","home","todd","rust-bio","src","pattern_matching","shift_and.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! `ShiftAnd` algorithm for pattern matching.\n//! Patterns may contain at most 64 symbols.\n//! Complexity: O(n) with text length n.\n//!\n//! # Example\n//!\n//! ```rust\n//! use bio::pattern_matching::shift_and;\n//! let pattern = b\"AAAA\";\n//! let text = b\"ACGGCTAGAAAAGGCTAG\";\n//! let shiftand = shift_and::ShiftAnd::new(pattern);\n//! let occ = shiftand.find_all(text).next().unwrap();\n//! assert_eq!(occ, 8);\n//! ```\n\nuse std::borrow::Borrow;\nuse std::iter::Enumerate;\n\n/// `ShiftAnd` algorithm.\npub struct ShiftAnd {\n    m: usize,\n    masks: [u64; 256],\n    accept: u64,\n}\n\nimpl ShiftAnd {\n    /// Create new ShiftAnd instance from a given pattern.\n    pub fn new\u003cC, P\u003e(pattern: P) -\u003e Self\n    where\n        P::IntoIter: ExactSizeIterator,\n        C: Borrow\u003cu8\u003e,\n        P: IntoIterator\u003cItem = C\u003e,\n    {\n        let pattern = pattern.into_iter();\n        let m = pattern.len();\n        assert!(m \u003c= 64, \"Expecting a pattern of at most 64 symbols.\");\n        let (masks, accept) = masks(pattern);\n\n        ShiftAnd { m, masks, accept }\n    }\n\n    /// Find all matches of pattern in the given text. Matches are returned as an iterator\n    /// over start positions.\n    pub fn find_all\u003cC, T\u003e(\u0026self, text: T) -\u003e Matches\u003c'_, C, T::IntoIter\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        Matches {\n            shiftand: self,\n            active: 0,\n            text: text.into_iter().enumerate(),\n        }\n    }\n}\n\n/// Calculate ShiftAnd masks. This function is called automatically when instantiating\n/// a new ShiftAnd for a given pattern.\npub fn masks\u003cC, P\u003e(pattern: P) -\u003e ([u64; 256], u64)\nwhere\n    C: Borrow\u003cu8\u003e,\n    P: IntoIterator\u003cItem = C\u003e,\n{\n    let mut masks = [0; 256];\n\n    let mut bit = 1;\n    for c in pattern {\n        masks[*c.borrow() as usize] |= bit;\n        bit *= 2;\n    }\n\n    (masks, bit / 2)\n}\n\n/// Iterator over start positions of matches.\npub struct Matches\u003c'a, C, T\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    shiftand: \u0026'a ShiftAnd,\n    active: u64,\n    text: Enumerate\u003cT\u003e,\n}\n\nimpl\u003c'a, C, T\u003e Iterator for Matches\u003c'a, C, T\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    type Item = usize;\n\n    fn next(\u0026mut self) -\u003e Option\u003cusize\u003e {\n        for (i, c) in self.text.by_ref() {\n            self.active = ((self.active \u003c\u003c 1) | 1) \u0026 self.shiftand.masks[*c.borrow() as usize];\n            if self.active \u0026 self.shiftand.accept \u003e 0 {\n                return Some(i + 1 - self.shiftand.m);\n            }\n        }\n\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use itertools::Itertools;\n\n    #[test]\n    fn test_find_all() {\n        let text = b\"dhjalkjwqnnnannanaflkjdklfj\";\n        let pattern = b\"qnnnannan\";\n        let shiftand = ShiftAnd::new(pattern);\n        assert_eq!(shiftand.find_all(text).collect_vec(), [8]);\n    }\n\n    #[test]\n    fn test_issue_416() {\n        let text_pos_0 = b\"CCTTTTTTTTTTTTTTT\";\n        let pattern = b\"CC\";\n        let shiftand = ShiftAnd::new(pattern);\n        assert_eq!(shiftand.find_all(text_pos_0).collect_vec(), [0]);\n    }\n\n    #[test]\n    fn test_multiple_finds() {\n        let text = b\"CCTCCTCC\";\n        let pattern = b\"CC\";\n        let shiftand = ShiftAnd::new(pattern);\n        assert_eq!(shiftand.find_all(text).collect_vec(), [0, 3, 6]);\n    }\n}\n","traces":[{"line":33,"address":[5713264,5713234,5713778,5712720],"length":1,"stats":{"Line":0},"fn_name":"new\u003c\u0026u8,\u0026[u8; 2]\u003e"},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[5713511,5712967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[5713064,5712975,5713519,5713608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[5713096,5713640,5713031,5713575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[5714096,5713952,5713808],"length":1,"stats":{"Line":0},"fn_name":"find_all\u003c\u0026u8,\u0026[u8; 27]\u003e"},{"line":57,"address":[5713993,5714137,5713849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[5714896,5714778,5714240,5715434],"length":1,"stats":{"Line":0},"fn_name":"masks\u003c\u0026u8,core::iter::adapters::rev::Rev\u003ccore::slice::iter::Iter\u003cu8\u003e\u003e\u003e"},{"line":69,"address":[5714289,5714945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[5714324,5714980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[5714497,5714992,5715425,5714482,5715138,5715153,5714336,5714769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[5715201,5714691,5715347,5714646,5715302,5714545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[5715377,5714656,5714721,5715387,5715312,5714731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[5714793,5715449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[5715552,5716222],"length":1,"stats":{"Line":0},"fn_name":"next\u003c\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":99,"address":[5716217,5715572,5715737,5715766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[5715861,5715981,5716020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[5716150,5716055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[7733776,7733781],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":117,"address":[5137623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[5137638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[5137653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[5137670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[5138260,5137952],"length":1,"stats":{"Line":0},"fn_name":"test_issue_416"},{"line":125,"address":[5137959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[5137974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[5137989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[5138006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[5138596,5138288],"length":1,"stats":{"Line":0},"fn_name":"test_multiple_finds"},{"line":133,"address":[5138295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[5138310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[5138325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[5138342],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":35},{"path":["/","home","todd","rust-bio","src","pattern_matching","ukkonen.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Bounded version of Ukkonens DP algorithm for approximate pattern matching.\n//! Complexity: O(n * k) on random texts.\n//!\n//! The algorithm finds all matches of a pattern in a text with up to k errors.\n//! Idea is to use dynamic programming to column-wise explore the edit matrix, but to omit\n//! parts of the matrix for which the error exceeds k. To achieve this, a value `lastk` is\n//! maintained that provides the lower feasible boundary of the matrix.\n//! Initially, lastk = min(k, m). In each iteration (over a column), lastk can increase by at most 1.\n//!\n//! # Example\n//!\n//! ```\n//! use bio::pattern_matching::ukkonen::{unit_cost, Ukkonen};\n//!\n//! let mut ukkonen = Ukkonen::with_capacity(10, unit_cost);\n//! let text = b\"ACCGTGGATGAGCGCCATAG\";\n//! let pattern = b\"TGAGCGA\";\n//! let occ: Vec\u003c(usize, usize)\u003e = ukkonen.find_all_end(pattern, text, 1).collect();\n//! assert_eq!(occ, [(13, 1), (14, 1)]);\n//! ```\n\nuse std::borrow::Borrow;\nuse std::cmp::min;\nuse std::iter;\nuse std::iter::repeat;\n\nuse crate::utils::TextSlice;\n\n/// Default cost function (unit costs).\npub fn unit_cost(a: u8, b: u8) -\u003e u32 {\n    (a != b) as u32\n}\n\n/// Ukkonens algorithm.\n#[allow(non_snake_case)]\npub struct Ukkonen\u003cF\u003e\nwhere\n    F: Fn(u8, u8) -\u003e u32,\n{\n    D: [Vec\u003cusize\u003e; 2],\n    cost: F,\n}\n\nimpl\u003cF\u003e Ukkonen\u003cF\u003e\nwhere\n    F: Fn(u8, u8) -\u003e u32,\n{\n    /// Initialize algorithm with given capacity and cost function.\n    pub fn with_capacity(m: usize, cost: F) -\u003e Self {\n        let get_vec = || Vec::with_capacity(m + 1);\n        Ukkonen {\n            D: [get_vec(), get_vec()],\n            cost,\n        }\n    }\n\n    /// Find all matches between pattern and text with up to k errors.\n    /// Matches are returned as an iterator over pairs of end position and distance.\n    pub fn find_all_end\u003c'a, C, T\u003e(\n        \u0026'a mut self,\n        pattern: TextSlice\u003c'a\u003e,\n        text: T,\n        k: usize,\n    ) -\u003e Matches\u003c'_, F, C, T::IntoIter\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        let m = pattern.len();\n        self.D[0].clear();\n        self.D[0].extend(repeat(k + 1).take(m + 1));\n        self.D[1].clear();\n        self.D[1].extend(0..=m);\n        Matches {\n            ukkonen: self,\n            pattern,\n            text: text.into_iter().enumerate(),\n            lastk: min(k, m),\n            m,\n            k,\n        }\n    }\n}\n\n/// Iterator over pairs of end positions and distance of matches.\npub struct Matches\u003c'a, F, C, T\u003e\nwhere\n    F: Fn(u8, u8) -\u003e u32,\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    ukkonen: \u0026'a mut Ukkonen\u003cF\u003e,\n    pattern: TextSlice\u003c'a\u003e,\n    text: iter::Enumerate\u003cT\u003e,\n    lastk: usize,\n    m: usize,\n    k: usize,\n}\n\nimpl\u003c'a, F, C, T\u003e Iterator for Matches\u003c'a, F, C, T\u003e\nwhere\n    F: 'a + Fn(u8, u8) -\u003e u32,\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    type Item = (usize, usize);\n\n    fn next(\u0026mut self) -\u003e Option\u003c(usize, usize)\u003e {\n        let cost = \u0026self.ukkonen.cost;\n        for (i, c) in \u0026mut self.text {\n            let col = i % 2;\n            let prev = 1 - col;\n\n            // start with zero edit distance (semi-global alignment)\n            self.ukkonen.D[col][0] = 0;\n            self.lastk = min(self.lastk + 1, self.m);\n            // in each column, go at most one cell further than before\n            // do not look at cells with too big k\n            for j in 1..=self.lastk {\n                self.ukkonen.D[col][j] = min(\n                    min(self.ukkonen.D[prev][j] + 1, self.ukkonen.D[col][j - 1] + 1),\n                    self.ukkonen.D[prev][j - 1] + (cost)(self.pattern[j - 1], *c.borrow()) as usize,\n                );\n            }\n\n            // reduce lastk as long as k is exceeded: while lastk can increase by at most 1, it can\n            // decrease more in one iteration.\n            while self.ukkonen.D[col][self.lastk] \u003e self.k {\n                self.lastk -= 1;\n            }\n\n            if self.lastk == self.m {\n                return Some((i, self.ukkonen.D[col][self.m]));\n            }\n        }\n\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_find_all_end() {\n        let mut ukkonen = Ukkonen::with_capacity(10, unit_cost);\n        let text = b\"ACCGTGGATGAGCGCCATAG\";\n        let pattern = b\"TGAGCGT\";\n        let occ: Vec\u003c(usize, usize)\u003e = ukkonen.find_all_end(pattern, text, 1).collect();\n        assert_eq!(occ, [(13, 1), (14, 1)]);\n    }\n\n    #[test]\n    fn test_find_start() {\n        let mut u = Ukkonen::with_capacity(10, unit_cost);\n\n        let pattern = b\"ACCGT\";\n        // hit begins at 1st position\n        let text1 = b\"ACCGTGGATGAGCGCCATAG\";\n        // hit begins at 2nd position\n        let text2 = b\"AACCGTGGATGAGCGCCATAG\";\n\n        let occ: Vec\u003c(usize, usize)\u003e = u.find_all_end(pattern, text1, 1).collect();\n        assert_eq!(occ, [(3, 1), (4, 0), (5, 1)]);\n        let occ: Vec\u003c(usize, usize)\u003e = u.find_all_end(pattern, text2, 1).collect();\n        assert_eq!(occ, [(4, 1), (5, 0), (6, 1)]);\n    }\n}\n","traces":[{"line":35,"address":[7744880],"length":1,"stats":{"Line":0},"fn_name":"unit_cost"},{"line":36,"address":[7744897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[5256992,5257229,5257214],"length":1,"stats":{"Line":0},"fn_name":"with_capacity\u003cfn(u8, u8) -\u003e u32\u003e"},{"line":55,"address":[5257232,5257251,5257018],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cfn(u8, u8) -\u003e u32\u003e"},{"line":57,"address":[5257088,5257033,5257176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[5258096,5258069,5258821,5257344],"length":1,"stats":{"Line":0},"fn_name":"find_all_end\u003cfn(u8, u8) -\u003e u32,\u0026u8,\u0026[u8; 21]\u003e"},{"line":74,"address":[5258200,5257448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[5258259,5257507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[5257574,5258326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[5257756,5258508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[5258536,5257784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[5257839,5258591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[5258664,5257912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[5261421,5258848],"length":1,"stats":{"Line":0},"fn_name":"next\u003cfn(u8, u8) -\u003e u32,\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":114,"address":[5258898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[5259091,5259121,5258925,5261416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[5259225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[5259305,5259245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[5259292,5259380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[5259478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[5259596,5260954,5259804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[5260773,5260833],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[5259844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[5260320,5260792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[5259791,5260967,5261158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[5261163,5261121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[5261101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[5261209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[5259109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[7733872,7733877],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":152,"address":[9773399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[9773414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[9773429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[9773465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[9773685,9773531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[9773776,9774423],"length":1,"stats":{"Line":0},"fn_name":"test_find_start"},{"line":161,"address":[9773783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[9773798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[9773813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[9773828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[9773864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[9773930,9774113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[9774058,9774175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[9774348,9774190],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":44},{"path":["/","home","todd","rust-bio","src","scores","blosum62.rs"],"content":"// Copyright 2014-2017 M. Rizky Luthfianto.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\nlazy_static! {\n    // taken from https://github.com/seqan/seqan/blob/master/include%2Fseqan%2Fscore%2Fscore_matrix_data.h#L327\n    static ref MAT: ndarray::Array2\u003ci32\u003e = ndarray::Array::from_shape_vec((27, 27), vec![\n         4, -2,  0, -2, -1, -2,  0, -2, -1, -1, -1, -1, -1, -2,  0, -1, -1, -1,  1,  0,  0,\n         0, -3, -2, -1,  0, -4,\n        -2,  4, -3,  4,  1, -3, -1,  0, -3, -4,  0, -4, -3,  3, -1, -2,  0, -1,  0, -1, -1,\n        -3, -4, -3,  1, -1, -4,\n         0, -3,  9, -3, -4, -2, -3, -3, -1, -1, -3, -1, -1, -3, -2, -3, -3, -3, -1, -1, -2,\n        -1, -2, -2, -3, -2, -4,\n        -2,  4, -3,  6,  2, -3, -1, -1, -3, -4, -1, -4, -3,  1, -1, -1,  0, -2,  0, -1, -1,\n        -3, -4, -3,  1, -1, -4,\n        -1,  1, -4,  2,  5, -3, -2,  0, -3, -3,  1, -3, -2,  0, -1, -1,  2,  0,  0, -1, -1,\n        -2, -3, -2,  4, -1, -4,\n        -2, -3, -2, -3, -3,  6, -3, -1,  0,  0, -3,  0,  0, -3, -1, -4, -3, -3, -2, -2, -1,\n        -1,  1,  3, -3, -1, -4,\n         0, -1, -3, -1, -2, -3,  6, -2, -4, -4, -2, -4, -3,  0, -1, -2, -2, -2,  0, -2, -1,\n        -3, -2, -3, -2, -1, -4,\n        -2,  0, -3, -1,  0, -1, -2,  8, -3, -3, -1, -3, -2,  1, -1, -2,  0,  0, -1, -2, -1,\n        -3, -2,  2,  0, -1, -4,\n        -1, -3, -1, -3, -3,  0, -4, -3,  4,  3, -3,  2,  1, -3, -1, -3, -3, -3, -2, -1, -1,\n         3, -3, -1, -3, -1, -4,\n        -1, -4, -1, -4, -3,  0, -4, -3,  3,  3, -3,  3,  2, -3, -1, -3, -3, -3, -2, -1, -1,\n         2, -3, -1, -3, -1, -4,\n        -1,  0, -3, -1,  1, -3, -2, -1, -3, -3,  5, -2, -1,  0, -1, -1,  1,  2,  0, -1, -1,\n        -2, -3, -2,  1, -1, -4,\n        -1, -4, -1, -4, -3,  0, -4, -3,  2,  3, -2,  4,  2, -3, -1, -3, -2, -2, -2, -1, -1,\n         1, -2, -1, -3, -1, -4,\n        -1, -3, -1, -3, -2,  0, -3, -2,  1,  2, -1,  2,  5, -2, -1, -2,  0, -1, -1, -1, -1,\n         1, -1, -1, -1, -1, -4,\n        -2,  3, -3,  1,  0, -3,  0,  1, -3, -3,  0, -3, -2,  6, -1, -2,  0,  0,  1,  0, -1,\n        -3, -4, -2,  0, -1, -4,\n         0, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1,  0,  0, -1,\n        -1, -2, -1, -1, -1, -4,\n        -1, -2, -3, -1, -1, -4, -2, -2, -3, -3, -1, -3, -2, -2, -2,  7, -1, -2, -1, -1, -2,\n        -2, -4, -3, -1, -2, -4,\n        -1,  0, -3,  0,  2, -3, -2,  0, -3, -3,  1, -2,  0,  0, -1, -1,  5,  1,  0, -1, -1,\n        -2, -2, -1,  3, -1, -4,\n        -1, -1, -3, -2,  0, -3, -2,  0, -3, -3,  2, -2, -1,  0, -1, -2,  1,  5, -1, -1, -1,\n        -3, -3, -2,  0, -1, -4,\n         1,  0, -1,  0,  0, -2,  0, -1, -2, -2,  0, -2, -1,  1,  0, -1,  0, -1,  4,  1,  0,\n        -2, -3, -2,  0,  0, -4,\n         0, -1, -1, -1, -1, -2, -2, -2, -1, -1, -1, -1, -1,  0,  0, -1, -1, -1,  1,  5,  0,\n         0, -2, -2, -1,  0, -4,\n         0, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1,  0,  0, -1,\n        -1, -2, -1, -1, -1, -4,\n         0, -3, -1, -3, -2, -1, -3, -3,  3,  2, -2,  1,  1, -3, -1, -2, -2, -3, -2,  0, -1,\n         4, -3, -1, -2, -1, -4,\n        -3, -4, -2, -4, -3,  1, -2, -2, -3, -3, -3, -2, -1, -4, -2, -4, -2, -3, -3, -2, -2,\n        -3, 11,  2, -3, -2, -4,\n        -2, -3, -2, -3, -2,  3, -3,  2, -1, -1, -2, -1, -1, -2, -1, -3, -1, -2, -2, -2, -1,\n        -1,  2,  7, -2, -1, -4,\n        -1,  1, -3,  1,  4, -3, -2,  0, -3, -3,  1, -3, -1,  0, -1, -1,  3,  0,  0, -1, -1,\n        -2, -3, -2,  4, -1, -4,\n         0, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1,  0,  0, -1,\n        -1, -2, -1, -1, -1, -4,\n        -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\n        -4, -4, -4, -4, -4,  1\n    ]).unwrap();\n}\n\n#[inline]\nfn lookup(a: u8) -\u003e usize {\n    if a == b'Y' {\n        23\n    } else if a == b'Z' {\n        24\n    } else if a == b'X' {\n        25\n    } else if a == b'*' {\n        26\n    } else {\n        (a - 65) as usize\n    }\n}\n\n/// Return the BLOSUM62 substitution matrix score of [a, b]\n///\n/// # Example\n///\n/// ```\n/// use bio::scores::blosum62;\n/// assert_eq!(blosum62(b'H', b'A'), -2);\n/// ```\npub fn blosum62(a: u8, b: u8) -\u003e i32 {\n    let a = lookup(a);\n    let b = lookup(b);\n\n    MAT[(a, b)]\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_blosum62() {\n        let score1 = blosum62(b'A', b'A');\n        assert_eq!(score1, 4);\n        let score2 = blosum62(b'O', b'*');\n        assert_eq!(score2, -4);\n        let score3 = blosum62(b'A', b'*');\n        assert_eq!(score3, -4);\n        let score4 = blosum62(b'*', b'*');\n        assert_eq!(score4, 1);\n        let score5 = blosum62(b'X', b'X');\n        assert_eq!(score5, -1);\n        let score6 = blosum62(b'X', b'Z');\n        assert_eq!(score6, -1);\n    }\n}\n","traces":[{"line":8,"address":[4474512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[4610876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[4610918,4610891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[4610960],"length":1,"stats":{"Line":0},"fn_name":"blosum62"},{"line":90,"address":[4610982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[4611004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[4611022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[5754240],"length":1,"stats":{"Line":0},"fn_name":"test_blosum62"},{"line":102,"address":[5754247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[5754263,5754367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[5754333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[5754415,5754534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[5754500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[5754698,5754582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[5754667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[5754746,5754862],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[5754831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[5754910,5755029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[5754995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[5755180,5755077],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":28},{"path":["/","home","todd","rust-bio","src","scores","mod.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\npub use self::blosum62::blosum62;\npub use self::pam120::pam120;\npub use self::pam200::pam200;\npub use self::pam250::pam250;\npub use self::pam40::pam40;\n\npub mod blosum62;\npub mod pam120;\npub mod pam200;\npub mod pam250;\npub mod pam40;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","scores","pam120.rs"],"content":"// Copyright 2015 M. Rizky Luthfianto.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\nlazy_static! {\n    // taken from https://github.com/seqan/seqan/blob/master/include%2Fseqan%2Fscore%2\n    // Fscore_matrix_data.h#L614\n    // Copyright (c) 2006-2015, Knut Reinert, FU Berlin\n    static ref MAT: ndarray::Array2\u003ci32\u003e = ndarray::Array::from_shape_vec((27, 27), vec![\n         3,  0, -3,  0,  0, -4,  1, -3, -1, -2, -2, -3, -2, -1, -1,  1, -1, -3,  1,  1, -1,  0,\n        -7, -4, -1, -1, -8,\n         0,  4, -6,  4,  3, -5,  0,  1, -3, -4,  0, -4, -4,  3, -1, -2,  0, -2,  0,  0, -1, -3,\n        -6, -3,  2, -1, -8,\n        -3, -6,  9, -7, -7, -6, -4, -4, -3, -5, -7, -7, -6, -5, -4, -4, -7, -4,  0, -3, -4, -3,\n        -8, -1, -7, -4, -8,\n         0,  4, -7,  5,  3, -7,  0,  0, -3, -4, -1, -5, -4,  2, -2, -3,  1, -3,  0, -1, -2, -3,\n        -8, -5,  3, -2, -8,\n         0,  3, -7,  3,  5, -7, -1, -1, -3, -4, -1, -4, -3,  1, -1, -2,  2, -3, -1, -2, -1, -3,\n        -8, -5,  4, -1, -8,\n        -4, -5, -6, -7, -7,  8, -5, -3,  0,  0, -7,  0, -1, -4, -3, -5, -6, -5, -3, -4, -3, -3,\n        -1,  4, -6, -3, -8,\n         1,  0, -4,  0, -1, -5,  5, -4, -4, -5, -3, -5, -4,  0, -2, -2, -3, -4,  1, -1, -2, -2,\n        -8, -6, -2, -2, -8,\n        -3,  1, -4,  0, -1, -3, -4,  7, -4, -4, -2, -3, -4,  2, -2, -1,  3,  1, -2, -3, -2, -3,\n        -3, -1,  1, -2, -8,\n        -1, -3, -3, -3, -3,  0, -4, -4,  6,  4, -3,  1,  1, -2, -1, -3, -3, -2, -2,  0, -1,  3,\n        -6, -2, -3, -1, -8,\n        -2, -4, -5, -4, -4,  0, -5, -4,  4,  4, -4,  3,  2, -3, -2, -3, -3, -3, -3, -2, -2,  2,\n        -5, -2, -3, -2, -8,\n        -2,  0, -7, -1, -1, -7, -3, -2, -3, -4,  5, -4,  0,  1, -2, -2,  0,  2, -1, -1, -2, -4,\n        -5, -5, -1, -2, -8,\n        -3, -4, -7, -5, -4,  0, -5, -3,  1,  3, -4,  5,  3, -4, -2, -3, -2, -4, -4, -3, -2,  1,\n        -3, -2, -3, -2, -8,\n        -2, -4, -6, -4, -3, -1, -4, -4,  1,  2,  0,  3,  8, -3, -2, -3, -1, -1, -2, -1, -2,  1,\n        -6, -4, -2, -2, -8,\n        -1,  3, -5,  2,  1, -4,  0,  2, -2, -3,  1, -4, -3,  4, -1, -2,  0, -1,  1,  0, -1, -3,\n        -4, -2,  0, -1, -8,\n        -1, -1, -4, -2, -1, -3, -2, -2, -1, -2, -2, -2, -2, -1, -2, -2, -1, -2, -1, -1, -2, -1,\n        -5, -3, -1, -2, -8,\n         1, -2, -4, -3, -2, -5, -2, -1, -3, -3, -2, -3, -3, -2, -2,  6,  0, -1,  1, -1, -2, -2,\n        -7, -6, -1, -2, -8,\n        -1,  0, -7,  1,  2, -6, -3,  3, -3, -3,  0, -2, -1,  0, -1,  0,  6,  1, -2, -2, -1, -3,\n        -6, -5,  4, -1, -8,\n        -3, -2, -4, -3, -3, -5, -4,  1, -2, -3,  2, -4, -1, -1, -2, -1,  1,  6, -1, -2, -2, -3,\n         1, -5, -1, -2, -8,\n         1,  0,  0,  0, -1, -3,  1, -2, -2, -3, -1, -4, -2,  1, -1,  1, -2, -1,  3,  2, -1, -2,\n        -2, -3, -1, -1, -8,\n         1,  0, -3, -1, -2, -4, -1, -3,  0, -2, -1, -3, -1,  0, -1, -1, -2, -2,  2,  4, -1,  0,\n        -6, -3, -2, -1, -8,\n        -1, -1, -4, -2, -1, -3, -2, -2, -1, -2, -2, -2, -2, -1, -2, -2, -1, -2, -1, -1, -2, -1,\n        -5, -3, -1, -2, -8,\n         0, -3, -3, -3, -3, -3, -2, -3,  3,  2, -4,  1,  1, -3, -1, -2, -3, -3, -2,  0, -1,  5,\n        -8, -3, -3, -1, -8,\n        -7, -6, -8, -8, -8, -1, -8, -3, -6, -5, -5, -3, -6, -4, -5, -7, -6,  1, -2, -6, -5, -8,\n        12, -2, -7, -5, -8,\n        -4, -3, -1, -5, -5,  4, -6, -1, -2, -2, -5, -2, -4, -2, -3, -6, -5, -5, -3, -3, -3, -3,\n        -2,  8, -5, -3, -8,\n        -1,  2, -7,  3,  4, -6, -2,  1, -3, -3, -1, -3, -2,  0, -1, -1,  4, -1, -1, -2, -1, -3,\n        -7, -5,  4, -1, -8,\n        -1, -1, -4, -2, -1, -3, -2, -2, -1, -2, -2, -2, -2, -1, -2, -2, -1, -2, -1, -1, -2, -1,\n        -5, -3, -1, -2, -8,\n        -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8,\n        -8, -8, -8, -8,  1\n    ]).unwrap();\n}\n\n#[inline]\nfn lookup(a: u8) -\u003e usize {\n    if a == b'Y' {\n        23\n    } else if a == b'Z' {\n        24\n    } else if a == b'X' {\n        25\n    } else if a == b'*' {\n        26\n    } else {\n        (a - 65) as usize\n    }\n}\n\n/// Return the PAM120 substitution matrix score of [a, b]\n///\n/// # Example\n///\n/// ```\n/// use bio::scores::pam120;\n/// assert_eq!(pam120(b'H', b'A'), -3);\n/// ```\npub fn pam120(a: u8, b: u8) -\u003e i32 {\n    let a = lookup(a);\n    let b = lookup(b);\n\n    MAT[(a, b)]\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pam120() {\n        let score1 = pam120(b'A', b'A');\n        assert_eq!(score1, 3);\n        let score2 = pam120(b'*', b'*');\n        assert_eq!(score2, 1);\n        let score3 = pam120(b'A', b'*');\n        assert_eq!(score3, -8);\n        let score4 = pam120(b'*', b'*');\n        assert_eq!(score4, 1);\n        let score5 = pam120(b'X', b'X');\n        assert_eq!(score5, -2);\n        let score6 = pam120(b'X', b'Z');\n        assert_eq!(score6, -1);\n    }\n}\n","traces":[{"line":10,"address":[4481856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[5067596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[5067611,5067638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[5067680],"length":1,"stats":{"Line":0},"fn_name":"pam120"},{"line":92,"address":[5067702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[5067724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[5067742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[7733973,7733968],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":104,"address":[7753991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[7754007,7754108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[7754077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[7754156,7754275],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[7754241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[7754323,7754439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[7754408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[7754603,7754487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[7754572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[7754770,7754651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[7754736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[7754921,7754818],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":28},{"path":["/","home","todd","rust-bio","src","scores","pam200.rs"],"content":"// Copyright 2015 M. Rizky Luthfianto.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\nlazy_static! {\n    // Taken from https://github.com/seqan/seqan/blob/master/include%2Fseqan%2Fscore\n    // %2Fscore_matrix_data.h#L710\n    // Copyright (c) 2006-2015, Knut Reinert, FU Berlin\n    static ref MAT: ndarray::Array2\u003ci32\u003e = ndarray::Array::from_shape_vec((27, 27), vec![\n         3,  0, -3,  0,  0, -4,  1, -2, -1, -2, -2, -2, -2,  0,  0,  1, -1, -2,  1,  1,  0,  0,\n        -7, -4,  0,  0, -9,\n         0,  3, -5,  4,  3, -6,  0,  1, -3, -4,  0, -4, -3,  3, -1, -1,  1, -1,  1,  0, -1, -3,\n        -6, -4,  2, -1, -9,\n        -3, -5, 12, -6, -7, -6, -4, -4, -3, -5, -7, -7, -6, -5, -4, -4, -7, -4,  0, -3, -4, -2,\n        -9,  0, -7, -4, -9,\n         0,  4, -6,  5,  4, -7,  0,  0, -3, -4,  0, -5, -4,  3, -1, -2,  2, -2,  0,  0, -1, -3,\n        -8, -5,  3, -1, -9,\n         0,  3, -7,  4,  5, -7,  0,  0, -3, -4,  0, -4, -3,  2, -1, -1,  3, -2,  0, -1, -1, -2,\n        -9, -5,  4, -1, -9,\n        -4, -6, -6, -7, -7, 10, -6, -2,  1,  2, -7,  2,  0, -4, -3, -6, -6, -5, -4, -4, -3, -2,\n         0,  7, -6, -3, -9,\n         1,  0, -4,  0,  0, -6,  6, -3, -3, -4, -2, -5, -4,  0, -1, -1, -2, -4,  1,  0, -1, -2,\n        -8, -6, -1, -1, -9,\n        -2,  1, -4,  0,  0, -2, -3,  8, -3, -3, -1, -3, -3,  2, -1, -1,  3,  2, -1, -2, -1, -3,\n        -3,  0,  2, -1, -9,\n        -1, -3, -3, -3, -3,  1, -3, -3,  6,  4, -2,  2,  2, -2, -1, -3, -3, -2, -2,  0, -1,  4,\n        -6, -2, -3, -1, -9,\n        -2, -4, -5, -4, -4,  2, -4, -3,  4,  5, -3,  5,  3, -3, -2, -3, -3, -3, -3, -1, -2,  3,\n        -4, -2, -3, -2, -9,\n        -2,  0, -7,  0,  0, -7, -2, -1, -2, -3,  6, -4,  1,  1, -1, -2,  1,  4,  0,  0, -1, -3,\n        -4, -5,  0, -1, -9,\n        -2, -4, -7, -5, -4,  2, -5, -3,  2,  5, -4,  7,  4, -4, -2, -3, -2, -4, -4, -2, -2,  2,\n        -2, -2, -3, -2, -9,\n        -2, -3, -6, -4, -3,  0, -4, -3,  2,  3,  1,  4,  8, -2, -1, -3, -1, -1, -2, -1, -1,  2,\n        -5, -3, -2, -1, -9,\n         0,  3, -5,  3,  2, -4,  0,  2, -2, -3,  1, -4, -2,  3,  0, -1,  1,  0,  1,  0,  0, -2,\n        -5, -2,  1,  0, -9,\n         0, -1, -4, -1, -1, -3, -1, -1, -1, -2, -1, -2, -1,  0, -1, -1, -1, -1,  0,  0, -1, -1,\n        -5, -3, -1, -1, -9,\n         1, -1, -4, -2, -1, -6, -1, -1, -3, -3, -2, -3, -3, -1, -1,  7,  0,  0,  1,  0, -1, -2,\n        -7, -6, -1, -1, -9,\n        -1,  1, -7,  2,  3, -6, -2,  3, -3, -3,  1, -2, -1,  1, -1,  0,  5,  1, -1, -1, -1, -3,\n        -6, -5,  4, -1, -9,\n        -2, -1, -4, -2, -2, -5, -4,  2, -2, -3,  4, -4, -1,  0, -1,  0,  1,  7, -1, -1, -1, -3,\n         2, -5,  0, -1, -9,\n         1,  1,  0,  0,  0, -4,  1, -1, -2, -3,  0, -4, -2,  1,  0,  1, -1, -1,  2,  2,  0, -1,\n        -3, -3, -1,  0, -9,\n         1,  0, -3,  0, -1, -4,  0, -2,  0, -1,  0, -2, -1,  0,  0,  0, -1, -1,  2,  4,  0,  0,\n        -6, -3, -1,  0, -9,\n         0, -1, -4, -1, -1, -3, -1, -1, -1, -2, -1, -2, -1,  0, -1, -1, -1, -1,  0,  0, -1, -1,\n        -5, -3, -1, -1, -9,\n         0, -3, -2, -3, -2, -2, -2, -3,  4,  3, -3,  2,  2, -2, -1, -2, -3, -3, -1,  0, -1,  5,\n        -8, -3, -2, -1, -9,\n        -7, -6, -9, -8, -9,  0, -8, -3, -6, -4, -4, -2, -5, -5, -5, -7, -6,  2, -3, -6, -5, -8,\n        18, -1, -7, -5, -9,\n        -4, -4,  0, -5, -5,  7, -6,  0, -2, -2, -5, -2, -3, -2, -3, -6, -5, -5, -3, -3, -3, -3,\n        -1, 11, -5, -3, -9,\n         0,  2, -7,  3,  4, -6, -1,  2, -3, -3,  0, -3, -2,  1, -1, -1,  4,  0, -1, -1, -1, -2,\n        -7, -5,  4, -1, -9,\n         0, -1, -4, -1, -1, -3, -1, -1, -1, -2, -1, -2, -1,  0, -1, -1, -1, -1,  0,  0, -1, -1,\n        -5, -3, -1, -1, -9,\n        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9,\n        -9, -9, -9, -9,  1\n    ]).unwrap();\n}\n\n#[inline]\nfn lookup(a: u8) -\u003e usize {\n    if a == b'Y' {\n        23\n    } else if a == b'Z' {\n        24\n    } else if a == b'X' {\n        25\n    } else if a == b'*' {\n        26\n    } else {\n        (a - 65) as usize\n    }\n}\n\n/// Return the PAM200 substitution matrix score of [a, b]\n///\n/// # Example\n///\n/// ```\n/// use bio::scores::pam200;\n/// assert_eq!(pam200(b'H', b'A'), -2);\n/// ```\npub fn pam200(a: u8, b: u8) -\u003e i32 {\n    let a = lookup(a);\n    let b = lookup(b);\n\n    MAT[(a, b)]\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pam200() {\n        let score1 = pam200(b'A', b'A');\n        assert_eq!(score1, 3);\n        let score2 = pam200(b'*', b'*');\n        assert_eq!(score2, 1);\n        let score3 = pam200(b'A', b'*');\n        assert_eq!(score3, -9);\n        let score4 = pam200(b'Y', b'Z');\n        assert_eq!(score4, -5);\n        let score5 = pam200(b'X', b'X');\n        assert_eq!(score5, -1);\n        let score6 = pam200(b'X', b'Z');\n        assert_eq!(score6, -1);\n    }\n}\n","traces":[{"line":10,"address":[4451680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[5067900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[5067915,5067942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[5067984],"length":1,"stats":{"Line":0},"fn_name":"pam200"},{"line":92,"address":[5068006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[5068028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[5068046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[4998560],"length":1,"stats":{"Line":0},"fn_name":"test_pam200"},{"line":104,"address":[4998567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[4998684,4998583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[4998653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[4998851,4998732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[4998817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[4998899,4999018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[4998984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[4999066,4999182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[4999151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[4999230,4999349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[4999315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[4999397,4999500],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":28},{"path":["/","home","todd","rust-bio","src","scores","pam250.rs"],"content":"// Copyright 2014 M. Rizky Luthfianto.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\nlazy_static! {\n    // taken from https://github.com/seqan/seqan/blob/master/include%2Fseqan\n    // %2Fscore%2Fscore_matrix_data.h#L806\n    // Copyright (c) 2006-2015, Knut Reinert, FU Berlin\n    static ref MAT: ndarray::Array2\u003ci32\u003e = ndarray::Array::from_shape_vec((27, 27), vec![\n         2,  0, -2,  0,  0, -3,  1, -1, -1, -2, -1, -2, -1,  0,  0,  1,  0, -2,  1,  1,  0,  0,\n        -6, -3,  0,  0, -8,\n         0,  3, -4,  3,  3, -4,  0,  1, -2, -3,  1, -3, -2,  2, -1, -1,  1, -1,  0,  0, -1, -2,\n        -5, -3,  2, -1, -8,\n        -2, -4, 12, -5, -5, -4, -3, -3, -2, -4, -5, -6, -5, -4, -3, -3, -5, -4,  0, -2, -3, -2,\n        -8,  0, -5, -3, -8,\n         0,  3, -5,  4,  3, -6,  1,  1, -2, -3,  0, -4, -3,  2, -1, -1,  2, -1,  0,  0, -1, -2,\n        -7, -4,  3, -1, -8,\n         0,  3, -5,  3,  4, -5,  0,  1, -2, -3,  0, -3, -2,  1, -1, -1,  2, -1,  0,  0, -1, -2,\n        -7, -4,  3, -1, -8,\n        -3, -4, -4, -6, -5,  9, -5, -2,  1,  2, -5,  2,  0, -3, -2, -5, -5, -4, -3, -3, -2, -1,\n         0,  7, -5, -2, -8,\n         1,  0, -3,  1,  0, -5,  5, -2, -3, -4, -2, -4, -3,  0, -1,  0, -1, -3,  1,  0, -1, -1,\n        -7, -5,  0, -1, -8,\n        -1,  1, -3,  1,  1, -2, -2,  6, -2, -2,  0, -2, -2,  2, -1,  0,  3,  2, -1, -1, -1, -2,\n        -3,  0,  2, -1, -8,\n        -1, -2, -2, -2, -2,  1, -3, -2,  5,  4, -2,  2,  2, -2, -1, -2, -2, -2, -1,  0, -1,  4,\n        -5, -1, -2, -1, -8,\n        -2, -3, -4, -3, -3,  2, -4, -2,  4,  4, -3,  4,  3, -3, -1, -3, -2, -3, -2, -1, -1,  3,\n        -4, -1, -3, -1, -8,\n        -1,  1, -5,  0,  0, -5, -2,  0, -2, -3,  5, -3,  0,  1, -1, -1,  1,  3,  0,  0, -1, -2,\n        -3, -4,  0, -1, -8,\n        -2, -3, -6, -4, -3,  2, -4, -2,  2,  4, -3,  6,  4, -3, -1, -3, -2, -3, -3, -2, -1,  2,\n        -2, -1, -3, -1, -8,\n        -1, -2, -5, -3, -2,  0, -3, -2,  2,  3,  0,  4,  6, -2, -1, -2, -1,  0, -2, -1, -1,  2,\n        -4, -2, -2, -1, -8,\n         0,  2, -4,  2,  1, -3,  0,  2, -2, -3,  1, -3, -2,  2,  0,  0,  1,  0,  1,  0,  0, -2,\n        -4, -2,  1,  0, -8,\n         0, -1, -3, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1,  0, -1, -1, -1, -1,  0,  0, -1, -1,\n        -4, -2, -1, -1, -8,\n         1, -1, -3, -1, -1, -5,  0,  0, -2, -3, -1, -3, -2,  0, -1,  6,  0,  0,  1,  0, -1, -1,\n        -6, -5,  0, -1, -8,\n         0,  1, -5,  2,  2, -5, -1,  3, -2, -2,  1, -2, -1,  1, -1,  0,  4,  1, -1, -1, -1, -2,\n        -5, -4,  3, -1, -8,\n        -2, -1, -4, -1, -1, -4, -3,  2, -2, -3,  3, -3,  0,  0, -1,  0,  1,  6,  0, -1, -1, -2,\n         2, -4,  0, -1, -8,\n         1,  0,  0,  0,  0, -3,  1, -1, -1, -2,  0, -3, -2,  1,  0,  1, -1,  0,  2,  1,  0, -1,\n        -2, -3,  0,  0, -8,\n         1,  0, -2,  0,  0, -3,  0, -1,  0, -1,  0, -2, -1,  0,  0,  0, -1, -1,  1,  3,  0,  0,\n        -5, -3, -1,  0, -8,\n         0, -1, -3, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1,  0, -1, -1, -1, -1,  0,  0, -1, -1,\n        -4, -2, -1, -1, -8,\n         0, -2, -2, -2, -2, -1, -1, -2,  4,  3, -2,  2,  2, -2, -1, -1, -2, -2, -1,  0, -1,  4,\n        -6, -2, -2, -1, -8,\n        -6, -5, -8, -7, -7,  0, -7, -3, -5, -4, -3, -2, -4, -4, -4, -6, -5,  2, -2, -5, -4, -6,\n        17,  0, -6, -4, -8,\n        -3, -3,  0, -4, -4,  7, -5,  0, -1, -1, -4, -1, -2, -2, -2, -5, -4, -4, -3, -3, -2, -2,\n         0, 10, -4, -2, -8,\n         0,  2, -5,  3,  3, -5,  0,  2, -2, -3,  0, -3, -2,  1, -1,  0,  3,  0,  0, -1, -1, -2,\n        -6, -4,  3, -1, -8,\n         0, -1, -3, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1,  0, -1, -1, -1, -1,  0,  0, -1, -1,\n        -4, -2, -1, -1, -8,\n        -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8,\n        -8, -8, -8, -8,  1,\n    ]).unwrap();\n}\n\n#[inline]\nfn lookup(a: u8) -\u003e usize {\n    if a == b'Y' {\n        23\n    } else if a == b'Z' {\n        24\n    } else if a == b'X' {\n        25\n    } else if a == b'*' {\n        26\n    } else {\n        (a - 65) as usize\n    }\n}\n\n/// Return the PAM250 substitution matrix score of [a, b]\n///\n/// # Example\n///\n/// ```\n/// use bio::scores::pam250;\n/// assert_eq!(pam250(b'H', b'A'), -1);\n/// ```\npub fn pam250(a: u8, b: u8) -\u003e i32 {\n    let a = lookup(a);\n    let b = lookup(b);\n\n    MAT[(a, b)]\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pam250() {\n        let score1 = pam250(b'A', b'A');\n        assert_eq!(score1, 2);\n        let score2 = pam250(b'*', b'*');\n        assert_eq!(score2, 1);\n        let score3 = pam250(b'A', b'*');\n        assert_eq!(score3, -8);\n        let score4 = pam250(b'*', b'*');\n        assert_eq!(score4, 1);\n        let score5 = pam250(b'X', b'X');\n        assert_eq!(score5, -1);\n        let score6 = pam250(b'X', b'Z');\n        assert_eq!(score6, -1);\n    }\n}\n","traces":[{"line":10,"address":[4466656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[4611180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[4611195,4611222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[4611264],"length":1,"stats":{"Line":0},"fn_name":"pam250"},{"line":92,"address":[4611286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[4611308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[4611326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[4999552],"length":1,"stats":{"Line":0},"fn_name":"test_pam250"},{"line":104,"address":[4999559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[4999575,4999676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[4999645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[4999843,4999724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[4999809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[4999891,5000007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[4999976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[5000055,5000171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[5000140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[5000219,5000338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[5000304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[5000489,5000386],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":28},{"path":["/","home","todd","rust-bio","src","scores","pam40.rs"],"content":"// Copyright 2014 M. Rizky Luthfianto.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\nlazy_static! {\n    // taken from https://github.com/seqan/seqan/blob/master/include%2Fseqan%2Fscore%2Fscore_matrix_data.h#L806\n    static ref MAT: ndarray::Array2\u003ci32\u003e = ndarray::Array::from_shape_vec((27, 27), vec![\n         6,  -3,  -6,  -3,  -2,  -7,  -1,  -6,  -4,  -5,  -6,  -5,  -4,  -3,  -3,  -1,  -3,\n        -6,   0,   0,  -3,  -2, -12,  -7,  -2,  -3, -15,\n        -3,   6, -11,   6,   2,  -9,  -2,  -1,  -5,  -7,  -2,  -8,  -8,   6,  -4,  -6,  -2,\n        -6,  -1,  -2,  -4,  -7,  -9,  -6,   1,  -4, -15,\n        -6, -11,   9, -12, -12, -11,  -8,  -7,  -5,  -9, -12, -13, -12,  -9,  -8,  -7, -12,\n        -7,  -2,  -7,  -8,  -5, -14,  -3, -12,  -8, -15,\n        -3,   6, -12,   7,   3, -13,  -3,  -3,  -6,  -9,  -4, -11,  -9,   2,  -5,  -7,  -2,\n        -9,  -3,  -4,  -5,  -7, -13, -10,   2,  -5, -15,\n        -2,   2, -12,   3,   7, -12,  -3,  -4,  -5,  -7,  -4,  -8,  -6,  -1,  -4,  -5,   2,\n        -8,  -4,  -5,  -4,  -6, -15,  -8,   6,  -4, -15,\n        -7,  -9, -11, -13, -12,   9,  -8,  -5,  -2,  -2, -12,  -2,  -3,  -8,  -7,  -9, -11,\n        -8,  -6,  -8,  -7,  -7,  -4,   2, -12,  -7, -15,\n        -1,  -2,  -8,  -3,  -3,  -8,   6,  -8,  -9,  -9,  -6,  -9,  -7,  -2,  -4,  -5,  -6,\n        -8,  -1,  -5,  -4,  -5, -13, -12,  -4,  -4, -15,\n        -6,  -1,  -7,  -3,  -4,  -5,  -8,   9,  -8,  -7,  -5,  -5,  -9,   1,  -4,  -3,   1,\n        -1,  -5,  -6,  -4,  -6,  -6,  -3,   0,  -4, -15,\n        -4,  -5,  -5,  -6,  -5,  -2,  -9,  -8,   8,   4,  -5,  -1,   0,  -4,  -4,  -7,  -7,\n        -5,  -6,  -2,  -4,   2, -12,  -5,  -5,  -4, -15,\n        -5,  -7,  -9,  -9,  -7,  -2,  -9,  -7,   4,   4,  -6,   3,   1,  -5,  -5,  -7,  -6,\n        -7,  -7,  -4,  -5,   0,  -9,  -6,  -6,  -5, -15,\n        -6,  -2, -12,  -4,  -4, -12,  -6,  -5,  -5,  -6,   6,  -7,  -1,   0,  -4,  -6,  -2,\n         1,  -3,  -2,  -4,  -8, -10,  -8,  -3,  -4, -15,\n        -5,  -8, -13, -11,  -8,  -2,  -9,  -5,  -1,   3,  -7,   7,   1,  -6,  -5,  -6,  -4,\n        -8,  -7,  -6,  -5,  -2,  -5,  -6,  -6,  -5, -15,\n        -4,  -8, -12,  -9,  -6,  -3,  -7,  -9,   0,   1,  -1,   1,  11,  -7,  -4,  -7,  -3,\n        -3,  -5,  -3,  -4,  -1, -11, -10,  -4,  -4, -15,\n        -3,   6,  -9,   2,  -1,  -8,  -2,   1,  -4,  -5,   0,  -6,  -7,   7,  -3,  -5,  -3,\n        -5,   0,  -1,  -3,  -7,  -7,  -4,  -2,  -3, -15,\n        -3,  -4,  -8,  -5,  -4,  -7,  -4,  -4,  -4,  -5,  -4,  -5,  -4,  -3,  -4,  -4,  -4,\n        -5,  -2,  -3,  -4,  -4,  -9,  -7,  -4,  -4, -15,\n        -1,  -6,  -7,  -7,  -5,  -9,  -5,  -3,  -7,  -7,  -6,  -6,  -7,  -5,  -4,   8,  -2,\n        -3,  -1,  -3,  -4,  -5, -12, -12,  -3,  -4, -15,\n        -3,  -2, -12,  -2,   2, -11,  -6,   1,  -7,  -6,  -2,  -4,  -3,  -3,  -4,  -2,   8,\n        -1,  -4,  -5,  -4,  -6, -11, -10,   6,  -4, -15,\n        -6,  -6,  -7,  -9,  -8,  -8,  -8,  -1,  -5,  -7,   1,  -8,  -3,  -5,  -5,  -3,  -1,\n         8,  -2,  -5,  -5,  -7,  -1,  -9,  -3,  -5, -15,\n         0,  -1,  -2,  -3,  -4,  -6,  -1,  -5,  -6,  -7,  -3,  -7,  -5,   0,  -2,  -1,  -4,\n        -2,   6,   1,  -2,  -5,  -4,  -6,  -4,  -2, -15,\n         0,  -2,  -7,  -4,  -5,  -8,  -5,  -6,  -2,  -4,  -2,  -6,  -3,  -1,  -3,  -3,  -5,\n        -5,   1,   7,  -3,  -2, -11,  -6,  -5,  -3, -15,\n        -3,  -4,  -8,  -5,  -4,  -7,  -4,  -4,  -4,  -5,  -4,  -5,  -4,  -3,  -4,  -4,  -4,\n        -5,  -2,  -3,  -4,  -4,  -9,  -7,  -4,  -4, -15,\n        -2,  -7,  -5,  -7,  -6,  -7,  -5,  -6,   2,   0,  -8,  -2,  -1,  -7,  -4,  -5,  -6,\n        -7,  -5,  -2,  -4,   7, -14,  -6,  -6,  -4, -15,\n       -12,  -9, -14, -13, -15,  -4, -13,  -6, -12,  -9, -10,  -5, -11,  -7,  -9, -12, -11,\n        -1,  -4, -11,  -9, -14,  13,  -4, -13,  -9, -15,\n        -7,  -6,  -3, -10,  -8,   2, -12,  -3,  -5,  -6,  -8,  -6, -10,  -4,  -7, -12, -10,\n        -9,  -6,  -6,  -7,  -6,  -4,  10,  -8,  -7, -15,\n        -2,   1, -12,   2,   6, -12,  -4,   0,  -5,  -6,  -3,  -6,  -4,  -2,  -4,  -3,   6,\n        -3,  -4,  -5,  -4,  -6, -13,  -8,   6,  -4, -15,\n        -3,  -4,  -8,  -5,  -4,  -7,  -4,  -4,  -4,  -5,  -4,  -5,  -4,  -3,  -4,  -4,  -4,\n        -5,  -2,  -3,  -4,  -4,  -9,  -7,  -4,  -4, -15,\n       -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15,\n       -15, -15, -15, -15, -15, -15, -15, -15, -15,   1\n    ]).unwrap();\n}\n\n#[inline]\nfn lookup(a: u8) -\u003e usize {\n    if a == b'Y' {\n        23\n    } else if a == b'Z' {\n        24\n    } else if a == b'X' {\n        25\n    } else if a == b'*' {\n        26\n    } else {\n        (a - 65) as usize\n    }\n}\n\n/// Return the PAM40 substitution matrix score of [a, b]\n///\n/// # Example\n///\n/// ```\n/// use bio::scores::pam40;\n/// assert_eq!(pam40(b'H', b'A'), -6);\n/// ```\npub fn pam40(a: u8, b: u8) -\u003e i32 {\n    let a = lookup(a);\n    let b = lookup(b);\n\n    MAT[(a, b)]\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pam40() {\n        let score1 = pam40(b'A', b'A');\n        assert_eq!(score1, 6);\n        let score2 = pam40(b'*', b'*');\n        assert_eq!(score2, 1);\n        let score3 = pam40(b'A', b'*');\n        assert_eq!(score3, -15);\n        let score4 = pam40(b'*', b'*');\n        assert_eq!(score4, 1);\n        let score5 = pam40(b'X', b'X');\n        assert_eq!(score5, -4);\n        let score6 = pam40(b'X', b'Z');\n        assert_eq!(score6, -4);\n    }\n}\n","traces":[{"line":8,"address":[4459024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[5068204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[5068246,5068219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[5068288],"length":1,"stats":{"Line":0},"fn_name":"pam40"},{"line":90,"address":[5068310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[5068332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[5068350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[7734064,7734069],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":102,"address":[7754983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[7755100,7754999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[7755069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[7755148,7755267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[7755233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[7755315,7755431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[7755400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[7755595,7755479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[7755564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[7755643,7755762],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[7755728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[7755810,7755913],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":28},{"path":["/","home","todd","rust-bio","src","seq_analysis","gc.rs"],"content":"// Copyright 2014-2016 Johannes Köster, Martin Larralde.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! GC counter over an `IntoTextIterator` object.\n\n//! Complexity: O(n), where n is the length of the sequence.\n\nuse std::borrow::Borrow;\n\n/// Base gc content counter\nfn gcn_content\u003cC: Borrow\u003cu8\u003e, T: IntoIterator\u003cItem = C\u003e\u003e(sequence: T, step: usize) -\u003e f32 {\n    let (l, count) = sequence\n        .into_iter()\n        .step_by(step)\n        .fold((0usize, 0usize), |(l, count), n| match *n.borrow() {\n            b'c' | b'g' | b'G' | b'C' =\u003e (l + 1, count + 1),\n            _ =\u003e (l + 1, count),\n        });\n    count as f32 / l as f32\n}\n\n/// Returns the ratio of bases which are guanine or cytososine\n///\n/// # Arguments\n///\n/// * `sequence` - A sequence of bases\n///\n/// # Example\n///\n/// ```\n/// use bio::seq_analysis::gc::gc_content;\n///\n/// const seq: \u0026'static [u8] = b\"GATATACA\";\n/// use approx::assert_relative_eq;\n/// assert_relative_eq!(gc_content(seq), 2. / 8., epsilon = f32::EPSILON);\n/// ```\npub fn gc_content\u003cC: Borrow\u003cu8\u003e, T: IntoIterator\u003cItem = C\u003e\u003e(sequence: T) -\u003e f32 {\n    gcn_content(sequence, 1usize)\n}\n\n/// Returns the ratio of bases in the 3rd position which are guanine\n/// or cytososine.\n///\n/// # Arguments\n///\n/// * `sequence` - A sequence of bases\n///\n/// # Example\n///\n/// ```\n/// use approx::assert_relative_eq;\n/// use bio::seq_analysis::gc::gc3_content;\n/// const seq: \u0026'static [u8] = b\"GATATACA\";\n/// //                           ^  ^  ^\n/// assert_relative_eq!(gc3_content(seq), 2. / 3., epsilon = f32::EPSILON);\n/// ```\npub fn gc3_content\u003cC: Borrow\u003cu8\u003e, T: IntoIterator\u003cItem = C\u003e\u003e(sequence: T) -\u003e f32 {\n    gcn_content(sequence, 3usize)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_gc_content() {\n        let gc0 = b\"ATAT\";\n        assert_relative_eq!(gc_content(gc0), 0.0, epsilon = f32::EPSILON);\n        let gc50 = b\"ATGC\";\n        assert_relative_eq!(gc_content(gc50), 0.5, epsilon = f32::EPSILON);\n        let gc100 = b\"GCGC\";\n        assert_relative_eq!(gc_content(gc100), 1.0, epsilon = f32::EPSILON);\n    }\n\n    #[test]\n    fn test_gc_content_large() {\n        const LENGTH: usize = 10_000_000;\n        let mut s = vec![b'G'; LENGTH];\n        s.extend_from_slice(\u0026[b'T'; LENGTH]);\n        let gc_content = gc_content(s);\n        assert_relative_eq!(gc_content, 0.5, epsilon = f32::EPSILON);\n    }\n}\n","traces":[{"line":13,"address":[5251168,5251504],"length":1,"stats":{"Line":0},"fn_name":"gcn_content\u003cu8,alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":14,"address":[5251587,5251529,5251286,5251188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[5251569,5251808,5252153,5252014,5251847,5251262,5252538,5252121,5252232,5252192,5252399,5252506],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cu8,alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":18,"address":[5252440,5251882,5251976,5252508,5252267,5252055,5252361,5252123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[5251953,5252004,5252016,5252338,5252389,5252401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[5251643,5251348],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[5252640,5252576],"length":1,"stats":{"Line":0},"fn_name":"gc_content\u003cu8,alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":40,"address":[5252580,5252649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[7734101,7734096],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":69,"address":[7481788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[7481803,7482061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[7482020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[7482995,7482035,7482758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[7482954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[7483692,7482969,7483901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[7485776,7484512],"length":1,"stats":{"Line":0},"fn_name":"test_gc_content_large"},{"line":80,"address":[7484526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[7484566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[7484597,7484711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[7484953,7484728],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":20},{"path":["/","home","todd","rust-bio","src","seq_analysis","mod.rs"],"content":"// Copyright 2014-2016 Johannes Köster, Martin Larralde.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Sequence analysis algorithms.\n\npub mod gc;\npub mod orf;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","seq_analysis","orf.rs"],"content":"// Copyright 2014-2016 Johannes Köster, Martin Larralde.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! One-way open reading frame (ORF) finder algorithm.\n//!\n//! Complexity: O(n).\n//!\n//! # Example\n//!\n//! ```\n//! use bio::seq_analysis::orf::{Finder, Orf};\n//! let start_codons = vec![b\"ATG\"];\n//! let stop_codons = vec![b\"TGA\", b\"TAG\", b\"TAA\"];\n//! let min_len = 50;\n//! let finder = Finder::new(start_codons, stop_codons, min_len);\n//!\n//! let sequence = b\"ACGGCTAGAAAAGGCTAGAAAA\";\n//!\n//! for Orf { start, end, offset } in finder.find_all(sequence) {\n//!     let orf = \u0026sequence[start..end];\n//!     //...do something with orf sequence...\n//! }\n//! ```\n//!\n//! Right now the only way to check the reverse strand for ORF is to use\n//! the `alphabet::dna::RevComp` struct and to check for both sequences.\n//! But that's not so performance friendly, as the reverse complementation and the ORF research\n//! could go on at the same time.\n\nuse std::borrow::Borrow;\nuse std::collections::VecDeque;\nuse std::iter;\n\n/// An implementation of a naive algorithm finder\n// Implementation note:\n//\n// VecDeque is used rather than the obvious [u8; 3] to represent\n// codons because a VecDeque\u003cu8\u003e is used to represent a sliding codon\n// (see: State.codon) window which unfortunately, cannot be compared\n// to [u8; 3].\npub struct Finder {\n    start_codons: Vec\u003cVecDeque\u003cu8\u003e\u003e,\n    stop_codons: Vec\u003cVecDeque\u003cu8\u003e\u003e,\n    min_len: usize,\n}\n\nimpl Finder {\n    /// Create a new instance of a finder for the given start and stop codons and the minimum\n    /// length of an ORF.\n    pub fn new\u003c'a\u003e(\n        start_codons: Vec\u003c\u0026'a [u8; 3]\u003e,\n        stop_codons: Vec\u003c\u0026'a [u8; 3]\u003e,\n        min_len: usize,\n    ) -\u003e Self {\n        Finder {\n            start_codons: start_codons\n                .iter()\n                .map(|x| x.iter().map(|\u0026x| x as u8).collect::\u003cVecDeque\u003cu8\u003e\u003e())\n                .collect(),\n            stop_codons: stop_codons\n                .iter()\n                .map(|x| x.iter().map(|\u0026x| x as u8).collect::\u003cVecDeque\u003cu8\u003e\u003e())\n                .collect(),\n            min_len,\n        }\n    }\n\n    /// Find all ORFs in the given sequence\n    pub fn find_all\u003cC, T\u003e(\u0026self, seq: T) -\u003e Matches\u003c'_, C, T::IntoIter\u003e\n    where\n        C: Borrow\u003cu8\u003e,\n        T: IntoIterator\u003cItem = C\u003e,\n    {\n        Matches {\n            finder: self,\n            state: State::new(),\n            seq: seq.into_iter().enumerate(),\n        }\n    }\n}\n\n/// An ORF representation with start and end position of said ORF,\n/// as well as offset of the reading frame (1,2,3) and strand location\n// (current: +, reverse complementary: -).\n#[derive(Debug, PartialEq)]\npub struct Orf {\n    pub start: usize,\n    pub end: usize,\n    pub offset: i8,\n}\n\n/// The current algorithm state.\nstruct State {\n    start_pos: [Option\u003cusize\u003e; 3],\n    codon: VecDeque\u003cu8\u003e,\n}\n\nimpl State {\n    /// Create new state.\n    pub fn new() -\u003e Self {\n        State {\n            start_pos: [None, None, None],\n            codon: VecDeque::new(),\n        }\n    }\n}\n\n/// Iterator over offset, start position, end position and sequence of matched ORFs.\npub struct Matches\u003c'a, C, T\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    finder: \u0026'a Finder,\n    state: State,\n    seq: iter::Enumerate\u003cT\u003e,\n}\n\nimpl\u003c'a, C, T\u003e Iterator for Matches\u003c'a, C, T\u003e\nwhere\n    C: Borrow\u003cu8\u003e,\n    T: Iterator\u003cItem = C\u003e,\n{\n    type Item = Orf;\n\n    fn next(\u0026mut self) -\u003e Option\u003cOrf\u003e {\n        let mut result: Option\u003cOrf\u003e = None;\n        let mut offset: usize;\n\n        for (index, nuc) in self.seq.by_ref() {\n            // update the codon\n            if self.state.codon.len() \u003e= 3 {\n                self.state.codon.pop_front();\n            }\n            self.state.codon.push_back(*nuc.borrow());\n            offset = (index + 1) % 3;\n\n            // inside orf\n            if self.state.start_pos[offset].is_some() {\n                // check if leaving orf\n                if self.finder.stop_codons.contains(\u0026self.state.codon) {\n                    // check if length is sufficient\n                    if index + 1 - self.state.start_pos[offset].unwrap() \u003e self.finder.min_len {\n                        // build results\n                        result = Some(Orf {\n                            start: self.state.start_pos[offset].unwrap() - 2,\n                            end: index + 1,\n                            offset: offset as i8,\n                        });\n                    }\n                    // reinitialize\n                    self.state.start_pos[offset] = None;\n                }\n            // check if entering orf\n            } else if self.finder.start_codons.contains(\u0026self.state.codon) {\n                self.state.start_pos[offset] = Some(index);\n            }\n            if result.is_some() {\n                return result;\n            }\n        }\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn basic_finder() -\u003e Finder {\n        let start_codons = vec![b\"ATG\"];\n        let stop_codons = vec![b\"TGA\", b\"TAG\", b\"TAA\"];\n        let min_len = 5;\n        Finder::new(start_codons, stop_codons, min_len)\n    }\n\n    #[test]\n    fn test_no_orf() {\n        let finder = basic_finder();\n        let sequence = b\"ACGGCTAGAAAAGGCTAGAAAA\";\n        assert!(finder.find_all(sequence).next().is_none());\n    }\n\n    #[test]\n    fn test_one_orf_no_offset() {\n        let finder = basic_finder();\n        let sequence = b\"GGGATGGGGTGAGGG\";\n        let expected = vec![Orf {\n            start: 3,\n            end: 12,\n            offset: 0,\n        }];\n        assert_eq!(expected, finder.find_all(sequence).collect::\u003cVec\u003cOrf\u003e\u003e());\n    }\n\n    #[test]\n    fn test_one_orf_with_offset() {\n        let finder = basic_finder();\n        let sequence = b\"AGGGATGGGGTGAGGG\";\n        let expected = vec![Orf {\n            start: 4,\n            end: 13,\n            offset: 1,\n        }];\n        assert_eq!(expected, finder.find_all(sequence).collect::\u003cVec\u003cOrf\u003e\u003e());\n    }\n\n    #[test]\n    fn test_two_orfs_different_offsets() {\n        let finder = basic_finder();\n        let sequence = b\"ATGGGGTGAGGGGGATGGAAAAATAAG\";\n        let expected = vec![\n            Orf {\n                start: 0,\n                end: 9,\n                offset: 0,\n            },\n            Orf {\n                start: 14,\n                end: 26,\n                offset: 2,\n            },\n        ];\n        assert_eq!(expected, finder.find_all(sequence).collect::\u003cVec\u003cOrf\u003e\u003e());\n    }\n}\n","traces":[{"line":52,"address":[6509529,6509040],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":58,"address":[6509203,6509088],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[6509362,6509256],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[4678668,4678688,4678988,4677728,4678348,4678368,4678028,4678048],"length":1,"stats":{"Line":0},"fn_name":"find_all\u003c\u0026u8,\u0026[u8; 16]\u003e"},{"line":78,"address":[4678435,4678755,4677795,4678115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[4678529,4678767,4678849,4678447,4677807,4678209,4678127,4677889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[6509568],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":104,"address":[6509585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[6509672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[4679008,4680906],"length":1,"stats":{"Line":0},"fn_name":"next\u003c\u0026u8,core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":129,"address":[4679058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[4679078,4679303,4680901,4679265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[4679472,4679407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[4679482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[4679506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[4679572,4679629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[4679674,4679616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[4680569,4679783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[4679871,4680457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[4680310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[4680262,4680114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[4680240,4680459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[4680497,4680576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[4680644,4679746,4680766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[4680686,4680776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[4680806,4680610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[4680822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[4679283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[5059146,5058880],"length":1,"stats":{"Line":0},"fn_name":"basic_finder"},{"line":173,"address":[5058896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[5058957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[5059018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[5059030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[5059184,5059416],"length":1,"stats":{"Line":0},"fn_name":"test_no_orf"},{"line":181,"address":[5059191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[5059201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[5059384,5059292,5059226],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[5059440,5059897],"length":1,"stats":{"Line":0},"fn_name":"test_one_orf_no_offset"},{"line":188,"address":[5059447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[5059457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[5059482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[5059673,5059547,5059627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[5060377,5059920],"length":1,"stats":{"Line":0},"fn_name":"test_one_orf_with_offset"},{"line":200,"address":[5059927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[5059937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[5059962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[5060107,5060027,5060153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[5060921,5060400],"length":1,"stats":{"Line":0},"fn_name":"test_two_orfs_different_offsets"},{"line":212,"address":[5060407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[5060417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[5060508,5060442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[5060450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[5060476],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[5060569,5060695,5060649],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":56},{"path":["/","home","todd","rust-bio","src","stats","bayesian","bayes_factors.rs"],"content":"use crate::stats::LogProb;\n\npub mod evidence {\n    /// Scale of evidence as defined by\n    /// [Kass and Raftery 1995](http://www.andrew.cmu.edu/user/kk3n/simplicity/KassRaftery1995.pdf).\n    #[derive(\n        Display,\n        Debug,\n        Clone,\n        Copy,\n        PartialEq,\n        Eq,\n        PartialOrd,\n        Ord,\n        Serialize,\n        Deserialize,\n        EnumString,\n        EnumIter,\n        IntoStaticStr,\n        EnumVariantNames,\n    )]\n    pub enum KassRaftery {\n        #[strum(serialize = \"none\")]\n        None,\n        #[strum(serialize = \"barely\")]\n        Barely,\n        #[strum(serialize = \"positive\")]\n        Positive,\n        #[strum(serialize = \"strong\")]\n        Strong,\n        #[strum(serialize = \"very-strong\")]\n        VeryStrong,\n    }\n}\n\ncustom_derive! {\n    /// A newtype for Bayes factors.\n    #[derive(\n        NewtypeFrom,\n        NewtypeDeref,\n        PartialEq,\n        PartialOrd,\n        Copy,\n        Clone,\n        Debug,\n    )]\n    pub struct BayesFactor(pub f64);\n}\n\nimpl BayesFactor {\n    /// Calculate Bayes factor from given probabilities.\n    pub fn new(a: LogProb, b: LogProb) -\u003e Self {\n        BayesFactor((a - b).exp())\n    }\n\n    /// Calculate strength of evidence as defined by\n    /// [Kass and Raftery 1995](http://www.andrew.cmu.edu/user/kk3n/simplicity/KassRaftery1995.pdf).\n    pub fn evidence_kass_raftery(\u0026self) -\u003e evidence::KassRaftery {\n        let k = **self;\n        if k \u003c= 1.0 {\n            evidence::KassRaftery::None\n        } else if k \u003c= 3.0 {\n            evidence::KassRaftery::Barely\n        } else if k \u003c= 20.0 {\n            evidence::KassRaftery::Positive\n        } else if k \u003c= 150.0 {\n            evidence::KassRaftery::Strong\n        } else {\n            evidence::KassRaftery::VeryStrong\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_bayes_factor() {\n        let bf = BayesFactor::new(LogProb(0.5_f64.ln()), LogProb(0.1_f64.ln()));\n        assert_relative_eq!(*bf, 5.0, epsilon = 1e-9);\n        assert_eq!(bf.evidence_kass_raftery(), evidence::KassRaftery::Positive);\n    }\n}\n","traces":[{"line":47,"address":[5253021,5252957,5253219,5253262,5253086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[5252688],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[5252842,5252898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[5252877,5252926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[5252921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[5252905,5252940,5252933,5252942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[5252935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[5252928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[6309744],"length":1,"stats":{"Line":0},"fn_name":"test_bayes_factor"},{"line":80,"address":[6309756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[6309868,6310110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[6310729,6310085,6310842],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":18},{"path":["/","home","todd","rust-bio","src","stats","bayesian","mod.rs"],"content":"// Copyright 2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Utilities for Bayesian statistics.\n\npub mod bayes_factors;\npub mod model;\npub use self::bayes_factors::BayesFactor;\npub use self::model::Model;\n\nuse itertools::Itertools;\nuse ordered_float::OrderedFloat;\n\nuse crate::stats::LogProb;\n\n/// For each of the hypothesis tests given as posterior error probabilities\n/// (PEPs, i.e. the posterior probability of the null hypothesis), estimate the FDR\n/// for the case that all null hypotheses with at most this PEP are rejected.\n/// FDR is calculated as presented by Müller, Parmigiani, and Rice,\n/// \"FDR and Bayesian Multiple Comparisons Rules\" (July 2006).\n/// Johns Hopkin's University, Dept. of Biostatistics Working Papers. Working Paper 115.\n///\n/// # Returns\n///\n/// A vector of expected FDRs in the same order as the given PEPs.\npub fn expected_fdr(peps: \u0026[LogProb]) -\u003e Vec\u003cLogProb\u003e {\n    // sort indices\n    let sorted_idx =\n        (0..peps.len()).sorted_by(|\u0026i, \u0026j| OrderedFloat(*peps[i]).cmp(\u0026OrderedFloat(*peps[j])));\n    // estimate FDR\n    let mut expected_fdr = vec![LogProb::ln_zero(); peps.len()];\n    for (j, (expected_fp, i)) in LogProb::ln_cumsum_exp(sorted_idx.clone().map(|i| peps[i]))\n        .zip(sorted_idx)\n        .enumerate()\n    {\n        let fdr = LogProb(*expected_fp - ((j + 1) as f64).ln());\n        expected_fdr[i] = if fdr \u003c= LogProb::ln_one() {\n            fdr\n        } else {\n            LogProb::ln_one()\n        };\n    }\n\n    expected_fdr\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::stats::LogProb;\n\n    #[test]\n    fn test_expected_fdr() {\n        let peps = [\n            LogProb(0.1f64.ln()),\n            LogProb::ln_zero(),\n            LogProb(0.25f64.ln()),\n        ];\n        let fdrs = expected_fdr(\u0026peps);\n        println!(\"{:?}\", fdrs);\n\n        assert_relative_eq!(*fdrs[1], *LogProb::ln_zero());\n        assert_relative_eq!(*fdrs[0], *LogProb(0.05f64.ln()));\n        assert_relative_eq!(*fdrs[2], *LogProb((0.35 / 3.0f64).ln()), epsilon = 0.000001);\n    }\n}\n","traces":[{"line":28,"address":[7703216,7704374],"length":1,"stats":{"Line":0},"fn_name":"expected_fdr"},{"line":30,"address":[5182352,5182376],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":33,"address":[7703369,7703470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[5182656,5182679],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":35,"address":[7703611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[7704018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[7704183,7704291,7704335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[7704263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[7704250,7704319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[4258327,4254624],"length":1,"stats":{"Line":0},"fn_name":"test_expected_fdr"},{"line":56,"address":[4254741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[4254638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[4254678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[4254692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[4254786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[4254820,4254993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[4255336,4255012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[4256401,4255296,4256114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[4256360,4257180,4257495],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":19},{"path":["/","home","todd","rust-bio","src","stats","bayesian","model.rs"],"content":"// Copyright 2019 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A trait system for Bayesian statistical modelling.\n\nuse std::cmp::Eq;\nuse std::collections::HashMap;\nuse std::hash::Hash;\nuse std::marker::PhantomData;\n\nuse itertools::Itertools;\nuse ordered_float::NotNan;\n\nuse crate::stats::LogProb;\n\npub type JointProbUniverse\u003cEvent\u003e = HashMap\u003cEvent, LogProb\u003e;\n\n/// Likelihood model.\npub trait Likelihood\u003cPayload = ()\u003e {\n    type Event;\n    type Data;\n\n    /// Compute likelihood of event given the data. Optionally, the passed payload can be used\n    /// to e.g., cache intermediate results. One payload corresponds to one model instance.\n    fn compute(\u0026self, event: \u0026Self::Event, data: \u0026Self::Data, payload: \u0026mut Payload) -\u003e LogProb;\n}\n\n/// Prior model.\npub trait Prior {\n    type Event;\n\n    fn compute(\u0026self, event: \u0026Self::Event) -\u003e LogProb;\n}\n\n/// Posterior model.\npub trait Posterior {\n    type Event;\n    type BaseEvent;\n    type Data;\n\n    fn compute\u003cF: FnMut(\u0026Self::BaseEvent, \u0026Self::Data) -\u003e LogProb\u003e(\n        \u0026self,\n        event: \u0026Self::Event,\n        data: \u0026Self::Data,\n        joint_prob: \u0026mut F,\n    ) -\u003e LogProb;\n}\n\n/// Bayesian model, consisting of a prior, a posterior and a likelihood model.\n/// Thereby, `Payload` is a custom payload of the model instance.\n/// This can be used to define custom caching mechanisms. See\n/// [here](https://github.com/varlociraptor/varlociraptor/blob/694e994547e8f523e5b0013fdf951b694f3870fa/src/model/modes/generic.rs#L200)\n/// for an example.\n#[derive(Clone, Debug, Getters, MutGetters)]\npub struct Model\u003cL, Pr, Po, Payload = ()\u003e\nwhere\n    L: Likelihood\u003cPayload\u003e,\n    Pr: Prior,\n    Po: Posterior,\n    Payload: Default,\n{\n    #[get = \"pub\"]\n    #[get_mut = \"pub\"]\n    likelihood: L,\n    #[get = \"pub\"]\n    #[get_mut = \"pub\"]\n    prior: Pr,\n    #[get = \"pub\"]\n    #[get_mut = \"pub\"]\n    posterior: Po,\n    payload: PhantomData\u003cPayload\u003e,\n}\n\nimpl\u003cEvent, PosteriorEvent, Data, L, Pr, Po, Payload\u003e Model\u003cL, Pr, Po, Payload\u003e\nwhere\n    Payload: Default,\n    Event: Hash + Eq + Clone,\n    PosteriorEvent: Hash + Eq + Clone,\n    L: Likelihood\u003cPayload, Event = Event, Data = Data\u003e,\n    Pr: Prior\u003cEvent = Event\u003e,\n    Po: Posterior\u003cBaseEvent = Event, Event = PosteriorEvent, Data = Data\u003e,\n{\n    /// Create new instance.\n    pub fn new(likelihood: L, prior: Pr, posterior: Po) -\u003e Self {\n        Model {\n            likelihood,\n            prior,\n            posterior,\n            payload: PhantomData,\n        }\n    }\n\n    /// Calculate joint probability, i.e. `Pr(event) * Pr(data | event)`.\n    fn joint_prob(\u0026self, event: \u0026Event, data: \u0026Data, payload: \u0026mut Payload) -\u003e LogProb {\n        self.prior.compute(event) + self.likelihood.compute(event, data, payload)\n    }\n\n    /// Compute model for a given universe of events.\n    pub fn compute\u003cU: IntoIterator\u003cItem = PosteriorEvent\u003e\u003e(\n        \u0026self,\n        universe: U,\n        data: \u0026Data,\n    ) -\u003e ModelInstance\u003cEvent, PosteriorEvent\u003e {\n        let mut joint_probs = HashMap::new();\n        let mut payload = Payload::default();\n        let (posterior_probs, marginal) = {\n            let mut joint_prob = |event: \u0026Event, data: \u0026Data| {\n                let p = self.joint_prob(event, data, \u0026mut payload);\n                joint_probs.insert(event.clone(), p);\n                p\n            };\n\n            let posterior_probs: HashMap\u003cPosteriorEvent, LogProb\u003e = universe\n                .into_iter()\n                .map(|event| {\n                    let p = self.posterior.compute(\u0026event, data, \u0026mut joint_prob);\n                    (event, p)\n                })\n                .collect();\n            let marginal = LogProb::ln_sum_exp(\u0026posterior_probs.values().cloned().collect_vec());\n\n            (posterior_probs, marginal)\n        };\n\n        ModelInstance {\n            joint_probs,\n            posterior_probs,\n            marginal,\n        }\n    }\n}\n\n/// Instance of a model for given data and event universe.\n/// From the instance, posterior, marginal and MAP can be computed.\npub struct ModelInstance\u003cEvent, PosteriorEvent\u003e\nwhere\n    Event: Hash + Eq,\n    PosteriorEvent: Hash + Eq,\n{\n    joint_probs: HashMap\u003cEvent, LogProb\u003e,\n    posterior_probs: HashMap\u003cPosteriorEvent, LogProb\u003e,\n    marginal: LogProb,\n}\n\nimpl\u003cEvent, PosteriorEvent\u003e ModelInstance\u003cEvent, PosteriorEvent\u003e\nwhere\n    Event: Hash + Eq,\n    PosteriorEvent: Hash + Eq,\n{\n    /// Posterior probability of given event.\n    pub fn posterior(\u0026self, event: \u0026PosteriorEvent) -\u003e Option\u003cLogProb\u003e {\n        self.posterior_probs.get(event).map(|p| p - self.marginal)\n    }\n\n    /// Marginal probability.\n    pub fn marginal(\u0026self) -\u003e LogProb {\n        self.marginal\n    }\n\n    /// Maximum a posteriori estimate.\n    pub fn maximum_posterior(\u0026self) -\u003e Option\u003c\u0026Event\u003e {\n        self.joint_probs\n            .iter()\n            .max_by_key(|(_, prob)| NotNan::new(***prob).unwrap())\n            .map(|(event, _)| event)\n    }\n}\n\nimpl\u003cPosteriorEvent\u003e ModelInstance\u003cNotNan\u003cf64\u003e, PosteriorEvent\u003e\nwhere\n    PosteriorEvent: Hash + Eq,\n{\n    pub fn expected_value(\u0026self) -\u003e NotNan\u003cf64\u003e {\n        self.joint_probs\n            .iter()\n            .map(|(event, prob)| *event * NotNan::new(**prob).unwrap())\n            .fold(NotNan::default(), |s, e| s + e)\n    }\n}\n\nmod tests {}\n","traces":[{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":29},{"path":["/","home","todd","rust-bio","src","stats","combinatorics.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Combinations with and without replacement.\n\nuse std::cmp;\n\n/// Calculate the number of combinations when choosing\n/// k elements from n elements without replacement, multiplied by a scaling factor.\n/// Time complexity: O(min(k, n - k))\n///\n/// # Examples\n/// ```\n/// use approx::assert_relative_eq;\n/// use bio::stats::combinatorics::scaled_combinations;\n/// assert_relative_eq!(scaled_combinations(5, 3, 0.5), 5., epsilon = f64::EPSILON);\n/// ```\npub fn scaled_combinations(n: u64, k: u64, scale: f64) -\u003e f64 {\n    if k \u003e n {\n        0.0\n    } else {\n        let mut comb = scale;\n        for j in 0..cmp::min(k, n - k) {\n            comb /= (j + 1) as f64;\n            comb *= (n - j) as f64;\n        }\n        comb\n    }\n}\n\n/// Calculate the number of combinations when choosing\n/// k elements from n elements without replacement.\n/// This is also known as n over k, or the binomial coefficient.\n/// Time complexity: O(min(k, n - k))\n///\n/// # Examples\n/// ```\n/// use approx::assert_relative_eq;\n/// use bio::stats::combinatorics::combinations;\n/// assert_relative_eq!(combinations(5, 3), 10., epsilon = f64::EPSILON);\n/// ```\npub fn combinations(n: u64, k: u64) -\u003e f64 {\n    scaled_combinations(n, k, 1.0)\n}\n\n/// Calculate the number of combinations when choosing\n/// k elements from n elements with replacement.\n/// Time complexity: O(min(k, n - k))\n///\n/// # Examples\n/// ```\n/// use approx::assert_relative_eq;\n/// use bio::stats::combinatorics::combinations_with_repl;\n/// assert_relative_eq!(combinations_with_repl(5, 3), 35., epsilon = f64::EPSILON);\n/// ```\npub fn combinations_with_repl(n: u64, k: u64) -\u003e f64 {\n    combinations(n + k - 1, k)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_comb() {\n        assert_relative_eq!(combinations(10, 3), 120.0, epsilon = f64::EPSILON);\n        assert_relative_eq!(combinations_with_repl(10, 3), 220.0, epsilon = f64::EPSILON);\n        assert_relative_eq!(\n            combinations(200, 10),\n            22451004309013280.0,\n            epsilon = f64::EPSILON\n        );\n    }\n\n    #[test]\n    fn test_comb_scaled() {\n        assert_relative_eq!(\n            scaled_combinations(150, 80, 1e-5),\n            6.664_393_816_347_938_4e38,\n            epsilon = f64::EPSILON\n        );\n    }\n}\n","traces":[{"line":20,"address":[4253440],"length":1,"stats":{"Line":0},"fn_name":"scaled_combinations"},{"line":21,"address":[4253488,4253737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[4253532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[4253509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[4253968,4253742,4253515,4253565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[4253882,4253779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[4253865,4253917,4254003,4253973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[4253725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[4254016],"length":1,"stats":{"Line":0},"fn_name":"combinations"},{"line":45,"address":[4254030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[4254064],"length":1,"stats":{"Line":0},"fn_name":"combinations_with_repl"},{"line":59,"address":[4254083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[4262336],"length":1,"stats":{"Line":0},"fn_name":"test_comb"},{"line":68,"address":[4262348,4262597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[4262568,4263519,4263294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[4264425,4264216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[4263490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[4265040],"length":1,"stats":{"Line":0},"fn_name":"test_comb_scaled"},{"line":79,"address":[4265084,4265293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[4265052],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":20},{"path":["/","home","todd","rust-bio","src","stats","hmm","errors.rs"],"content":"// Copyright 2019 Johannes Köster, University of Duisburg-Essen.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Error definitions for the `hmm` module.\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum Error {\n    #[error(\n        \"inferred from A: N_0={}, N_1={} (must be equal), from B: N={}, M={}, from pi: N={}\",\n        an0,\n        an1,\n        bn,\n        bm,\n        pin\n    )]\n    InvalidDimension {\n        an0: usize,\n        an1: usize,\n        bn: usize,\n        bm: usize,\n        pin: usize,\n    },\n}\npub type Result\u003cT, E = Error\u003e = std::result::Result\u003cT, E\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","stats","hmm","mod.rs"],"content":"// Copyright 2018 Manuel Holtgrewe, Berlin Institute of Health.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! An implementation of Hidden Markov Models in Rust.\n//!\n//! ## Examples\n//!\n//! ### Discrete Emission Distribution\n//!\n//! We construct the example from Borodovsky \u0026 Ekisheva (2006), pp. 80 (also see\n//! [these slides](http://cecas.clemson.edu/~ahoover/ece854/refs/Gonze-ViterbiAlgorithm.pdf).\n//!\n//! ```rust\n//! use approx::assert_relative_eq;\n//! use bio::stats::hmm::discrete_emission::Model as DiscreteEmissionHMM;\n//! use bio::stats::hmm::viterbi;\n//! use bio::stats::Prob;\n//! use ndarray::array;\n//!\n//! let transition = array![[0.5, 0.5], [0.4, 0.6]];\n//! let observation = array![[0.2, 0.3, 0.3, 0.2], [0.3, 0.2, 0.2, 0.3]];\n//! let initial = array![0.5, 0.5];\n//!\n//! let hmm = DiscreteEmissionHMM::with_float(\u0026transition, \u0026observation, \u0026initial)\n//!     .expect(\"Dimensions should be consistent\");\n//! let (path, log_prob) = viterbi(\u0026hmm, \u0026vec![2, 2, 1, 0, 1, 3, 2, 0, 0]);\n//! let prob = Prob::from(log_prob);\n//! assert_relative_eq!(4.25e-8_f64, *prob, epsilon = 1e-9_f64);\n//! ```\n//!\n//! ### Continuous (Gaussian) Emission Distribution\n//!\n//! ```rust\n//! use approx::assert_relative_eq;\n//! use bio::stats::hmm::univariate_continuous_emission::GaussianModel as GaussianHMM;\n//! use bio::stats::hmm::viterbi;\n//! use bio::stats::Prob;\n//! use ndarray::array;\n//! use statrs::distribution::Normal;\n//!\n//! let transition = array![[0.5, 0.5], [0.4, 0.6]];\n//! let observation = vec![\n//!     Normal::new(0.0, 1.0).unwrap(),\n//!     Normal::new(2.0, 1.0).unwrap(),\n//! ];\n//! let initial = array![0.5, 0.5];\n//!\n//! let hmm = GaussianHMM::with_float(\u0026transition, observation, \u0026initial)\n//!     .expect(\"Dimensions should be consistent\");\n//! let (path, log_prob) = viterbi(\n//!     \u0026hmm,\n//!     \u0026vec![-0.1, 0.1, -0.2, 0.5, 0.8, 1.1, 1.2, 1.5, 0.5, 0.2],\n//! );\n//! let prob = Prob::from(log_prob);\n//! assert_relative_eq!(2.64e-8_f64, *prob, epsilon = 1e-9_f64);\n//! ```\n//!\n//! ## Numeric Stability\n//!\n//! The implementation uses log-scale probabilities for numeric stability.\n//!\n//! ## Limitations\n//!\n//! Currently, only discrete and single-variate Gaussian continuous HMMs are implemented.\n//! Also, only dense transition matrices are supported.\n//!\n//! ## References\n//!\n//! - Rabiner, Lawrence R. \"A tutorial on hidden Markov models and selected applications\n//!   in speech recognition.\" Proceedings of the IEEE 77, no. 2 (1989): 257-286.\n\npub mod errors;\n\nuse std::cmp::Ordering;\n\nuse ndarray::prelude::*;\nuse num_traits::Zero;\nuse ordered_float::OrderedFloat;\nuse statrs::distribution::Continuous;\n\npub use self::errors::{Error, Result};\n\nuse super::LogProb;\n\ncustom_derive! {\n    /// A newtype for HMM states.\n    #[derive(\n        NewtypeFrom,\n        NewtypeDeref,\n        PartialEq,\n        Copy,\n        Clone,\n        Debug\n    )]\n    // #[derive(Serialize, Deserialize)]\n    pub struct State(pub usize);\n}\n\n/// Iterate over the states of a `Model`.\npub struct StateIter {\n    nxt: usize,\n    max: usize,\n}\n\nimpl StateIter {\n    /// Constructor.\n    pub fn new(num_states: usize) -\u003e Self {\n        Self {\n            nxt: 0,\n            max: num_states,\n        }\n    }\n}\n\nimpl Iterator for StateIter {\n    type Item = State;\n\n    fn next(\u0026mut self) -\u003e Option\u003cState\u003e {\n        if self.nxt \u003c self.max {\n            let cur = self.nxt;\n            self.nxt += 1;\n            Some(State(cur))\n        } else {\n            None\n        }\n    }\n}\n\n/// Transition between two states in a `Model`.\n#[derive(Debug, Copy, Clone, PartialEq)]\npub struct StateTransition {\n    /// Source of the transition.\n    pub src: State,\n    /// Destination of the transition.\n    pub dst: State,\n}\n\nimpl StateTransition {\n    /// Constructor.\n    pub fn new(src: State, dst: State) -\u003e Self {\n        Self { src, dst }\n    }\n}\n\n/// Iterate over all state transitions of a `Model`.\npub struct StateTransitionIter {\n    nxt_a: usize,\n    nxt_b: usize,\n    max: usize,\n}\n\nimpl StateTransitionIter {\n    /// Constructor.\n    pub fn new(num_states: usize) -\u003e Self {\n        Self {\n            nxt_a: 0,\n            nxt_b: 0,\n            max: num_states,\n        }\n    }\n}\n\nimpl Iterator for StateTransitionIter {\n    type Item = StateTransition;\n\n    fn next(\u0026mut self) -\u003e Option\u003cStateTransition\u003e {\n        let cur_b = self.nxt_b;\n        let cur_a = self.nxt_a;\n        if self.nxt_b \u003c self.max {\n            self.nxt_b += 1;\n            Some(StateTransition::new(State(cur_a), State(cur_b)))\n        } else if self.nxt_a \u003c self.max {\n            self.nxt_b = 0;\n            self.nxt_a += 1;\n            Some(StateTransition::new(State(cur_a), State(cur_b)))\n        } else {\n            None\n        }\n    }\n}\n\n/// A trait for Hidden Markov Models (HMM) with generic `Observation` type.\n///\n/// Rabiner (1989) defines a Hidden Markov Model λ as the tiple (*A*, *B*, π) of transition matrix\n/// *A*, emission probabilities *B*, and initial state distribution π.  This has been generalized\n/// in `Model` such that you implement `transition_prob()`, `observation_prob()`, and\n/// `initial_prob()` (and the other methods; implementation of `transition_prob_idx()` can\n/// optionally be implemented and your implementation of `transition_prob()` can then panic).\n///\n/// The inference algorithm implementations `viterbi()`, `forward()`, and `backward()` will work\n/// with any implementation.\n///\n/// Consequently, this allows for the implementation of HMMs with both discrete and continuous\n/// emission distributions.\npub trait Model\u003cObservation\u003e {\n    /// The number of states in the model.\n    fn num_states(\u0026self) -\u003e usize;\n\n    /// Return iterator over the states of an HMM.\n    fn states(\u0026self) -\u003e StateIter;\n\n    /// Returns an iterator of all transitions.\n    fn transitions(\u0026self) -\u003e StateTransitionIter;\n\n    /// Transition probability between two states `from` and `to`.\n    fn transition_prob(\u0026self, from: State, to: State) -\u003e LogProb;\n\n    /// Transition probability between two states `from` and `to` for observation with index\n    /// `_to_idx` (index of `to`).\n    ///\n    /// This feature comes in handy in several applications of HMMs to biological sequences.\n    /// One prominent one is how XHMM by Fromer et al. (2014) uses the distance between target\n    /// regions for adjusting the transition probabilities.\n    ///\n    /// The default implementation return the result of the position-independent\n    /// `transition_prob()`.\n    fn transition_prob_idx(\u0026self, from: State, to: State, _to_idx: usize) -\u003e LogProb {\n        self.transition_prob(from, to)\n    }\n\n    /// Initial probability given the HMM `state`.\n    fn initial_prob(\u0026self, state: State) -\u003e LogProb;\n\n    /// Probability for the given observation in the given state.\n    fn observation_prob(\u0026self, state: State, observation: \u0026Observation) -\u003e LogProb;\n}\n\n/// Compute the probability Viterbi matrix and the pointers to the origin.\nfn viterbi_matrices\u003cO, M: Model\u003cO\u003e\u003e(\n    hmm: \u0026M,\n    observations: \u0026[O],\n) -\u003e (Array2\u003cLogProb\u003e, Array2\u003cusize\u003e) {\n    // The matrix with probabilities.\n    let mut vals = Array2::\u003cLogProb\u003e::zeros((observations.len(), hmm.num_states()));\n    // For each cell in `vals`, a pointer to the row in the previous column (for the traceback).\n    let mut from = Array2::\u003cusize\u003e::zeros((observations.len(), hmm.num_states()));\n\n    // Compute matrix.\n    for (i, o) in observations.iter().enumerate() {\n        if i == 0 {\n            // Initial column.\n            for s in hmm.states() {\n                vals[[0, *s]] = hmm.initial_prob(s) + hmm.observation_prob(s, o);\n                from[[0, *s]] = *s;\n            }\n        } else {\n            // Subsequent columns.\n            for j in hmm.states() {\n                let x = vals\n                    .index_axis(Axis(0), i - 1)\n                    .iter()\n                    .enumerate()\n                    .map(|(a, p)| (State(a), p))\n                    .max_by(|(a, \u0026x), (b, \u0026y)| {\n                        if x.is_zero() \u0026\u0026 y.is_zero() {\n                            Ordering::Equal\n                        } else if x.is_zero() {\n                            Ordering::Less\n                        } else if y.is_zero() {\n                            Ordering::Greater\n                        } else {\n                            (x + hmm.transition_prob_idx(*a, j, i))\n                                .partial_cmp(\u0026(y + hmm.transition_prob_idx(*b, j, i)))\n                                .unwrap()\n                        }\n                    })\n                    .map(|(x, y)| (x, *y))\n                    .unwrap();\n                vals[[i, *j]] =\n                    x.1 + hmm.transition_prob_idx(x.0, j, i) + hmm.observation_prob(j, o);\n                from[[i, *j]] = *x.0;\n            }\n        }\n    }\n\n    (vals, from)\n}\n\nfn viterbi_traceback(vals: Array2\u003cLogProb\u003e, from: Array2\u003cusize\u003e) -\u003e (Vec\u003cState\u003e, LogProb) {\n    // Traceback through matrix.\n    let n = vals.len_of(Axis(0));\n    let mut result: Vec\u003cState\u003e = Vec::new();\n    let mut curr = 0;\n    let mut res_prob = LogProb::ln_zero();\n    for (i, col) in vals.axis_iter(Axis(0)).rev().enumerate() {\n        if i == 0 {\n            let tmp = col\n                .iter()\n                .enumerate()\n                .max_by_key(|\u0026(_, item)| OrderedFloat(**item))\n                .unwrap();\n            curr = tmp.0;\n            res_prob = *tmp.1;\n        } else {\n            curr = from[[n - i, curr]];\n        }\n        result.push(State(curr));\n    }\n    result.reverse();\n\n    (result, res_prob)\n}\n\n/// Execute Viterbi algorithm on the given slice of `Observation` values to get the maximum a\n/// posteriori (MAP) probability.\n///\n/// ## Arguments\n///\n/// - `hmm` - the `Model` to run the Viterbi algorithm on\n/// - `observations` - a slice of observation values to use in the algorithm\n///\n/// ## Result\n///\n/// The resulting pair *(s, p)* is the `Vec\u003cState\u003e` of most probable states given `hmm`\n/// and `observations` as well as the probability (as `LogProb`) of path `s`.\n///\n/// ## Type Parameters\n///\n/// - `O` - the observation type\n/// - `M` - type `Model` type\npub fn viterbi\u003cO, M: Model\u003cO\u003e\u003e(hmm: \u0026M, observations: \u0026[O]) -\u003e (Vec\u003cState\u003e, LogProb) {\n    let (vals, from) = viterbi_matrices(hmm, observations);\n    viterbi_traceback(vals, from)\n}\n\n/// Execute the forward algorithm and return the forward probabilites as `LogProb` values\n/// and the resulting forward probability.\n///\n/// ## Arguments\n///\n/// - `hmm` - the `Model` to run the forward algorithm on\n/// - `observations` - a slice of observation values to use in the algorithm\n///\n/// ## Result\n///\n/// The resulting pair (*P*, *p*) is the forward probability table (`P[[s, o]]` is the entry\n/// for state `s` and observation `o`) and the overall probability for `observations` (as\n/// `LogProb`).\n///\n/// ## Type Parameters\n///\n/// - `O` - the observation type\n/// - `M` - type `Model` type\npub fn forward\u003cO, M: Model\u003cO\u003e\u003e(hmm: \u0026M, observations: \u0026[O]) -\u003e (Array2\u003cLogProb\u003e, LogProb) {\n    // The matrix with probabilities.\n    let mut vals = Array2::\u003cLogProb\u003e::zeros((observations.len(), hmm.num_states()));\n\n    // Compute matrix.\n    for (i, o) in observations.iter().enumerate() {\n        if i == 0 {\n            // Initial column.\n            for s in hmm.states() {\n                vals[[0, *s]] = hmm.initial_prob(s) + hmm.observation_prob(s, o);\n            }\n        } else {\n            // Subsequent columns.\n            for j in hmm.states() {\n                let xs = hmm\n                    .states()\n                    .map(|k| {\n                        vals[[i - 1, *k]]\n                            + hmm.transition_prob_idx(k, j, i)\n                            + hmm.observation_prob(j, o)\n                    })\n                    .collect::\u003cVec\u003cLogProb\u003e\u003e();\n                vals[[i, *j]] = LogProb::ln_sum_exp(\u0026xs);\n            }\n        }\n    }\n\n    // Compute final probability.\n    let prob = LogProb::ln_sum_exp(vals.row(observations.len() - 1).to_slice().unwrap());\n\n    (vals, prob)\n}\n\n/// Execute the backward algorithm and return the backward probabilities as `LogProb` values\n/// and the resulting backward probability.\n///\n/// ## Arguments\n///\n/// - `hmm` - the `Model` to run the backward algorithm on\n/// - `observations` - a slice of observation values to use in the algorithm\n///\n/// ## Result\n///\n/// The resulting pair (*P*, *p*) is the backward probability table (`P[[s, o]]` is the entry\n/// for state `s` and observation `o`) and the overall probability for `observations` (as\n/// `LogProb`).\n///\n/// ## Type Parameters\n///\n/// - `O` - the observation type\n/// - `M` - type `Model` type\npub fn backward\u003cO, M: Model\u003cO\u003e\u003e(hmm: \u0026M, observations: \u0026[O]) -\u003e (Array2\u003cLogProb\u003e, LogProb) {\n    // The matrix with probabilities.\n    let mut vals = Array2::\u003cLogProb\u003e::zeros((observations.len(), hmm.num_states()));\n\n    // Compute matrix.\n    let n = observations.len();\n    for (i, o) in observations.iter().rev().enumerate() {\n        if i == 0 {\n            for j in hmm.states() {\n                let maybe_initial = if i == observations.len() - 1 {\n                    hmm.initial_prob(j)\n                } else {\n                    LogProb::ln_one()\n                };\n                vals[[0, *j]] = LogProb::ln_one() + hmm.observation_prob(j, o) + maybe_initial;\n            }\n        } else {\n            // Previous columns.\n            for j in hmm.states() {\n                let maybe_initial = if i == observations.len() - 1 {\n                    hmm.initial_prob(j)\n                } else {\n                    LogProb::ln_one()\n                };\n                let xs = hmm\n                    .states()\n                    .map(|k| {\n                        vals[[i - 1, *k]]\n                            + hmm.transition_prob_idx(j, k, n - i)\n                            + hmm.observation_prob(j, o)\n                            + maybe_initial\n                    })\n                    .collect::\u003cVec\u003cLogProb\u003e\u003e();\n                vals[[i, *j]] = LogProb::ln_sum_exp(\u0026xs);\n            }\n        }\n    }\n\n    // Compute final probability.\n    let prob = LogProb::ln_sum_exp(vals.row(observations.len() - 1).to_slice().unwrap());\n\n    (vals, prob)\n}\n\n/// Implementation of Hidden Markov Model with emission values from discrete distributions.\npub mod discrete_emission {\n    use super::super::{LogProb, Prob};\n    use super::*;\n\n    /// Implementation of a `hmm::Model` with emission values from discrete distributions.\n    ///\n    /// Log-scale probabilities are used for numeric stability.\n    ///\n    /// In Rabiner's tutorial, a discrete emission value HMM has `N` states and `M` output symbols.\n    /// The state transition matrix with dimensions `NxN` is `A`, the observation probability\n    /// distribution is the matrix `B` with dimensions `NxM` and the initial state distribution `pi`\n    /// has length `N`.\n    #[derive(Debug, PartialEq)]\n    pub struct Model {\n        /// The state transition matrix (size `NxN`), `A` in Rabiner's tutorial.\n        transition: Array2\u003cLogProb\u003e,\n\n        /// The observation symbol probability distribution (size `NxM`), `B` in Rabiner's tutorial.\n        observation: Array2\u003cLogProb\u003e,\n\n        /// The initial state distribution (size `N`), `pi` in Rabiner's tutorial.\n        initial: Array1\u003cLogProb\u003e,\n    }\n\n    impl Model {\n        /// Construct new Hidden MarkovModel with the given transition, observation, and initial\n        /// state matrices and vectors already in log-probability space.\n        pub fn new(\n            transition: Array2\u003cLogProb\u003e,\n            observation: Array2\u003cLogProb\u003e,\n            initial: Array1\u003cLogProb\u003e,\n        ) -\u003e Result\u003cSelf\u003e {\n            let (an0, an1) = transition.dim();\n            let (bn, bm) = observation.dim();\n            let pin = initial.dim();\n\n            if an0 != an1 || an0 != bn || an0 != pin {\n                Err(Error::InvalidDimension {\n                    an0,\n                    an1,\n                    bn,\n                    bm,\n                    pin,\n                })\n            } else {\n                Ok(Self {\n                    transition,\n                    observation,\n                    initial,\n                })\n            }\n        }\n\n        /// Construct new Hidden MarkovModel with the given transition, observation, and initial\n        /// state matrices and vectors already as `Prob` values.\n        pub fn with_prob(\n            transition: \u0026Array2\u003cProb\u003e,\n            observation: \u0026Array2\u003cProb\u003e,\n            initial: \u0026Array1\u003cProb\u003e,\n        ) -\u003e Result\u003cSelf\u003e {\n            Self::new(\n                transition.map(|x| LogProb::from(*x)),\n                observation.map(|x| LogProb::from(*x)),\n                initial.map(|x| LogProb::from(*x)),\n            )\n        }\n\n        /// Construct new Hidden MarkovModel with the given transition, observation, and initial\n        /// state matrices and vectors with probabilities as `f64` values.\n        pub fn with_float(\n            transition: \u0026Array2\u003cf64\u003e,\n            observation: \u0026Array2\u003cf64\u003e,\n            initial: \u0026Array1\u003cf64\u003e,\n        ) -\u003e Result\u003cSelf\u003e {\n            Self::new(\n                transition.map(|x| LogProb::from(Prob(*x))),\n                observation.map(|x| LogProb::from(Prob(*x))),\n                initial.map(|x| LogProb::from(Prob(*x))),\n            )\n        }\n    }\n\n    impl super::Model\u003cusize\u003e for Model {\n        fn num_states(\u0026self) -\u003e usize {\n            self.transition.dim().0\n        }\n\n        fn states(\u0026self) -\u003e StateIter {\n            StateIter {\n                nxt: 0,\n                max: self.num_states(),\n            }\n        }\n\n        fn transitions(\u0026self) -\u003e StateTransitionIter {\n            StateTransitionIter {\n                nxt_a: 0,\n                nxt_b: 0,\n                max: self.num_states(),\n            }\n        }\n\n        fn transition_prob(\u0026self, from: State, to: State) -\u003e LogProb {\n            self.transition[[*from, *to]]\n        }\n\n        fn initial_prob(\u0026self, state: State) -\u003e LogProb {\n            self.initial[[*state]]\n        }\n\n        fn observation_prob(\u0026self, state: State, observation: \u0026usize) -\u003e LogProb {\n            self.observation[[*state, *observation]]\n        }\n    }\n}\n\n/// Implementation of Hidden Markov Models with emission values from univariate continuous\n/// distributions.\npub mod univariate_continuous_emission {\n    use super::super::{LogProb, Prob};\n    use super::*;\n\n    /// Implementation of a `hmm::Model` with emission values from univariate continuous distributions.\n    ///\n    /// Log-scale probabilities are used for numeric stability.\n    pub struct Model\u003cDist: Continuous\u003cf64, f64\u003e\u003e {\n        /// The state transition matrix (size `NxN`), `A` in Rabiner's tutorial.\n        transition: Array2\u003cLogProb\u003e,\n\n        /// The emission probability distributions.\n        observation: Vec\u003cDist\u003e,\n\n        /// The initial state distribution (size `N`), `pi` in Rabiner's tutorial.\n        initial: Array1\u003cLogProb\u003e,\n    }\n\n    impl\u003cDist: Continuous\u003cf64, f64\u003e\u003e Model\u003cDist\u003e {\n        /// Construct new Hidden MarkovModel with the given transition, observation, and initial\n        /// state matrices and vectors already in log-probability space.\n        pub fn new(\n            transition: Array2\u003cLogProb\u003e,\n            observation: Vec\u003cDist\u003e,\n            initial: Array1\u003cLogProb\u003e,\n        ) -\u003e Result\u003cSelf\u003e {\n            let (an0, an1) = transition.dim();\n            let bn = observation.len();\n            let pin = initial.dim();\n\n            if an0 != an1 || an0 != bn || an0 != pin {\n                Err(Error::InvalidDimension {\n                    an0,\n                    an1,\n                    bn,\n                    bm: bn,\n                    pin,\n                })\n            } else {\n                Ok(Self {\n                    transition,\n                    observation,\n                    initial,\n                })\n            }\n        }\n\n        /// Construct new Hidden MarkovModel with the given transition, observation, and initial\n        /// state matrices and vectors already as `Prob` values.\n        pub fn with_prob(\n            transition: \u0026Array2\u003cProb\u003e,\n            observation: Vec\u003cDist\u003e,\n            initial: \u0026Array1\u003cProb\u003e,\n        ) -\u003e Result\u003cSelf\u003e {\n            Self::new(\n                transition.map(|x| LogProb::from(*x)),\n                observation,\n                initial.map(|x| LogProb::from(*x)),\n            )\n        }\n\n        /// Construct new Hidden MarkovModel with the given transition, observation, and initial\n        /// state matrices and vectors with probabilities as `f64` values.\n        pub fn with_float(\n            transition: \u0026Array2\u003cf64\u003e,\n            observation: Vec\u003cDist\u003e,\n            initial: \u0026Array1\u003cf64\u003e,\n        ) -\u003e Result\u003cSelf\u003e {\n            Self::new(\n                transition.map(|x| LogProb::from(Prob(*x))),\n                observation,\n                initial.map(|x| LogProb::from(Prob(*x))),\n            )\n        }\n    }\n\n    impl\u003cDist: Continuous\u003cf64, f64\u003e\u003e super::Model\u003cf64\u003e for Model\u003cDist\u003e {\n        fn num_states(\u0026self) -\u003e usize {\n            self.transition.dim().0\n        }\n\n        fn states(\u0026self) -\u003e StateIter {\n            StateIter {\n                nxt: 0,\n                max: self.num_states(),\n            }\n        }\n\n        fn transitions(\u0026self) -\u003e StateTransitionIter {\n            StateTransitionIter {\n                nxt_a: 0,\n                nxt_b: 0,\n                max: self.num_states(),\n            }\n        }\n\n        fn transition_prob(\u0026self, from: State, to: State) -\u003e LogProb {\n            self.transition[[*from, *to]]\n        }\n\n        fn initial_prob(\u0026self, state: State) -\u003e LogProb {\n            self.initial[[*state]]\n        }\n\n        fn observation_prob(\u0026self, state: State, observation: \u0026f64) -\u003e LogProb {\n            LogProb::from(Prob::from(self.observation[*state].pdf(*observation)))\n        }\n    }\n\n    /// Shortcut for HMM with emission values from a Gaussian distribution.\n    pub type GaussianModel = Model\u003cstatrs::distribution::Normal\u003e;\n}\n\n#[cfg(test)]\nmod tests {\n    use super::super::Prob;\n    use ndarray::array;\n    use statrs::distribution::Normal;\n\n    use super::discrete_emission::Model as DiscreteEmissionHMM;\n    use super::univariate_continuous_emission::GaussianModel as GaussianHMM;\n    use super::*;\n\n    #[test]\n    fn test_discrete_viterbi_toy_example() {\n        // We construct the toy example from Borodovsky \u0026 Ekisheva (2006), pp. 80.\n        //\n        // http://cecas.clemson.edu/~ahoover/ece854/refs/Gonze-ViterbiAlgorithm.pdf\n        //\n        // States: 0=High GC content, 1=Low GC content\n        // Symbols: 0=A, 1=C, 2=G, 3=T\n        let transition = array![[0.5, 0.5], [0.4, 0.6]];\n        let observation = array![[0.2, 0.3, 0.3, 0.2], [0.3, 0.2, 0.2, 0.3]];\n        let initial = array![0.5, 0.5];\n\n        let hmm = DiscreteEmissionHMM::with_float(\u0026transition, \u0026observation, \u0026initial)\n            .expect(\"Dimensions should be consistent\");\n        let (path, log_prob) = viterbi(\u0026hmm, \u0026[2, 2, 1, 0, 1, 3, 2, 0, 0]);\n        let prob = Prob::from(log_prob);\n\n        let expected = vec![0, 0, 0, 1, 1, 1, 1, 1, 1]\n            .iter()\n            .map(|i| State(*i))\n            .collect::\u003cVec\u003cState\u003e\u003e();\n        assert_eq!(expected, path);\n        assert_relative_eq!(4.25e-8_f64, *prob, epsilon = 1e-9_f64);\n    }\n\n    #[test]\n    fn test_discrete_forward_toy_example() {\n        // Same toy example as above.\n        let transition = array![[0.5, 0.5], [0.4, 0.6]];\n        let observation = array![[0.2, 0.3, 0.3, 0.2], [0.3, 0.2, 0.2, 0.3]];\n        let initial = array![0.5, 0.5];\n\n        let hmm = DiscreteEmissionHMM::with_float(\u0026transition, \u0026observation, \u0026initial)\n            .expect(\"Dimensions should be consistent\");\n        let log_prob = forward(\u0026hmm, \u0026[2, 2, 1, 0]).1;\n        let prob = Prob::from(log_prob);\n\n        assert_relative_eq!(0.0038432_f64, *prob, epsilon = 0.0001);\n    }\n\n    #[test]\n    fn test_discrete_backward_toy_example() {\n        // Same toy example as above.\n        let transition = array![[0.5, 0.5], [0.4, 0.6]];\n        let observation = array![[0.2, 0.3, 0.3, 0.2], [0.3, 0.2, 0.2, 0.3]];\n        let initial = array![0.5, 0.5];\n\n        let hmm = DiscreteEmissionHMM::with_float(\u0026transition, \u0026observation, \u0026initial)\n            .expect(\"Dimensions should be consistent\");\n        let log_prob = backward(\u0026hmm, \u0026[2, 2, 1, 0]).1;\n        let prob = Prob::from(log_prob);\n\n        assert_relative_eq!(0.0038432_f64, *prob, epsilon = 0.0001);\n    }\n\n    #[test]\n    fn test_discrete_forward_equals_backward_toy_example() {\n        // Same toy example as above.\n        let transition = array![[0.5, 0.5], [0.4, 0.6]];\n        let observation = array![[0.2, 0.3, 0.3, 0.2], [0.3, 0.2, 0.2, 0.3]];\n        let initial = array![0.5, 0.5];\n        let hmm = DiscreteEmissionHMM::with_float(\u0026transition, \u0026observation, \u0026initial)\n            .expect(\"Dimensions should be consistent\");\n\n        for len in 1..10 {\n            let mut seq: Vec\u003cusize\u003e = vec![0; len];\n            while seq.iter().sum::\u003cusize\u003e() != len {\n                for i in 0..len {\n                    if seq[i] == 0 {\n                        seq[i] = 1;\n                        break;\n                    } else {\n                        seq[i] = 0;\n                    }\n                }\n\n                let prob_fwd = *Prob::from(forward(\u0026hmm, \u0026seq).1);\n                let prob_bck = *Prob::from(backward(\u0026hmm, \u0026seq).1);\n                assert_relative_eq!(prob_fwd, prob_bck, epsilon = 0.00001);\n            }\n        }\n    }\n\n    #[test]\n    fn test_gaussian_viterbi_simple_example() {\n        let transition = array![[0.5, 0.5], [0.4, 0.6]];\n        let observation = vec![\n            Normal::new(0.0, 1.0).unwrap(),\n            Normal::new(2.0, 1.0).unwrap(),\n        ];\n        let initial = array![0.5, 0.5];\n\n        let hmm = GaussianHMM::with_float(\u0026transition, observation, \u0026initial)\n            .expect(\"Dimensions should be consistent\");\n        let (path, log_prob) = viterbi(\u0026hmm, \u0026[-0.1, 0.1, -0.2, 0.5, 0.8, 1.1, 1.2, 1.5, 0.5, 0.2]);\n        let prob = Prob::from(log_prob);\n\n        let expected = vec![0, 0, 0, 0, 0, 1, 1, 1, 0, 0]\n            .iter()\n            .map(|i| State(*i))\n            .collect::\u003cVec\u003cState\u003e\u003e();\n        assert_eq!(expected, path);\n        assert_relative_eq!(2.64e-8_f64, *prob, epsilon = 1e-9_f64);\n    }\n\n    #[test]\n    fn test_gaussian_forward_simple_example() {\n        let transition = array![[0.5, 0.5], [0.4, 0.6]];\n        let observation = vec![\n            Normal::new(0.0, 1.0).unwrap(),\n            Normal::new(2.0, 1.0).unwrap(),\n        ];\n        let initial = array![0.5, 0.5];\n\n        let hmm = GaussianHMM::with_float(\u0026transition, observation, \u0026initial)\n            .expect(\"Dimensions should be consistent\");\n        let log_prob = forward(\u0026hmm, \u0026[0.1, 1.5, 1.8, 2.2, 0.5]).1;\n        let prob = Prob::from(log_prob);\n\n        assert_relative_eq!(7.820e-4_f64, *prob, epsilon = 1e-5_f64);\n    }\n\n    #[test]\n    fn test_gaussian_backward_simple_example() {\n        let transition = array![[0.5, 0.5], [0.4, 0.6]];\n        let observation = vec![\n            Normal::new(0.0, 1.0).unwrap(),\n            Normal::new(2.0, 1.0).unwrap(),\n        ];\n        let initial = array![0.5, 0.5];\n\n        let hmm = GaussianHMM::with_float(\u0026transition, observation, \u0026initial)\n            .expect(\"Dimensions should be consistent\");\n        let log_prob = backward(\u0026hmm, \u0026[0.1, 1.5, 1.8, 2.2, 0.5]).1;\n        let prob = Prob::from(log_prob);\n\n        assert_relative_eq!(7.820e-4_f64, *prob, epsilon = 1e-5_f64);\n    }\n\n    #[test]\n    fn test_gaussian_forward_equals_backward_simple_example() {\n        let transition = array![[0.5, 0.5], [0.4, 0.6]];\n        let observation = vec![\n            Normal::new(0.0, 1.0).unwrap(),\n            Normal::new(2.0, 1.0).unwrap(),\n        ];\n        let initial = array![0.5, 0.5];\n        let hmm = GaussianHMM::with_float(\u0026transition, observation, \u0026initial)\n            .expect(\"Dimensions should be consistent\");\n\n        let seqs = vec![vec![0.1, 0.5, 1.0, 1.5, 1.8, 2.1]];\n        for seq in \u0026seqs {\n            let prob_fwd = *Prob::from(forward(\u0026hmm, \u0026seq).1);\n            let prob_bck = *Prob::from(backward(\u0026hmm, \u0026seq).1);\n            assert_relative_eq!(prob_fwd, prob_bck, epsilon = 0.00001);\n        }\n    }\n}\n","traces":[{"line":98,"address":[5842829,5842990,5842947,5842877],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[5840848],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":120,"address":[5840896],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":121,"address":[5840928,5840910,5841009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[5840935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[5840948,5841011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[5840985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[5840919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[5841056],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":156,"address":[5841104],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":168,"address":[5841136],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":169,"address":[5841166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[5841183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[5841199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[5841318,5841237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[5841281,5841363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[5841214,5841562,5841403,5841557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[5841410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[5841497,5841418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[5841460,5841542],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[5841396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[4527328],"length":1,"stats":{"Line":0},"fn_name":"transition_prob_idx\u003cbio::stats::hmm::discrete_emission::Model,usize\u003e"},{"line":220,"address":[4527352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[8039170,8041735,8039155,8041750,8036608,8039184],"length":1,"stats":{"Line":0},"fn_name":"viterbi_matrices\u003cf64,bio::stats::hmm::univariate_continuous_emission::Model\u003cstatrs::distribution::normal::Normal\u003e\u003e"},{"line":236,"address":[8039269,8036693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[8036909,8036805,8039485,8039381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[8038618,8041198,8036972,8039953,8039656,8039548,8037373,8037080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[8040278,8040025,8037698,8038764,8041344,8037445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[8041219,8040036,8041730,8038769,8038639,8037456,8039150,8041349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[8041381,8038801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[8039012,8041592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[8040076,8041193,8038613,8040283,8037496,8037703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[8037861,8040362,8037782,8037978,8040441,8040558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[8037813,8040315,8040393,8037735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[8041779,8041843,8041760,8041824],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cusize,bio::stats::hmm::discrete_emission::Model\u003e"},{"line":256,"address":[8041888,8041924,8037922,8042336,8042372,8040502],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cf64,bio::stats::hmm::univariate_continuous_emission::Model\u003cstatrs::distribution::normal::Normal\u003e\u003e"},{"line":257,"address":[8042426,8041978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[8042504,8042056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[8042040,8042488,8042077,8042552,8042104,8042525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[8042099,8042547],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[8042531,8042110,8042558,8042083,8042627,8042179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[8042174,8042622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[8042283,8042574,8042731,8042126,8042193,8042641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[8042214,8042662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[8042798,8042848,8042784,8042862],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cusize,bio::stats::hmm::discrete_emission::Model\u003e"},{"line":271,"address":[8040868,8038288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[8040694,8038114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[8041023,8038443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[8037249,8039829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[5842775,5841568],"length":1,"stats":{"Line":0},"fn_name":"viterbi_traceback"},{"line":283,"address":[5841606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[5841656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[5841700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[5841712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[5841997,5842621,5841745,5841836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[5842616,5842258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[5842493,5842280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[8042912,8042926],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":294,"address":[5842595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[5842603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[5842300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[5842435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[5842636,5841971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[5842653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[8043869,8043405,8043440,8042976],"length":1,"stats":{"Line":0},"fn_name":"viterbi\u003cf64,bio::stats::hmm::univariate_continuous_emission::Model\u003cstatrs::distribution::normal::Normal\u003e\u003e"},{"line":324,"address":[8043016,8043480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[8043636,8043172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[8043904,8047925,8045905,8045920,8047910,8045890],"length":1,"stats":{"Line":0},"fn_name":"forward\u003cf64,bio::stats::hmm::univariate_continuous_emission::Model\u003cstatrs::distribution::normal::Normal\u003e\u003e"},{"line":348,"address":[8043989,8046005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[8044209,8044419,8047242,8046439,8046225,8045222,8044101,8046117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[8045368,8047388,8044483,8046756,8044736,8046503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[8047263,8047628,8045373,8045608,8044494,8047393,8046514,8045243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[8045405,8047425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[8046761,8044741,8046554,8047237,8045217,8044534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[8046793,8046942,8044922,8044773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[8044834,8046854,8048240,8047936],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cusize,bio::stats::hmm::discrete_emission::Model\u003e"},{"line":363,"address":[8048521,8047955,8048157,8048217,8048259,8048461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[8048108,8048412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[8048477,8048173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[8047081,8046980,8045061,8044960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[8047641,8045621,8044394,8046414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[8047824,8045804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[8051130,8051145,8053738,8053753,8051152,8048544],"length":1,"stats":{"Line":0},"fn_name":"backward\u003cf64,bio::stats::hmm::univariate_continuous_emission::Model\u003cstatrs::distribution::normal::Normal\u003e\u003e"},{"line":399,"address":[8051237,8048629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[8048741,8051349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[8052825,8049154,8051762,8048884,8050217,8051492,8048795,8051403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[8049471,8049218,8052995,8050387,8051826,8052079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[8051837,8050408,8050844,8052846,8053452,8049229,8050238,8053016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[8050440,8053048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[8050568,8053176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[8050555,8053239,8053163,8050631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[8050642,8053220,8053250,8050612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[8051877,8049269,8049492,8052100,8052820,8050212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[8049524,8052132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[8052268,8049660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[8049644,8049756,8052364,8052252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[8049911,8052318,8052519,8049710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[8054208,8052399,8049791,8053760],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cusize,bio::stats::hmm::discrete_emission::Model\u003e"},{"line":424,"address":[8054533,8054593,8053785,8054085,8054623,8054233,8054175,8054145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[8053950,8054398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[8054101,8054549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[8054615,8054167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[8052557,8052658,8050050,8049949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[8050857,8053465,8051737,8049129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[8051043,8053651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[7705274,7704416],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":474,"address":[7704456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[7704574,7704646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[7704678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[7704752,7705039,7704716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[7705071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[7704911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[7704823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[7704854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[7704885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[7705623,7705328],"length":1,"stats":{"Line":0},"fn_name":"with_prob"},{"line":503,"address":[4527376,4527390],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":504,"address":[4527424,4527438],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":505,"address":[4527486,4527472],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":511,"address":[7705959,7705664],"length":1,"stats":{"Line":0},"fn_name":"with_float"},{"line":517,"address":[4527534,4527520],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":518,"address":[4527584,4527598],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":519,"address":[4527648,4527662],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":525,"address":[7706000],"length":1,"stats":{"Line":0},"fn_name":"num_states"},{"line":526,"address":[7706009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[7706032],"length":1,"stats":{"Line":0},"fn_name":"states"},{"line":532,"address":[7706041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[7706096],"length":1,"stats":{"Line":0},"fn_name":"transitions"},{"line":540,"address":[7706126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[7706176],"length":1,"stats":{"Line":0},"fn_name":"transition_prob"},{"line":545,"address":[7706200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[7706320],"length":1,"stats":{"Line":0},"fn_name":"initial_prob"},{"line":549,"address":[7706334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[7706416],"length":1,"stats":{"Line":0},"fn_name":"observation_prob"},{"line":553,"address":[7706440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[7773072,7773908],"length":1,"stats":{"Line":0},"fn_name":"new\u003cstatrs::distribution::normal::Normal\u003e"},{"line":586,"address":[7773112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[7773230,7773289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[7773297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[7773335,7773371,7773690],"length":1,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[7773717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[7773547],"length":1,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[7773442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":601,"address":[7773478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[7773521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[7774314,7773968],"length":1,"stats":{"Line":0},"fn_name":"with_float\u003cstatrs::distribution::normal::Normal\u003e"},{"line":629,"address":[7774366,7774013,7774352],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cstatrs::distribution::normal::Normal\u003e"},{"line":630,"address":[7774074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[7774115,7774416,7774430],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cstatrs::distribution::normal::Normal\u003e"},{"line":637,"address":[7774480],"length":1,"stats":{"Line":0},"fn_name":"num_states\u003cstatrs::distribution::normal::Normal\u003e"},{"line":638,"address":[7774489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":641,"address":[7774512],"length":1,"stats":{"Line":0},"fn_name":"states\u003cstatrs::distribution::normal::Normal\u003e"},{"line":644,"address":[7774521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":656,"address":[7774576],"length":1,"stats":{"Line":0},"fn_name":"transition_prob\u003cstatrs::distribution::normal::Normal\u003e"},{"line":657,"address":[7774600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[7774720],"length":1,"stats":{"Line":0},"fn_name":"initial_prob\u003cstatrs::distribution::normal::Normal\u003e"},{"line":661,"address":[7774734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[7774816],"length":1,"stats":{"Line":0},"fn_name":"observation_prob\u003cstatrs::distribution::normal::Normal\u003e"},{"line":665,"address":[7774840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[7734421,7734416],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":691,"address":[7774990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[7775172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[7775404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":695,"address":[7775548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":697,"address":[7775637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[7775787,7775722],"length":1,"stats":{"Line":0},"fn_name":null},{"line":700,"address":[7776104,7775806,7775957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[7734448,7734462],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":704,"address":[7776326,7776191,7776374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":705,"address":[7776428,7776340,7776648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[7734485,7734480],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":711,"address":[7777598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":712,"address":[7777780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":713,"address":[7778012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":715,"address":[7778156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[7778245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[7778371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[7778659,7778413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":724,"address":[7734512,7734517],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":726,"address":[7779582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":727,"address":[7779764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":728,"address":[7779996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":730,"address":[7780140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":732,"address":[7780229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":733,"address":[7780355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[7780397,7780643],"length":1,"stats":{"Line":0},"fn_name":null},{"line":739,"address":[7734549,7734544],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":741,"address":[7781566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":742,"address":[7781748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[7781980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":744,"address":[7782124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":747,"address":[7782470,7782360,7782213,7784652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":748,"address":[7782510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":749,"address":[7782680,7782533,7783824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":750,"address":[7782749,7783143,7782947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":751,"address":[7782987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":752,"address":[7783046,7783156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":755,"address":[7783091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":759,"address":[7783163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[7783388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":761,"address":[7783829,7783621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":767,"address":[7734581,7734576],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":768,"address":[7784750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":769,"address":[7785221,7785034,7784940,7785278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":770,"address":[7784956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":771,"address":[7785102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":773,"address":[7785296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":775,"address":[7785431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[7785592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":778,"address":[7785742,7785677],"length":1,"stats":{"Line":0},"fn_name":null},{"line":780,"address":[7786067,7785920,7785761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":782,"address":[7734622,7734608],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":784,"address":[7786289,7786337,7786154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[7786611,7786303,7786391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":789,"address":[7734640,7734645],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":790,"address":[7787582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":791,"address":[7788110,7787772,7788053,7787866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":792,"address":[7787788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":793,"address":[7787934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[7788128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[7788263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[7788424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":800,"address":[7788550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[7788592,7788838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":806,"address":[7734672,7734677],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":807,"address":[7789774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[7789964,7790302,7790245,7790058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":809,"address":[7789980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":810,"address":[7790126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":812,"address":[7790320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":814,"address":[7790455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[7790616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[7790742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":819,"address":[7790784,7791030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[7734709,7734704],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":824,"address":[7791966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":825,"address":[7792156,7792437,7792250,7792494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[7792172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[7792318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":829,"address":[7792512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":830,"address":[7792647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":833,"address":[7792826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":834,"address":[7793288,7793081,7793981,7793211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":835,"address":[7793320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":836,"address":[7793545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":837,"address":[7793778,7793986],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":262},{"path":["/","home","todd","rust-bio","src","stats","mod.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Mathematical and statistical tools.\n\npub mod bayesian;\npub mod combinatorics;\npub mod hmm;\npub mod pairhmm;\npub mod probs;\n\npub use crate::stats::probs::{LogProb, PHREDProb, Prob};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","stats","pairhmm","homopolypairhmm.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Copyright 2020 Till Hartmann.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A pair Hidden Markov Model for calculating the probability that two sequences are related to\n//! each other. Depending on the used parameters, this can, e.g., be used to calculate the\n//! probability that a certain sequencing read comes from a given position in a reference genome.\n//! In contrast to `PairHMM`, this `HomopolyPairHMM` takes into account homopolymer errors as\n//! often encountered e.g. in Oxford Nanopore Technologies sequencing.\n//!\n//! Time complexity: O(n * m) where `n = seq1.len()`, `m = seq2.len()` (or `m = min(seq2.len(), max_edit_dist)` with banding enabled).\n//! Memory complexity: O(m) where `m = seq2.len()`.\n//! Note that if the number of states weren't fixed in this implementation, we would have to include\n//! these in both time and memory complexity above as an additional factor.\n//!\n//! The `HomopolyPairHMM` introduces the term \"hop\" for starting and extending homopolymer runs\n//! by analogy with \"gap\". Therefore, the constructor needs an additional parameter `hop_params`\n//! implementing `HopParameters`. Also, the emission parameter needs to implement `Emission`,\n//! since this HMM model needs to be able to distinguish the four different match states for\n//! A, C, G and T (see Details below).\n//!\n//! # Details\n//! The HomopolyPairHMM defined in this module has one Match state for each character from [A, C, G, T],\n//! for each of those Match states two corresponding Hop (homopolymer run) states\n//! (one for a run in sequence `x`, one for a run in `y`),\n//! as well as the usual GapX and GapY states.\n//!\n//! In states `MatchV` (where `V` ∈ `{A, C, G, T}`), the probability to emit anything other than\n//! `(V, V)`, `(V, y != V)`, `(x != V, y)` should be zero.\n//!\n//! State `HopVZ` (where `V` ∈ `{A, C, G, T}`, `Z` ∈ `{X, Y}`) can only be transitioned to from\n//! corresponding state `MatchV`.\n//!\n//! The transition matrix is given below:\n//!     | MA | MC | MG | MT | HAX | HAY | HCX | HCY | HGX | HGY | HTX | HTY | GX | GY\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! MA  |  x |  x |  x |  x |  x  |  x  |     |     |     |     |     |     |  x |  x\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! MC  |  x |  x |  x |  x |     |     |  x  |  x  |     |     |     |     |  x |  x\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! MG  |  x |  x |  x |  x |     |     |     |     |  x  |  x  |     |     |  x |  x\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! MT  |  x |  x |  x |  x |     |     |     |     |     |     |  x  |  x  |  x |  x\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! HAX |  x |  x |  x |  x |  x  |     |     |     |     |     |     |     |    |\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! HAY |  x |  x |  x |  x |     |  x  |     |     |     |     |     |     |    |\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! HCX |  x |  x |  x |  x |     |     |  x  |     |     |     |     |     |    |\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! HCY |  x |  x |  x |  x |     |     |     |  x  |     |     |     |     |    |\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! HGX |  x |  x |  x |  x |     |     |     |     |  x  |     |     |     |    |\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! HGY |  x |  x |  x |  x |     |     |     |     |     |  x  |     |     |    |\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! HTX |  x |  x |  x |  x |     |     |     |     |     |     |  x  |     |    |\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! HTY |  x |  x |  x |  x |     |     |     |     |     |     |     |  x  |    |\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! GX  |  x |  x |  x |  x |     |     |     |     |     |     |     |     |  x |\n//! ----|----|----|----|----|-----|-----|-----|-----|-----|-----|-----|-----|----|---\n//! GY  |  x |  x |  x |  x |     |     |     |     |     |     |     |     |    |  x\n\nuse std::cmp;\nuse std::fmt::Debug;\nuse std::iter::once;\nuse std::mem;\nuse std::ops::Shr;\nuse std::usize;\n\nuse enum_map::{Enum, EnumMap};\nuse itertools::Itertools;\nuse num_traits::Zero;\n\nuse crate::stats::pairhmm::homopolypairhmm::State::*;\nuse crate::stats::pairhmm::{\n    Emission, EmissionParameters, GapParameters, StartEndGapParameters, XYEmission,\n};\nuse crate::stats::probs::LogProb;\nuse crate::stats::Prob;\nuse std::collections::HashMap;\n\n#[derive(Eq, PartialEq, Debug, Enum, Clone, Copy)]\n#[repr(usize)]\npub enum State {\n    MatchA = 0,\n    MatchC = 1,\n    MatchG = 2,\n    MatchT = 3,\n    GapX = 4,\n    GapY = 5,\n    HopAX = 6,\n    HopAY = 7,\n    HopCX = 8,\n    HopCY = 9,\n    HopGX = 10,\n    HopGY = 11,\n    HopTX = 12,\n    HopTY = 13,\n}\n\nimpl State {\n    fn supports(\u0026self, x: u8, y: u8) -\u003e bool {\n        match self {\n            MatchA if x == b'A' || y == b'A' =\u003e true,\n            MatchC if x == b'C' || y == b'C' =\u003e true,\n            MatchG if x == b'G' || y == b'G' =\u003e true,\n            MatchT if x == b'T' || y == b'T' =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\nconst STATES: [State; 14] = [\n    MatchA, MatchC, MatchG, MatchT, GapX, GapY, HopAX, HopAY, HopCX, HopCY, HopGX, HopGY, HopTX,\n    HopTY,\n];\n\nconst MATCH_STATES: [State; 4] = [MatchA, MatchC, MatchG, MatchT];\nconst HOP_X_STATES: [State; 4] = [HopAX, HopCX, HopGX, HopTX];\nconst HOP_Y_STATES: [State; 4] = [HopAY, HopCY, HopGY, HopTY];\n\n// We define Shr (\u003e\u003e) for `State` such that a transition from State `a` to State `b` can be modeled\n// as `a \u003e\u003e b`, where `a \u003e\u003e b` is an integer in `0..(1 \u003c\u003c (2 * NUM_STATES)) - 1]` used for indexing\n// the transition table (see `build_transition_table`).\nimpl Shr for State {\n    type Output = usize;\n\n    fn shr(self, rhs: State) -\u003e Self::Output {\n        let a = self as u32;\n        let b = rhs as u32;\n        interleave_bits(a, b) as usize\n    }\n}\n\nfn space_bits(a: u32) -\u003e u64 {\n    let mut x = a as u64 \u0026 0x0000_0000_FFFF_FFFF;\n    x = (x | (x \u003c\u003c 16)) \u0026 0x0000_FFFF_0000_FFFF;\n    x = (x | (x \u003c\u003c 8)) \u0026 0x00FF_00FF_00FF_00FF;\n    x = (x | (x \u003c\u003c 4)) \u0026 0x0F0F_0F0F_0F0F_0F0F;\n    x = (x | (x \u003c\u003c 2)) \u0026 0x3333_3333_3333_3333;\n    x = (x | (x \u003c\u003c 1)) \u0026 0x5555_5555_5555_5555;\n    x\n}\n\nfn interleave_bits(a: u32, b: u32) -\u003e u64 {\n    space_bits(a) \u003c\u003c 1 | space_bits(b)\n}\n\n/// Trait for parametrization of `PairHMM` hop behavior.\npub trait HopParameters {\n    /// Probability to start hop in x.\n    fn prob_hop_x(\u0026self) -\u003e LogProb;\n\n    /// Probability to start hop in y.\n    fn prob_hop_y(\u0026self) -\u003e LogProb;\n\n    /// Probability to extend hop in x.\n    fn prob_hop_x_extend(\u0026self) -\u003e LogProb;\n\n    /// Probability to extend hop in y.\n    fn prob_hop_y_extend(\u0026self) -\u003e LogProb;\n}\n\n/// A pair Hidden Markov Model for comparing sequences x and y as described by\n/// Durbin, R., Eddy, S., Krogh, A., \u0026 Mitchison, G. (1998). Biological Sequence Analysis.\n/// Current Topics in Genome Analysis 2008. http://doi.org/10.1017/CBO9780511790492.\n/// The default model has been extended to consider homopolymer errors, at the cost of more states\n/// and transitions.\n#[derive(Debug, Clone)]\npub struct HomopolyPairHMM {\n    transition_probs: HashMap\u003cusize, LogProb\u003e,\n}\n\nimpl HomopolyPairHMM {\n    /// Create a new instance of a HomopolyPairHMM.\n    /// # Arguments\n    ///\n    /// * `gap_params` - parameters for opening or extending gaps\n    /// * `hop_params` - parameters for opening or extending hops\n    pub fn new\u003cG, H\u003e(gap_params: \u0026G, hop_params: \u0026H) -\u003e Self\n    where\n        G: GapParameters,\n        H: HopParameters,\n    {\n        Self {\n            transition_probs: build_transition_table(gap_params, hop_params),\n        }\n    }\n\n    /// Calculate the probability of sequence x being related to y via any alignment.\n    ///\n    /// # Arguments\n    ///\n    /// * `emission_params` - parameters for emission\n    /// * `alignment_mode` - parameters for free end/start gaps\n    /// * `max_edit_dist` - maximum edit distance to consider; if not `None`, perform banded alignment\n    pub fn prob_related\u003cE, A\u003e(\n        \u0026self,\n        emission_params: \u0026E,\n        alignment_mode: \u0026A,\n        max_edit_dist: Option\u003cusize\u003e,\n    ) -\u003e LogProb\n    where\n        E: EmissionParameters + Emission,\n        A: StartEndGapParameters,\n    {\n        let mut prev = 0;\n        let mut curr = 1;\n        let mut v: [EnumMap\u003cState, Vec\u003cLogProb\u003e\u003e; 2] = [EnumMap::new(), EnumMap::new()];\n        let transition_probs = \u0026self.transition_probs;\n\n        let len_y = emission_params.len_y();\n        let len_x = emission_params.len_x();\n        let mut min_edit_dist: [Vec\u003cusize\u003e; 2] =\n            [vec![usize::MAX; len_y + 1], vec![usize::MAX; len_y + 1]];\n        let free_end_gap_x = alignment_mode.free_end_gap_x();\n        let free_start_gap_x = alignment_mode.free_start_gap_x();\n\n        let mut prob_cols = Vec::with_capacity(len_x * STATES.len());\n\n        for state in \u0026STATES {\n            v[prev][*state] = vec![LogProb::zero(); len_y + 1];\n        }\n\n        v[curr] = v[prev].clone();\n\n        for \u0026m in \u0026MATCH_STATES {\n            v[prev][m][0] = LogProb::from(Prob(1. / 4.));\n        }\n\n        for i in 0..len_x {\n            if free_start_gap_x {\n                let prob_start_gap_x = LogProb(*alignment_mode.prob_start_gap_x(i) - 4f64.ln());\n                for \u0026m in \u0026MATCH_STATES {\n                    v[prev][m][0] = v[prev][m][0].ln_add_exp(prob_start_gap_x);\n                }\n                min_edit_dist[prev][0] = 0;\n            }\n\n            // cache probs for x[i]\n            let prob_emit_x_and_gap = emission_params.prob_emit_x(i);\n            let emission_x = emission_params.emission_x(i);\n\n            for j in 0..len_y {\n                let j_ = j + 1;\n                let j_minus_one = j_ - 1;\n\n                let min_edit_dist_topleft = min_edit_dist[prev][j_minus_one];\n                let min_edit_dist_top = min_edit_dist[curr][j_minus_one];\n                let min_edit_dist_left = min_edit_dist[prev][j_];\n\n                if let Some(max_edit_dist) = max_edit_dist {\n                    if min3(min_edit_dist_topleft, min_edit_dist_top, min_edit_dist_left)\n                        \u003e max_edit_dist\n                    {\n                        // skip this cell if best edit dist is already larger than given maximum\n                        continue;\n                    }\n                }\n\n                let emission_y = emission_params.emission_y(j);\n                let mut any_match = false;\n                for \u0026m in \u0026MATCH_STATES {\n                    if m.supports(emission_x, emission_y) {\n                        let emission = emission_params.prob_emit_xy(i, j);\n                        let emission_prob = match emission {\n                            XYEmission::Match(p) =\u003e p,\n                            // since we have separate match states, we need to halve mismatch probs\n                            // (since e.g. ('A', _) and (_, 'A') are distinct cases)\n                            XYEmission::Mismatch(p) =\u003e LogProb::from(*p - 2f64.ln()),\n                        };\n                        any_match |= emission.is_match();\n                        v[curr][m][j_] = emission_prob\n                            + LogProb::ln_sum_exp(\n                                \u0026STATES\n                                    .iter()\n                                    .map(|\u0026s| {\n                                        transition_probs.get(\u0026(s \u003e\u003e m)).unwrap_or(\u0026LogProb::zero())\n                                            + v[prev][s][j_minus_one]\n                                    })\n                                    .collect_vec(),\n                            );\n                    } else {\n                        v[curr][m][j_] = LogProb::zero();\n                    }\n                }\n\n                v[curr][GapY][j_] = prob_emit_x_and_gap\n                    + LogProb::ln_sum_exp(\n                        \u0026MATCH_STATES\n                            .iter()\n                            .map(|\u0026s| transition_probs[\u0026(s \u003e\u003e GapY)] + v[prev][s][j_])\n                            .chain(once(transition_probs[\u0026(GapY \u003e\u003e GapY)] + v[prev][GapY][j_]))\n                            .collect_vec(),\n                    );\n\n                MATCH_HOP_Y.iter().for_each(|\u0026(m, h)| {\n                    v[curr][h][j_] = (transition_probs[\u0026(m \u003e\u003e h)] + v[prev][m][j_])\n                        .ln_add_exp(transition_probs[\u0026(h \u003e\u003e h)] + v[prev][h][j_])\n                });\n\n                v[curr][GapX][j_] = emission_params.prob_emit_y(j)\n                    + LogProb::ln_sum_exp(\n                        \u0026MATCH_STATES\n                            .iter()\n                            .map(|\u0026s| transition_probs[\u0026(s \u003e\u003e GapX)] + v[curr][s][j_minus_one])\n                            .chain(once(\n                                transition_probs[\u0026(GapX \u003e\u003e GapX)] + v[curr][GapX][j_minus_one],\n                            ))\n                            .collect_vec(),\n                    );\n\n                MATCH_HOP_X.iter().for_each(|\u0026(m, h)| {\n                    v[curr][h][j_] = (transition_probs[\u0026(m \u003e\u003e h)] + v[curr][m][j_minus_one])\n                        .ln_add_exp(transition_probs[\u0026(h \u003e\u003e h)] + v[curr][h][j_minus_one])\n                });\n\n                // calculate minimal number of mismatches\n                if max_edit_dist.is_some() {\n                    min_edit_dist[curr][j_] = min3(\n                        if any_match {\n                            // a match, so nothing changes\n                            min_edit_dist_topleft\n                        } else {\n                            // one new mismatch\n                            min_edit_dist_topleft.saturating_add(1)\n                        },\n                        // gap or hop in y (no new mismatch)\n                        min_edit_dist_left.saturating_add(1),\n                        // gap or hop in x (no new mismatch)\n                        min_edit_dist_top.saturating_add(1),\n                    )\n                };\n\n                if free_end_gap_x {\n                    // Cache column probabilities or simply record the last probability.\n                    // We can put all of them in one array since we simply have to sum in the end.\n                    // This is also good for numerical stability.\n                    prob_cols.extend(MATCH_STATES.iter().map(|\u0026s| v[curr][s][len_y]));\n                    prob_cols.extend(HOP_Y_STATES.iter().map(|\u0026s| v[curr][s][len_y]));\n                    prob_cols.extend(HOP_X_STATES.iter().map(|\u0026s| v[curr][s][len_y]));\n                    prob_cols.push(v[curr][GapY][len_y]);\n                    // TODO check removing this (we don't want open gaps in x):\n                    prob_cols.push(v[curr][GapX][len_y]);\n                }\n            }\n            mem::swap(\u0026mut prev, \u0026mut curr);\n            for \u0026s in \u0026MATCH_STATES {\n                v[curr][s].reset(LogProb::zero());\n            }\n        }\n        let p = if free_end_gap_x {\n            LogProb::ln_sum_exp(\u0026prob_cols.iter().cloned().collect_vec())\n        } else {\n            LogProb::ln_sum_exp(\n                \u0026STATES\n                    .iter()\n                    .map(|\u0026state| v[prev][state][len_y])\n                    .collect_vec(),\n            )\n        };\n        // take the minimum with 1.0, because sum of paths can exceed probability 1.0\n        // especially in case of repeats\n        assert!(!p.is_nan());\n        if p \u003e LogProb::ln_one() {\n            LogProb::ln_one()\n        } else {\n            p\n        }\n    }\n}\n\n// explicitly defined groups of transitions between states\nconst MATCH_HOP_X: [(State, State); 4] = [\n    (MatchA, HopAX),\n    (MatchC, HopCX),\n    (MatchG, HopGX),\n    (MatchT, HopTX),\n];\nconst MATCH_HOP_Y: [(State, State); 4] = [\n    (MatchA, HopAY),\n    (MatchC, HopCY),\n    (MatchG, HopGY),\n    (MatchT, HopTY),\n];\nconst HOP_X_HOP_X: [(State, State); 4] = [\n    (HopAX, HopAX),\n    (HopCX, HopCX),\n    (HopGX, HopGX),\n    (HopTX, HopTX),\n];\nconst HOP_Y_HOP_Y: [(State, State); 4] = [\n    (HopAY, HopAY),\n    (HopCY, HopCY),\n    (HopGY, HopGY),\n    (HopTY, HopTY),\n];\nconst HOP_X_MATCH: [(State, State); 16] = [\n    (HopAX, MatchA),\n    (HopAX, MatchC),\n    (HopAX, MatchG),\n    (HopAX, MatchT),\n    (HopCX, MatchC),\n    (HopCX, MatchC),\n    (HopCX, MatchG),\n    (HopCX, MatchT),\n    (HopGX, MatchG),\n    (HopGX, MatchC),\n    (HopGX, MatchG),\n    (HopGX, MatchT),\n    (HopTX, MatchT),\n    (HopTX, MatchC),\n    (HopTX, MatchG),\n    (HopTX, MatchT),\n];\nconst HOP_Y_MATCH: [(State, State); 16] = [\n    (HopAY, MatchA),\n    (HopAY, MatchC),\n    (HopAY, MatchG),\n    (HopAY, MatchT),\n    (HopCY, MatchC),\n    (HopCY, MatchC),\n    (HopCY, MatchG),\n    (HopCY, MatchT),\n    (HopGY, MatchG),\n    (HopGY, MatchC),\n    (HopGY, MatchG),\n    (HopGY, MatchT),\n    (HopTY, MatchT),\n    (HopTY, MatchC),\n    (HopTY, MatchG),\n    (HopTY, MatchT),\n];\nconst MATCH_SAME_: [(State, State); 4] = [\n    (MatchA, MatchA),\n    (MatchC, MatchC),\n    (MatchG, MatchG),\n    (MatchT, MatchT),\n];\nconst MATCH_OTHER: [(State, State); 12] = [\n    (MatchA, MatchC),\n    (MatchA, MatchG),\n    (MatchA, MatchT),\n    (MatchC, MatchA),\n    (MatchC, MatchG),\n    (MatchC, MatchT),\n    (MatchG, MatchC),\n    (MatchG, MatchA),\n    (MatchG, MatchT),\n    (MatchT, MatchC),\n    (MatchT, MatchG),\n    (MatchT, MatchA),\n];\n\nfn build_transition_table\u003cG: GapParameters, H: HopParameters\u003e(\n    gap_params: \u0026G,\n    hop_params: \u0026H,\n) -\u003e HashMap\u003cusize, LogProb\u003e {\n    let mut transition_probs = HashMap::new();\n\n    let prob_hop_x = hop_params.prob_hop_x();\n    let prob_hop_y = hop_params.prob_hop_y();\n    let prob_hop_x_extend = hop_params.prob_hop_x_extend();\n    let prob_hop_y_extend = hop_params.prob_hop_y_extend();\n\n    let prob_gap_x = gap_params.prob_gap_x();\n    let prob_gap_y = gap_params.prob_gap_y();\n    let prob_gap_x_extend = gap_params.prob_gap_x_extend();\n    let prob_gap_y_extend = gap_params.prob_gap_y_extend();\n\n    MATCH_HOP_X.iter().for_each(|(a, b)| {\n        transition_probs.insert(*a \u003e\u003e *b, prob_hop_x);\n    });\n    MATCH_HOP_Y.iter().for_each(|(a, b)| {\n        transition_probs.insert(*a \u003e\u003e *b, prob_hop_y);\n    });\n    HOP_X_HOP_X.iter().for_each(|(a, b)| {\n        transition_probs.insert(*a \u003e\u003e *b, prob_hop_x_extend);\n    });\n    HOP_Y_HOP_Y.iter().for_each(|(a, b)| {\n        transition_probs.insert(*a \u003e\u003e *b, prob_hop_y_extend);\n    });\n    HOP_X_MATCH.iter().for_each(|(a, b)| {\n        transition_probs.insert(*a \u003e\u003e *b, prob_hop_x_extend.ln_one_minus_exp());\n    });\n    HOP_Y_MATCH.iter().for_each(|(a, b)| {\n        transition_probs.insert(*a \u003e\u003e *b, prob_hop_y_extend.ln_one_minus_exp());\n    });\n\n    let match_same =\n        LogProb::ln_sum_exp(\u0026[prob_gap_y, prob_gap_x, prob_hop_x, prob_hop_y]).ln_one_minus_exp();\n    let match_other =\n        LogProb::ln_sum_exp(\u0026[prob_gap_y, prob_gap_x, prob_hop_x, prob_hop_y]).ln_one_minus_exp();\n    MATCH_SAME_.iter().for_each(|(a, b)| {\n        transition_probs.insert(*a \u003e\u003e *b, match_same);\n    });\n    MATCH_OTHER.iter().for_each(|(a, b)| {\n        transition_probs.insert(*a \u003e\u003e *b, match_other);\n    });\n\n    MATCH_STATES.iter().for_each(|\u0026a| {\n        transition_probs.insert(a \u003e\u003e GapX, prob_gap_y);\n    });\n    MATCH_STATES.iter().for_each(|\u0026a| {\n        transition_probs.insert(a \u003e\u003e GapY, prob_gap_x);\n    });\n    MATCH_STATES.iter().for_each(|\u0026b| {\n        transition_probs.insert(GapX \u003e\u003e b, prob_gap_y_extend.ln_one_minus_exp());\n    });\n    MATCH_STATES.iter().for_each(|\u0026b| {\n        transition_probs.insert(GapY \u003e\u003e b, prob_gap_x_extend.ln_one_minus_exp());\n    });\n    transition_probs.insert(GapX \u003e\u003e GapX, prob_gap_y_extend);\n    transition_probs.insert(GapY \u003e\u003e GapY, prob_gap_x_extend);\n    transition_probs\n}\n\ntrait Reset\u003cT: Copy\u003e {\n    fn reset(\u0026mut self, value: T);\n}\n\nimpl\u003cT: Copy\u003e Reset\u003cT\u003e for [T] {\n    fn reset(\u0026mut self, value: T) {\n        for v in self {\n            *v = value;\n        }\n    }\n}\n\nfn min3\u003cT: Ord\u003e(a: T, b: T, c: T) -\u003e T {\n    cmp::min(a, cmp::min(b, c))\n}\n\n#[cfg(test)]\nmod tests {\n    use std::iter::repeat;\n\n    use crate::stats::pairhmm::homopolypairhmm::tests::AlignmentMode::{Global, Semiglobal};\n    use crate::stats::pairhmm::PairHMM;\n    use crate::stats::{LogProb, Prob};\n\n    use super::*;\n\n    // Single base insertion and deletion rates for R1 according to Schirmer et al.\n    // BMC Bioinformatics 2016, 10.1186/s12859-016-0976-y\n    static PROB_ILLUMINA_INS: Prob = Prob(2.8e-6);\n    static PROB_ILLUMINA_DEL: Prob = Prob(5.1e-6);\n    static PROB_ILLUMINA_SUBST: Prob = Prob(0.0021);\n\n    // log(0.0021)\n    const PROB_SUBSTITUTION: LogProb = LogProb(-6.165_817_934_252_76);\n    // log(2.8e-6)\n    const PROB_OPEN_GAP_Y: LogProb = LogProb(-12.785_891_140_783_116);\n    // log(5.1e-6)\n    const PROB_OPEN_GAP_X: LogProb = LogProb(-12.186_270_018_233_994);\n\n    const EMIT_MATCH: LogProb = LogProb(-0.0021022080918701985);\n    const EMIT_GAP_AND_Y: LogProb = LogProb(-0.0021022080918701985);\n    const EMIT_X_AND_GAP: LogProb = LogProb(-0.0021022080918701985);\n\n    const T_MATCH_TO_HOP_X: LogProb = LogProb(-11.512925464970229);\n    const T_MATCH_TO_HOP_Y: LogProb = LogProb(-11.512925464970229);\n    const T_HOP_X_TO_HOP_X: LogProb = LogProb(-2.3025850929940455);\n    const T_HOP_Y_TO_HOP_Y: LogProb = LogProb(-2.3025850929940455);\n\n    const T_MATCH_TO_MATCH: LogProb = LogProb(-7.900_031_205_113_962e-6);\n    const T_MATCH_TO_GAP_Y: LogProb = LogProb(-12.785_891_140_783_116);\n    const T_MATCH_TO_GAP_X: LogProb = LogProb(-12.186_270_018_233_994);\n    const T_GAP_TO_GAP: LogProb = LogProb(-9.210340371976182);\n\n    pub enum AlignmentMode {\n        Global,\n        Semiglobal,\n    }\n\n    impl StartEndGapParameters for AlignmentMode {\n        fn free_start_gap_x(\u0026self) -\u003e bool {\n            match self {\n                AlignmentMode::Semiglobal =\u003e true,\n                AlignmentMode::Global =\u003e false,\n            }\n        }\n\n        fn free_end_gap_x(\u0026self) -\u003e bool {\n            match self {\n                AlignmentMode::Semiglobal =\u003e true,\n                AlignmentMode::Global =\u003e false,\n            }\n        }\n    }\n\n    struct TestEmissionParams {\n        x: Vec\u003cu8\u003e,\n        y: Vec\u003cu8\u003e,\n    }\n\n    impl EmissionParameters for TestEmissionParams {\n        fn prob_emit_xy(\u0026self, i: usize, j: usize) -\u003e XYEmission {\n            if self.x[i] == self.y[j] {\n                XYEmission::Match(PROB_SUBSTITUTION.ln_one_minus_exp())\n            } else {\n                XYEmission::Mismatch(LogProb::from(PROB_ILLUMINA_SUBST / Prob(3.)))\n            }\n        }\n\n        fn prob_emit_x(\u0026self, _i: usize) -\u003e LogProb {\n            PROB_SUBSTITUTION.ln_one_minus_exp()\n        }\n\n        fn prob_emit_y(\u0026self, _j: usize) -\u003e LogProb {\n            PROB_SUBSTITUTION.ln_one_minus_exp()\n        }\n\n        fn len_x(\u0026self) -\u003e usize {\n            self.x.len()\n        }\n\n        fn len_y(\u0026self) -\u003e usize {\n            self.y.len()\n        }\n    }\n\n    impl Emission for TestEmissionParams {\n        fn emission_x(\u0026self, i: usize) -\u003e u8 {\n            self.x[i]\n        }\n\n        fn emission_y(\u0026self, j: usize) -\u003e u8 {\n            self.y[j]\n        }\n    }\n\n    struct TestSingleGapParams;\n\n    impl GapParameters for TestSingleGapParams {\n        fn prob_gap_x(\u0026self) -\u003e LogProb {\n            PROB_OPEN_GAP_Y\n        }\n\n        fn prob_gap_y(\u0026self) -\u003e LogProb {\n            PROB_OPEN_GAP_X\n        }\n\n        fn prob_gap_x_extend(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n\n        fn prob_gap_y_extend(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n    }\n\n    struct NoGapParams;\n\n    impl GapParameters for NoGapParams {\n        fn prob_gap_x(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n\n        fn prob_gap_y(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n\n        fn prob_gap_x_extend(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n\n        fn prob_gap_y_extend(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n    }\n\n    struct TestExtendGapParams;\n\n    impl GapParameters for TestExtendGapParams {\n        fn prob_gap_x(\u0026self) -\u003e LogProb {\n            LogProb::from(PROB_ILLUMINA_INS)\n        }\n\n        fn prob_gap_y(\u0026self) -\u003e LogProb {\n            LogProb::from(PROB_ILLUMINA_DEL)\n        }\n\n        fn prob_gap_x_extend(\u0026self) -\u003e LogProb {\n            T_GAP_TO_GAP\n        }\n\n        fn prob_gap_y_extend(\u0026self) -\u003e LogProb {\n            T_GAP_TO_GAP\n        }\n    }\n\n    struct TestNoHopParams;\n\n    impl HopParameters for TestNoHopParams {\n        fn prob_hop_x(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n\n        fn prob_hop_y(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n\n        fn prob_hop_x_extend(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n\n        fn prob_hop_y_extend(\u0026self) -\u003e LogProb {\n            LogProb::zero()\n        }\n    }\n\n    struct TestHopParams;\n\n    impl HopParameters for TestHopParams {\n        fn prob_hop_x(\u0026self) -\u003e LogProb {\n            T_MATCH_TO_HOP_X\n        }\n\n        fn prob_hop_y(\u0026self) -\u003e LogProb {\n            T_MATCH_TO_HOP_Y\n        }\n\n        fn prob_hop_x_extend(\u0026self) -\u003e LogProb {\n            T_HOP_X_TO_HOP_X\n        }\n\n        fn prob_hop_y_extend(\u0026self) -\u003e LogProb {\n            T_HOP_Y_TO_HOP_Y\n        }\n    }\n\n    lazy_static! {\n        static ref SINGLE_GAPS_NO_HOPS_PHMM: HomopolyPairHMM =\n            HomopolyPairHMM::new(\u0026SINGLE_GAP_PARAMS, \u0026NO_HOP_PARAMS);\n        static ref EXTEND_GAPS_NO_HOPS_PHMM: HomopolyPairHMM =\n            HomopolyPairHMM::new(\u0026EXTEND_GAP_PARAMS, \u0026NO_HOP_PARAMS);\n        static ref NO_GAPS_WITH_HOPS_PHMM: HomopolyPairHMM =\n            HomopolyPairHMM::new(\u0026NO_GAP_PARAMS, \u0026TestHopParams);\n    }\n\n    #[test]\n    fn impossible_global_alignment() {\n        let x = b\"AAA\".to_vec();\n        let y = b\"A\".to_vec();\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n        assert_eq!(p, LogProb::zero());\n    }\n\n    #[test]\n    fn test_hompolymer_run_in_y() {\n        let pair_hmm = \u0026NO_GAPS_WITH_HOPS_PHMM;\n        for i in 1..5 {\n            let x = b\"ACGT\".to_vec();\n            let y = format!(\"AC{}GT\", repeat(\"C\").take(i).join(\"\"))\n                .as_bytes()\n                .to_vec();\n            let emission_params = TestEmissionParams { x, y };\n\n            let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n            let p_most_likely_path_with_hops = LogProb(\n                *EMIT_MATCH // A A\n                    + *T_MATCH_TO_MATCH\n                    + *EMIT_MATCH // C C\n                    + *T_MATCH_TO_HOP_X // C CC\n                    + *T_HOP_X_TO_HOP_X * ((i - 1) as f64)\n                    + (1. - 0.1f64).ln()\n                    + *EMIT_MATCH // G G\n                    + *T_MATCH_TO_MATCH\n                    + *EMIT_MATCH, // T T\n            );\n            assert!(*p \u003c= 0.0);\n            assert!(*p \u003e= *p_most_likely_path_with_hops);\n            assert!(*p \u003c *p_most_likely_path_with_hops + 1.);\n        }\n    }\n\n    #[test]\n    fn test_hompolymer_run_in_x() {\n        let pair_hmm = \u0026NO_GAPS_WITH_HOPS_PHMM;\n        for i in 1..5 {\n            let x = format!(\"AC{}GT\", repeat(\"C\").take(i).join(\"\"))\n                .as_bytes()\n                .to_vec();\n\n            let y = b\"ACGT\".to_vec();\n\n            let emission_params = TestEmissionParams { x, y };\n\n            let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n            let p_most_likely_path_with_hops = LogProb(\n                *EMIT_MATCH // A A\n                    + *T_MATCH_TO_MATCH\n                    + *EMIT_MATCH // C C\n                    + *T_MATCH_TO_HOP_Y // CC C\n                    + *T_HOP_Y_TO_HOP_Y * ((i - 1) as f64)\n                    + (1. - 0.1f64).ln()\n                    + *EMIT_MATCH // G G\n                    + *T_MATCH_TO_MATCH\n                    + *EMIT_MATCH, // T T\n            );\n            assert!(*p \u003c= 0.0);\n            assert!(*p \u003e= *p_most_likely_path_with_hops);\n            assert!(*p \u003c *p_most_likely_path_with_hops + 1.);\n        }\n    }\n\n    #[test]\n    fn test_interleave_gaps_x() {\n        let x = b\"AGAGAG\".to_vec();\n        let y = b\"ACGTACGTACGT\".to_vec();\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n\n        let n_matches = 6.;\n        let n_insertions = 6.;\n\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH_TO_MATCH * (n_matches - n_insertions)\n                + *EMIT_GAP_AND_Y * n_insertions\n                + *T_MATCH_TO_GAP_X * n_insertions\n                + *(PROB_OPEN_GAP_Y.ln_one_minus_exp()) * n_insertions,\n        );\n\n        let p_max = LogProb(*T_MATCH_TO_GAP_X * n_insertions);\n\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_interleave_gaps_y() {\n        let x = b\"ACGTACGTACGT\".to_vec();\n        let y = b\"AGAGAG\".to_vec();\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n\n        let n_matches = 6.;\n        let n_insertions = 6.;\n\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH_TO_MATCH * (n_matches - n_insertions)\n                + *EMIT_X_AND_GAP * n_insertions\n                + *T_MATCH_TO_GAP_Y * n_insertions\n                + *PROB_OPEN_GAP_X.ln_one_minus_exp() * n_insertions,\n        );\n\n        let p_max = LogProb(*T_MATCH_TO_GAP_Y * n_insertions);\n\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    static SINGLE_GAP_PARAMS: TestSingleGapParams = TestSingleGapParams;\n    static EXTEND_GAP_PARAMS: TestExtendGapParams = TestExtendGapParams;\n    static NO_GAP_PARAMS: NoGapParams = NoGapParams;\n    static NO_HOP_PARAMS: TestNoHopParams = TestNoHopParams;\n\n    #[test]\n    fn test_same() {\n        let x = b\"AGCTCGATCGATCGATC\".to_vec();\n        let y = b\"AGCTCGATCGATCGATC\".to_vec();\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n        let n = 17.;\n        let p_most_likely_path = LogProb(*EMIT_MATCH * n + *T_MATCH_TO_MATCH * (n - 1.));\n        let p_max = LogProb(*EMIT_MATCH * n);\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.001);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.001);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_gap_x() {\n        let x = b\"AGCTCGATCGATCGATC\".to_vec();\n        let y = b\"AGCTCGATCTGATCGATCT\".to_vec();\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n\n        let n_matches = 17.;\n        let n_insertions = 2.;\n\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH_TO_MATCH * (n_matches - n_insertions)\n                + *EMIT_GAP_AND_Y * n_insertions\n                + *T_MATCH_TO_GAP_X * n_insertions\n                + (1. - *PROB_ILLUMINA_INS).ln(),\n        );\n\n        let p_max = LogProb(*T_MATCH_TO_GAP_X * 2.);\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_gap_x_2() {\n        let x = b\"ACAGTA\".to_vec();\n        let y = b\"ACAGTCA\".to_vec();\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n\n        let n_matches = 6.;\n        let n_insertions = 1.;\n\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH_TO_MATCH * (n_matches - n_insertions)\n                + *EMIT_GAP_AND_Y * n_insertions\n                + *T_MATCH_TO_GAP_X * n_insertions\n                + (1. - *PROB_ILLUMINA_INS).ln(),\n        );\n\n        let p_max = LogProb(*T_MATCH_TO_GAP_X * n_insertions);\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_gap_y() {\n        let x = b\"AGCTCGATCTGATCGATCT\".to_vec();\n        let y = b\"AGCTCGATCGATCGATC\".to_vec();\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n\n        let n_matches = 17.;\n        let n_deletions = 2.;\n\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH_TO_MATCH * (n_matches - n_deletions)\n                + *EMIT_X_AND_GAP * n_deletions\n                + *T_MATCH_TO_GAP_Y * n_deletions\n                + (1. - *PROB_ILLUMINA_DEL).ln(),\n        );\n\n        let p_max = LogProb(*T_MATCH_TO_GAP_Y * 2.);\n\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_multigap_y() {\n        let x = b\"AGCTCGATCTGATCGATCT\".to_vec();\n        let y = b\"AGCTTCTGATCGATCT\".to_vec();\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026EXTEND_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n        let n_matches = 16.;\n        let n_consecutive_deletions = 3.;\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH_TO_MATCH * (n_matches - n_consecutive_deletions)\n                + *PROB_OPEN_GAP_Y\n                + *EMIT_X_AND_GAP * n_consecutive_deletions\n                + *T_GAP_TO_GAP * (n_consecutive_deletions - 1.)\n                + *T_GAP_TO_GAP.ln_one_minus_exp(),\n        );\n\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n    }\n\n    #[test]\n    fn test_mismatch() {\n        let x = b\"AGCTCGAGCGATCGATC\".to_vec();\n        let y = b\"TGCTCGATCGATCGATC\".to_vec();\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Global, None);\n\n        let n = 17.;\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * (n - 2.)\n                + *T_MATCH_TO_MATCH * (n - 1.)\n                + (*PROB_ILLUMINA_SUBST / 3.).ln() * 2.,\n        );\n        let p_max = LogProb((*PROB_ILLUMINA_SUBST / 3.).ln() * 2.);\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 1e-2);\n        assert_relative_eq!(*p, *p_max, epsilon = 1e-1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_banded() {\n        let x = b\"GATCACAGGTCTATCACCCTATTAACCACTCACGGGAGCTCTCCATGC\\\nATTTGGTATTTTCGTCTGGGGGGTATGCACGCGATAGCATTGCGAGACGCTGGAGCCGGAGCACCCTATGTCGCAGTAT\\\nCTGTCTTTGATTCCTGCCTCATCCTATTATTTATCGCACCTACGTTCAATATTACAGGCGAACATACTTACTAAAGTGT\"\n            .to_vec();\n\n        let y = b\"GGGTATGCACGCGATAGCATTGCGAGATGCTGGAGCTGGAGCACCCTATGTCGC\".to_vec();\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026Semiglobal, None);\n\n        let p_banded = pair_hmm.prob_related(\u0026emission_params, \u0026Semiglobal, Some(2));\n        assert_relative_eq!(*p, *p_banded, epsilon = 1e-3);\n    }\n\n    #[test]\n    fn test_phmm_vs_phhmm() {\n        let x = b\"AGAGAGC\".to_vec();\n        let y = b\"ATACGTACGTC\".to_vec();\n        let emission_params = TestEmissionParams { x, y };\n\n        let pair_hhmm = \u0026SINGLE_GAPS_NO_HOPS_PHMM;\n        let p1 = pair_hhmm.prob_related(\u0026emission_params, \u0026Global, None);\n\n        struct TestSingleGapParamsPairHMM;\n        impl crate::stats::pairhmm::StartEndGapParameters for TestSingleGapParamsPairHMM {\n            fn free_start_gap_x(\u0026self) -\u003e bool {\n                false\n            }\n\n            fn free_end_gap_x(\u0026self) -\u003e bool {\n                false\n            }\n        }\n        impl crate::stats::pairhmm::GapParameters for TestSingleGapParamsPairHMM {\n            fn prob_gap_x(\u0026self) -\u003e LogProb {\n                LogProb::from(PROB_ILLUMINA_DEL)\n            }\n\n            fn prob_gap_y(\u0026self) -\u003e LogProb {\n                LogProb::from(PROB_ILLUMINA_INS)\n            }\n\n            fn prob_gap_x_extend(\u0026self) -\u003e LogProb {\n                LogProb::zero()\n            }\n\n            fn prob_gap_y_extend(\u0026self) -\u003e LogProb {\n                LogProb::zero()\n            }\n        }\n\n        fn prob_emit_x_or_y() -\u003e LogProb {\n            LogProb::from(Prob(1.0) - PROB_ILLUMINA_SUBST)\n        }\n\n        struct TestEmissionParamsPairHMM {\n            x: \u0026'static [u8],\n            y: \u0026'static [u8],\n        }\n\n        impl crate::stats::pairhmm::EmissionParameters for TestEmissionParamsPairHMM {\n            fn prob_emit_xy(\u0026self, i: usize, j: usize) -\u003e crate::stats::pairhmm::XYEmission {\n                if self.x[i] == self.y[j] {\n                    crate::stats::pairhmm::XYEmission::Match(LogProb::from(\n                        Prob(1.0) - PROB_ILLUMINA_SUBST,\n                    ))\n                } else {\n                    crate::stats::pairhmm::XYEmission::Mismatch(LogProb::from(\n                        PROB_ILLUMINA_SUBST / Prob(3.0),\n                    ))\n                }\n            }\n\n            fn prob_emit_x(\u0026self, _: usize) -\u003e LogProb {\n                prob_emit_x_or_y()\n            }\n\n            fn prob_emit_y(\u0026self, _: usize) -\u003e LogProb {\n                prob_emit_x_or_y()\n            }\n\n            fn len_x(\u0026self) -\u003e usize {\n                self.x.len()\n            }\n\n            fn len_y(\u0026self) -\u003e usize {\n                self.y.len()\n            }\n        }\n\n        let mut pair_hmm = PairHMM::new(\u0026TestSingleGapParamsPairHMM);\n\n        let x = b\"AGAGAGC\";\n        let y = b\"ATACGTACGTC\";\n        let p2 = pair_hmm.prob_related(\n            \u0026TestEmissionParamsPairHMM { x, y },\n            \u0026AlignmentMode::Global,\n            None,\n        );\n        assert_relative_eq!(*p1, *p2, epsilon = 1e-4)\n    }\n}\n","traces":[{"line":106,"address":[7975024],"length":1,"stats":{"Line":0},"fn_name":"supports"},{"line":107,"address":[7975312,7975307,7975227,7975267,7975094],"length":1,"stats":{"Line":0},"fn_name":"shr"},{"line":108,"address":[7975269,7975054,7975100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[7975229,7975117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[7975127,7975189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[7975137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[7975089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[7975312],"length":1,"stats":{"Line":0},"fn_name":"shr"},{"line":133,"address":[7975326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[7975330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[7975334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[7975360],"length":1,"stats":{"Line":0},"fn_name":"space_bits"},{"line":140,"address":[7975368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[7975388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[7975443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[7975498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[7975553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[7975608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[7975680],"length":1,"stats":{"Line":0},"fn_name":"interleave_bits"},{"line":150,"address":[7975696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[8077680,8077744,8077808],"length":1,"stats":{"Line":0},"fn_name":"new\u003cbio::stats::pairhmm::homopolypairhmm::tests::NoGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestHopParams\u003e"},{"line":190,"address":[8077704,8077832,8077768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[8078176,8077872],"length":1,"stats":{"Line":0},"fn_name":"prob_related\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestEmissionParams,bio::stats::pairhmm::homopolypairhmm::tests::AlignmentMode\u003e"},{"line":211,"address":[8077949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[8077977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[8078139,8077989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[8078113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[8078121,8078207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[8078278,8078215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[8078286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[8078583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[8078623,8078686],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[8078695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[8079028,8078815,8079421,8078933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[8079068,8079434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[8079522,8079833,8078992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[8080388,8079930,8080125,8079789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[8080178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[8087592,8080544,8080409,8080053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[8080584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[8080609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[8081329,8080745,8080916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[8080959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[8080880,8081342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[8081452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[8081502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[8081763,8087452,8081532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[8081867,8081803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[8081945,8081838,8081908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[8081986,8081916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[8082096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[8082243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[8082390,8082526,8082467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[8082517,8082449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[8082535,8082485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[8082542],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[8082743,8083712,8082550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[8083898,8083710,8082778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[8082864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[8082942,8082971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[8082925,8082944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[8082976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[8083129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[8083498,8083170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[8083424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[8083341,8083188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[8083253,8088710,8088688],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestEmissionParams,bio::stats::pairhmm::homopolypairhmm::tests::AlignmentMode\u003e"},{"line":282,"address":[8088723,8088953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[8088807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[8082821,8083717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[8084593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[8084519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[8082685,8084436,8083999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[8088976,8083927,8088998],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestEmissionParams,bio::stats::pairhmm::homopolypairhmm::tests::AlignmentMode\u003e"},{"line":297,"address":[8084006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[8084817,8089298,8089264],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestEmissionParams,bio::stats::pairhmm::homopolypairhmm::tests::AlignmentMode\u003e"},{"line":302,"address":[8089337,8089868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[8089609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[8084985,8085732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[8085658],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[8085138,8085001,8085575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[8090048,8090070,8085066],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestEmissionParams,bio::stats::pairhmm::homopolypairhmm::tests::AlignmentMode\u003e"},{"line":311,"address":[8085515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[8085145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[8090370,8085956,8090336],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestEmissionParams,bio::stats::pairhmm::homopolypairhmm::tests::AlignmentMode\u003e"},{"line":318,"address":[8090940,8090409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[8090681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[8086108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[8086416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[8086154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[8086240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[8086324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[8087450,8086588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[8086599,8091139,8091120],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestEmissionParams,bio::stats::pairhmm::homopolypairhmm::tests::AlignmentMode\u003e"},{"line":344,"address":[8091312,8091331,8086750],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestEmissionParams,bio::stats::pairhmm::homopolypairhmm::tests::AlignmentMode\u003e"},{"line":345,"address":[8086901,8091523,8091504],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestEmissionParams,bio::stats::pairhmm::homopolypairhmm::tests::AlignmentMode\u003e"},{"line":346,"address":[8087052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[8087251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[8081733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[8087876,8087457,8087597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[8087640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[8080524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[8088159,8087933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[8087881,8088289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[8091696,8091715,8088233],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestEmissionParams,bio::stats::pairhmm::homopolypairhmm::tests::AlignmentMode\u003e"},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[8088451,8088493,8088191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[8088598,8088480,8088532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[8088600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[8088580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[8094120,8094105,8098600,8094128,8091888,8098585,8096360,8096345,8096368],"length":1,"stats":{"Line":0},"fn_name":"build_transition_table\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestExtendGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":463,"address":[8096426,8091946,8094186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[8096439,8091959,8094199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[8096554,8092001,8094241,8092074,8094314,8096481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[8094323,8096563,8092083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[8096605,8092125,8094365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[8092167,8096647,8094407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[8094449,8096689,8092209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[8096731,8092251,8094491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[8094533,8096773,8092293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[8098722,8098818,8098608,8098800,8092327,8098626,8098704,8094567,8096807],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestExtendGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":476,"address":[8098742,8098646,8098838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[8098914,8094679,8099088,8092439,8099010,8098896,8098992,8096919,8099106],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestSingleGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":479,"address":[8098934,8099030,8099126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[8099184,8099394,8099376,8092551,8099280,8097031,8094791,8099298,8099202],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestExtendGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":482,"address":[8099222,8099318,8099414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[8099664,8099490,8099682,8097143,8099472,8092663,8099568,8099586,8094903],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestSingleGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":485,"address":[8099702,8099510,8099606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[8092775,8099760,8099779,8097255,8100003,8095015,8099872,8099891,8099984],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestExtendGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":488,"address":[8099911,8100023,8099799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[8100227,8100339,8100320,8100115,8100208,8095127,8092887,8100096,8097367],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestExtendGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":491,"address":[8100359,8100135,8100247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[8092999,8097479,8095239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[8097640,8095400,8093160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[8093315,8100432,8097795,8100546,8095555,8100528,8100450,8100624,8100642],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::NoGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestHopParams\u003e"},{"line":499,"address":[8100470,8100662,8100566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[8100930,8100912,8100834,8093415,8100720,8097895,8100738,8095655,8100816],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestSingleGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":502,"address":[8100950,8100854,8100758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[8101029,8101125,8095755,8093515,8101104,8101200,8101008,8101221,8097995],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestExtendGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":506,"address":[8101133,8101229,8101037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[8095855,8101317,8101413,8101509,8101488,8098095,8101392,8093615,8101296],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestSingleGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":509,"address":[8101517,8101421,8101325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[8101584,8093715,8098195,8101808,8101827,8095955,8101603,8101696,8101715],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestExtendGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":512,"address":[8101611,8101723,8101835],"length":1,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[8101920,8102144,8101939,8093815,8102032,8096055,8102163,8102051,8098295],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cbio::stats::pairhmm::homopolypairhmm::tests::TestExtendGapParams,bio::stats::pairhmm::homopolypairhmm::tests::TestNoHopParams\u003e"},{"line":515,"address":[8102171,8101947,8102059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[8098395,8096155,8093915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[8096242,8094002,8098482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[6398000],"length":1,"stats":{"Line":0},"fn_name":"reset\u003cbio::stats::probs::LogProb\u003e"},{"line":528,"address":[6398026,6398133,6398109,6398135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[6398129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[8102256,8102410],"length":1,"stats":{"Line":0},"fn_name":"min3\u003cusize\u003e"},{"line":535,"address":[8102422,8102309,8102424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[6319104],"length":1,"stats":{"Line":0},"fn_name":"free_start_gap_x"},{"line":582,"address":[6319131,6319124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[6319133,6319113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[6319126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[6319152],"length":1,"stats":{"Line":0},"fn_name":"free_end_gap_x"},{"line":589,"address":[6319172,6319179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[6319181,6319161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[6319174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[6319200],"length":1,"stats":{"Line":0},"fn_name":"prob_emit_xy"},{"line":603,"address":[6319229,6319437,6319439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[6319344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[6319405,6319303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[6319440],"length":1,"stats":{"Line":0},"fn_name":"prob_emit_x"},{"line":611,"address":[6319454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[6319488],"length":1,"stats":{"Line":0},"fn_name":"prob_emit_y"},{"line":615,"address":[6319502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[6319536],"length":1,"stats":{"Line":0},"fn_name":"len_x"},{"line":619,"address":[6319545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[6319568],"length":1,"stats":{"Line":0},"fn_name":"len_y"},{"line":623,"address":[6319577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[6319616],"length":1,"stats":{"Line":0},"fn_name":"emission_x"},{"line":629,"address":[6319630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":632,"address":[6319664],"length":1,"stats":{"Line":0},"fn_name":"emission_y"},{"line":633,"address":[6319678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[6319712],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_x"},{"line":641,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[6319728],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_y"},{"line":645,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[6319744],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_x_extend"},{"line":649,"address":[6319753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":652,"address":[6319776],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_y_extend"},{"line":653,"address":[6319785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[6319808],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_x"},{"line":661,"address":[6319817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[6319840],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_y"},{"line":665,"address":[6319849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[6319872],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_x_extend"},{"line":669,"address":[6319881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":672,"address":[6319904],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_y_extend"},{"line":673,"address":[6319913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[6319936],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_x"},{"line":681,"address":[6319945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[6319984],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_y"},{"line":685,"address":[6319993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[6320032],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_x_extend"},{"line":689,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[6320048],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_y_extend"},{"line":693,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":700,"address":[6320064],"length":1,"stats":{"Line":0},"fn_name":"prob_hop_x"},{"line":701,"address":[6320073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[6320096],"length":1,"stats":{"Line":0},"fn_name":"prob_hop_y"},{"line":705,"address":[6320105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[6320128],"length":1,"stats":{"Line":0},"fn_name":"prob_hop_x_extend"},{"line":709,"address":[6320137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":712,"address":[6320160],"length":1,"stats":{"Line":0},"fn_name":"prob_hop_y_extend"},{"line":713,"address":[6320169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[6320192],"length":1,"stats":{"Line":0},"fn_name":"prob_hop_x"},{"line":721,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":724,"address":[6320208],"length":1,"stats":{"Line":0},"fn_name":"prob_hop_y"},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":728,"address":[6320224],"length":1,"stats":{"Line":0},"fn_name":"prob_hop_x_extend"},{"line":729,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":732,"address":[6320240],"length":1,"stats":{"Line":0},"fn_name":"prob_hop_y_extend"},{"line":733,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":739,"address":[5501995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":741,"address":[5518875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[5502555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":747,"address":[6320736,6321310],"length":1,"stats":{"Line":0},"fn_name":"impossible_global_alignment"},{"line":748,"address":[6320743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":749,"address":[6320782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":750,"address":[6320810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":752,"address":[6320925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[6321001,6320940,6321094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":754,"address":[6321248,6321103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":758,"address":[6321344,6323514],"length":1,"stats":{"Line":0},"fn_name":"test_hompolymer_run_in_y"},{"line":759,"address":[6321351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[6321536,6321382,6323490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":761,"address":[6321576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":762,"address":[6321731,6321610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":765,"address":[6322208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":767,"address":[6322426,6322531,6322352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":769,"address":[6323121,6322750,6322980,6323074,6323027,6322905,6322691,6322540,6322632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":770,"address":[6322586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":771,"address":[6322645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":772,"address":[6322704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":773,"address":[6322763,6322936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":774,"address":[6322923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":775,"address":[6322990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":776,"address":[6323037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[6323084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":779,"address":[6323142,6323201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":780,"address":[6323186,6323239,6323319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":781,"address":[6323304,6323441,6323357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[6323552,6324107],"length":1,"stats":{"Line":0},"fn_name":"test_hompolymer_run_in_x"},{"line":787,"address":[6323559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":788,"address":[6323582,6323736,6325624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":789,"address":[6324122,6323776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":793,"address":[6324332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[6324404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[6324540,6324681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[6325218,6325124,6325171,6324841,6325049,6324690,6325265,6324782,6324900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":800,"address":[6324736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[6324795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[6324854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[6324913,6325080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":804,"address":[6325067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":805,"address":[6325134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":806,"address":[6325181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[6325228],"length":1,"stats":{"Line":0},"fn_name":null},{"line":809,"address":[6325345,6325286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":810,"address":[6325330,6325383,6325463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":811,"address":[6325583,6325448,6325501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[6325648,6329076],"length":1,"stats":{"Line":0},"fn_name":"test_interleave_gaps_x"},{"line":817,"address":[6325662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[6325704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":820,"address":[6325735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":822,"address":[6325871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[6326058,6325886,6325953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":825,"address":[6326077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[6326085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":829,"address":[6326346,6326275,6326093,6326204,6326459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":830,"address":[6326151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":831,"address":[6326217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":832,"address":[6326288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":833,"address":[6326359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":836,"address":[6326472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":838,"address":[6326606,6326538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[6326588,6326646,6326904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":840,"address":[6327834,6326883,6328092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[6329020,6328944,6328071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":845,"address":[6332548,6329120],"length":1,"stats":{"Line":0},"fn_name":"test_interleave_gaps_y"},{"line":846,"address":[6329134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":847,"address":[6329176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":849,"address":[6329207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[6329343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":852,"address":[6329530,6329425,6329358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":854,"address":[6329549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":855,"address":[6329557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":858,"address":[6329676,6329747,6329818,6329565,6329931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":859,"address":[6329623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":860,"address":[6329689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":861,"address":[6329760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":862,"address":[6329831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":865,"address":[6329944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":867,"address":[6330010,6330078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":868,"address":[6330060,6330376,6330118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":869,"address":[6331306,6331564,6330355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":870,"address":[6331543,6332492,6332416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":879,"address":[6335754,6332592],"length":1,"stats":{"Line":0},"fn_name":"test_same"},{"line":880,"address":[6332606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":881,"address":[6332648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":882,"address":[6332679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":884,"address":[6332815],"length":1,"stats":{"Line":0},"fn_name":null},{"line":885,"address":[6332830,6333002,6332897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":886,"address":[6333021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":887,"address":[6333029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":888,"address":[6333158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":889,"address":[6333292,6333224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":890,"address":[6333274,6333590,6333332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":891,"address":[6334520,6334778,6333569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":892,"address":[6335698,6335624,6334757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":896,"address":[6335792,6339194],"length":1,"stats":{"Line":0},"fn_name":"test_gap_x"},{"line":897,"address":[6335806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":898,"address":[6335848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":899,"address":[6335879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":901,"address":[6336015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":902,"address":[6336097,6336202,6336030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":904,"address":[6336221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":905,"address":[6336239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":908,"address":[6336363,6336426,6336247,6336489,6336585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":909,"address":[6336305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":910,"address":[6336376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":911,"address":[6336439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":912,"address":[6336502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":915,"address":[6336598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":916,"address":[6336724,6336656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":917,"address":[6337022,6336706,6336764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":918,"address":[6338210,6337952,6337001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":919,"address":[6339062,6338189,6339138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":923,"address":[6339232,6342622],"length":1,"stats":{"Line":0},"fn_name":"test_gap_x_2"},{"line":924,"address":[6339246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":925,"address":[6339288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":926,"address":[6339319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":928,"address":[6339455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":929,"address":[6339470,6339537,6339642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":931,"address":[6339661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":932,"address":[6339679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":935,"address":[6339803,6339687,6339921,6339862,6340017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":936,"address":[6339745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":937,"address":[6339816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":938,"address":[6339875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":939,"address":[6339934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":942,"address":[6340030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":943,"address":[6340152,6340084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":944,"address":[6340450,6340192,6340134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":945,"address":[6340429,6341638,6341380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":946,"address":[6342566,6341617,6342490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":950,"address":[6346058,6342656],"length":1,"stats":{"Line":0},"fn_name":"test_gap_y"},{"line":951,"address":[6342670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":952,"address":[6342712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":953,"address":[6342743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":955,"address":[6342879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":956,"address":[6342894,6342961,6343066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":958,"address":[6343085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":959,"address":[6343103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":962,"address":[6343353,6343290,6343111,6343227,6343449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":963,"address":[6343169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":964,"address":[6343240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":965,"address":[6343303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":966,"address":[6343366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":969,"address":[6343462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":971,"address":[6343520,6343588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":972,"address":[6343628,6343886,6343570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":973,"address":[6344816,6345074,6343865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":974,"address":[6345053,6345926,6346002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":978,"address":[6348192,6346096],"length":1,"stats":{"Line":0},"fn_name":"test_multigap_y"},{"line":979,"address":[6346110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":980,"address":[6346152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":981,"address":[6346183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":983,"address":[6346319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":984,"address":[6346401,6346334,6346506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":985,"address":[6346525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":986,"address":[6346543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":988,"address":[6346667,6346860,6346551,6346961,6346726,6346797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":989,"address":[6346609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":990,"address":[6346680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":991,"address":[6346739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":992,"address":[6346810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":993,"address":[6346873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":996,"address":[6347050,6346982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":997,"address":[6347337,6347090,6347032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1001,"address":[6351515,6348224],"length":1,"stats":{"Line":0},"fn_name":"test_mismatch"},{"line":1002,"address":[6348238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1003,"address":[6348280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1004,"address":[6348311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1006,"address":[6348447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1007,"address":[6348634,6348462,6348529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1009,"address":[6348653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1011,"address":[6348661,6348877,6348777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1012,"address":[6348719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1013,"address":[6348790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1015,"address":[6348890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1016,"address":[6348985,6349053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1017,"address":[6349035,6349351,6349093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1018,"address":[6350539,6349330,6350281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1019,"address":[6350518,6351459,6351385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1023,"address":[6351552,6353220],"length":1,"stats":{"Line":0},"fn_name":"test_banded"},{"line":1024,"address":[6351566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1029,"address":[6351608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1031,"address":[6351639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1033,"address":[6351775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1034,"address":[6351962,6351790,6351857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1036,"address":[6351971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1037,"address":[6352101,6352374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1041,"address":[6353264,6355050],"length":1,"stats":{"Line":0},"fn_name":"test_phmm_vs_phhmm"},{"line":1042,"address":[6353278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1043,"address":[6353320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1044,"address":[6353351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1046,"address":[6353487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1047,"address":[6353674,6353502,6353569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1051,"address":[6355088],"length":1,"stats":{"Line":0},"fn_name":"free_start_gap_x"},{"line":1052,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1055,"address":[6355104],"length":1,"stats":{"Line":0},"fn_name":"free_end_gap_x"},{"line":1056,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1060,"address":[6355120],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_x"},{"line":1061,"address":[6355129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1064,"address":[6355168],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_y"},{"line":1065,"address":[6355177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1068,"address":[6355216],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_x_extend"},{"line":1069,"address":[6355225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1072,"address":[6355248],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_y_extend"},{"line":1073,"address":[6355257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1077,"address":[6355280],"length":1,"stats":{"Line":0},"fn_name":"prob_emit_x_or_y"},{"line":1078,"address":[6355284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1087,"address":[6355360],"length":1,"stats":{"Line":0},"fn_name":"prob_emit_xy"},{"line":1088,"address":[6355723,6355721,6355400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1089,"address":[6355634],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1090,"address":[6355589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1093,"address":[6355691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1094,"address":[6355548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1099,"address":[6355728],"length":1,"stats":{"Line":0},"fn_name":"prob_emit_x"},{"line":1100,"address":[6355742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1103,"address":[6355776],"length":1,"stats":{"Line":0},"fn_name":"prob_emit_y"},{"line":1104,"address":[6355790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1107,"address":[6355824],"length":1,"stats":{"Line":0},"fn_name":"len_x"},{"line":1108,"address":[6355836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1111,"address":[6355872],"length":1,"stats":{"Line":0},"fn_name":"len_y"},{"line":1112,"address":[6355884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1116,"address":[6353683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1118,"address":[6353705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1119,"address":[6353720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1120,"address":[6353787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1121,"address":[6353735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1123,"address":[6353775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1125,"address":[6353934,6354181,6353868],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":460},{"path":["/","home","todd","rust-bio","src","stats","pairhmm","mod.rs"],"content":"//! This module contains the implementation of a classic `PairHMM` as described in\n//! Durbin, R., Eddy, S., Krogh, A., \u0026 Mitchison, G. (1998). Biological Sequence Analysis.\n//! Current Topics in Genome Analysis 2008. http://doi.org/10.1017/CBO9780511790492.\n//! It also contains a modified variant `HomopolyPairHMM` with additional homopolymer states suited\n//! for dealing with homopolymer runs in sequencing as often encountered in Oxford Nanopore\n//! sequencing data.\n//!\n//! Traits defined in this module apply to both `PairHMM` and `HomopolyPairHMM`.\n//!\n//! # Examples\n//! ```\n//! use approx::assert_relative_eq;\n//! use bio::stats::pairhmm::{\n//!     EmissionParameters, GapParameters, PairHMM, StartEndGapParameters, XYEmission,\n//! };\n//! use bio::stats::{LogProb, Prob};\n//! use num_traits::Zero;\n//!\n//! // Two sequences for which we'd like to know if they are likely related.\n//! let x = b\"AAAA\";\n//! let y = b\"AAAT\";\n//!\n//! // For this example, we disallow gaps, so all probabilities are zero here.\n//! struct GapParams;\n//! impl GapParameters for GapParams {\n//!     fn prob_gap_x(\u0026self) -\u003e LogProb {\n//!         LogProb::zero()\n//!     }\n//!     fn prob_gap_y(\u0026self) -\u003e LogProb {\n//!         LogProb::zero()\n//!     }\n//!     fn prob_gap_x_extend(\u0026self) -\u003e LogProb {\n//!         LogProb::zero()\n//!     }\n//!     fn prob_gap_y_extend(\u0026self) -\u003e LogProb {\n//!         LogProb::zero()\n//!     }\n//! }\n//! let gap_params = GapParams;\n//!\n//! // The PairHMM instance stores the gap params, since these are constant.\n//! let mut pairhmm = PairHMM::new(\u0026gap_params);\n//!\n//! // However, emission parameters depend on the actual sequences\n//! struct EmissionParams {\n//!     x: \u0026'static [u8],\n//!     y: \u0026'static [u8],\n//! }\n//!\n//! const PROB_SUBSTITUTION: f64 = 0.1;\n//! const PROB_NO_SUBSTITUION: f64 = 1. - PROB_SUBSTITUTION;\n//! impl EmissionParameters for EmissionParams {\n//!     fn prob_emit_xy(\u0026self, i: usize, j: usize) -\u003e XYEmission {\n//!         if self.x[i] == self.y[j] {\n//!             // if two bases match, emit a Match!\n//!             XYEmission::Match(LogProb::from(Prob(PROB_NO_SUBSTITUION)))\n//!         } else {\n//!             // otherwise emit a Mismatch!\n//!             // Note that the probability here is `mismatch / 3`, since probabilities should sum\n//!             // to 1 and there are 3 possible mismatch configurations\n//!             XYEmission::Mismatch(LogProb::from(Prob(PROB_SUBSTITUTION / 3.)))\n//!         }\n//!     }\n//!\n//!     // In this example, emitting x[i] is as likely as not observing a mismatch.\n//!     // In more complex cases, this might e.g. depend on base qualities reported by the sequencer\n//!     fn prob_emit_x(\u0026self, i: usize) -\u003e LogProb {\n//!         LogProb::from(Prob(PROB_NO_SUBSTITUION))\n//!     }\n//!     fn prob_emit_y(\u0026self, j: usize) -\u003e LogProb {\n//!         LogProb::from(Prob(PROB_NO_SUBSTITUION))\n//!     }\n//!\n//!     fn len_x(\u0026self) -\u003e usize {\n//!         self.x.len()\n//!     }\n//!     fn len_y(\u0026self) -\u003e usize {\n//!         self.y.len()\n//!     }\n//! }\n//!\n//! // Since we want to do global alignment here, disallow free start and end gaps in x.\n//! struct GlobalAlignmentMode;\n//! impl StartEndGapParameters for GlobalAlignmentMode {\n//!     fn free_start_gap_x(\u0026self) -\u003e bool {\n//!         false\n//!     }\n//!     fn free_end_gap_x(\u0026self) -\u003e bool {\n//!         false\n//!     }\n//! }\n//!\n//! // Finally calculate the probability of relatedness between x and y!\n//! let prob_related = pairhmm.prob_related(\u0026EmissionParams { x, y }, \u0026GlobalAlignmentMode, None);\n//!\n//! // … and compare it to a rough estimation\n//! let prob_expected = LogProb::from(Prob(PROB_NO_SUBSTITUION.powi(3) * PROB_SUBSTITUTION / 3.));\n//! assert_relative_eq!(*prob_related, *prob_expected, epsilon = 1e-5);\n//! ```\npub use homopolypairhmm::{HomopolyPairHMM, HopParameters};\npub use pairhmm::PairHMM;\n\nuse crate::stats::LogProb;\n\nmod homopolypairhmm;\nmod pairhmm;\n\n// traits common to pairhmm implementations\n\n/// Trait for parametrization of `PairHMM` emission behavior.\npub trait EmissionParameters {\n    /// Emission probability for `(x[i], y[j])`.\n    /// Returns a tuple with probability and a boolean indicating whether emissions match\n    /// (e.g., are the same DNA alphabet letter).\n    fn prob_emit_xy(\u0026self, i: usize, j: usize) -\u003e XYEmission;\n\n    /// Emission probability for `(x[i], -)`.\n    fn prob_emit_x(\u0026self, i: usize) -\u003e LogProb;\n\n    /// Emission probability for `(-, y[j])`.\n    fn prob_emit_y(\u0026self, j: usize) -\u003e LogProb;\n\n    fn len_x(\u0026self) -\u003e usize;\n\n    fn len_y(\u0026self) -\u003e usize;\n}\n/// Trait needed for the `HomopolyPairHMM`, because its implementation details\n/// depend on the actual bases to distinguish between Match states.\npub trait Emission {\n    /// Base emitted at `i` in sequence `x`.\n    /// Should be one of b'A', b'C', b'G' or b'T'.\n    fn emission_x(\u0026self, i: usize) -\u003e u8;\n    /// Base emitted at `i` in sequence `y`.\n    /// Should be one of b'A', b'C', b'G' or b'T'.\n    fn emission_y(\u0026self, j: usize) -\u003e u8;\n}\n\n/// Trait for parametrization of `PairHMM` gap behavior.\npub trait GapParameters {\n    /// Probability to open gap in x.\n    fn prob_gap_x(\u0026self) -\u003e LogProb;\n\n    /// Probability to open gap in y.\n    fn prob_gap_y(\u0026self) -\u003e LogProb;\n\n    /// Probability to extend gap in x.\n    fn prob_gap_x_extend(\u0026self) -\u003e LogProb;\n\n    /// Probability to extend gap in y.\n    fn prob_gap_y_extend(\u0026self) -\u003e LogProb;\n}\n\n/// Trait for parametrization of `PairHMM` start and end gap behavior.\n/// This trait can be used to implement global and semiglobal alignments.\n///\n/// * global: methods return `false` and `LogProb::ln_zero()`.\n/// * semiglobal: methods return `true` and `LogProb::ln_one()`.\npub trait StartEndGapParameters {\n    /// Probability to start at `x[i]`. This can be left unchanged if you use `free_start_gap_x` and\n    /// `free_end_gap_x`.\n    #[inline]\n    #[allow(unused_variables)]\n    fn prob_start_gap_x(\u0026self, i: usize) -\u003e LogProb {\n        if self.free_start_gap_x() {\n            LogProb::ln_one()\n        } else {\n            // For global alignment, this has to return 0.0.\n            LogProb::ln_zero()\n        }\n    }\n\n    /// Allow free start gap in x.\n    fn free_start_gap_x(\u0026self) -\u003e bool;\n\n    /// Allow free end gap in x.\n    fn free_end_gap_x(\u0026self) -\u003e bool;\n}\n\n#[derive(Debug)]\npub enum XYEmission {\n    Match(LogProb),\n    Mismatch(LogProb),\n}\n\nimpl XYEmission {\n    pub fn prob(\u0026self) -\u003e LogProb {\n        match *self {\n            XYEmission::Match(p) =\u003e p,\n            XYEmission::Mismatch(p) =\u003e p,\n        }\n    }\n\n    pub fn is_match(\u0026self) -\u003e bool {\n        match *self {\n            XYEmission::Match(_) =\u003e true,\n            XYEmission::Mismatch(_) =\u003e false,\n        }\n    }\n}\n","traces":[{"line":163,"address":[4935664,4935744],"length":1,"stats":{"Line":0},"fn_name":"prob_start_gap_x\u003cbio::stats::pairhmm::pairhmm::tests::TestSingleGapParams\u003e"},{"line":164,"address":[4935678,4935758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[4935790,4935710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[7729329,7729409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[5948896],"length":1,"stats":{"Line":0},"fn_name":"prob"},{"line":187,"address":[5948944,5948921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[5948927,5948909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[5948950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[5948992],"length":1,"stats":{"Line":0},"fn_name":"is_match"},{"line":194,"address":[5949013,5949020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[5949015,5949001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[5949022],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["/","home","todd","rust-bio","src","stats","pairhmm","pairhmm.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A pair Hidden Markov Model for calculating the probability that two sequences are related to\n//! each other. Depending on the used parameters, this can, e.g., be used to calculate the\n//! probability that a certain sequencing read comes from a given position in a reference genome.\n//!\n//! Time complexity: O(n * m) where `n = seq1.len()`, `m = seq2.len()` (or `m = min(seq2.len(), max_edit_dist)` with banding enabled).\n//! Memory complexity: O(m) where `m = seq2.len()`.\n//! Note that if the number of states weren't fixed in this implementation, we would have to include\n//! these in both time and memory complexity above as an additional factor.\n\nuse std::cmp;\nuse std::mem;\nuse std::usize;\n\npub use crate::stats::pairhmm::{\n    EmissionParameters, GapParameters, StartEndGapParameters, XYEmission,\n};\nuse crate::stats::LogProb;\n\n/// Fast approximation of sum over the three given proabilities. If the largest is sufficiently\n/// large compared to the others, we just return that instead of computing the full (expensive)\n/// sum.\n#[inline]\nfn ln_sum3_exp_approx(mut p0: LogProb, mut p1: LogProb, mut p2: LogProb) -\u003e LogProb {\n    if p1 \u003c p2 {\n        mem::swap(\u0026mut p1, \u0026mut p2);\n    }\n    if p1 \u003e p0 {\n        mem::swap(\u0026mut p1, \u0026mut p0);\n    }\n    if *(p0 - p1) \u003e 10.0 {\n        // if p0 is strong enough compared to second, just return the maximum\n        p0\n    } else {\n        // calculate accurate sum (slower)\n        LogProb::ln_sum_exp(\u0026[p0, p1, p2])\n    }\n}\n\n/// A pair Hidden Markov Model for comparing sequences x and y as described by\n/// Durbin, R., Eddy, S., Krogh, A., \u0026 Mitchison, G. (1998). Biological Sequence Analysis.\n/// Current Topics in Genome Analysis 2008. http://doi.org/10.1017/CBO9780511790492.\n#[derive(Debug, Clone)]\npub struct PairHMM {\n    fm: [Vec\u003cLogProb\u003e; 2],\n    fx: [Vec\u003cLogProb\u003e; 2],\n    fy: [Vec\u003cLogProb\u003e; 2],\n    min_edit_dist: [Vec\u003cusize\u003e; 2],\n    prob_cols: Vec\u003cLogProb\u003e,\n    gap_params: GapParamCache,\n}\n\n#[derive(Debug, Clone)]\nstruct GapParamCache {\n    prob_no_gap: LogProb,\n    prob_no_gap_x_extend: LogProb,\n    prob_no_gap_y_extend: LogProb,\n    prob_gap_x: LogProb,\n    prob_gap_y: LogProb,\n    prob_gap_x_extend: LogProb,\n    prob_gap_y_extend: LogProb,\n    do_gap_x_extend: bool,\n    do_gap_y_extend: bool,\n}\n\nimpl PairHMM {\n    pub fn new\u003cG\u003e(gap_params: \u0026G) -\u003e Self\n    where\n        G: GapParameters,\n    {\n        let gap_params = GapParamCache {\n            prob_no_gap: gap_params\n                .prob_gap_x()\n                .ln_add_exp(gap_params.prob_gap_y())\n                .ln_one_minus_exp(),\n            prob_no_gap_x_extend: gap_params.prob_gap_x_extend().ln_one_minus_exp(),\n            prob_no_gap_y_extend: gap_params.prob_gap_y_extend().ln_one_minus_exp(),\n            prob_gap_x: gap_params.prob_gap_x(),\n            prob_gap_y: gap_params.prob_gap_y(),\n            prob_gap_x_extend: gap_params.prob_gap_x_extend(),\n            prob_gap_y_extend: gap_params.prob_gap_y_extend(),\n            do_gap_y_extend: gap_params.prob_gap_y_extend() != LogProb::ln_zero(),\n            do_gap_x_extend: gap_params.prob_gap_x_extend() != LogProb::ln_zero(),\n        };\n        Self {\n            fm: [Vec::new(), Vec::new()],\n            fx: [Vec::new(), Vec::new()],\n            fy: [Vec::new(), Vec::new()],\n            min_edit_dist: [Vec::new(), Vec::new()],\n            prob_cols: Vec::new(),\n            gap_params,\n        }\n    }\n\n    /// Calculate the probability of sequence x being related to y via any alignment.\n    ///\n    /// # Arguments\n    ///\n    /// * `gap_params` - parameters for opening or extending gaps\n    /// * `emission_params` - parameters for emission\n    /// * `max_edit_dist` - maximum edit distance to consider; if not `None`, perform banded alignment\n    pub fn prob_related\u003cE, A\u003e(\n        \u0026mut self,\n        emission_params: \u0026E,\n        alignment_mode: \u0026A,\n        max_edit_dist: Option\u003cusize\u003e,\n    ) -\u003e LogProb\n    where\n        E: EmissionParameters,\n        A: StartEndGapParameters,\n    {\n        for k in 0..2 {\n            self.fm[k].clear();\n            self.fx[k].clear();\n            self.fy[k].clear();\n            self.min_edit_dist[k].clear();\n            self.prob_cols.clear();\n\n            self.fm[k].resize(emission_params.len_y() + 1, LogProb::ln_zero());\n            self.fx[k].resize(emission_params.len_y() + 1, LogProb::ln_zero());\n            self.fy[k].resize(emission_params.len_y() + 1, LogProb::ln_zero());\n            self.min_edit_dist[k].resize(emission_params.len_y() + 1, usize::MAX);\n\n            if alignment_mode.free_end_gap_x() {\n                let c = (emission_params.len_x() * 3).saturating_sub(self.prob_cols.capacity());\n                self.prob_cols.reserve_exact(c);\n            }\n        }\n\n        let mut prev = 0;\n        let mut curr = 1;\n        self.fm[prev][0] = LogProb::ln_one();\n\n        // iterate over x\n        for i in 0..emission_params.len_x() {\n            // allow alignment to start from offset in x (if prob_start_gap_x is set accordingly)\n            self.fm[prev][0] = self.fm[prev][0].ln_add_exp(alignment_mode.prob_start_gap_x(i));\n            if alignment_mode.free_start_gap_x() {\n                self.min_edit_dist[prev][0] = 0;\n            }\n\n            let prob_emit_x = emission_params.prob_emit_x(i);\n\n            // TODO: in the case of no gap extensions, we can reduce the number of columns of y that need to be looked at (by cone).\n            let (j_min, j_max) = (0, emission_params.len_y());\n\n            // iterate over y\n            for j in j_min..j_max {\n                let j_ = j + 1;\n                let j_minus_one = j_ - 1;\n\n                let min_edit_dist_topleft = self.min_edit_dist[prev][j_minus_one];\n                let min_edit_dist_top = self.min_edit_dist[curr][j_minus_one];\n                let min_edit_dist_left = self.min_edit_dist[prev][j_];\n\n                if let Some(max_edit_dist) = max_edit_dist {\n                    if cmp::min(\n                        min_edit_dist_topleft,\n                        cmp::min(min_edit_dist_top, min_edit_dist_left),\n                    ) \u003e max_edit_dist\n                    {\n                        // skip this cell if best edit dist is already larger than given maximum\n                        continue;\n                    }\n                }\n\n                let (prob_match_mismatch, prob_gap_x, prob_gap_y, min_edit_dist) = {\n                    let fm_curr = \u0026self.fm[curr];\n                    let fm_prev = \u0026self.fm[prev];\n                    let fx_prev = \u0026self.fx[prev];\n                    let fy_curr = \u0026self.fy[curr];\n                    let fy_prev = \u0026self.fy[prev];\n\n                    // match or mismatch\n                    let emit_xy = emission_params.prob_emit_xy(i, j);\n                    let prob_match_mismatch = emit_xy.prob()\n                        + ln_sum3_exp_approx(\n                            self.gap_params.prob_no_gap + fm_prev[j_minus_one],\n                            // coming from state X\n                            self.gap_params.prob_no_gap_x_extend + fx_prev[j_minus_one],\n                            // coming from state Y\n                            self.gap_params.prob_no_gap_y_extend + fy_prev[j_minus_one],\n                        );\n\n                    // gap in y\n                    let mut prob_gap_y = prob_emit_x\n                        + (\n                            // open gap\n                            self.gap_params.prob_gap_y + fm_prev[j_]\n                        );\n                    if self.gap_params.do_gap_y_extend {\n                        prob_gap_y = prob_gap_y.ln_add_exp(\n                            // extend gap\n                            self.gap_params.prob_gap_y_extend + fx_prev[j_],\n                        );\n                    }\n\n                    // gap in x\n                    let mut prob_gap_x = emission_params.prob_emit_y(j)\n                        + (\n                            // open gap\n                            self.gap_params.prob_gap_x + fm_curr[j_minus_one]\n                        );\n                    if self.gap_params.do_gap_x_extend {\n                        prob_gap_x = prob_gap_x.ln_add_exp(\n                            // extend gap\n                            self.gap_params.prob_gap_x_extend + fy_curr[j_minus_one],\n                        );\n                    }\n\n                    // calculate minimal number of mismatches\n                    let min_edit_dist = if max_edit_dist.is_some() {\n                        cmp::min(\n                            if emit_xy.is_match() {\n                                // a match, so nothing changes\n                                min_edit_dist_topleft\n                            } else {\n                                // one new mismatch\n                                min_edit_dist_topleft.saturating_add(1)\n                            },\n                            cmp::min(\n                                // gap in y (no new mismatch)\n                                min_edit_dist_left.saturating_add(1),\n                                // gap in x (no new mismatch)\n                                min_edit_dist_top.saturating_add(1),\n                            ),\n                        )\n                    } else {\n                        0\n                    };\n\n                    (prob_match_mismatch, prob_gap_x, prob_gap_y, min_edit_dist)\n                };\n\n                self.fm[curr][j_] = prob_match_mismatch;\n                self.fx[curr][j_] = prob_gap_y;\n                self.fy[curr][j_] = prob_gap_x;\n                if max_edit_dist.is_some() {\n                    self.min_edit_dist[curr][j_] = min_edit_dist;\n                }\n            }\n\n            if alignment_mode.free_end_gap_x() {\n                // Cache column probabilities or simply record the last probability.\n                // We can put all of them in one array since we simply have to sum in the end.\n                // This is also good for numerical stability.\n                self.prob_cols.push(*self.fm[curr].last().unwrap());\n                self.prob_cols.push(*self.fx[curr].last().unwrap());\n                // TODO check removing this (we don't want open gaps in x):\n                self.prob_cols.push(*self.fy[curr].last().unwrap());\n            }\n\n            // next column\n            mem::swap(\u0026mut curr, \u0026mut prev);\n            // reset next column to zeros\n            for v in \u0026mut self.fm[curr] {\n                *v = LogProb::ln_zero();\n            }\n        }\n\n        let p = if alignment_mode.free_end_gap_x() {\n            LogProb::ln_sum_exp(\u0026self.prob_cols)\n        } else {\n            LogProb::ln_sum_exp(\u0026[\n                *self.fm[prev].last().unwrap(),\n                *self.fx[prev].last().unwrap(),\n                *self.fy[prev].last().unwrap(),\n            ])\n        };\n        // take the minimum with 1.0, because sum of paths can exceed probability 1.0\n        // especially in case of repeats\n        assert!(!p.is_nan());\n        if p \u003e LogProb::ln_one() {\n            LogProb::ln_one()\n        } else {\n            p\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::stats::{LogProb, Prob};\n\n    use super::*;\n\n    // Single base insertion and deletion rates for R1 according to Schirmer et al.\n    // BMC Bioinformatics 2016, 10.1186/s12859-016-0976-y\n    static PROB_ILLUMINA_INS: Prob = Prob(2.8e-6);\n    static PROB_ILLUMINA_DEL: Prob = Prob(5.1e-6);\n    static PROB_ILLUMINA_SUBST: Prob = Prob(0.0021);\n\n    fn prob_emit_x_or_y() -\u003e LogProb {\n        LogProb::from(Prob(1.0) - PROB_ILLUMINA_SUBST)\n    }\n\n    struct TestEmissionParams {\n        x: \u0026'static [u8],\n        y: \u0026'static [u8],\n    }\n\n    impl EmissionParameters for TestEmissionParams {\n        fn prob_emit_xy(\u0026self, i: usize, j: usize) -\u003e XYEmission {\n            if self.x[i] == self.y[j] {\n                XYEmission::Match(LogProb::from(Prob(1.0) - PROB_ILLUMINA_SUBST))\n            } else {\n                XYEmission::Mismatch(LogProb::from(PROB_ILLUMINA_SUBST / Prob(3.0)))\n            }\n        }\n\n        fn prob_emit_x(\u0026self, _: usize) -\u003e LogProb {\n            prob_emit_x_or_y()\n        }\n\n        fn prob_emit_y(\u0026self, _: usize) -\u003e LogProb {\n            prob_emit_x_or_y()\n        }\n\n        fn len_x(\u0026self) -\u003e usize {\n            self.x.len()\n        }\n\n        fn len_y(\u0026self) -\u003e usize {\n            self.y.len()\n        }\n    }\n\n    struct TestSingleGapParams;\n\n    impl GapParameters for TestSingleGapParams {\n        fn prob_gap_x(\u0026self) -\u003e LogProb {\n            LogProb::from(PROB_ILLUMINA_INS)\n        }\n\n        fn prob_gap_y(\u0026self) -\u003e LogProb {\n            LogProb::from(PROB_ILLUMINA_DEL)\n        }\n\n        fn prob_gap_x_extend(\u0026self) -\u003e LogProb {\n            LogProb::ln_zero()\n        }\n\n        fn prob_gap_y_extend(\u0026self) -\u003e LogProb {\n            LogProb::ln_zero()\n        }\n    }\n\n    impl StartEndGapParameters for TestSingleGapParams {\n        fn free_start_gap_x(\u0026self) -\u003e bool {\n            false\n        }\n\n        fn free_end_gap_x(\u0026self) -\u003e bool {\n            false\n        }\n    }\n\n    pub enum AlignmentMode {\n        Global,\n        Semiglobal,\n    }\n\n    impl StartEndGapParameters for AlignmentMode {\n        fn free_start_gap_x(\u0026self) -\u003e bool {\n            match self {\n                AlignmentMode::Semiglobal =\u003e true,\n                AlignmentMode::Global =\u003e false,\n            }\n        }\n\n        fn free_end_gap_x(\u0026self) -\u003e bool {\n            match self {\n                AlignmentMode::Semiglobal =\u003e true,\n                AlignmentMode::Global =\u003e false,\n            }\n        }\n    }\n\n    const EMIT_MATCH: LogProb = LogProb(-0.0021022080918701985);\n    const EMIT_GAP_X: LogProb = LogProb(-0.0021022080918701985);\n    const EMIT_GAP_Y: LogProb = LogProb(-0.0021022080918701985);\n    const T_MATCH: LogProb = LogProb(-7.900_031_205_113_962e-6);\n    const T_GAP_X: LogProb = LogProb(-12.785891140783116);\n    const T_GAP_Y: LogProb = LogProb(-12.186270018233994);\n\n    #[test]\n    fn impossible_global_alignment() {\n        let x = b\"AAA\";\n        let y = b\"A\";\n        let emission_params = TestEmissionParams { x, y };\n\n        let mut pair_hmm = PairHMM::new(\u0026TestSingleGapParams);\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026AlignmentMode::Global, None);\n        assert_eq!(p, LogProb::ln_zero());\n    }\n\n    #[test]\n    fn test_interleave_gaps_y() {\n        let x = b\"ACGTACGTACGT\";\n        let y = b\"AGAGAG\";\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let mut pair_hmm = PairHMM::new(\u0026TestSingleGapParams);\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026AlignmentMode::Global, None);\n\n        let n_matches = 6.;\n        let n_insertions = 6.;\n\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH * (n_matches - n_insertions)\n                + *EMIT_GAP_Y * n_insertions\n                + *T_GAP_Y * n_insertions\n                + (1. - *PROB_ILLUMINA_DEL).ln() * n_insertions,\n        );\n\n        let p_max = LogProb(*T_GAP_Y * n_insertions);\n\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_interleave_gaps_x() {\n        let x = b\"AGAGAG\";\n        let y = b\"ACGTACGTACGT\";\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let mut pair_hmm = PairHMM::new(\u0026TestSingleGapParams);\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026AlignmentMode::Global, None);\n\n        let n_matches = 6.;\n        let n_insertions = 6.;\n\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH * (n_matches - n_insertions)\n                + *EMIT_GAP_X * n_insertions\n                + *T_GAP_X * n_insertions\n                + (1. - *PROB_ILLUMINA_INS).ln() * n_insertions,\n        );\n\n        let p_max = LogProb(*T_GAP_X * n_insertions);\n\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_same() {\n        let x = b\"AGCTCGATCGATCGATC\";\n        let y = b\"AGCTCGATCGATCGATC\";\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let mut pair_hmm = PairHMM::new(\u0026TestSingleGapParams);\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026AlignmentMode::Global, None);\n        let n = x.len() as f64;\n        let p_most_likely_path = LogProb(*EMIT_MATCH * n + *T_MATCH * (n - 1.));\n        let p_max = LogProb(*EMIT_MATCH * n);\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.001);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.001);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_gap_x() {\n        let x = b\"AGCTCGATCGATCGATC\";\n        let y = b\"AGCTCGATCTGATCGATCT\";\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let mut pair_hmm = PairHMM::new(\u0026TestSingleGapParams);\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026AlignmentMode::Global, None);\n\n        let n_matches = 17.;\n        let n_insertions = 2.;\n\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH * (n_matches - n_insertions)\n                + *EMIT_GAP_X * n_insertions\n                + *T_GAP_X * n_insertions\n                + (1. - *PROB_ILLUMINA_INS).ln(),\n        );\n\n        let p_max = LogProb(*T_GAP_X * 2.);\n\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_gap_y() {\n        let x = b\"AGCTCGATCTGATCGATCT\";\n        let y = b\"AGCTCGATCGATCGATC\";\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let mut pair_hmm = PairHMM::new(\u0026TestSingleGapParams);\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026AlignmentMode::Global, None);\n\n        let n_matches = 17.;\n        let n_deletions = 2.;\n\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * n_matches\n                + *T_MATCH * (n_matches - n_deletions)\n                + *EMIT_GAP_Y * n_deletions\n                + *T_GAP_Y * n_deletions\n                + (1. - *PROB_ILLUMINA_DEL).ln(),\n        );\n\n        let p_max = LogProb(*T_GAP_Y * 2.);\n\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 0.01);\n        assert_relative_eq!(*p, *p_max, epsilon = 0.1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_mismatch() {\n        let x = b\"AGCTCGAGCGATCGATC\";\n        let y = b\"TGCTCGATCGATCGATC\";\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let mut pair_hmm = PairHMM::new(\u0026TestSingleGapParams);\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026AlignmentMode::Global, None);\n\n        let n = x.len() as f64;\n        let p_most_likely_path = LogProb(\n            *EMIT_MATCH * (n - 2.) + *T_MATCH * (n - 1.) + (*PROB_ILLUMINA_SUBST / 3.).ln() * 2.,\n        );\n        let p_max = LogProb((*PROB_ILLUMINA_SUBST / 3.).ln() * 2.);\n        assert!(*p \u003c= 0.0);\n        assert_relative_eq!(*p_most_likely_path, *p, epsilon = 1e-4);\n        assert_relative_eq!(*p, *p_max, epsilon = 1e-1);\n        assert!(*p \u003c= *p_max);\n    }\n\n    #[test]\n    fn test_banded() {\n        let x = b\"GATCACAGGTCTATCACCCTATTAACCACTCACGGGAGCTCTCCATGC\\\nATTTGGTATTTTCGTCTGGGGGGTATGCACGCGATAGCATTGCGAGACGCTGGAGCCGGAGCACCCTATGTCGCAGTAT\\\nCTGTCTTTGATTCCTGCCTCATCCTATTATTTATCGCACCTACGTTCAATATTACAGGCGAACATACTTACTAAAGTGT\";\n\n        let y = b\"GGGTATGCACGCGATAGCATTGCGAGATGCTGGAGCTGGAGCACCCTATGTCGC\";\n\n        let emission_params = TestEmissionParams { x, y };\n\n        let mut pair_hmm = PairHMM::new(\u0026TestSingleGapParams);\n        let p = pair_hmm.prob_related(\u0026emission_params, \u0026AlignmentMode::Semiglobal, None);\n\n        let p_banded = pair_hmm.prob_related(\u0026emission_params, \u0026AlignmentMode::Semiglobal, Some(2));\n\n        assert_relative_eq!(*p, *p_banded, epsilon = 1e-7);\n    }\n}\n","traces":[{"line":28,"address":[4317536],"length":1,"stats":{"Line":0},"fn_name":"ln_sum3_exp_approx"},{"line":29,"address":[4317558,4317604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[4317589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[4317652,4317606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[4317637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[4317654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[4317774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4317715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[6376000,6375193,6374560,6376633],"length":1,"stats":{"Line":0},"fn_name":"new\u003cbio::stats::pairhmm::pairhmm::tests::TestSingleGapParams\u003e"},{"line":76,"address":[6374598,6376038,6376077,6374637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[6376115,6374675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[6376153,6374713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[6374751,6376191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[6376207,6374767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[6376223,6374783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[6376239,6374799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[6374815,6376255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[6376313,6374873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[6375156,6375049,6376489,6376596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[6375339,6375149,6376656,6375260,6375216,6376779,6376589,6376700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[6376827,6376957,6376874,6375434,6376772,6375332,6375387,6375517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[6376997,6375695,6375557,6376938,6377056,6377135,6375616,6375498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[6375688,6377128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[6385568,6377440],"length":1,"stats":{"Line":0},"fn_name":"prob_related\u003cbio::stats::pairhmm::pairhmm::tests::TestEmissionParams,bio::stats::pairhmm::pairhmm::tests::AlignmentMode\u003e"},{"line":116,"address":[6385828,6377700,6379184,6385639,6377511,6387312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[6377740,6385868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[6377822,6385950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[6386036,6377908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[6386122,6377994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[6378084,6386212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[6386232,6378104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[6378313,6386441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[6378526,6386654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[6378739,6386867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[6387310,6379182,6378939,6387067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[6387274,6378977,6379146,6387105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[6387298,6379170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[6385785,6377657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[6385797,6377669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[6387317,6385809,6379189,6377681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[6384668,6379515,6392796,6387455,6379327,6387643],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[6379555,6387683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[6388013,6379885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[6379915,6388043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[6380063,6388191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[6388222,6380094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[6380330,6388295,6380167,6383799,6391927,6388458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[6380370,6388554,6388498,6380426],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[6388592,6388533,6380464,6388629,6380405,6380501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[6388683,6388600,6380555,6380472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[6388778,6380650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[6380798,6388926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[6389227,6389074,6389141,6380946,6381013,6381099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[6389188,6381060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[6389125,6380997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[6391233,6383105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[6389245,6381177,6389305,6389143,6381117,6381015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[6389404,6389268,6389344,6381140,6381276,6381216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[6389507,6381315,6381239,6389443,6381379,6389367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[6389470,6389610,6381418,6381342,6389546,6381482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[6389673,6381602,6389573,6381445,6389730,6381545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[6381570,6389698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[6381625,6381994,6389753,6390122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[6390090,6381962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[6381671,6389799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[6381767,6389895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[6389991,6381863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[6382131,6390259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[6390227,6382099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[6390169,6382041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[6382153,6390281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[6382191,6390427,6382299,6390319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[6390337,6382209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[6382475,6390475,6382347,6390603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[6382443,6390571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[6390513,6382385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[6390625,6382497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[6382643,6382535,6390771,6390663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[6382553,6390681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[6390849,6382721,6382675,6390803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[6382726,6390854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[6382835,6390963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[6390945,6382817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[6382991,6391119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[6382709,6390837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[6383044,6391172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[6383210,6391338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[6383344,6391472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[6391610,6383482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[6391748,6383620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[6391787,6383659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[6380313,6392588,6383811,6388441,6384460,6391939],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[6391958,6383830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[6392168,6384040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[6392382,6384254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[6384462,6392590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[6392612,6384673,6384748,6392876,6392801,6384484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[6384713,6392841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[6392885,6384757,6387626,6379498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[6392931,6384803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[6393465,6385337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[6384903,6392891,6384763,6393031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[6393155,6385027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[6385179,6393307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[6385445,6385404,6392989,6393532,6384861,6393573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[6393603,6385475,6393557,6393656,6385528,6385429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[6393658,6385530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[6385510,6393638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[9682784],"length":1,"stats":{"Line":0},"fn_name":"prob_emit_x_or_y"},{"line":298,"address":[9682788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[9682864],"length":1,"stats":{"Line":0},"fn_name":"prob_emit_xy"},{"line":308,"address":[9683225,9683227,9682904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[9683093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[9683195,9683052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[9683232],"length":1,"stats":{"Line":0},"fn_name":"prob_emit_x"},{"line":316,"address":[9683246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[9683280],"length":1,"stats":{"Line":0},"fn_name":"prob_emit_y"},{"line":320,"address":[9683294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[9683328],"length":1,"stats":{"Line":0},"fn_name":"len_x"},{"line":324,"address":[9683340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[9683376],"length":1,"stats":{"Line":0},"fn_name":"len_y"},{"line":328,"address":[9683388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[9683424],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_x"},{"line":336,"address":[9683433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[9683472],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_y"},{"line":340,"address":[9683481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[9683520],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_x_extend"},{"line":344,"address":[9683529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[9683552],"length":1,"stats":{"Line":0},"fn_name":"prob_gap_y_extend"},{"line":348,"address":[9683561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[9683584],"length":1,"stats":{"Line":0},"fn_name":"free_start_gap_x"},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[9683600],"length":1,"stats":{"Line":0},"fn_name":"free_end_gap_x"},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[9683616],"length":1,"stats":{"Line":0},"fn_name":"free_start_gap_x"},{"line":369,"address":[9683643,9683636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[9683625,9683645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[9683638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[9683664],"length":1,"stats":{"Line":0},"fn_name":"free_end_gap_x"},{"line":376,"address":[9683684,9683691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[9683693,9683673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[9683686],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[4935845,4935840],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":392,"address":[9683719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[9683734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[9683749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[9683791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[9683808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[9683881,9684063,9683937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[4935872,4935877],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":403,"address":[9684158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[9684173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[9684188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[9684242],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[9684262],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[9684357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[9684365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[9684524,9684446,9684774,9684373,9684595,9684666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[9684471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[9684537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[9684608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[9684679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[9684787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[9684921,9684853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[9684903,9684961,9685219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[9685198,9686149,9686407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[9687259,9686386,9687335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[4935909,4935904],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":432,"address":[9687422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[9687437],"length":1,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[9687452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[9687506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[9687526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[9687621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[9687629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[9687930,9687710,9687788,9687859,9687637,9688038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[9687735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[9687801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[9687872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[9687943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[9688051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[9688185,9688117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[9688167,9688483,9688225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[9688462,9689671,9689413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[9690599,9690523,9689650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[4935941,4935936],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":461,"address":[9690686],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[9690701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[9690716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[9690770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[9690790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[9690875,9690957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[9691014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[9691157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[9691292,9691224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[9691274,9691590,9691332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[9692520,9692778,9691569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[9693706,9693630,9692757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[4935968,4935973],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":479,"address":[9693790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[9693805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[9693820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[9693874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[9693894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[9693989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[9694007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[9694297,9694393,9694015,9694234,9694088,9694171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[9694113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[9694184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[9694247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[9694310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[9694406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[9694532,9694464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[9694830,9694514,9694572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[9695760,9696018,9694809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[9696870,9696946,9695997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[4936000,4936005],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":508,"address":[9697038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[9697053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[9697068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[9697122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[9697142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[9697237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[9697255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[9697545,9697641,9697419,9697482,9697336,9697263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[9697361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[9697432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[9697495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[9697558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[9697654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[9697780,9697712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[9697762,9697820,9698078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[9699008,9699266,9698057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[9700118,9699245,9700194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[4936032,4936037],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":537,"address":[9700286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[9700301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[9700316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[9700370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[9700390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[9700475,9700557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[9700614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[9700869],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[9701032,9700964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[9701072,9701014,9701330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[9702260,9702518,9701309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[9702497,9703446,9703370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[4936064,4936069],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":558,"address":[9703534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[9703549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[9703564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[9703618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[9703638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[9703723,9703851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[9704141,9703868],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":260},{"path":["/","home","todd","rust-bio","src","stats","probs","cdf.rs"],"content":"// Copyright 2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Support for discrete probability distributions in terms of cumulative distribution\n//! functions (CDF).\n//!\n//! # Examples\n//!\n//! Example usage of all CDF functions:\n//! ```\n//! use approx::assert_relative_eq;\n//! use bio::stats::probs::cdf::{Entry, CDF};\n//! use bio::stats::probs::{LogProb, Prob};\n//! use ordered_float::NotNan;\n//! use std::ops::Range;\n//! // pmf1 is an example PMF with `LogProb(0.0)` at `0`, with `LogProb(0.1)`\n//! // at `{1, 2, ..., 8}` and LogProb(0.2) at `10`\n//! let mut pmf1 = vec![Entry::new(0, LogProb((0.0 as f64).ln()))];\n//! for i in 1..=8 {\n//!     pmf1.push(Entry::new(i, LogProb((0.1 as f64).ln())));\n//! }\n//! pmf1.push(Entry::new(10, LogProb((0.2 as f64).ln())));\n//!\n//! // create the cumulative distribution function from the probability mass function\n//! let cdf = CDF::from_pmf(pmf1.clone());\n//! assert_relative_eq!(*cdf.get(\u00260).unwrap(), (0.0 as f64).ln(), epsilon = 0.0);\n//! assert_relative_eq!(\n//!     *cdf.get(\u00263).unwrap(),\n//!     (0.3 as f64).ln(),\n//!     epsilon = 0.0000000001\n//! );\n//!\n//! // get back the original probability mass value at 7\n//! assert_relative_eq!(\n//!     *cdf.get_pmf(\u00267).unwrap(),\n//!     (0.1 as f64).ln(),\n//!     epsilon = 0.00001\n//! );\n//!\n//! // Check that cdf sums up to 1.0\n//! assert_relative_eq!(\n//!     f64::from(cdf.total_prob()),\n//!     (1.0 as f64).ln(),\n//!     epsilon = 0.0\n//! );\n//!\n//! // copy a CDF via its iter() function\n//! let mut cdf_copy = CDF::from_cdf(cdf.iter().cloned());\n//! assert_eq!(cdf.len(), cdf_copy.len());\n//!\n//! // get the maximum a posteriori probability estimate\n//! assert_eq!(cdf_copy.map().unwrap(), \u002610);\n//!\n//! // get the 50% credible interval\n//! assert_eq!(cdf_copy.credible_interval(0.5).unwrap(), \u00262..\u00268);\n//!\n//! // cdf_vec is an example Entry vector with `LogProb(0.0)` at `ordered_float::NotNan`\n//! // values `{0.0, 1.0, 2.0}` and increasing by `LogProb(0.2)` at each to `{3.0, 4.0, ..., 7.0}`\n//! let mut cdf_vec = Vec::new();\n//! for i in 0..=2 {\n//!     cdf_vec.push(Entry::new(\n//!         NotNan::new(i as f64).unwrap(),\n//!         LogProb::ln_zero(),\n//!     ))\n//! }\n//! for i in 3..=7 {\n//!     cdf_vec.push(Entry::new(\n//!         NotNan::new(i as f64).unwrap(),\n//!         LogProb(((i - 2) as f64 * 0.2f64).ln()),\n//!     ));\n//! }\n//!\n//! // create cdf from vector of `Entry`s\n//! let mut cdf_from_vec = CDF::from_cdf(cdf_vec.into_iter());\n//!\n//! assert_relative_eq!(\n//!     *cdf_from_vec.get(\u0026NotNan::new(2.0).unwrap()).unwrap(),\n//!     LogProb::ln_zero(),\n//!     epsilon = 0.0\n//! );\n//! assert_relative_eq!(\n//!     *cdf_from_vec.get(\u0026NotNan::new(4.0).unwrap()).unwrap(),\n//!     LogProb((0.4 as f64).ln()),\n//!     epsilon = 0.0\n//! );\n//!\n//! // get the number of `Entry`s in cdf_from_vec\n//! assert_eq!(cdf_from_vec.len(), 8);\n//!\n//! // remove three zero values at `{0.0, 1.0, 2.0}` with `CDF::reduce()`\n//! cdf_from_vec = CDF::reduce(cdf_from_vec);\n//! assert_eq!(cdf_from_vec.len(), 5);\n//! ```\n\nuse std::f64;\nuse std::iter;\nuse std::ops::Range;\nuse std::slice;\n\nuse itertools::Itertools;\nuse ordered_float::OrderedFloat;\n\nuse crate::stats::LogProb;\n\n/// An `Entry` associates a `LogProb` with a value on an ordered axis. It can for example be\n/// used to set up probability mass functions or cumulative distribution functions ([CDF](struct.CDF)).\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Entry\u003cT: Ord\u003e {\n    /// A `value` on the ordered axis, which has to have the Trait [`std::cmp::Ord`](https://doc.rust-lang.org/std/cmp/trait.Ord.html) implemented.\n    pub value: T,\n    /// A probability at that `value` / point x on the x-axis.\n    pub prob: LogProb,\n}\n\nimpl\u003cT: Ord\u003e Entry\u003cT\u003e {\n    /// Create a new `Entry` for `prob` at `value`.\n    ///\n    /// `value` needs to have the Trait [`std::cmp::Ord`](https://doc.rust-lang.org/std/cmp/trait.Ord.html)\n    /// implemented. As `f64` only has PartialOrd, use something like the [`ordered_float` crate](https://docs.rs/ordered-float/1.0.2/ordered_float/)\n    /// if you want to use floating point numbers.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bio::stats::probs::cdf::Entry;\n    /// use bio::stats::LogProb;\n    /// let entry = Entry::new(5, LogProb(0.6));\n    /// assert_eq!(entry.value, 5);\n    /// assert_eq!(entry.prob, LogProb(0.6));\n    /// ```\n    pub fn new(value: T, prob: LogProb) -\u003e Self {\n        Entry { value, prob }\n    }\n}\n\n/// Implementation of a cumulative distribution function as a vector of `Entry`s.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CDF\u003cT: Ord\u003e {\n    inner: Vec\u003cEntry\u003cT\u003e\u003e,\n}\n\nimpl\u003cT: Ord\u003e CDF\u003cT\u003e {\n    /// Create CDF from a vector representing a probability mass function (PMF).\n    /// The PMF may contain duplicate values the probabilities of which are summed\n    /// during generation of the CDF.\n    ///\n    /// Runtime complexity: O(n log n), where n is the number of `entries`.\n    ///\n    /// # Arguments\n    ///\n    /// * `entries` - The PMF as a vector of `Entry` objects (values with an associated `LogProb`).\n    pub fn from_pmf(mut entries: Vec\u003cEntry\u003cT\u003e\u003e) -\u003e Self {\n        entries.sort_by(|a, b| a.value.cmp(\u0026b.value));\n        let mut inner: Vec\u003cEntry\u003cT\u003e\u003e = Vec::new();\n        for mut e in entries {\n            let p = inner\n                .last()\n                .map_or(LogProb::ln_zero(), |e| e.prob)\n                .ln_add_exp(e.prob);\n            if !inner.is_empty() \u0026\u0026 inner.last().unwrap().value == e.value {\n                inner.last_mut().unwrap().prob = p;\n            } else {\n                e.prob = p;\n                inner.push(e);\n            }\n        }\n        let mut cdf = CDF { inner };\n\n        // cap at prob=1.0 if there are slightly exceeding values due to numerical issues.\n        for e in \u0026mut cdf.inner {\n            e.prob = e.prob.cap_numerical_overshoot(0.00001);\n        }\n\n        cdf\n    }\n\n    /// Create CDF from iterator. This can be used to replace the values of a CDF.\n    ///\n    /// Runtime complexity: O(n), where n is the number of `entries`.\n    ///\n    /// # Arguments\n    ///\n    /// * `entries` - An iterator over `Entry\u003cT\u003e` values, where T requires\n    pub fn from_cdf\u003cI: Iterator\u003cItem = Entry\u003cT\u003e\u003e\u003e(entries: I) -\u003e Self {\n        CDF {\n            inner: entries.collect_vec(),\n        }\n    }\n\n    /// Reduce CDF by omitting values with zero probability.\n    ///\n    /// Runtime complexity: O(n), where n is the number of `value`s with `prob` of zero.\n    pub fn reduce(self) -\u003e Self {\n        let mut inner = Vec::new();\n        let mut last = LogProb::ln_zero();\n        for e in self.inner {\n            if last != e.prob {\n                last = e.prob;\n                inner.push(e);\n            }\n        }\n        CDF { inner }\n    }\n\n    /// Downsample CDF to n entries. Panics if n \u003c= 1 and returns identity if n is greater\n    /// than the number of entries.\n    ///\n    /// Runtime complexity: O(m), where m is the original number of `Entry`s in `CDF`.\n    ///\n    /// # Arguments\n    ///\n    /// * `n` - Number of entries after downsampling.\n    pub fn sample(mut self, n: usize) -\u003e Self {\n        assert!(n \u003e 1);\n        if self.inner.len() \u003c= n {\n            self\n        } else {\n            let s = self.inner.len() / (n - 1);\n            let last = self.inner.pop().unwrap();\n            let mut inner = self.inner.into_iter().step_by(s).collect_vec();\n            inner.push(last);\n            CDF { inner }\n        }\n    }\n\n    /// Provide an iterator for the CDF.\n    pub fn iter(\u0026self) -\u003e slice::Iter\u003c'_, Entry\u003cT\u003e\u003e {\n        self.inner.iter()\n    }\n\n    /// Provide a mutable iterator over entries.\n    ///\n    /// This does not check for consistency. In other words, you\n    /// should not change the order of the entries, nor the probabilities!\n    pub fn iter_mut(\u0026mut self) -\u003e slice::IterMut\u003c'_, Entry\u003cT\u003e\u003e {\n        self.inner.iter_mut()\n    }\n\n    /// Provide an iterator over the PMF corresponding to this CDF.\n    pub fn iter_pmf(\u0026self) -\u003e CDFPMFIter\u003c'_, T\u003e {\n        fn cdf_to_pmf\u003c'a, G: Ord\u003e(\n            last_prob: \u0026mut LogProb,\n            e: \u0026'a Entry\u003cG\u003e,\n        ) -\u003e Option\u003cEntry\u003c\u0026'a G\u003e\u003e {\n            let prob = e.prob.ln_sub_exp(*last_prob);\n            *last_prob = e.prob;\n            Some(Entry::new(\u0026e.value, prob))\n        }\n        self.inner.iter().scan(LogProb::ln_zero(), cdf_to_pmf)\n    }\n\n    /// Get cumulative probability for a given value.\n    ///\n    /// If the value is not present, return the probability of the previous value.\n    /// Time complexity: O(log n), where n is the number of `Entry`s in `CDF`.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - A value at which you're interested in the cumulative probability.\n    pub fn get(\u0026self, value: \u0026T) -\u003e Option\u003cLogProb\u003e {\n        if self.inner.is_empty() {\n            None\n        } else {\n            Some(match self.inner.binary_search_by(|e| e.value.cmp(value)) {\n                Ok(i) =\u003e self.inner[i].prob,\n                Err(i) =\u003e {\n                    if i \u003e 0 {\n                        self.inner[i - 1].prob\n                    } else {\n                        LogProb::ln_zero()\n                    }\n                }\n            })\n        }\n    }\n\n    /// Get probability (i.e. probability mass) for a given `value`.\n    ///\n    /// Time complexity: O(log n), where n is the number of `Entry`s in `CDF`.\n    pub fn get_pmf(\u0026self, value: \u0026T) -\u003e Option\u003cLogProb\u003e {\n        if self.inner.is_empty() {\n            None\n        } else {\n            Some(match self.inner.binary_search_by(|e| e.value.cmp(value)) {\n                Ok(i) =\u003e {\n                    if i \u003e 0 {\n                        self.inner[i].prob.ln_sub_exp(self.inner[i - 1].prob)\n                    } else {\n                        self.inner[0].prob\n                    }\n                }\n                Err(i) =\u003e {\n                    if i \u003e 0 {\n                        self.inner[i - 1].prob\n                    } else {\n                        LogProb::ln_zero()\n                    }\n                }\n            })\n        }\n    }\n\n    /// Return total probability of the `CDF`.\n    ///\n    /// Time complexity: O(1).\n    pub fn total_prob(\u0026self) -\u003e LogProb {\n        self.inner.last().map_or(LogProb::ln_zero(), |e| e.prob)\n    }\n\n    /// Return maximum a posteriori probability estimate (MAP).\n    ///\n    /// Time complexity: O(n), where n is the number of `Entry`s in `CDF`.\n    pub fn map(\u0026self) -\u003e Option\u003c\u0026T\u003e {\n        if let Some(mut max) = self.iter_pmf().next() {\n            for e in self.iter_pmf() {\n                if e.prob \u003e= max.prob {\n                    max = e;\n                }\n            }\n            Some(max.value)\n        } else {\n            None\n        }\n    }\n\n    /// Return w%-credible interval. The width w is a float between 0 and 1. Panics otherwise.\n    /// E.g. provide `width=0.95` for the 95% credible interval.\n    ///\n    /// Runtime complexity: O(log n), where n is the number of `Entry`s in `CDF`.\n    ///\n    /// # Arguments\n    ///\n    /// * `width` - wanted width of the credible interval as a fraction of 1.\n    pub fn credible_interval(\u0026self, width: f64) -\u003e Option\u003cRange\u003c\u0026T\u003e\u003e {\n        assert!((0.0..=1.0).contains(\u0026width));\n\n        if self.inner.is_empty() {\n            return None;\n        }\n\n        let margin = 1.0 - width;\n        let p_lower = OrderedFloat((margin / 2.0).ln());\n        let p_upper = OrderedFloat((1.0 - margin / 2.0).ln());\n        let lower = self\n            .inner\n            .binary_search_by(|e| OrderedFloat(*e.prob).cmp(\u0026p_lower))\n            .unwrap_or_else(|i| if i \u003e 0 { i - 1 } else { 0 });\n        let mut upper = self\n            .inner\n            .binary_search_by(|e| OrderedFloat(*e.prob).cmp(\u0026p_upper))\n            .unwrap_or_else(|i| i);\n        if upper == self.inner.len() {\n            upper -= 1;\n        }\n\n        Some(\u0026self.inner[lower].value..\u0026self.inner[upper].value)\n    }\n\n    /// Number of `Entry`s in the `CDF`.\n    ///\n    /// Time complexity: O(1)\n    pub fn len(\u0026self) -\u003e usize {\n        self.inner.len()\n    }\n\n    /// Returns `true` if a CDF is empty, false otherwise.\n    ///\n    /// Time complexity: O(1)\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.inner.is_empty()\n    }\n}\n\nimpl\u003cT: Clone + Ord\u003e CDF\u003cT\u003e\nwhere\n    f64: From\u003cT\u003e,\n{\n    /// Calculate expected value.\n    ///\n    /// Runtime complexity: O(n), where n is the number of `Entry`s in `CDF`.\n    pub fn expected_value(\u0026self) -\u003e f64 {\n        self.iter_pmf()\n            .map(|e| f64::from(e.value.clone()) * e.prob.exp())\n            .fold(0.0f64, |s, e| s + e)\n    }\n\n    /// Calculate variance.\n    ///\n    /// Runtime complexity: O(n), where n is the number of `Entry`s in `CDF`.\n    pub fn variance(\u0026self) -\u003e f64 {\n        let ev = self.expected_value();\n        self.iter_pmf()\n            .map(|e| (f64::from(e.value.clone()) - ev).powi(2) * e.prob.exp())\n            .fold(0.0, |s, e| s + e)\n    }\n\n    /// Calculate standard deviation.\n    ///\n    /// Runtime complexity: O(n), where n is the number of `Entry`s in `CDF`.\n    pub fn standard_deviation(\u0026self) -\u003e f64 {\n        self.variance().sqrt()\n    }\n}\n\npub type CDFPMFIter\u003c'a, T\u003e = iter::Scan\u003c\n    slice::Iter\u003c'a, Entry\u003cT\u003e\u003e,\n    LogProb,\n    fn(\u0026mut LogProb, \u0026'a Entry\u003cT\u003e) -\u003e Option\u003cEntry\u003c\u0026'a T\u003e\u003e,\n\u003e;\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::stats::LogProb;\n    use ordered_float::NotNan;\n\n    #[test]\n    fn test_cdf() {\n        let mut pmf = vec![Entry::new(NotNan::new(0.0).unwrap(), LogProb(0.1f64.ln()))];\n        for i in 0..9 {\n            pmf.push(Entry::new(\n                NotNan::new(i as f64).unwrap(),\n                LogProb(0.1f64.ln()),\n            ));\n        }\n        println!(\"{:?}\", pmf);\n\n        let cdf = CDF::from_pmf(pmf.clone());\n        println!(\"{:?}\", cdf);\n        for e in pmf.iter().skip(2) {\n            assert_relative_eq!(*e.prob, *cdf.get_pmf(\u0026e.value).unwrap(), epsilon = 0.000003);\n        }\n        assert_relative_eq!(*cdf.total_prob(), 1.0f64.ln());\n        assert_relative_eq!(\n            *cdf.get(\u0026NotNan::new(1.0).unwrap()).unwrap(),\n            0.3f64.ln(),\n            epsilon = 0.00000001\n        );\n        {\n            let ci = cdf.credible_interval(0.95).unwrap();\n            assert_relative_eq!(**ci.start, 0.0);\n            assert_relative_eq!(**ci.end, 8.0);\n        }\n\n        {\n            for e in cdf.iter_pmf() {\n                assert_relative_eq!(\n                    e.prob.exp(),\n                    if **e.value == 0.0 { 0.2 } else { 0.1 },\n                    epsilon = 0.0001\n                );\n            }\n        }\n\n        assert_relative_eq!(cdf.sample(5).total_prob().exp(), 1.0);\n    }\n}\n","traces":[{"line":133,"address":[6501712,6501664],"length":1,"stats":{"Line":0},"fn_name":"new\u003c\u0026ordered_float::NotNan\u003cf64\u003e\u003e"},{"line":154,"address":[6503297,6501760],"length":1,"stats":{"Line":0},"fn_name":"from_pmf\u003cordered_float::NotNan\u003cf64\u003e\u003e"},{"line":155,"address":[6503373,6501802,6503328],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cordered_float::NotNan\u003cf64\u003e\u003e"},{"line":156,"address":[6501943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[6502208,6502143,6502922,6502236,6501958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[6502477,6502340,6502511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[6503401,6503392,6502444],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cordered_float::NotNan\u003cf64\u003e\u003e"},{"line":161,"address":[6502502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[6502553,6502891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[6502785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[6502727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[6502736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[6502957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[6503274,6503196,6503020,6503119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[6503233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[6504238,6503424],"length":1,"stats":{"Line":0},"fn_name":"sample\u003cordered_float::NotNan\u003cf64\u003e\u003e"},{"line":216,"address":[6503516,6503459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[6503599,6503501,6504191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[6503634],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[6503800,6503609,6503682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[6503833,6503793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[6503924,6504060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[6504078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[6504272],"length":1,"stats":{"Line":0},"fn_name":"iter_pmf\u003cordered_float::NotNan\u003cf64\u003e\u003e"},{"line":243,"address":[6504400],"length":1,"stats":{"Line":0},"fn_name":"cdf_to_pmf\u003cordered_float::NotNan\u003cf64\u003e\u003e"},{"line":247,"address":[6504424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[6504466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[6504475],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[6504304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[6504544],"length":1,"stats":{"Line":0},"fn_name":"get\u003cordered_float::NotNan\u003cf64\u003e\u003e"},{"line":263,"address":[6504569,6504896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[6504610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[6504955,6504593,6504692,6504875,6504928,6504653,6504917,6504919],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cordered_float::NotNan\u003cf64\u003e\u003e"},{"line":267,"address":[6504699,6504678,6504906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[6504734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[6504752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[6504786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[6504758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[6504992],"length":1,"stats":{"Line":0},"fn_name":"get_pmf\u003cordered_float::NotNan\u003cf64\u003e\u003e"},{"line":283,"address":[6505017,6505384],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[6505058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[6505110,6505354,6505164,6505041,6505616,6505643],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cordered_float::NotNan\u003cf64\u003e\u003e"},{"line":287,"address":[6505147,6505166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[6505187,6505605,6505610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[6505430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[6505394,6505591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[6505202],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[6505223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[6505260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[6505229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[6505680],"length":1,"stats":{"Line":0},"fn_name":"total_prob\u003cordered_float::NotNan\u003cf64\u003e\u003e"},{"line":309,"address":[6505776,6505785,6505689],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cordered_float::NotNan\u003cf64\u003e\u003e"},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[6505808],"length":1,"stats":{"Line":0},"fn_name":"credible_interval\u003cordered_float::NotNan\u003cf64\u003e\u003e"},{"line":337,"address":[6505902,6505840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[6505888,6505939],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[6506008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[6505945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[6506062,6505980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[6506071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[6506135,6506176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[6506160,6506608,6506576],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cordered_float::NotNan\u003cf64\u003e\u003e"},{"line":349,"address":[6506686,6506672],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cordered_float::NotNan\u003cf64\u003e\u003e"},{"line":350,"address":[6506276,6506235],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[6506260,6506816,6506784],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cordered_float::NotNan\u003cf64\u003e\u003e"},{"line":353,"address":[6506892,6506897,6506880],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cordered_float::NotNan\u003cf64\u003e\u003e"},{"line":354,"address":[6506330,6506407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[6506409,6506370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[6506452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[4690557,4690256],"length":1,"stats":{"Line":0},"fn_name":"test_cdf"},{"line":421,"address":[4690276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[4690858,4690572,4691075,4690704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[4691008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[4690886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[4690965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[4691096,4690795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[4691188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[4691234,4691408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[4691710,4691435,4692110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[4691750,4692115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[4691691,4693045,4693320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[4694577,4694326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[4694108,4693290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[4694284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[4695515,4694545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[4695594,4695800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[4695779,4696579,4696756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[4698217,4697779,4697543,4696746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[4698014,4698222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[4697855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[4697919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[4699152,4697708,4699498],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":129},{"path":["/","home","todd","rust-bio","src","stats","probs","errors.rs"],"content":"// Copyright 2019 Johannes Köster, University of Duisburg-Essen.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Error definitions for the `probs` module.\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum Error {\n    #[error(\"probabilty {} not in interval [0,1]\", prob)]\n    InvalidProb { prob: f64 },\n}\npub type Result\u003cT, E = Error\u003e = std::result::Result\u003cT, E\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","stats","probs","mod.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Handling log-probabilities. Log probabilities are an important tool to deal with probabilities\n//! in a numerically stable way, in particular when having probabilities close to zero.\n\npub mod cdf;\npub mod errors;\n\nuse std::f64;\nuse std::iter;\nuse std::mem;\nuse std::ops::{Add, AddAssign, Div, Mul, Sub, SubAssign};\n\nuse itertools::Itertools;\nuse itertools_num::linspace;\nuse num_traits::{Float, Zero};\nuse ordered_float::NotNan;\n\nuse crate::utils::FastExp;\n\npub use self::errors::{Error, Result};\n\n/// A factor to convert log-probabilities to PHRED-scale (phred = p * `LOG_TO_PHRED_FACTOR`).\nconst LOG_TO_PHRED_FACTOR: f64 = -4.342_944_819_032_517_5; // -10 * 1 / ln(10)\n\n/// A factor to convert PHRED-scale to log-probabilities (p = phred * `PHRED_TO_LOG_FACTOR`).\nconst PHRED_TO_LOG_FACTOR: f64 = -0.230_258_509_299_404_56; // 1 / (-10 * log10(e))\n\n/// Calculate log(1 - p) with p given in log space without loss of precision as described in\n/// http://cran.r-project.org/web/packages/Rmpfr/vignettes/log1mexp-note.pdf.\nfn ln_1m_exp(p: f64) -\u003e f64 {\n    assert!(p \u003c= 0.0);\n    if p \u003c -0.693 {\n        (-p.fastexp()).ln_1p()\n    } else {\n        (-p.exp_m1()).ln()\n    }\n}\n\ncustom_derive! {\n    /// A newtype for probabilities.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// #[macro_use]\n    /// extern crate approx;\n    /// # extern crate bio;\n    /// # fn main() {\n    /// use bio::stats::Prob;\n    ///\n    /// let p = Prob(0.5);\n    /// let q = Prob(0.2);\n    ///\n    /// assert_relative_eq!(*(p + q), *Prob(0.7));\n    /// # }\n    /// ```\n    #[derive(\n        NewtypeFrom,\n        NewtypeDeref,\n        NewtypeAdd(*),\n        NewtypeSub(*),\n        NewtypeMul(*),\n        NewtypeDiv(*),\n        PartialEq,\n        PartialOrd,\n        Copy,\n        Clone,\n        Debug,\n        Default\n    )]\n    #[derive(Serialize, Deserialize)]\n    pub struct Prob(pub f64);\n}\n\nimpl Prob {\n    pub fn checked(p: f64) -\u003e Result\u003cSelf\u003e {\n        if (0.0..=1.0).contains(\u0026p) {\n            Ok(Prob(p))\n        } else {\n            Err(Error::InvalidProb { prob: p })\n        }\n    }\n}\n\ncustom_derive! {\n    /// A newtype for log-scale probabilities.\n    /// For performance reasons, we use an approximation of the exp method\n    /// implemented in `bio::utils::FastExp`. This can lead to slight\n    /// errors, but should not matter given that most of the probability differences\n    /// are reflected within the integer part of the log probability.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// #[macro_use]\n    /// extern crate approx;\n    /// # extern crate bio;\n    /// # fn main() {\n    /// use bio::stats::{LogProb, Prob};\n    ///\n    /// // convert from probability\n    /// let p = LogProb::from(Prob(0.5));\n    /// // convert manually\n    /// let q = LogProb(0.2f64.ln());\n    /// // obtain zero probability in log-space\n    /// let o = LogProb::ln_one();\n    ///\n    /// assert_relative_eq!(*Prob::from(p.ln_add_exp(q) + o), *Prob(0.7), epsilon=0.000001);\n    /// # }\n    /// ```\n    #[derive(\n        NewtypeFrom,\n        NewtypeDeref,\n        NewtypeAdd(*),\n        NewtypeSub(*),\n        PartialEq,\n        PartialOrd,\n        Copy,\n        Clone,\n        Debug\n    )]\n    #[derive(Serialize, Deserialize)]\n    pub struct LogProb(pub f64);\n}\n\ncustom_derive! {\n    /// A newtype for PHRED-scale probabilities.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// #[macro_use]\n    /// extern crate approx;\n    /// # extern crate bio;\n    /// # fn main() {\n    /// use bio::stats::{PHREDProb, Prob};\n    ///\n    /// let p = PHREDProb::from(Prob(0.5));\n    ///\n    /// assert_relative_eq!(*Prob::from(p), *Prob(0.5));\n    /// # }\n    /// ```\n    #[derive(\n        NewtypeFrom,\n        NewtypeDeref,\n        NewtypeAdd(*),\n        NewtypeSub(*),\n        PartialEq,\n        PartialOrd,\n        Copy,\n        Clone,\n        Debug\n    )]\n    #[derive(Serialize, Deserialize)]\n    pub struct PHREDProb(pub f64);\n}\n\n/// Iterator returned by scans over logprobs.\npub type ScanIter\u003cI\u003e = iter::Scan\u003c\n    \u003cI as IntoIterator\u003e::IntoIter,\n    LogProb,\n    fn(\u0026mut LogProb, LogProb) -\u003e Option\u003cLogProb\u003e,\n\u003e;\n\nstatic LOGPROB_LN_ZERO: LogProb = LogProb(f64::NEG_INFINITY);\nstatic LOGPROB_LN_ONE: LogProb = LogProb(0.0);\n\nimpl LogProb {\n    pub fn is_valid(\u0026self) -\u003e bool {\n        !self.is_nan() \u0026\u0026 **self \u003c= 0.0\n    }\n\n    /// Log-space representation of Pr=0\n    #[inline]\n    pub fn ln_zero() -\u003e LogProb {\n        LOGPROB_LN_ZERO\n    }\n\n    /// Log-space representation of Pr=1\n    #[inline]\n    pub fn ln_one() -\u003e LogProb {\n        LOGPROB_LN_ONE\n    }\n\n    /// sums of LogProbs, e.g. with `ln_sum_exp()` can end up\n    /// slightly above the maximum of `LogProb \u003c= 0` due to\n    /// numerical imprecisions -- this function can rescue such\n    /// values before panics due to asserts in other functions\n    /// handling LogProbs, e.g. `ln_1m_exp`\n    pub fn cap_numerical_overshoot(\u0026self, epsilon: f64) -\u003e LogProb {\n        if *self \u003c= LogProb::ln_one() {\n            *self\n        } else {\n            let capped = **self - epsilon;\n            if capped \u003c= 0.0 {\n                LogProb::ln_one()\n            } else {\n                panic!(\n                    \"Cannot correct LogProb {:?} -- not within given epsilon of 0.0 ({})\",\n                    **self, epsilon\n                );\n            }\n        }\n    }\n\n    /// Numerically stable calculation of 1 - p in log-space.\n    pub fn ln_one_minus_exp(\u0026self) -\u003e LogProb {\n        LogProb(ln_1m_exp(**self))\n    }\n\n    /// Numerically stable sum of probabilities in log-space.\n    pub fn ln_sum_exp(probs: \u0026[LogProb]) -\u003e LogProb {\n        if probs.is_empty() {\n            Self::ln_zero()\n        } else {\n            let mut pmax = probs[0];\n            let mut imax = 0;\n            for (i, \u0026p) in probs.iter().enumerate().skip(1) {\n                if p \u003e pmax {\n                    pmax = p;\n                    imax = i;\n                }\n            }\n            if pmax == Self::ln_zero() {\n                Self::ln_zero()\n            } else if *pmax == f64::INFINITY {\n                LogProb(f64::INFINITY)\n            } else {\n                pmax + LogProb(\n                    (probs\n                        .iter()\n                        .enumerate()\n                        .filter_map(|(i, p)| {\n                            if i == imax || *p == Self::ln_zero() {\n                                None\n                            } else {\n                                Some((p - pmax).fastexp())\n                            }\n                        })\n                        .sum::\u003cf64\u003e())\n                    .ln_1p(),\n                )\n            }\n        }\n    }\n\n    /// Numerically stable addition of probabilities in log-space.\n    pub fn ln_add_exp(self, other: LogProb) -\u003e LogProb {\n        if other == Self::ln_zero() {\n            // do nothing\n            self\n        } else {\n            let (mut p0, mut p1) = (self, other);\n            if p1 \u003e p0 {\n                mem::swap(\u0026mut p0, \u0026mut p1);\n            }\n            if p0 == Self::ln_zero() {\n                Self::ln_zero()\n            } else if *p0 == f64::INFINITY {\n                LogProb(f64::INFINITY)\n            } else {\n                p0 + LogProb((p1 - p0).fastexp().ln_1p())\n            }\n        }\n    }\n\n    /// Numerically stable subtraction of probabilities in log-space.\n    pub fn ln_sub_exp(self, other: LogProb) -\u003e LogProb {\n        if other == Self::ln_zero() {\n            self\n        } else {\n            let (p0, p1) = (self, other);\n            assert!(\n                p0 \u003e= p1,\n                \"Subtraction would lead to negative probability, which is undefined in log space.\"\n            );\n            if *p1 == f64::NEG_INFINITY {\n                p0\n            } else if relative_eq!(*p0, *p1) || p0 == Self::ln_zero() {\n                // the first case leads to zero,\n                // in the second case p0 and p1 are -inf, which is fine\n                Self::ln_zero()\n            } else if *p0 == f64::INFINITY {\n                LogProb(f64::INFINITY)\n            } else {\n                p0 + (p1 - p0).ln_one_minus_exp()\n            }\n        }\n    }\n\n    /// Calculate the cumulative sum of the given probabilities in a numerically stable way (Durbin 1998).\n    pub fn ln_cumsum_exp\u003cI: IntoIterator\u003cItem = LogProb\u003e\u003e(probs: I) -\u003e ScanIter\u003cI\u003e {\n        probs\n            .into_iter()\n            .scan(Self::ln_zero(), Self::scan_ln_add_exp)\n    }\n\n    /// Integrate numerically stable over given log-space density in the interval [a, b]. Uses the trapezoidal rule with n grid points.\n    pub fn ln_trapezoidal_integrate_exp\u003cT, D\u003e(mut density: D, a: T, b: T, n: usize) -\u003e LogProb\n    where\n        T: Copy + Add\u003cOutput = T\u003e + Sub\u003cOutput = T\u003e + Div\u003cOutput = T\u003e + Mul\u003cOutput = T\u003e + Float,\n        D: FnMut(usize, T) -\u003e LogProb,\n        f64: From\u003cT\u003e,\n    {\n        let mut probs = linspace(a, b, n)\n            .enumerate()\n            .dropping(1)\n            .dropping_back(1)\n            .map(|(i, v)| LogProb(*density(i, v) + 2.0f64.ln()))\n            .collect_vec();\n        probs.push(density(0, a));\n        probs.push(density(n, b));\n        let width = f64::from(b - a);\n\n        LogProb(*Self::ln_sum_exp(\u0026probs) + width.ln() - (2.0 * (n - 1) as f64).ln())\n    }\n\n    /// Integrate numerically stable over given log-space density in the interval [a, b]. Uses Simpson's rule with n (odd) grid points.\n    pub fn ln_simpsons_integrate_exp\u003cT, D\u003e(mut density: D, a: T, b: T, n: usize) -\u003e LogProb\n    where\n        T: Copy + Add\u003cOutput = T\u003e + Sub\u003cOutput = T\u003e + Div\u003cOutput = T\u003e + Mul\u003cOutput = T\u003e + Float,\n        D: FnMut(usize, T) -\u003e LogProb,\n        f64: From\u003cT\u003e,\n    {\n        assert_eq!(n % 2, 1, \"n must be odd\");\n        let mut probs = linspace(a, b, n)\n            .enumerate()\n            .dropping(1)\n            .dropping_back(1)\n            .map(|(i, v)| {\n                let weight = (2 + (i % 2) * 2) as f64;\n                LogProb(*density(i, v) + weight.ln()) // factors alter between 2 and 4\n            })\n            .collect_vec();\n        probs.push(density(0, a));\n        probs.push(density(n, b));\n        let width = f64::from(b - a);\n\n        LogProb(*Self::ln_sum_exp(\u0026probs) + width.ln() - ((n - 1) as f64).ln() - 3.0f64.ln())\n    }\n\n    /// Integrate numerically stable over given log-space density and grid points. Uses the trapezoidal rule.\n    pub fn ln_trapezoidal_integrate_grid_exp\u003cT, D\u003e(mut density: D, grid: \u0026[T]) -\u003e LogProb\n    where\n        T: Copy + Add\u003cOutput = T\u003e + Sub\u003cOutput = T\u003e + Div\u003cOutput = T\u003e + Mul\u003cOutput = T\u003e + Float,\n        D: FnMut(usize, T) -\u003e LogProb,\n        f64: From\u003cT\u003e,\n    {\n        let probs = grid\n            .iter()\n            .enumerate()\n            .dropping(1)\n            .map(|(i, v)| {\n                LogProb(\n                    *(density(i - 1, grid[i - 1]).ln_add_exp(density(i, *v))) - 2.0f64.ln()\n                        + f64::from(*v - grid[i - 1]).ln(),\n                )\n            })\n            .collect_vec();\n        LogProb::ln_sum_exp(\u0026probs)\n    }\n\n    fn scan_ln_add_exp(s: \u0026mut LogProb, p: LogProb) -\u003e Option\u003cLogProb\u003e {\n        *s = s.ln_add_exp(p);\n        Some(*s)\n    }\n}\n\nimpl\u003c'a\u003e iter::Sum\u003c\u0026'a LogProb\u003e for LogProb {\n    fn sum\u003cI: Iterator\u003cItem = \u0026'a LogProb\u003e\u003e(iter: I) -\u003e Self {\n        iter.fold(LogProb(0.0), |a, b| a + *b)\n    }\n}\n\nimpl\u003c'a\u003e iter::Sum\u003cLogProb\u003e for LogProb {\n    fn sum\u003cI: Iterator\u003cItem = LogProb\u003e\u003e(iter: I) -\u003e Self {\n        iter.fold(LogProb(0.0), |a, b| a + b)\n    }\n}\n\nimpl AddAssign for LogProb {\n    fn add_assign(\u0026mut self, other: LogProb) {\n        *self = *self + other;\n    }\n}\n\nimpl SubAssign for LogProb {\n    fn sub_assign(\u0026mut self, other: LogProb) {\n        *self = *self - other;\n    }\n}\n\nimpl From\u003cNotNan\u003cf64\u003e\u003e for LogProb {\n    fn from(p: NotNan\u003cf64\u003e) -\u003e LogProb {\n        LogProb(*p)\n    }\n}\n\nimpl From\u003cLogProb\u003e for NotNan\u003cf64\u003e {\n    fn from(p: LogProb) -\u003e NotNan\u003cf64\u003e {\n        NotNan::from(*p)\n    }\n}\n\nimpl From\u003cLogProb\u003e for Prob {\n    fn from(p: LogProb) -\u003e Prob {\n        Prob(p.fastexp())\n    }\n}\n\nimpl From\u003cPHREDProb\u003e for Prob {\n    fn from(p: PHREDProb) -\u003e Prob {\n        Prob(10.0f64.powf(-*p / 10.0))\n    }\n}\n\nimpl From\u003cProb\u003e for LogProb {\n    fn from(p: Prob) -\u003e LogProb {\n        LogProb(p.ln())\n    }\n}\n\nimpl From\u003cPHREDProb\u003e for LogProb {\n    fn from(p: PHREDProb) -\u003e LogProb {\n        LogProb(*p * PHRED_TO_LOG_FACTOR)\n    }\n}\n\nimpl From\u003cProb\u003e for PHREDProb {\n    fn from(p: Prob) -\u003e PHREDProb {\n        PHREDProb(-10.0 * p.log10())\n    }\n}\n\nimpl From\u003cLogProb\u003e for PHREDProb {\n    fn from(p: LogProb) -\u003e PHREDProb {\n        PHREDProb(*p * LOG_TO_PHRED_FACTOR)\n    }\n}\n\nimpl Default for LogProb {\n    fn default() -\u003e LogProb {\n        LogProb::ln_zero()\n    }\n}\n\nimpl Default for PHREDProb {\n    fn default() -\u003e PHREDProb {\n        PHREDProb::from(Prob(0.0))\n    }\n}\n\nimpl Zero for Prob {\n    fn zero() -\u003e Self {\n        Prob(0.0)\n    }\n\n    fn is_zero(\u0026self) -\u003e bool {\n        **self == 0.0\n    }\n}\n\nimpl Zero for LogProb {\n    fn zero() -\u003e Self {\n        LogProb::ln_zero()\n    }\n\n    fn is_zero(\u0026self) -\u003e bool {\n        self.is_infinite() \u0026\u0026 self.signum() \u003c 0.0\n    }\n}\n\nimpl Zero for PHREDProb {\n    fn zero() -\u003e Self {\n        PHREDProb::from(Prob(0.0))\n    }\n\n    fn is_zero(\u0026self) -\u003e bool {\n        *self == Self::zero()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use itertools::Itertools;\n\n    #[test]\n    fn test_sum() {\n        let probs = [LogProb::ln_zero(), LogProb::ln_one(), LogProb::ln_zero()];\n        assert_eq!(LogProb::ln_sum_exp(\u0026probs), LogProb::ln_one());\n    }\n\n    #[test]\n    fn test_empty_sum() {\n        assert_eq!(LogProb::ln_sum_exp(\u0026[]), LogProb::ln_zero());\n    }\n\n    #[test]\n    fn test_cumsum() {\n        let probs = vec![\n            LogProb::ln_zero(),\n            LogProb(0.01f64.ln()),\n            LogProb(0.001f64.ln()),\n        ];\n        let cumsum = LogProb::ln_cumsum_exp(probs).collect_vec();\n\n        assert_relative_eq!(*cumsum[0], *LogProb::ln_zero());\n        assert_relative_eq!(*cumsum[1], 0.01f64.ln());\n        assert_relative_eq!(*cumsum[2], 0.011f64.ln(), epsilon = 0.000001);\n    }\n\n    #[test]\n    fn test_sub() {\n        assert_eq!(\n            LogProb::ln_one().ln_sub_exp(LogProb::ln_one()),\n            LogProb::ln_zero()\n        );\n        assert_relative_eq!(\n            *LogProb::ln_one().ln_sub_exp(LogProb(0.5f64.ln())),\n            *LogProb(0.5f64.ln()),\n            epsilon = 0.0000000001\n        );\n        assert_relative_eq!(\n            *LogProb(-1.6094379124341).ln_sub_exp(LogProb::ln_zero()),\n            *LogProb(-1.6094379124341)\n        );\n    }\n\n    #[test]\n    fn test_one_minus() {\n        assert_eq!(LogProb::ln_zero().ln_one_minus_exp(), LogProb::ln_one());\n        assert_eq!(LogProb::ln_one().ln_one_minus_exp(), LogProb::ln_zero());\n    }\n\n    #[test]\n    fn test_trapezoidal_integrate() {\n        let density = |_, _| LogProb(0.1f64.ln());\n        let prob = LogProb::ln_trapezoidal_integrate_exp(density, 0.0, 10.0, 5);\n        assert_relative_eq!(*prob, *LogProb::ln_one(), epsilon = 0.0000001);\n    }\n\n    #[test]\n    fn test_trapezoidal_integrate_grid() {\n        let grid: Vec\u003c_\u003e = linspace(0.0, 10.0, 5).collect();\n        let density = |_, _| LogProb(0.1f64.ln());\n        let prob = LogProb::ln_trapezoidal_integrate_grid_exp(density, \u0026grid);\n        assert_relative_eq!(*prob, *LogProb::ln_one(), epsilon = 0.0000001);\n    }\n\n    #[test]\n    fn test_simpsons_integrate() {\n        let density = |_, _| LogProb(0.1f64.ln());\n        let prob = LogProb::ln_simpsons_integrate_exp(density, 0.0, 10.0, 5);\n        assert_relative_eq!(*prob, *LogProb::ln_one(), epsilon = 0.0000001);\n    }\n\n    #[test]\n    fn test_cap_numerical_overshoot() {\n        let under_top = LogProb(-0.00000005);\n        assert_eq!(under_top, under_top.cap_numerical_overshoot(0.0000001));\n        let over_top = LogProb(0.00000005);\n        assert_eq!(\n            LogProb::ln_one(),\n            over_top.cap_numerical_overshoot(0.0000001)\n        );\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_cap_numerical_overshoot_panic() {\n        let over_top = LogProb(0.00000005);\n        over_top.cap_numerical_overshoot(0.00000001);\n    }\n\n    #[test]\n    fn test_sum_one_zero() {\n        assert_eq!(\n            LogProb::ln_one().ln_add_exp(LogProb::ln_zero()),\n            LogProb::ln_one()\n        );\n    }\n\n    #[test]\n    fn test_zero() {\n        assert!(LogProb::zero().is_zero());\n        assert!(Prob::zero().is_zero());\n        assert!(PHREDProb::zero().is_zero());\n    }\n}\n","traces":[{"line":34,"address":[4936976],"length":1,"stats":{"Line":0},"fn_name":"ln_1m_exp"},{"line":35,"address":[4937022,4936986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[4937004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[4937071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[4937052,4937180,4937144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[4941472,4941499],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":76,"address":[4941182,4941358,4941428,4941053,4941315,4941117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[4937184],"length":1,"stats":{"Line":0},"fn_name":"checked"},{"line":81,"address":[4937194,4937258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[4937260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[4937225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[4943008,4943035],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":127,"address":[4942942,4942637,4942766,4942899,4942701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[4944032,4944059],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":159,"address":[4943661,4943966,4943790,4943923,4943725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[4937312],"length":1,"stats":{"Line":0},"fn_name":"is_valid"},{"line":174,"address":[4937326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[4937424],"length":1,"stats":{"Line":0},"fn_name":"ln_zero"},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[4937440],"length":1,"stats":{"Line":0},"fn_name":"ln_one"},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[4937456],"length":1,"stats":{"Line":0},"fn_name":"cap_numerical_overshoot"},{"line":195,"address":[4937482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[4937544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[4937573,4937527],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[4937592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[4937618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[4937636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[4937606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[4937856],"length":1,"stats":{"Line":0},"fn_name":"ln_one_minus_exp"},{"line":212,"address":[4937865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[4937920],"length":1,"stats":{"Line":0},"fn_name":"ln_sum_exp"},{"line":217,"address":[4937953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[4937991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[4938073,4937977,4938026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[4938039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[4938051,4938302,4938444,4938105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[4938376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[4938418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[4938436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[4938449,4938283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[4938504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[4938603,4938484,4938525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[4938589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[4938748,4938557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[4938618,4938572,4938663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[4938631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[6398355,6398357,6398183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[6398280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[6398305,6398259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[4938784],"length":1,"stats":{"Line":0},"fn_name":"ln_add_exp"},{"line":253,"address":[4938812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[4938927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[4938858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[4938951,4938900,4938974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[4938959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[4938976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[4939033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[4939016,4939051,4939127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[4939113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[4939073,4939132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[4939232],"length":1,"stats":{"Line":0},"fn_name":"ln_sub_exp"},{"line":273,"address":[4939260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[4939393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[4939306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[4939417,4939443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[4939363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[4939478,4939423,4939532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[4939520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[4939500,4939537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[4939702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[4939685,4939802,4939723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[4939788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[4939807,4939745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[6398368,6398544,6398695,6398519],"length":1,"stats":{"Line":0},"fn_name":"ln_cumsum_exp\u003ccore::iter::adapters::map::Map\u003calloc::vec::into_iter::IntoIter\u003cusize, alloc::alloc::Global\u003e, closure-1\u003e\u003e"},{"line":297,"address":[6398558,6398385,6398631,6398449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[6398707,6398719,6398531,6398655,6398543,6398473,6398425,6398609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[6399553,6398720],"length":1,"stats":{"Line":0},"fn_name":"ln_trapezoidal_integrate_exp\u003cf64,closure-0\u003e"},{"line":309,"address":[6398784,6398913,6398862],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[6398905,6399620,6399600],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cf64,closure-0\u003e"},{"line":315,"address":[6398973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[6399107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[6399195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[6399254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[6400911,6399760],"length":1,"stats":{"Line":0},"fn_name":"ln_simpsons_integrate_exp\u003cf64,closure-0\u003e"},{"line":329,"address":[6399963,6399816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[6400227,6400148,6399953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[6400219,6400944,6400986],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cf64,closure-0\u003e"},{"line":335,"address":[6401003,6401197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[6401159,6401227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[6400287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[6400424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[6400515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[6400574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[6401631,6401312],"length":1,"stats":{"Line":0},"fn_name":"ln_trapezoidal_integrate_grid_exp\u003cf64,closure-0\u003e"},{"line":353,"address":[6401329,6401476,6401443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[6401664,6401455,6401708],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003cf64,closure-0\u003e"},{"line":358,"address":[6402396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[6401732,6402392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[6402185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[6401534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[4939856],"length":1,"stats":{"Line":0},"fn_name":"scan_ln_add_exp"},{"line":368,"address":[4939879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[4939909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[4939952],"length":1,"stats":{"Line":0},"fn_name":"add_assign"},{"line":387,"address":[4939975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[4940016],"length":1,"stats":{"Line":0},"fn_name":"sub_assign"},{"line":393,"address":[4940039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[4940080],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":399,"address":[4940090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[7729456],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":405,"address":[7729466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[4940144],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":411,"address":[4940154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[4940208],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":417,"address":[4940218],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[4940320],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":423,"address":[4940330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[4940400],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":429,"address":[4940410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[4940464],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":435,"address":[4940474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[4940544],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":441,"address":[4940554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[4940608],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":447,"address":[4940609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[4940640],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":453,"address":[4940644],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[4940688],"length":1,"stats":{"Line":0},"fn_name":"zero"},{"line":462,"address":[4940704],"length":1,"stats":{"Line":0},"fn_name":"is_zero"},{"line":463,"address":[4940713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[4940768],"length":1,"stats":{"Line":0},"fn_name":"zero"},{"line":469,"address":[4940769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[4940800],"length":1,"stats":{"Line":0},"fn_name":"is_zero"},{"line":473,"address":[4940814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[4940928],"length":1,"stats":{"Line":0},"fn_name":"zero"},{"line":479,"address":[4940932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[4940976],"length":1,"stats":{"Line":0},"fn_name":"is_zero"},{"line":483,"address":[4940990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[4529392,4529397],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":494,"address":[5261447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[5261641,5261516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[4529424,4529429],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":500,"address":[5261687,5261810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[4529456,4529461],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":505,"address":[5261880,5262053,5261944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[5261896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[5261985,5261920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[5262002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[5262120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[5262574,5262210,5262313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[5263352,5262533,5263613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[5263572,5264392,5264681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[4529493,4529488],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":519,"address":[5265622,5265759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[5265548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[5265608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[5266190,5265973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[5265803,5265727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[5265896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[5266976,5267109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[5266154,5266896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[5266940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[4529525,4529520],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":536,"address":[5267762,5267623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[5267944,5267736,5267797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[4529552,4529557],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":542,"address":[4529584,4529604],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":543,"address":[5268012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[5268042,5268308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[4529648,4529653],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":549,"address":[5268942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[4529700,4529680],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":551,"address":[5269115,5268992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[5269132,5269440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[4529744,4529749],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":557,"address":[4529796,4529776],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":558,"address":[5270316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[5270612,5270346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[4529845,4529840],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":564,"address":[5271239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[5271253,5271395],"length":1,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[5271352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[5271460,5271569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[5271369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[5271430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[4529872,4529877],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":576,"address":[5271617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[5271630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[4529904,4529909],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":582,"address":[5271804,5271711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[5271655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[5271700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[4529941,4529936],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":590,"address":[5271892,5271844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[5271959,5271879,5271922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[5272018,5272048,5271989,5271946],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":205},{"path":["/","home","todd","rust-bio","src","utils","fastexp.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! This module provides a trait adding a fast approximation of the exponential function to f64.\n//! This can be very useful if the exact value is not too important, for example when working with\n//! `bio::stats::LogProb`.\n\nuse num_traits::Float;\nuse std::f64;\nuse std::ops;\n\nconst COEFF_0: f64 = 1.0;\nconst COEFF_1: f64 = 4.831_794_110;\nconst COEFF_2: f64 = 0.143_440_676;\nconst COEFF_3: f64 = 0.019_890_581;\nconst COEFF_4: f64 = 0.006_935_931;\n#[allow(clippy::approx_constant)]\nconst ONEBYLOG2: f64 = 1.442_695_041;\nconst OFFSET_F64: i64 = 1023;\nconst FRACTION_F64: u32 = 52;\nconst MIN_VAL: f64 = -500.0;\n\n/// This trait adds a fast approximation of exp to float types.\npub trait FastExp\u003cV: Float + ops::MulAssign\u003e {\n    fn fastexp(\u0026self) -\u003e V;\n}\n\nimpl FastExp\u003cf64\u003e for f64 {\n    /// Fast approximation of exp() as shown by Kopczynski 2017:\n    /// https://eldorado.tu-dortmund.de/bitstream/2003/36203/1/Dissertation_Kopczynski.pdf\n    fn fastexp(\u0026self) -\u003e f64 {\n        if *self \u003e MIN_VAL {\n            let mut x = ONEBYLOG2 * self;\n\n            let mut bits = x as i64;\n\n            x -= bits as f64;\n            let mut f2 = x;\n            let mut x_tmp = x;\n\n            bits += OFFSET_F64;\n            bits \u003c\u003c= FRACTION_F64;\n\n            f2 *= COEFF_4;\n            x_tmp += COEFF_1;\n            f2 += COEFF_3;\n            x_tmp *= x;\n            f2 *= x;\n            f2 += COEFF_2;\n            f2 *= x_tmp;\n            f2 += COEFF_0;\n\n            f64::from_bits(bits as u64) * f2\n        } else {\n            0.0\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_fastexp() {\n        let x = 1e-15_f64.ln();\n        assert_relative_eq!(x.fastexp(), 1e-15);\n        let x = 1e-8_f64.ln();\n        assert_relative_eq!(x.fastexp(), 1e-8, epsilon = 0.00000000000002);\n        let x = 0.5_f64.ln();\n        assert_relative_eq!(x.fastexp(), 0.5, epsilon = 0.01);\n        let x = -159.000_000_023_278_6_f64;\n        assert_relative_eq!(x.fastexp(), (-159.000_000_023_278_6).exp());\n    }\n}\n","traces":[{"line":33,"address":[5011136],"length":1,"stats":{"Line":0},"fn_name":"fastexp"},{"line":34,"address":[5011177,5011150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[5011187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[5011206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[5011258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[5011281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[5011293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[5011354,5011305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[5011389,5011338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[5840642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[5840662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[5840682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[5011454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[5011472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[5011490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[5011510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[5011528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[5840796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[5840416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[8130240],"length":1,"stats":{"Line":0},"fn_name":"test_fastexp"},{"line":68,"address":[8130252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[8130274,8130470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[8130443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[8131059,8131304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[8131277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[8132001,8132263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[8132219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[8132960,8132236,8133137],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":28},{"path":["/","home","todd","rust-bio","src","utils","interval","errors.rs"],"content":"// Copyright 2019 Johannes Köster, University of Duisburg-Essen.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Error definitions for the `interval` module.\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum Error {\n    #[error(\"an Interval must have a Range with a positive width\")]\n    InvalidRange,\n}\npub type Result\u003cT, E = Error\u003e = std::result::Result\u003cT, E\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","src","utils","interval","mod.rs"],"content":"//! This module defines a newtype `Interval` for `std::ops::Range`, which will panic if `end` \u003c `start`.\n//!\n//! # Examples\n//! Create a new `Interval` given a `Range`.\n//! ```\n//! use bio::utils::Interval;\n//! assert_eq!(Interval::new(3..6).unwrap(), (3..6).into());\n//! ```\n//!\n//! Building an `Interval` from a `Range` with start \u003e end should panic.\n//! ```should_panic\n//! use bio::utils::Interval;\n//! Interval::from(7..1);\n//! ```\n//!\n//! If you want to handle invalid ranges properly, use the `new` constructor\n//! ```\n//! use bio::utils::Interval;\n//! match Interval::new(7..1) {\n//!     Ok(interval) =\u003e println!(\"{:?}\", interval),\n//!     Err(error) =\u003e eprintln!(\"interval start \u003e end\"),\n//! }\n//! ```\n\npub mod errors;\n\nuse std::ops::{Deref, Range};\n\npub use self::errors::{Error, Result};\n\n/// An `Interval` wraps the `std::ops::Range` from the stdlib and is defined by a start and end field\n/// where end should be \u003e= start.\n#[derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]\npub struct Interval\u003cN: Ord + Clone\u003e(Range\u003cN\u003e);\n\nimpl\u003cN: Ord + Clone\u003e Interval\u003cN\u003e {\n    /// Construct a new `Interval` from the given Range.\n    /// Will return `Err` if end \u003c start.\n    pub fn new(r: Range\u003cN\u003e) -\u003e Result\u003cInterval\u003cN\u003e\u003e {\n        if r.end \u003e= r.start {\n            Ok(Interval(r))\n        } else {\n            Err(Error::InvalidRange)\n        }\n    }\n}\n\n/// Convert a `Range` into an `Interval`. This conversion will panic if the `Range` has end \u003c start\nimpl\u003cN: Ord + Clone\u003e From\u003cRange\u003cN\u003e\u003e for Interval\u003cN\u003e {\n    fn from(r: Range\u003cN\u003e) -\u003e Self {\n        match Interval::new(r) {\n            Ok(interval) =\u003e interval,\n            Err(Error::InvalidRange) =\u003e panic!(\"Cannot convert negative width range to interval\"),\n        }\n    }\n}\n\n/// Convert a reference to a `Range` to an interval by cloning. This conversion will panic if the\n/// `Range` has end \u003c start\nimpl\u003c'a, N: Ord + Clone\u003e From\u003c\u0026'a Range\u003cN\u003e\u003e for Interval\u003cN\u003e {\n    fn from(r: \u0026Range\u003cN\u003e) -\u003e Self {\n        match Interval::new(r.clone()) {\n            Ok(interval) =\u003e interval,\n            Err(Error::InvalidRange) =\u003e panic!(\"Cannot convert negative width range to interval\"),\n        }\n    }\n}\n\n/// Use the `Deref` operator to get a reference to `Range` wrapped by the `Interval` newtype.\nimpl\u003cN: Ord + Clone\u003e Deref for Interval\u003cN\u003e {\n    type Target = Range\u003cN\u003e;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Interval;\n\n    #[test]\n    #[should_panic]\n    fn negative_width_range() {\n        let _ = Interval::from(10..5);\n    }\n\n    #[test]\n    fn range_interval_conversions() {\n        assert_eq!(Interval::new(1..10).unwrap(), (1..10).into());\n        assert_eq!(Interval::from(1..10), Interval::new(1..10).unwrap());\n        //deref access\n        let r = Interval::new(1..10).unwrap();\n        assert_eq!(*r, (1..10));\n        assert_eq!(r.start, 1);\n        assert_eq!(r.end, 10);\n    }\n}\n","traces":[{"line":39,"address":[4432848,4433040,4432744,4432936,4433113,4432656],"length":1,"stats":{"Line":0},"fn_name":"new\u003ci64\u003e"},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[4433552],"length":1,"stats":{"Line":0},"fn_name":"from\u003ci64\u003e"},{"line":62,"address":[4433610,4433561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[4433612,4433596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[4433667,4433637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[4433680,4433696,4433712],"length":1,"stats":{"Line":0},"fn_name":"deref\u003cisize\u003e"},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[4612240],"length":1,"stats":{"Line":0},"fn_name":"negative_width_range"},{"line":85,"address":[4612241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[4612272],"length":1,"stats":{"Line":0},"fn_name":"range_interval_conversions"},{"line":90,"address":[4612279,4612625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[4612993,4612558,4612669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[4613037,4612893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[4613080,4613217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[4613373,4613266,4613187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[4613343,4613426,4613523],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":23},{"path":["/","home","todd","rust-bio","src","utils","mod.rs"],"content":"// Copyright 2014-2016 Johannes Köster.\n// Licensed under the MIT license (http://opensource.org/licenses/MIT)\n// This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Common utilities.\n\nmod fastexp;\npub use self::fastexp::FastExp;\n\nmod text;\npub use self::text::{trim_newline, Text, TextSlice};\n\nmod interval;\npub use self::interval::Interval;\n\n/// In place implementation of scan over a slice.\npub fn scan\u003cT: Copy, F: Fn(T, T) -\u003e T\u003e(a: \u0026mut [T], op: F) {\n    let mut s = a[0];\n    for v in a.iter_mut().skip(1) {\n        s = op(s, *v);\n        *v = s;\n    }\n}\n\n// Inplace implementation of prescan over a slice.\npub fn prescan\u003cT: Copy, F: Fn(T, T) -\u003e T\u003e(a: \u0026mut [T], neutral: T, op: F) {\n    let mut s = neutral;\n    for v in a.iter_mut() {\n        let t = *v;\n        *v = s;\n        s = op(s, t);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_scan() {\n        let mut a = vec![1, 0, 0, 1];\n        scan(\u0026mut a[..], |a, b| a + b);\n        assert_eq!(a, vec![1, 1, 1, 2]);\n    }\n\n    #[test]\n    fn test_prescan() {\n        let mut a = vec![1, 0, 0, 1];\n        prescan(\u0026mut a[..], 0, |a, b| a + b);\n        assert_eq!(a, vec![0, 1, 1, 1]);\n    }\n}\n","traces":[{"line":18,"address":[4267472,4267072],"length":1,"stats":{"Line":0},"fn_name":"scan\u003ci32,closure-0\u003e"},{"line":19,"address":[4267105,4267167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[4267467,4267359,4267135,4267236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[4267396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[4267461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[4267504,4267807,4268144,4268447,4268122,4267840],"length":1,"stats":{"Line":0},"fn_name":"prescan\u003cusize,closure-0\u003e"},{"line":28,"address":[4852729,4852393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[4852903,4853006,4852734,4852567,4852835,4852398,4852499,4852670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[4852596,4852932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[4267739,4268379,4268065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[4268387,4268071,4267747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[7735280,7735285],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":42,"address":[5060951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[5061011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[5061115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[5061804,5061392],"length":1,"stats":{"Line":0},"fn_name":"test_prescan"},{"line":49,"address":[5061399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[5061459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[5061565],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":19},{"path":["/","home","todd","rust-bio","src","utils","text.rs"],"content":"/// Type alias for an owned text, i.e. ``Vec\u003cu8\u003e``.\npub type Text = Vec\u003cu8\u003e;\n/// Type alias for a text slice, i.e. ``\u0026[u8]``.\npub type TextSlice\u003c'a\u003e = \u0026'a [u8];\n\n/// Remove a trailing newline from the given string in place.\npub fn trim_newline(s: \u0026mut String) {\n    if s.ends_with('\\n') {\n        s.pop();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::Deref;\n\n    /// This function demonstrates the use of the IntoSequenceIterator alias, which takes both\n    /// slices and iterators.\n    fn print_sequence\u003cItem: Deref\u003cTarget = u8\u003e, T: IntoIterator\u003cItem = Item\u003e\u003e(sequence: T) {\n        for c in sequence {\n            println!(\"{}\", *c);\n        }\n    }\n\n    #[test]\n    fn test_print_sequence() {\n        let s = b\"ACGT\";\n        // use iterator\n        print_sequence(s.iter().step_by(1));\n        // use slice\n        print_sequence(\u0026s[..]);\n        // use vec\n        print_sequence(\u0026vec![b'A', b'C']);\n        // keep ownership\n        println!(\"{:?}\", s);\n    }\n\n    #[test]\n    fn test_trim_newline_from_string() {\n        let mut s = String::from(\"AGCT\\n\");\n        trim_newline(\u0026mut s);\n        assert_eq!(s, String::from(\"AGCT\"));\n    }\n}\n","traces":[{"line":7,"address":[5709824],"length":1,"stats":{"Line":0},"fn_name":"trim_newline"},{"line":8,"address":[5709838,5709900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[5709895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[7725217,7724698,7724736,7725668,7724272,7725248],"length":1,"stats":{"Line":0},"fn_name":"print_sequence\u003c\u0026u8,\u0026[u8]\u003e"},{"line":21,"address":[7724743,7724434,7724449,7724295,7725208,7725659,7724938,7725402,7724689,7724953,7725417,7725263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[7725464,7724496,7724609,7725579,7725122,7725009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[7726110,7725861,7725856,7725888],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":28,"address":[7725895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[7725907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[7725968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[7726010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[7726125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[7726304,7726602,7726277,7726272],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":41,"address":[7726311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[7726338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[7726412,7726345],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":16},{"path":["/","home","todd","rust-bio","tests","data_structures","mod.rs"],"content":"mod rank_select;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","todd","rust-bio","tests","data_structures","rank_select.rs"],"content":"use proptest::prelude::*;\nuse std::collections::HashMap;\nuse std::hash::Hash;\n\n// Naive Rank datastructure.\n//\n// Each index in the `ranks` vector is the index in the sequence.\n// At each of the indexes the overall rank of all values seen up to\n// that point is stored in a HashMap.\n#[derive(Default)]\nstruct Rank\u003cT: Hash + Eq + Clone\u003e {\n    ranks: Vec\u003cHashMap\u003cT, usize\u003e\u003e,\n    len: usize,\n}\n\n// Naive Select data structure.\n//\n// All values in the sequence are keys in the HashMap.\n// Each value has an associated vector where the indexes are the ranks\n// and the value at each index is the index in the sequence at which the\n// rank occured.\n#[derive(Default)]\nstruct Select\u003cT: Hash + Eq + Clone\u003e {\n    select: HashMap\u003cT, Vec\u003cusize\u003e\u003e,\n    len: usize,\n}\n\nimpl\u003cT: Hash + Eq + Clone\u003e Select\u003cT\u003e {\n    fn push(\u0026mut self, val: T) {\n        self.select\n            .entry(val)\n            .or_insert_with(Vec::new)\n            .push(self.len);\n        self.len += 1;\n    }\n\n    fn select(\u0026self, rank: usize, val: \u0026T) -\u003e Option\u003cu64\u003e {\n        if rank \u003e 0 {\n            if let Some(ranks) = self.select.get(val) {\n                if let Some(idx) = ranks.get(rank - 1) {\n                    return Some(*idx as u64);\n                }\n            }\n        }\n        return None;\n    }\n}\n\nimpl\u003cT: Hash + Eq + Clone\u003e Rank\u003cT\u003e {\n    fn push(\u0026mut self, val: T) {\n        if let Some(prev) = self.ranks.last() {\n            let mut nxt: HashMap\u003c_, _\u003e = prev.clone();\n            *nxt.entry(val).or_insert(0) += 1;\n            self.ranks.push(nxt.clone());\n        } else {\n            let mut nxt = HashMap::new();\n            nxt.insert(val, 1);\n            self.ranks.push(nxt);\n        }\n        self.len += 1;\n    }\n\n    fn get_rank(\u0026self, idx: usize, val: T) -\u003e Option\u003cu64\u003e {\n        if idx \u003c self.len {\n            let rank = self\n                .ranks\n                .get(idx)\n                .map(|x| *x.get(\u0026val).unwrap_or(\u00260))\n                .unwrap_or(0);\n            Some(rank as u64)\n        } else {\n            None\n        }\n    }\n}\n\nproptest! {\n    #[test]\n    fn rank_same_as_naive(input: Vec\u003cbool\u003e, k in 1usize..1000usize) {\n        use bio::data_structures::rank_select::RankSelect;\n        use bv::BitVec;\n        let mut bv = BitVec::new();\n        let mut naive = Rank::default();\n        for \u0026i in \u0026input {\n            naive.push(i);\n            bv.push(i)\n        }\n        let rs = RankSelect::new(bv, k);\n        for idx in 0..=input.len() {\n            assert_eq!(naive.get_rank(idx, false), rs.rank_0(idx as u64));\n            assert_eq!(naive.get_rank(idx, true), rs.rank_1(idx as u64));\n        }\n    }\n\n    #[test]\n    fn select_same_as_naive(input: Vec\u003cbool\u003e, k in 1usize..1000usize) {\n        use bio::data_structures::rank_select::RankSelect;\n        use bv::BitVec;\n        let mut bv = BitVec::new();\n        let mut naive = Select::default();\n        for \u0026i in \u0026input {\n            naive.push(i);\n            bv.push(i)\n        }\n        let rs = RankSelect::new(bv, k);\n        for idx in 0..=input.len() {\n            assert_eq!(naive.select(idx, \u0026false), rs.select_0(idx as u64));\n            assert_eq!(naive.select(idx, \u0026true), rs.select_1(idx as u64));\n        }\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[4415148,4415193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[4415189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[4415204,4415271,4415241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[4415280],"length":1,"stats":{"Line":0},"fn_name":"select\u003cbool\u003e"},{"line":38,"address":[4415314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[4415332,4415538,4415393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4415414,4415375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[4415768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[4416127,4416188,4416024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[4416232,4416181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[4415850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[4404415,4405711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[4417218],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[4417246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[4417253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[4417325,4417463,4417609,4417695,4417408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[4417649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[4417674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[4417542],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[4418542,4417800,4417700,4417989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[4418303,4418036],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[4418557,4418364,4418270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[4418978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[4419006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[4419013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[4419085,4419168,4419369,4419223,4419455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[4419409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[4419434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[4419302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[4419560,4420309,4419460,4419749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[4420070,4419786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[4420022,4420324,4420131],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":50},{"path":["/","home","todd","rust-bio","tests","mod.rs"],"content":"mod data_structures;\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>